'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
                                                                                                                                                                                                  * Appcelerator Titanium Mobile
                                                                                                                                                                                                  * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
                                                                                                                                                                                                  * Licensed under the terms of the Apache Public License
                                                                                                                                                                                                  * Please see the LICENSE included with this distribution for details.
                                                                                                                                                                                                  */

/* eslint-disable quote-props */

/* globals OS_ANDROID, OS_IOS */
// Add global constants.

Object.defineProperties(commonjsGlobal, {
  'OS_ANDROID': {
    value: true,
    writable: false },

  'OS_IOS': {
    value: false,
    writable: false },

  OS_VERSION_MAJOR: {
    value: Ti.Platform.versionMajor,
    writable: false },

  OS_VERSION_MINOR: {
    value: Ti.Platform.versionMinor,
    writable: false },

  OS_VERSION_PATCH: {
    value: Ti.Platform.versionPatch,
    writable: false } });



// Copyright Node.js contributors. All rights reserved.
const kNodeModulesRE = /^(.*)[\\/]node_modules[\\/]/;
const customInspectSymbol = Symbol.for('nodejs.util.inspect.custom');
const isBuffer = Symbol.for('titanium.buffer.isBuffer');
const colorRegExp = /\u001b\[\d\d?m/g; // eslint-disable-line no-control-regex

function removeColors(str) {
  return str.replace(colorRegExp, '');
}
function isError(e) {
  // An error could be an instance of Error while not being a native error
  // or could be from a different realm and not be instance of Error but still
  // be a native error.
  return isNativeError(e) || e instanceof Error;
}
let getStructuredStack;

class StackTraceError extends Error {}

StackTraceError.prepareStackTrace = (err, trace) => trace;

StackTraceError.stackTraceLimit = Infinity;
function isInsideNodeModules() {
  if (getStructuredStack === undefined) {
    getStructuredStack = () => new StackTraceError().stack;
  }

  let stack = getStructuredStack(); // stack is only an array on v8, try to convert manually if string

  if (typeof stack === 'string') {
    const stackFrames = [];
    const lines = stack.split(/\n/);

    for (const line of lines) {
      const lineInfo = line.match(/(.*)@(.*):(\d+):(\d+)/);

      if (lineInfo) {
        const filename = lineInfo[2].replace('file://', '');
        stackFrames.push({
          getFileName: () => filename });

      }
    }

    stack = stackFrames;
  } // Iterate over all stack frames and look for the first one not coming
  // from inside Node.js itself:


  if (Array.isArray(stack)) {
    for (const frame of stack) {
      const filename = frame.getFileName(); // If a filename does not start with / or contain \,
      // it's likely from Node.js core.

      if (!/^\/|\\/.test(filename)) {
        continue;
      }

      return kNodeModulesRE.test(filename);
    }
  }

  return false;
}
function join(output, separator) {
  let str = '';

  if (output.length !== 0) {
    const lastIndex = output.length - 1;

    for (let i = 0; i < lastIndex; i++) {
      // It is faster not to use a template string here
      str += output[i];
      str += separator;
    }

    str += output[lastIndex];
  }

  return str;
}
function uncurryThis(f) {
  return function () {
    return f.call.apply(f, arguments);
  };
}
const ALL_PROPERTIES = 0;
const ONLY_ENUMERABLE = 2;
const propertyFilter = {
  ALL_PROPERTIES,
  ONLY_ENUMERABLE };

function getOwnNonIndexProperties(obj, filter) {
  const props = [];
  const keys = filter === ONLY_ENUMERABLE ? Object.keys(obj) : Object.getOwnPropertyNames(obj);

  for (var i = 0; i < keys.length; ++i) {
    const key = keys[i];

    if (!isAllDigits(key)) {
      props.push(key);
    }
  }

  return props;
}

function isAllDigits(s) {
  if (s.length === 0) {
    return false;
  }

  for (var i = 0; i < s.length; ++i) {
    const code = s.charCodeAt(i);

    if (code < 48 || code > 57) {
      return false;
    }
  }

  return true;
}

// Copyright Node.js contributors. All rights reserved.
const TypedArrayPrototype = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_toStringTag = uncurryThis(Object.getOwnPropertyDescriptor(TypedArrayPrototype, Symbol.toStringTag).get);

function isObject(value) {
  return typeof value === 'object';
}

function isFunction(value) {
  return typeof value === 'function';
}

function checkPrototype(value, name) {
  return Object.prototype.toString.call(value) === `[object ${name}]`;
}

function isAnyArrayBuffer(value) {
  if (isArrayBuffer(value)) {
    return true;
  }

  return isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
  return isObject(value) && checkPrototype(value, 'Arguments');
}
function isArrayBuffer(value) {
  return isObject(value) && checkPrototype(value, 'ArrayBuffer');
} // Cached to make sure no userland code can tamper with it.

const isArrayBufferView = ArrayBuffer.isView;
function isAsyncFunction(value) {
  return isFunction(value) && checkPrototype(value, 'AsyncFunction');
}
function isBigInt64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigInt64Array';
}
function isBigUint64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'BigUint64Array';
}
function isBooleanObject(value) {
  return isObject(value) && checkPrototype(value, 'Boolean');
}
function isBoxedPrimitive(value) {
  if (!isObject(value)) {
    return false;
  }

  return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) // || isBigIntObject(value)
  || isSymbolObject(value);
}
function isDataView(value) {
  return isObject(value) && checkPrototype(value, 'DataView');
}
function isDate(value) {
  return isObject(value) && checkPrototype(value, 'Date');
} // @todo isExternal

function isFloat32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float32Array';
}
function isFloat64Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Float64Array';
}
function isGeneratorFunction(value) {
  return isFunction(value) && checkPrototype(value, 'GeneratorFunction');
}
function isGeneratorObject(value) {
  return isObject(value) && checkPrototype(value, 'Generator');
}
function isInt8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int8Array';
}
function isInt16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int16Array';
}
function isInt32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Int32Array';
}
function isMap(value) {
  return isObject(value) && checkPrototype(value, 'Map');
}
function isMapIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Map Iterator';
} // @todo isModuleNamespaceObject

function isNativeError(value) {
  // if not an instance of an Error, definitely not a native error
  if (!(value instanceof Error)) {
    return false;
  }

  if (!value || !value.constructor) {
    return false;
  }

  return ['Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError'].includes(value.constructor.name);
}
function isNumberObject(value) {
  return isObject(value) && checkPrototype(value, 'Number');
}
function isPromise(value) {
  return isObject(value) && checkPrototype(value, 'Promise');
} // @todo isProxy

function isRegExp(value) {
  return isObject(value) && checkPrototype(value, 'RegExp');
}
function isSet(value) {
  return isObject(value) && checkPrototype(value, 'Set');
}
function isSetIterator(value) {
  if (typeof value !== 'object') {
    return false;
  }

  const prototype = Object.getPrototypeOf(value);
  return prototype && prototype[Symbol.toStringTag] === 'Set Iterator';
}
function isSharedArrayBuffer(value) {
  if (!global.SharedArrayBuffer) {
    return false;
  }

  return isObject(value) && checkPrototype(value, 'SharedArrayBuffer');
}
function isStringObject(value) {
  return isObject(value) && checkPrototype(value, 'String');
}
function isSymbolObject(value) {
  return isObject(value) && checkPrototype(value, 'Symbol');
}
function isTypedArray(value) {
  const isBuiltInTypedArray = TypedArrayProto_toStringTag(value) !== undefined;

  if (isBuiltInTypedArray) {
    return true;
  }

  return value[isBuffer] === true;
}
function isUint8Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8Array';
}
function isUint8ClampedArray(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint8ClampedArray';
}
function isUint16Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint16Array';
}
function isUint32Array(value) {
  return TypedArrayProto_toStringTag(value) === 'Uint32Array';
}
function isWeakMap(value) {
  return isObject(value) && checkPrototype(value, 'WeakMap');
}
function isWeakSet(value) {
  return isObject(value) && checkPrototype(value, 'WeakSet');
} // @todo isWebAssemblyCompiledModule

var types = /*#__PURE__*/Object.freeze({
  __proto__: null,
  isAnyArrayBuffer: isAnyArrayBuffer,
  isArgumentsObject: isArgumentsObject,
  isArrayBuffer: isArrayBuffer,
  isArrayBufferView: isArrayBufferView,
  isAsyncFunction: isAsyncFunction,
  isBigInt64Array: isBigInt64Array,
  isBigUint64Array: isBigUint64Array,
  isBooleanObject: isBooleanObject,
  isBoxedPrimitive: isBoxedPrimitive,
  isDataView: isDataView,
  isDate: isDate,
  isFloat32Array: isFloat32Array,
  isFloat64Array: isFloat64Array,
  isGeneratorFunction: isGeneratorFunction,
  isGeneratorObject: isGeneratorObject,
  isInt8Array: isInt8Array,
  isInt16Array: isInt16Array,
  isInt32Array: isInt32Array,
  isMap: isMap,
  isMapIterator: isMapIterator,
  isNativeError: isNativeError,
  isNumberObject: isNumberObject,
  isPromise: isPromise,
  isRegExp: isRegExp,
  isSet: isSet,
  isSetIterator: isSetIterator,
  isSharedArrayBuffer: isSharedArrayBuffer,
  isStringObject: isStringObject,
  isSymbolObject: isSymbolObject,
  isTypedArray: isTypedArray,
  isUint8Array: isUint8Array,
  isUint8ClampedArray: isUint8ClampedArray,
  isUint16Array: isUint16Array,
  isUint32Array: isUint32Array,
  isWeakMap: isWeakMap,
  isWeakSet: isWeakSet });


// Copyright Node.js contributors. All rights reserved.
let error;

function lazyError() {
  if (!error) {
    // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
    // error = require('./errors').codes.ERR_INTERNAL_ASSERTION;
    error = codes.ERR_INTERNAL_ASSERTION;
  }

  return error;
}

function assert(value, message) {
  if (!value) {
    const ERR_INTERNAL_ASSERTION = lazyError();
    throw new ERR_INTERNAL_ASSERTION(message);
  }
}

function fail(message) {
  const ERR_INTERNAL_ASSERTION = lazyError();
  throw new ERR_INTERNAL_ASSERTION(message);
}

assert.fail = fail;

// Copyright Node.js contributors. All rights reserved.
const messages = new Map();
const codes = {}; // @todo implement this once needed

class SystemError extends Error {} // Utility function for registering the error codes.


function E(sym, val, def, ...otherClasses) {
  // Special case for SystemError that formats the error message differently
  // The SystemErrors only have SystemError as their base classes.
  messages.set(sym, val);

  if (def === SystemError) {
    throw new Error('Node compatible SystemError not yet implemented.');
  } else {
    def = makeNodeErrorWithCode(def, sym);
  }

  if (otherClasses.length !== 0) {
    otherClasses.forEach(clazz => {
      def[clazz.name] = makeNodeErrorWithCode(clazz, sym);
    });
  }

  codes[sym] = def;
}

function makeNodeErrorWithCode(Base, key) {
  return class NodeError extends Base {
    constructor(...args) {
      super();
      const message = getMessage(key, args, this);
      Object.defineProperty(this, 'message', {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true });

      addCodeToName(this, super.name, key);
    }

    get code() {
      return key;
    }

    set code(value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true });

    }

    toString() {
      return `${this.name} [${key}]: ${this.message}`;
    }};


}

function getMessage(key, args, self) {
  const msg = messages.get(key);
  /*
                                 // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
                                 if (assert === undefined) {
                                 	assert = require('./internal/assert');
                                 }
                                 */

  if (typeof msg === 'function') {
    assert(msg.length <= args.length, // Default options do not count.
    `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${msg.length}).`);
    return msg.apply(self, args);
  }

  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
  assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not ` + `match the required ones (${expectedLength}).`);

  if (args.length === 0) {
    return msg;
  }

  args.unshift(msg);
  return format.apply(null, args); // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
  // return lazyInternalUtilInspect().format.apply(null, args);
}

function addCodeToName(err, name, code) {
  // Add the error code to the name to include it in the stack trace.
  err.name = `${name} [${code}]`; // Access the stack to generate the error message including the error code
  // from the name.
  // @fixme: This only works on V8/Android, iOS/JSC has a different Error structure.
  // should we try to make errors behave the same across platforms?
  // eslint-disable-next-line no-unused-expressions

  err.stack; // Reset the name to the actual name.

  if (name === 'SystemError') {
    Object.defineProperty(err, 'name', {
      value: name,
      enumerable: false,
      writable: true,
      configurable: true });

  } else {
    delete err.name;
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS', // Using a default argument here is important so the argument is not counted
// towards `Function#length`.
(name = undefined) => {
  if (name) {
    return `"${name}" is outside of buffer bounds`;
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INTERNAL_ASSERTION', message => {
  const suffix = 'This is caused by either a bug in Titanium ' + 'or incorrect usage of Titanium internals.\n' + 'Please open an issue with this stack trace at ' + 'https://jira.appcelerator.org\n';
  return message === undefined ? suffix : `${message}\n${suffix}`;
}, Error);
E('ERR_INVALID_ARG_TYPE', (name, expected, actual) => {
  assert(typeof name === 'string', '\'name\' must be a string'); // determiner: 'must be' or 'must not be'

  let determiner;

  if (typeof expected === 'string' && expected.startsWith('not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  let msg;

  if (name.endsWith(' argument')) {
    // For cases like 'first argument'
    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;
  } else {
    const type = name.includes('.') ? 'property' : 'argument';
    msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, 'type')}`;
  } // TODO(BridgeAR): Improve the output by showing `null` and similar.


  msg += `. Received type ${typeof actual}`;
  return msg;
}, TypeError);
let maxStack_ErrorName;
let maxStack_ErrorMessage;
/**
                            * Returns true if `err.name` and `err.message` are equal to engine-specific
                            * values indicating max call stack size has been exceeded.
                            * "Maximum call stack size exceeded" in V8.
                            *
                            * @param {Error} err The error to check
                            * @returns {boolean}
                            */

function isStackOverflowError(err) {
  if (maxStack_ErrorMessage === undefined) {
    try {
      function overflowStack() {
        overflowStack();
      }

      overflowStack();
    } catch (e) {
      maxStack_ErrorMessage = e.message;
      maxStack_ErrorName = e.name;
    }
  }

  return err.name === maxStack_ErrorName && err.message === maxStack_ErrorMessage;
}

function oneOf(expected, thing) {
  assert(typeof thing === 'string', '`thing` has to be of type string');

  if (Array.isArray(expected)) {
    const len = expected.length;
    assert(len > 0, 'At least one expected value needs to be specified');
    expected = expected.map(i => String(i));

    if (len > 2) {
      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` + expected[len - 1];
    } else if (len === 2) {
      return `one of ${thing} ${expected[0]} or ${expected[1]}`;
    } else {
      return `of ${thing} ${expected[0]}`;
    }
  } else {
    return `of ${thing} ${String(expected)}`;
  }
}

class FastBuffer extends Uint8Array {}
/**
                                        * loop over input, every 2 characters, parse as an int
                                        * basically each two characters are a "byte" or an 8-bit uint
                                        * we append them all together to form a single buffer holding all the values
                                        * @param {string} value string we're encoding in hex
                                        * @returns {integer[]} array of encoded bytes
                                        */

function stringToHexBytes(value) {
  const length = value.length / 2;
  const byteArray = [];

  for (let i = 0; i < length; i++) {
    const numericValue = parseInt(value.substr(i * 2, 2), 16);

    if (!Number.isNaN(numericValue)) {
      // drop bad hex characters
      byteArray.push(numericValue);
    }
  }

  return byteArray;
}

// as a result it is *much* slower to read/write values
// because we need to go across the JS/Native boundary per-byte!
// We also need to use a Proxy to handle intercepting set/get of indices to redirect to the underlying Ti.Buffer

class SlowBuffer {
  /**
                   * Constructs a new buffer.
                   *
                   * Primarily used internally in this module together with `newBuffer` to
                   * create a new Buffer instance wrapping a Ti.Buffer.
                   *
                   * Also supports the deprecated Buffer() constructors which are safe
                   * to use outside of this module.
                   *
                   * @param {Ti.Buffer} tiBuffer the underlying data/bytes
                   * @param {integer} [start=0] start offset of array/buffer
                   * @param {integer} [length] length of the underlying array/buffer to wrap
                   */
  constructor(tiBuffer, start = 0, length = tiBuffer.length - start) {
    Object.defineProperties(this, {
      byteOffset: {
        value: start },

      length: {
        value: length },

      _tiBuffer: {
        value: tiBuffer } });


  }
  /**
     * Wraps creation of a Buffer instance inside a Proxy so we can handle array index access
     * @param {Ti.Buffer} tiBuffer the underlying data/bytes
     * @param {integer} [start=0] start offset of array/buffer
     * @param {integer} [length] length of the underlying array/buffer to wrap
     * @returns {Buffer} wrapped inside a Proxy
     */


  static fromTiBuffer(tiBuffer, start, length) {
    return new Proxy(new SlowBuffer(tiBuffer, start, length), arrayIndexHandler); // eslint-disable-line security/detect-new-buffer
  }

  static fromString(value, encoding) {
    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }

    encoding = encoding.toLowerCase();

    if (encoding === 'base64') {
      const blob = Ti.Utils.base64decode(value);
      const blobStream = Ti.Stream.createStream({
        source: blob,
        mode: Ti.Stream.MODE_READ });

      const buffer = Ti.Stream.readAll(blobStream);
      blobStream.close();
      return SlowBuffer.fromTiBuffer(buffer);
    }

    if (encoding === 'hex') {
      const bytes = stringToHexBytes(value);
      const length = bytes.length;
      const tiBuffer = Ti.createBuffer({
        length });


      for (let i = 0; i < length; i++) {
        tiBuffer[i] = bytes[i] & 0xFF; // mask to one byte
      }

      return SlowBuffer.fromTiBuffer(tiBuffer);
    }

    const tiBuffer = Ti.createBuffer({
      value: value,
      type: getTiCodecCharset(encoding) });

    return SlowBuffer.fromTiBuffer(tiBuffer);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  get buffer() {
    // Get the slice of the array from byteOffset to length
    return Uint8Array.from(this).buffer;
  }

  _slice(offset, length) {
    return SlowBuffer.fromTiBuffer(this._tiBuffer, offset, length);
  }

  _fill(value, offset, end, encoding) {
    const valueType = typeof value;

    if (valueType === 'string') {
      const bufToFillWith = SlowBuffer.fromString(value, encoding);
      const fillBufLength = bufToFillWith.length;

      if (fillBufLength === 0) {
        throw new Error('no valid fill data');
      } // If the buffer length === 1, we can just do this._tiBuffer.fill(value, offset, end);


      if (fillBufLength === 1) {
        this._tiBuffer.fill(bufToFillWith._tiBuffer[0], offset, end);

        return this;
      } // multiple byte fill!


      const length = end - offset;

      for (let i = 0; i < length; i++) {
        // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
        const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
        this._tiBuffer[i + offset] = fillChar;
      }

      return this;
    } // if the value is a number (or a buffer with a single byte) we can use tiBuffer.fill();


    this._tiBuffer.fill(value, offset, end);
  }

  getAdjustedIndex(index) {
    return getAdjustedIndex(this, index);
  }

  setAdjustedIndex(index, value) {
    return setAdjustedIndex(this, index, value);
  } // This is a method we should get by extending Uint8Array, so really should only be overriden on a "SlowBuffer" that wraps Ti.Buffer


  set(src, offset = 0) {
    const numBytes = src.length; // check src.length + offset doesn't go beyond our length!
    // FIXME: Re-enable
    // checkOffset(this, offset, numBytes);
    // copy src values into this buffer starting at offset

    for (let i = 0; i < numBytes; i++) {
      setAdjustedIndex(this, i + offset, src[i]);
    }
  }
  /**
     * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
     * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
     */


  toTiBuffer() {
    if (this.length === this._tiBuffer.length && this.byteOffset === 0) {
      return this._tiBuffer;
    }

    return this._tiBuffer.clone(this.byteOffset, this.length);
  }}

// Use a Proxy to hack array style index accessors

const arrayIndexHandler = {
  get(target, propKey, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        return getAdjustedIndex(target, num);
      }
    } else if (propKey === isBuffer) {
      return true;
    }

    return Reflect.get(target, propKey, receiver);
  },

  set(target, propKey, value, receiver) {
    if (typeof propKey === 'string') {
      const num = Number(propKey);

      if (Number.isSafeInteger(num)) {
        setAdjustedIndex(target, num, value);
        return true;
      }
    }

    return Reflect.set(target, propKey, value, receiver);
  },

  has(target, key) {
    if (typeof key === 'string') {
      const num = Number(key);

      if (Number.isSafeInteger(num)) {
        // ensure it's a positive "safe" integer within the range of the buffer
        return num >= 0 && num < target._tiBuffer.length;
      }
    }

    return key in target;
  } };



function getAdjustedIndex(buf, index) {
  if (index < 0) {
    return undefined;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index >= buf._tiBuffer.length) {
      return undefined;
    }

    return buf._tiBuffer[index + buf.byteOffset];
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  return buf[index];
}

function setAdjustedIndex(buf, index, value) {
  if (index < 0) {
    return;
  } // Wrapping Ti.Buffer?


  if (buf._tiBuffer) {
    if (index < buf._tiBuffer.length) {
      buf._tiBuffer[index + buf.byteOffset] = value;
    }

    return;
  } // Raw TypedArray/ArrayBuffer
  // FIXME: do we need to account for byteOffset here?


  buf[index] = value;
} // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings


const TI_CODEC_MAP = new Map();
TI_CODEC_MAP.set('utf-8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf8', Ti.Codec.CHARSET_UTF8);
TI_CODEC_MAP.set('utf-16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('utf16le', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('ucs-2', Ti.Codec.CHARSET_UTF16LE);
TI_CODEC_MAP.set('latin1', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('binary', Ti.Codec.CHARSET_ISO_LATIN_1);
TI_CODEC_MAP.set('ascii', Ti.Codec.CHARSET_ASCII);
/**
                                                    * @param {string} encoding desired encoding name
                                                    * @returns {integer} Ti.Codec constant that maps to the encoding
                                                    */

function getTiCodecCharset(encoding) {
  return TI_CODEC_MAP.get(encoding);
}

/**
   * This implementation of Buffer uses a Ti.Buffer internally to back it.
   * This is likley an order of magnitude slower than using a variant that extends Uint8Array!
   * I think if we're not already wrapping a Ti.Buffer, it may be better to have two implementations
   * and, like browserify, just extend Uint8Array for any Buffers we need to read/write a lot
   * and then add a simple conversion method to turn it into a Ti.Buffer when needed.
   *
   * The Ti.Buffer impl has to go through the binding layer for reading/writing every byte.
   * If we anticipate the Buffer staying on the JS side, I'm willing to bet that the Uint8Array
   * the JS engine provides would be *way* faster.
   *
   * Also note that both Ti.Buffer and Node's Buffer were created before the JS engines had typed arrays
   * (and Uint8Array in particular) as a means of encapsulating a byte array. We should consider accepting
   * a Uint8Array in any of our APIs that take a Ti.Buffer and eventually deprecating/removing Ti.Buffer.
   */
const {
  ALL_PROPERTIES: ALL_PROPERTIES$1,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$1 } =
propertyFilter;
const VALID_ENCODINGS = ['hex', 'utf8', 'utf-8', 'ascii', 'latin1', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le']; // Used to cheat for read/writes of doubles

const doubleArray = new Float64Array(1);
const uint8DoubleArray = new Uint8Array(doubleArray.buffer); // Used to cheat to read/write floats

const floatArray = new Float32Array(1);
const uint8FloatArray = new Uint8Array(floatArray.buffer); // Node.js does some very weird stuff here

FastBuffer.prototype.constructor = Buffer$1; // new FastBuffer() calls Buffer function?

Buffer$1.prototype = FastBuffer.prototype; // Then it hijacks Buffer's prototype to point at FastBuffer's?!
// Does this effectively mean Buffer extends Uint8Array, because FastBuffer did? This fails for me
// How the hell can we make it happy? We really want to extend Uint8Array if we can
// addBufferPrototypeMethods(Buffer.prototype); // Here's where it hangs some of the methods

Buffer$1.poolSize = 8192;
/**
                           * Constructs a new buffer.
                           *
                           * Primarily used internally in this module together with `newBuffer` to
                           * create a new Buffer instance wrapping a Ti.Buffer.
                           *
                           * Also supports the deprecated Buffer() constructors which are safe
                           * to use outside of this module.
                           *
                           * @param {integer[]|Buffer|integer|string|Ti.Buffer} arg the underlying data/bytes
                           * @param {string|integer} encodingOrOffset encoding of the string, or start offset of array/buffer
                           * @param {integer} length length of the underlying array/buffer to wrap
                           * @returns {Buffer}
                           */

function Buffer$1(arg, encodingOrOffset, length) {
  if (arg === undefined) {
    return;
  }

  if (typeof arg !== 'object' || arg.apiName !== 'Ti.Buffer') {
    showFlaggedDeprecation();

    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(`The "string" argument must be of type "string". Received type ${typeof arg}`);
      }

      return Buffer$1.alloc(arg);
    }

    return Buffer$1.from(arg, encodingOrOffset, length);
  } // The slow case - we're wrapping a Ti.Buffer


  return SlowBuffer.fromTiBuffer(arg, encodingOrOffset, length);
}
/**
   * @param {integer[]|Buffer|string} value value we're wrapping
   * @param {string|number} [encodingOrOffset]
   * @param {number} [length]
   * @returns {Buffer}
   */


Buffer$1.from = function (value, encodingOrOffset, length) {
  const valueType = typeof value;

  if (valueType === 'string') {
    return fromString(value, encodingOrOffset);
  } else if (valueType === 'object') {
    if (isAnyArrayBuffer(value)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }

    if (Array.isArray(value) || value instanceof Uint8Array) {
      return fromArray(value);
    }

    if (Buffer$1.isBuffer(value)) {
      return fromBuffer(value);
    } // We want to limit the use of SlowBuffers to only when we're wrapping a Ti.Buffer, hopefully!


    if (value.apiName && value.apiName === 'Ti.Buffer') {
      return SlowBuffer.fromTiBuffer(value);
    }
  }

  throw new TypeError('The \'value\' argument must be one of type: \'string\', \'Array\', \'Buffer\', \'Ti.Buffer\'');
};
/**
    * @param {ArrayBuffer} obj ArrayBuffer to wrap
    * @param {number} [byteOffset=0] byte offste to begin
    * @param {number} [length] length to wrap
    * @returns {Buffer}
    */


function fromArrayBuffer(obj, byteOffset, length) {
  // Convert byteOffset to integer
  if (byteOffset === undefined) {
    byteOffset = 0;
  } else {
    byteOffset = +byteOffset;

    if (Number.isNaN(byteOffset)) {
      byteOffset = 0;
    }
  }

  const maxLength = obj.byteLength - byteOffset;

  if (maxLength < 0) {
    throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('offset');
  }

  if (length === undefined) {
    length = maxLength;
  } else {
    // Convert length to non-negative integer.
    length = +length;

    if (length > 0) {
      if (length > maxLength) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS('length');
      }
    } else {
      length = 0;
    }
  }

  return new FastBuffer(obj, byteOffset, length);
}
/**
   * @param {string} value value to wrap
   * @param {string} [encoding='utf8'] character encoding
   * @returns {Buffer}
   */


function fromString(value, encoding = 'utf8') {
  if (!Buffer$1.isEncoding(encoding)) {
    throw new TypeError(`Unknown encoding: ${encoding}`);
  }

  encoding = encoding.toLowerCase();

  if (encoding === 'base64') {
    const blob = Ti.Utils.base64decode(value);
    return new FastBuffer(blob.toArrayBuffer());
  }

  if (encoding === 'hex') {
    return fromArray(stringToHexBytes(value));
  } // Convert the SlowBuffer to a fast buffer by just copying bytes recursively here


  return fromBuffer(SlowBuffer.fromString(value, encoding));
}
/**
   * @param {integer[]|Uint8Array|array} value values to wrap
   * @returns {Buffer}
   */


function fromArray(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  return new FastBuffer(value);
}
/**
   * Ideally this should only be used when we're copying a SlowBuffer into a new FastBuffer
   * @param {Buffer} value buffer to copy
   * @returns {Buffer}
   */


function fromBuffer(value) {
  const length = value.length;

  if (length === 0) {
    return new FastBuffer();
  }

  const buffer = Buffer$1.allocUnsafe(length);
  value.copy(buffer, 0, 0, length);
  return buffer;
}

Object.setPrototypeOf(Buffer$1, Uint8Array); // What is this doing?! Making Buffer.prototype point at Uint8Array now

/**
 * 0 is returned if target is the same as buf
 * 1 is returned if target should come before buf when sorted.
 * -1 is returned if target should come after buf when sorted.
 * @param {Buffer} target Buffer to compare against
 * @param {integer} [targetStart=0] index to start in target
 * @param {integer} [targetEnd=target.length] index to end in target
 * @param {integer} [sourceStart=0] index to start in this Buffer
 * @param {integer} [sourceEnd=this.length] index to end in this Buffer
 * @returns {integer}
 */

Buffer$1.prototype.compare = function (target, targetStart, targetEnd, sourceStart, sourceEnd) {
  if (!Buffer$1.isBuffer(target)) {
    throw new TypeError(`The "target" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  }

  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (targetEnd === undefined) {
    targetEnd = target.length;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  } // ERR_OUT_OF_RANGE is thrown if targetStart < 0, sourceStart < 0, targetEnd > target.byteLength, or sourceEnd > source.byteLength


  if (targetStart < 0 || sourceStart < 0 || targetEnd > target.length || sourceEnd > this.length) {
    throw new RangeError('Index out of range'); // FIXME: set "code" to ERR_INDEX_OUT_OF_RANGE
  } // Use slices to make the loop easier


  const source = this.slice(sourceStart, sourceEnd);
  const sourceLength = source.length;
  const dest = target.slice(targetStart, targetEnd);
  const destLength = dest.length;
  const length = Math.min(sourceLength, destLength);

  for (let i = 0; i < length; i++) {
    const targetValue = dest.getAdjustedIndex(i);
    const sourceValue = source.getAdjustedIndex(i);

    if (targetValue !== sourceValue) {
      // No match! Return 1 or -1 based on what is greater!
      if (sourceValue < targetValue) {
        return -1;
      }

      return 1;
    }
  } // sort based on length!


  if (sourceLength < destLength) {
    return -1;
  }

  if (sourceLength > destLength) {
    return 1;
  }

  return 0;
};
/**
    * Copies from this to target
    * @param {Buffer} target destination we're copying into
    * @param {integer} [targetStart=0] start index to copy into in destination Buffer
    * @param {integer} [sourceStart=0] start index to copy from within `this`
    * @param {integer} [sourceEnd=this.length] end index to copy from within `this`
    * @returns {integer} number of bytes copied
    */


Buffer$1.prototype.copy = function (target, targetStart, sourceStart, sourceEnd) {
  if (targetStart === undefined) {
    targetStart = 0;
  }

  if (sourceStart === undefined) {
    sourceStart = 0;
  }

  if (sourceEnd === undefined) {
    sourceEnd = this.length;
  }

  if (sourceStart === sourceEnd) {
    return 0;
  }

  if (target.length === 0 || this.length === 0) {
    return 0;
  } // TODO: check for out of bounds?


  let length = sourceEnd - sourceStart; // Cap length to remaining bytes in target!

  const remaining = target.length - targetStart;

  if (length > remaining) {
    sourceEnd = sourceStart + remaining;
    length = remaining;
  } // Determine actual number of bytes we'll copy, constrain by source buffer length as well as target (above)


  let numBytes = length;
  const sourceLen = this.length - sourceStart;

  if (numBytes > sourceLen) {
    numBytes = sourceLen;
  } // TODO: handle overlap when target === this!
  // TODO: Do we need to take target byteOffset into account here?


  let source = this;

  if (sourceStart !== 0 || sourceEnd < source.length) {
    source = new Uint8Array(this.buffer, this.byteOffset + sourceStart, numBytes);
  }

  target.set(source, targetStart);
  return numBytes;
};
/**
    * Creates and returns an iterator of [index, byte] pairs from the contents of buf.
    * @returns {Iterator}
    */
// TODO: Is this only necessary for SlowBuffer?


Buffer$1.prototype.entries = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const entryIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: [nextIndex, buffer.getAdjustedIndex(nextIndex)],
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return entryIterator;
};

Buffer$1.prototype.equals = function (otherBuffer) {
  if (!Buffer$1.isBuffer(otherBuffer)) {
    throw new TypeError('argument must be a Buffer');
  }

  if (otherBuffer === this) {
    return true;
  }

  return this.compare(otherBuffer) === 0;
};
/**
    * @param {string|Buffer|UInt8Array|integer} value The value with which to fill `buf`.
    * @param {integer} [offset=0] Number of bytes to skip before starting to fill `buf`
    * @param {integer} [end] Where to stop filling buf (not inclusive). `buf.length` by default
    * @param {string} [encoding='utf8'] The encoding for `value` if `value` is a string.
    * @returns {this}
    */


Buffer$1.prototype.fill = function (value, offset, end, encoding) {
  const offsetType = typeof offset;

  if (offsetType === 'undefined') {
    // value supplied
    offset = 0;
    end = this.length;
    encoding = 'utf8';
  } else if (offsetType === 'string') {
    // value, encoding supplied
    encoding = offset;
    offset = 0;
    end = this.length;
  } else if (typeof end === 'string') {
    // value, offset, encoding supplied
    encoding = end;
    end = this.length;
  }

  this._fill(value, offset, end, encoding);

  return this;
};

const TypedArrayPrototype$1 = Object.getPrototypeOf(Uint8Array.prototype);
const TypedArrayProto_byteLength = Object.getOwnPropertyDescriptor(TypedArrayPrototype$1, 'byteLength').get;
const TypedArrayFill = TypedArrayPrototype$1.fill;

Buffer$1.prototype._fill = function (value, offset, end, encoding) {
  if (typeof value === 'number') {
    // OOB check
    const byteLen = TypedArrayProto_byteLength.call(this);
    const fillLength = end - offset;

    if (offset > end || fillLength + offset > byteLen) {
      throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }

    TypedArrayFill.call(this, value, offset, end);
  } else {
    const bufToFillWith = SlowBuffer.fromString(value, encoding);
    const fillBufLength = bufToFillWith.length;

    if (fillBufLength === 0) {
      throw new Error('no valid fill data');
    }

    if (fillBufLength === 1) {
      TypedArrayFill.call(this, bufToFillWith._tiBuffer[0], offset, end);
      return this;
    } // multiple byte fill!


    const length = end - offset;

    for (let i = 0; i < length; i++) {
      // TODO: Do we need to account for byteOffset here (on `this`, not on the buffer we just created)?
      const fillChar = bufToFillWith._tiBuffer[i % fillBufLength];
      this.setAdjustedIndex(i + offset, fillChar);
    }
  }
};

Buffer$1.prototype.includes = function (value, byteOffset, encoding) {
  return this.indexOf(value, byteOffset, encoding) !== -1;
};
/**
    * @param {string|Buffer|integer} value What to search for
    * @param {integer} [byteOffset=0] Where to begin searching in buf. If negative, then offset is calculated from the end of buf
    * @param {string} [encoding='utf8'] If value is a string, this is the encoding used to determine the binary representation of the string that will be searched for in buf
    * @returns {integer} The index of the first occurrence of value in buf, or -1 if buf does not contain value.
    */


Buffer$1.prototype.indexOf = function (value, byteOffset, encoding) {
  if (this.length === 0) {
    // empty buffer? can't find anything!
    return -1;
  } // if byteOffset is undefined, make it 0


  if (typeof byteOffset === 'undefined') {
    byteOffset = 0;
  } else if (typeof byteOffset === 'string') {
    // if it's a string, that's actually encoding
    encoding = byteOffset;
    byteOffset = 0;
  } // if we don't have an encoding yet, use utf8


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  if (byteOffset < 0) {
    // convert negative indices
    byteOffset = this.length + byteOffset;

    if (byteOffset < 0) {
      // still negative? start at 0
      byteOffset = 0;
    }
  } else if (byteOffset >= this.length) {
    return -1; // can't find past end of buffer!
  }

  if (typeof value === 'number') {
    value &= 0xFF; // clamp to 255
    // This is a simpler case, we have a single byte we need to search for
    // so just loop through and try to find it

    return indexOf(this, value, byteOffset);
  } // coerce a string to a Buffer


  if (typeof value === 'string') {
    value = fromString(value, encoding);
  } // value is now a Buffer...


  const matchLength = value.length;

  if (matchLength === 0) {
    return -1; // never find empty value!
  }

  if (matchLength === 1) {
    // simple case, match one byte!
    return indexOf(this, value[0], byteOffset);
  }

  let currentIndex = byteOffset;
  const thisLength = this.length;

  if (matchLength > thisLength) {
    return -1; // can't match if the value is longer than this Buffer!
  } // FIXME: Can we rewrite this in a less funky way?
  // FIXME: Can stop earlier based on matchLength!


  firstMatch: while (currentIndex < thisLength) {
    // eslint-disable-line no-labels
    // match first byte!
    let firstByteMatch = indexOf(this, value[0], currentIndex);

    if (firstByteMatch === -1) {
      // couldn't even match the very first byte, so no match overall!
      return -1;
    } // ok, we found the first byte, now we need to see if the next consecutive bytes match!


    for (let x = 1; x < matchLength; x++) {
      if (firstByteMatch + x >= thisLength) {
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }

      if (this[firstByteMatch + x] !== value[x]) {
        // didn't match!
        currentIndex = firstByteMatch + 1; // move past our first match

        continue firstMatch; // eslint-disable-line no-labels
      }
    }

    return firstByteMatch; // the rest matched, hurray!
  }

  return -1;
};

Buffer$1.prototype.keys = function () {
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: nextIndex,
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
    * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
    */


Buffer$1.prototype.readDoubleBE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[7] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[0] = this[offset++];
  return doubleArray[0];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 8
    * @returns {double} Reads a 64-bit double from buf at the specified offset with specified endian format
    */


Buffer$1.prototype.readDoubleLE = function (offset = 0) {
  checkOffset(this, offset, 8); // Node cheats and uses a Float64Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float64Array
  // FIXME: This assumes LE system byteOrder

  uint8DoubleArray[0] = this[offset++];
  uint8DoubleArray[1] = this[offset++];
  uint8DoubleArray[2] = this[offset++];
  uint8DoubleArray[3] = this[offset++];
  uint8DoubleArray[4] = this[offset++];
  uint8DoubleArray[5] = this[offset++];
  uint8DoubleArray[6] = this[offset++];
  uint8DoubleArray[7] = this[offset++];
  return doubleArray[0];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
    * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
    */


Buffer$1.prototype.readFloatBE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[3] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[0] = this[offset++];
  return floatArray[0];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4
    * @returns {float} Reads a 32-bit float from buf at the specified offset with specified endian format
    */


Buffer$1.prototype.readFloatLE = function (offset = 0) {
  checkOffset(this, offset, 4); // Node cheats and uses a Float32Array and UInt8Array backed by the same buffer
  // so basically it reads in the bytes stuffing them into Uint8Array, then returns the value from the Float32Array
  // FIXME: This assumes LE system byteOrder

  uint8FloatArray[0] = this[offset++];
  uint8FloatArray[1] = this[offset++];
  uint8FloatArray[2] = this[offset++];
  uint8FloatArray[3] = this[offset++];
  return floatArray[0];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
    * @returns {integer}
    */


Buffer$1.prototype.readInt8 = function (offset = 0) {
  const unsignedValue = this.readUInt8(offset);
  return unsignedToSigned(unsignedValue, 1);
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.readInt16BE = function (offset) {
  const unsignedValue = this.readUInt16BE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.readInt16LE = function (offset = 0) {
  const unsignedValue = this.readUInt16LE(offset);
  return unsignedToSigned(unsignedValue, 2);
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.readInt32BE = function (offset = 0) {
  const unsignedValue = this.readUInt32BE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.readInt32LE = function (offset = 0) {
  const unsignedValue = this.readUInt32LE(offset);
  return unsignedToSigned(unsignedValue, 4);
};
/**
    * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
    * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.readIntBE = function (offset, byteLength) {
  const unsignedValue = this.readUIntBE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
    * Reads byteLength number of bytes from buf at the specified offset and interprets the result as a two's complement signed value. Supports up to 48 bits of accuracy.
    * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength umber of bytes to read. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.readIntLE = function (offset, byteLength) {
  const unsignedValue = this.readUIntLE(offset, byteLength);
  return unsignedToSigned(unsignedValue, byteLength);
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 1.
    * @returns {integer}
    */


Buffer$1.prototype.readUInt8 = function (offset = 0) {
  checkOffset(this, offset, 1);
  return this[offset];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.readUInt16BE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte shifted and OR'd with second byte

  return this[offset] << 8 | this[offset + 1];
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.readUInt16LE = function (offset = 0) {
  checkOffset(this, offset, 2); // first byte OR'd with second byte shifted

  return this[offset] | this[offset + 1] << 8;
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.readUInt32BE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]); // rather than shifting by << 24, multiply the first byte and add it in so we don't retain the "sign bit"
  // (because bit-wise operators assume a 32-bit number)
};
/**
    * @param {integer} [offset=0] Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.readUInt32LE = function (offset = 0) {
  checkOffset(this, offset, 4);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000; // rather than shifting by << 24, multiply the last byte and add it in so we don't retain the "sign bit"
};
/**
    * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.readUIntBE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte
  // we're doing the same loop as #readUIntLE, just backwards!

  for (let i = byteLength - 1; i >= 0; i--) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
    * @param {integer} offset Number of bytes to skip before starting to read. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to read. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.readUIntLE = function (offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  let result = 0;
  let multiplier = 1; // we use a multipler for each byte

  for (let i = 0; i < byteLength; i++) {
    result += this.getAdjustedIndex(offset + i) * multiplier;
    multiplier *= 0x100; // move multiplier to next byte
  }

  return result;
};
/**
    * @param {integer} [start=0] Where the new `Buffer` will start.
    * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
    * @returns {Buffer}
    */


Buffer$1.prototype.slice = function (start, end) {
  const thisLength = this.length;

  if (typeof start === 'undefined') {
    start = 0;
  } else if (start < 0) {
    start = thisLength + start;

    if (start < 0) {
      // if this is still negative, use 0 (that matches Node)
      start = 0;
    }
  }

  if (typeof end === 'undefined') {
    end = thisLength;
  } else if (end < 0) {
    end = thisLength + end;
  } // Specifying end greater than buf.length will return the same result as that of end equal to buf.length.


  if (end > thisLength) {
    end = thisLength;
  } // What if end is less than start?


  let length = end - start;

  if (length <= 0) {
    length = 0; // return empty view of Buffer! retain byte offset, set length to 0
  } // Wrap the same ArrayBuffer object but specify the start/end to "crop" with


  return this._slice(this.byteOffset + start, length);
};

Buffer$1.prototype._slice = function (offset, length) {
  return new FastBuffer(this.buffer, offset, length);
};
/**
    * @param {integer} [start=0] Where the new `Buffer` will start.
    * @param {integer} [end=this.length] Where the new Buffer will end (not inclusive). Default: `buf.length`.
    * @returns {Buffer}
    */


Buffer$1.prototype.subarray = function (start, end) {
  return this.slice(start, end);
};
/**
    * Interprets buf as an array of unsigned 16-bit integers and swaps the byte order in-place.
    * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 2.
    * @returns {Buffer}
    */


Buffer$1.prototype.swap16 = function () {
  const length = this.length;

  if (length % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (let i = 0; i < length; i += 2) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    this.setAdjustedIndex(i, second);
    this.setAdjustedIndex(i + 1, first);
  }

  return this;
};
/**
    * Interprets buf as an array of unsigned 32-bit integers and swaps the byte order in-place.
    * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 4.
    * @returns {Buffer}
    */


Buffer$1.prototype.swap32 = function () {
  const length = this.length;

  if (length % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (let i = 0; i < length; i += 4) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    this.setAdjustedIndex(i, fourth);
    this.setAdjustedIndex(i + 1, third);
    this.setAdjustedIndex(i + 2, second);
    this.setAdjustedIndex(i + 3, first);
  }

  return this;
};
/**
    * Interprets buf as an array of unsigned 64-bit integers and swaps the byte order in-place.
    * Throws ERR_INVALID_BUFFER_SIZE if buf.length is not a multiple of 8.
    * @returns {Buffer}
    */


Buffer$1.prototype.swap64 = function () {
  const length = this.length;

  if (length % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (let i = 0; i < length; i += 8) {
    const first = this.getAdjustedIndex(i);
    const second = this.getAdjustedIndex(i + 1);
    const third = this.getAdjustedIndex(i + 2);
    const fourth = this.getAdjustedIndex(i + 3);
    const fifth = this.getAdjustedIndex(i + 4);
    const sixth = this.getAdjustedIndex(i + 5);
    const seventh = this.getAdjustedIndex(i + 6);
    const eighth = this.getAdjustedIndex(i + 7);
    this.setAdjustedIndex(i, eighth);
    this.setAdjustedIndex(i + 1, seventh);
    this.setAdjustedIndex(i + 2, sixth);
    this.setAdjustedIndex(i + 3, fifth);
    this.setAdjustedIndex(i + 4, fourth);
    this.setAdjustedIndex(i + 5, third);
    this.setAdjustedIndex(i + 6, second);
    this.setAdjustedIndex(i + 7, first);
  }

  return this;
};
/**
    * @returns {object}
    */


Buffer$1.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    // Take advantage of slice working on "Array-like" objects (just like `arguments`)
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice#Array-like_objects
    data: [].slice.call(this) };

};
/**
    * @param {string} [encoding='utf8'] The character encoding to use
    * @param {integer} [start=0] The byte offset to start decoding at
    * @param {integer} [end] The byte offset to stop decoding at (not inclusive). `buf.length` default
    * @returns {string}
    */


Buffer$1.prototype.toString = function (encoding, start, end) {
  // fast case of no args
  if (arguments.length === 0) {
    return this.toTiBuffer().toString();
  }

  const length = this.length;

  if (start >= length) {
    return ''; // start is past end of buffer, return empty string
  }

  if (start < 0 || typeof start !== 'number') {
    start = 0;
  }

  if (end > length || typeof end !== 'number') {
    // no end specified, or past end of buffer, use length of buffer
    end = length;
  } // else keep end as passed in


  if (end <= start) {
    return ''; // if end is before start return empty string
  } // If start !== 0 and end !== length, maybe we should do a Buffer.subarray/slice over the range and call toString() on that?


  if (start !== 0 || end !== length) {
    return this.slice(start, end).toString(encoding);
  } // base case, start is 0, end is length


  if (encoding === undefined) {
    encoding = 'utf8';
  } else {
    encoding = encoding.toLowerCase(); // Throw if bad encoding!

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError(`Unknown encoding: ${encoding}`);
    }
  }

  if (encoding === 'utf8' || encoding === 'utf-8') {
    return this.toTiBuffer().toString(); // we return utf-8 by default natively
  }

  if (encoding === 'base64') {
    return Ti.Utils.base64encode(this.toTiBuffer().toBlob()).toString();
  }

  if (encoding === 'hex') {
    return this.hexSlice(0, length);
  }

  if (encoding === 'latin1' || encoding === 'binary') {
    let latin1String = '';

    for (let i = 0; i < length; i++) {
      // each one is a "byte"
      latin1String += String.fromCharCode(this.getAdjustedIndex(i));
    }

    return latin1String;
  }

  if (encoding === 'ascii') {
    let ascii = '';

    for (let i = 0; i < length; i++) {
      // we store bytes (8-bit), but ascii is 7-bit. Node "masks" the last bit off, so let's do the same
      ascii += String.fromCharCode(this.getAdjustedIndex(i) & 0x7F);
    }

    return ascii;
  } // UCS2/UTF16


  return this.ucs2Slice(0, length);
};

Buffer$1.prototype.getAdjustedIndex = function (index) {
  return this[index];
};

Buffer$1.prototype.setAdjustedIndex = function (index, value) {
  return this[index] = value;
};

Buffer$1.prototype.hexSlice = function (start, end) {
  let hexStr = '';

  for (let i = start; i < end; i++) {
    // each one is a "byte"
    let hex = (this.getAdjustedIndex(i) & 0xff).toString(16);
    hex = hex.length === 1 ? '0' + hex : hex;
    hexStr += hex;
  }

  return hexStr;
};

Buffer$1.prototype.ucs2Slice = function (start, end) {
  let out = '';
  let i = start;

  while (i < end) {
    // utf-16/ucs-2 is 2-bytes per character
    const byte1 = this.getAdjustedIndex(i++);
    const byte2 = this.getAdjustedIndex(i++);
    const code_unit = (byte2 << 8) + byte1; // we mash together the two bytes

    out += String.fromCodePoint(code_unit);
  }

  return out;
};
/**
    * Provides a conversion method for interacting with Ti APIs that require a Ti.Buffer
    * @returns {Ti.Buffer} the underlying Ti.Buffer backing this Buffer instance
    */


Buffer$1.prototype.toTiBuffer = function () {
  const tiBuffer = Ti.createBuffer({
    length: this.length });

  copyBuffer(this, tiBuffer, 0, this.length);
  return tiBuffer;
};
/**
    * @param {Buffer} src source Buffer we're copying from
    * @param {Ti.Buffer} dest destination Ti.Buffer we're copying into
    * @param {integer} offset start offset we're copying to in destination
    * @param {integer} length number of bytes to copy
    * @returns {integer} actual number of bytes copied
    */


function copyBuffer(src, dest, offset, length) {
  const srcLength = src.length;
  const destLength = dest.length;
  let i = 0;

  for (; i < length; i++) {
    const destIndex = i + offset; // are we trying to write past end of destination? Or read past end of source? Stop!

    if (destIndex >= destLength || i >= srcLength) {
      break;
    }

    dest[destIndex] = src[i];
  }

  return i;
}
/**
   * Creates and returns an iterator for buf values (bytes)
   * @returns {Iterator}
   */
// TODO: Move to SlowBuffer?


Buffer$1.prototype.values = function () {
  const buffer = this;
  let nextIndex = 0;
  const end = this.length;
  const myIterator = {
    next: function () {
      if (nextIndex < end) {
        const result = {
          value: buffer.getAdjustedIndex(nextIndex),
          done: false };

        nextIndex++;
        return result;
      }

      return {
        value: undefined,
        done: true };

    },
    [Symbol.iterator]: function () {
      return this;
    } };

  return myIterator;
};
/**
    * Called when buffer is used in a for..of loop. Delegates to #values()
    * @returns {Iterator}
    */
// TODO: Move to SlowBuffer?


Buffer$1.prototype[Symbol.iterator] = function () {
  return this.values();
};
/**
    * Writes string to buf at offset according to the character encoding in encoding.
    * The length parameter is the number of bytes to write. If buf did not contain enough space to
    * fit the entire string, only part of string will be written. However, partially encoded
    * characters will not be written.
    * @param {string} string String to write to `buf`.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write string
    * @param {integer} [length=buf.length - offset] Number of bytes to write
    * @param {string} [encoding='utf8'] The character encoding of string
    * @returns {integer}
    */


Buffer$1.prototype.write = function (string, offset, length, encoding) {
  if (typeof offset === 'string') {
    encoding = offset;
    offset = 0;
    length = this.length;
  } else if (typeof length === 'string') {
    encoding = length;
    length = this.length - offset;
  } else {
    // we cap `length` at the length of our buffer
    const remaining = this.length - offset;

    if (length > remaining) {
      length = remaining;
    }
  }

  encoding = encoding || 'utf8'; // so we need to convert `remaining` bytes of our string into a byte array/buffer

  const src = fromString(string, encoding); // FIXME: Can we let it know to only convert `remaining` bytes?
  // then stick that into our buffer starting at `offset`!

  return src.copy(this, offset, 0, length);
};

Buffer$1.prototype.writeDoubleBE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeDoubleLE = function (value, offset = 0) {
  checkOffset(this, offset, 8);
  doubleArray[0] = value;
  this.setAdjustedIndex(offset++, uint8DoubleArray[0]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[1]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[2]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[3]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[4]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[5]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[6]);
  this.setAdjustedIndex(offset++, uint8DoubleArray[7]);
  return offset; // at this point, we should have already added 8 to offset
};

Buffer$1.prototype.writeFloatBE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  return offset; // at this point, we should have already added 4 to offset
};

Buffer$1.prototype.writeFloatLE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  floatArray[0] = value;
  this.setAdjustedIndex(offset++, uint8FloatArray[0]);
  this.setAdjustedIndex(offset++, uint8FloatArray[1]);
  this.setAdjustedIndex(offset++, uint8FloatArray[2]);
  this.setAdjustedIndex(offset++, uint8FloatArray[3]);
  return offset; // at this point, we should have already added 4 to offset
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
    * @returns {integer}
    */


Buffer$1.prototype.writeInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, -128, 127);

  if (value >= 0) {
    // just write it normally
    this.setAdjustedIndex(offset, value);
  } else {
    // convert from signed to 2's complement bits
    this.setAdjustedIndex(offset, 0xFF + value + 1); // max value, plus the negative number, add one
  }

  return offset + 1;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.writeInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value >>> 8); // just shift over a byte

  this.setAdjustedIndex(offset + 1, value & 0xFF); // mask to first byte

  return offset + 2;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.writeInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, -32768, 32767);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.writeInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xFF);
  return offset + 4;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.writeInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, -2147483648, 2147483647);
  this.setAdjustedIndex(offset, value & 0xFF);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.writeIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0x100;
  }

  return offset + byteLength;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.writeIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  const minMaxBase = Math.pow(2, 8 * byteLength - 1);
  checkValue(value, -minMaxBase, minMaxBase - 1);

  if (value < 0) {
    value = minMaxBase * 2 + value;
  }

  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 1.
    * @returns {integer}
    */


Buffer$1.prototype.writeUInt8 = function (value, offset = 0) {
  checkOffset(this, offset, 1);
  checkValue(value, 0, 255);
  this.setAdjustedIndex(offset, value);
  return offset + 1;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.writeUInt16BE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value >>> 8);
  this.setAdjustedIndex(offset + 1, value & 0xff);
  return offset + 2;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 2.
    * @returns {integer}
    */


Buffer$1.prototype.writeUInt16LE = function (value, offset = 0) {
  checkOffset(this, offset, 2);
  checkValue(value, 0, 65535);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  return offset + 2;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.writeUInt32BE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value >>> 24);
  this.setAdjustedIndex(offset + 1, value >>> 16);
  this.setAdjustedIndex(offset + 2, value >>> 8);
  this.setAdjustedIndex(offset + 3, value & 0xff);
  return offset + 4;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} [offset=0] Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - 4.
    * @returns {integer}
    */


Buffer$1.prototype.writeUInt32LE = function (value, offset = 0) {
  checkOffset(this, offset, 4);
  checkValue(value, 0, 4294967295);
  this.setAdjustedIndex(offset, value & 0xff);
  this.setAdjustedIndex(offset + 1, value >>> 8);
  this.setAdjustedIndex(offset + 2, value >>> 16);
  this.setAdjustedIndex(offset + 3, value >>> 24);
  return offset + 4;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.writeUIntBE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = byteLength - 1; i >= 0; i--) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
};
/**
    * @param {integer} value Number to be written to buf.
    * @param {integer} offset Number of bytes to skip before starting to write. Must satisfy 0 <= offset <= buf.length - byteLength.
    * @param {integer} byteLength Number of bytes to write. Must satisfy 0 < byteLength <= 6.
    * @returns {integer}
    */


Buffer$1.prototype.writeUIntLE = function (value, offset, byteLength) {
  if (byteLength <= 0 || byteLength > 6) {
    throw new RangeError('Index out of range');
  }

  checkOffset(this, offset, byteLength);
  checkValue(value, 0, Math.pow(2, 8 * byteLength) - 1);
  let multiplier = 1;

  for (let i = 0; i < byteLength; i++) {
    let byteValue = value / multiplier & 0xFF;
    this.setAdjustedIndex(offset + i, byteValue);
    multiplier *= 0X100;
  }

  return offset + byteLength;
}; // TODO: Implement remaining instance methods:
// buf.lastIndexOf(value[, byteOffset][, encoding])
// buf.readBigInt64BE([offset])
// buf.readBigInt64LE([offset])
// buf.readBigUInt64BE([offset])
// buf.readBigUInt64LE([offset])
// buf.writeBigInt64BE(value[, offset])
// buf.writeBigInt64LE(value[, offset])
// buf.writeBigUInt64BE(value[, offset])
// buf.writeBigUInt64LE(value[, offset])
// FIXME: We need to minimize using a backing Ti.Buffer whenever possible, because
// going back and forth across the bridge for every byte is *very* expensive
// Ideally we should have a "SlowBuffer" that is used when we explicitly wrap a Ti.Buffer
// So that writes are passed through. Otherwise we should avoid using one at all costs
// i.e. when we do Buffer.concat and are only doing reads - why do we need a Ti.Buffer?
// Can we have Ti.Buffer really just wrap a Uint8Array and add it's own methods?


Buffer$1.allocUnsafe = function (length) {
  return new FastBuffer(length);
};

Buffer$1.allocUnsafeSlow = function (length) {
  return Buffer$1.allocUnsafe(length);
};

Buffer$1.alloc = function (length, fill = 0, encoding = 'utf8') {
  const buf = Buffer$1.allocUnsafe(length);

  if (fill !== 0) {
    buf.fill(fill, encoding);
  }

  return buf;
};
/**
    * @param {string|Buffer|TypedArray|DataView|ArrayBuffer|SharedArrayBuffer} string original string
    * @param {string} [encoding='utf8'] encoding whose byte length we need to grab
    * @returns {integer}
    */


Buffer$1.byteLength = function (string, encoding = 'utf8') {
  if (typeof string !== 'string') {
    if (Buffer$1.isBuffer(string)) {
      return string.length; // return Buffer's length
    }

    return string.byteLength; // TypedArray, ArrayBuffer, SharedArrayBuffer, DataView
  }

  let length = string.length;

  switch (encoding.toLowerCase()) {
    case 'utf8':
    case 'utf-8':
      return utf8ByteLength(string);

    case 'latin1':
    case 'binary':
    case 'ascii':
      return length;

    case 'ucs-2':
    case 'ucs2':
    case 'utf16le':
    case 'utf16-le':
      return 2 * length;

    case 'hex':
      return length / 2;

    case 'base64':
      // Subtract up to two padding chars from end of string!
      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      if (length > 1 && string.charAt(length - 1) === '=') {
        length--;
      }

      return Math.floor(length * 3 / 4);
    // drop fractional value
  }

  return utf8ByteLength(string);
};

Buffer$1.compare = function (buf1, buf2) {
  if (!Buffer$1.isBuffer(buf1)) {
    throw new TypeError(`The "buf1" argument must be one of type Buffer or Uint8Array. Received type ${typeof buf1}`);
  } // TODO: Wrap UInt8Array args in buffers?


  return buf1.compare(buf2);
};
/**
    * @param {Buffer[]|UInt8Array[]} list list of Buffers to concatenate
    * @param {integer} [totalLength] Total length of the Buffer instances in list when concatenated.
    * @returns {Buffer}
    */


Buffer$1.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new TypeError('list argument must be an Array');
  }

  if (list.length === 0) {
    return new FastBuffer(); // one empty Buffer!
  } // allocate one Buffer of `totalLength`? Cap at totalLength?


  if (totalLength === undefined) {
    totalLength = 0; // generate the total length from each buffer's length?

    for (let i = 0; i < list.length; i++) {
      totalLength += list[i].length;
    }
  }

  const result = Buffer$1.allocUnsafe(totalLength);
  let position = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    buf.copy(result, position);
    position += buf.length;

    if (position >= totalLength) {
      break;
    }
  }

  return result;
};
/**
    * @param {string} encoding possible encoding name
    * @returns {boolean}
    */


Buffer$1.isEncoding = function (encoding) {
  if (typeof encoding !== 'string') {
    return false;
  }

  return VALID_ENCODINGS.includes(encoding.toLowerCase());
};
/**
    * @param {*} obj possible Buffer instance
    * @returns {boolean}
    */


Buffer$1.isBuffer = function (obj) {
  return obj !== null && obj !== undefined && (obj instanceof Buffer$1 || obj[isBuffer] === true);
};

let INSPECT_MAX_BYTES = 50; // Override how buffers are presented by util.inspect().

Buffer$1.prototype[customInspectSymbol] = function (recurseTimes, ctx) {
  const max = INSPECT_MAX_BYTES;
  const actualMax = Math.min(max, this.length);
  const remaining = this.length - max;
  let str = this.slice(0, actualMax).toString('hex').replace(/(.{2})/g, '$1 ').trim();

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  } // Inspect special properties as well, if possible.


  if (ctx) {
    let extras = false;
    const filter = ctx.showHidden ? ALL_PROPERTIES$1 : ONLY_ENUMERABLE$1;
    const obj = getOwnNonIndexProperties(this, filter).reduce((obj, key) => {
      extras = true;
      obj[key] = this[key];
      return obj;
    }, Object.create(null));

    if (extras) {
      if (this.length !== 0) {
        str += ', ';
      } // '[Object: null prototype] {'.length === 26
      // This is guarded with a test.


      str += inspect(obj, { ...ctx,
        breakLength: Infinity,
        compact: true }).
      slice(27, -2);
    }
  }

  return `<${this.constructor.name} ${str}>`;
};

Buffer$1.prototype.inspect = Buffer$1.prototype[customInspectSymbol]; // HACK: ArrayBuffer.isView returns true for Node Buffer, but false for us. Until we can extend Uint8Array, we need to hack this sniffing method

const ArrayBufferIsView = ArrayBuffer.isView;

ArrayBuffer.isView = function (thing) {
  return ArrayBufferIsView(thing) || thing instanceof Buffer$1;
};

Object.setPrototypeOf(SlowBuffer.prototype, Buffer$1.prototype);
Object.setPrototypeOf(SlowBuffer, Buffer$1);
var BufferModule = {
  Buffer: Buffer$1,
  // TODO: Implement transcode()!
  transcode: (_source, _fromEncoding, _toEncoding) => {},
  INSPECT_MAX_BYTES: 50,
  kMaxLength: 2147483647,
  kStringMaxLength: 1073741799,
  constants: {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 1073741799 } };


/**
                                        * Searches a Buffer for the index of a single byte.
                                        * @param {Buffer} buffer buffer to search
                                        * @param {integer} singleByte byte we're looking for
                                        * @param {integer} offset start offset we search at
                                        * @returns {integer}
                                        */

function indexOf(buffer, singleByte, offset) {
  const length = buffer.length;

  for (let i = offset; i < length; i++) {
    if (buffer.getAdjustedIndex(i) === singleByte) {
      return i;
    }
  }

  return -1;
}
/**
   * This function explicitly avoids bitwise operations because JS assumes 32-bit sequences for those.
   * It's possible we may be able to use them when byteLength < 4 if that's faster.
   *
   * @param {integer} unsignedValue value before converting back to signed
   * @param {integer} byteLength number of bytes
   * @returns {integer} the signed value that is represented by the unsigned value's bytes
   */


function unsignedToSigned(unsignedValue, byteLength) {
  const bitLength = byteLength * 8;
  const maxPositiveValue = Math.pow(2, bitLength - 1);

  if (unsignedValue < maxPositiveValue) {
    return unsignedValue;
  }

  const maxUnsignedValue = Math.pow(2, bitLength);
  unsignedValue -= maxUnsignedValue;
  return unsignedValue;
}
/**
   * @param {string} string utf-8 string
   * @returns {integer}
   */


function utf8ByteLength(string) {
  // Just convert to a Ti.Buffer and let it tell us the length
  const buf = Ti.createBuffer({
    value: string,
    type: Ti.Codec.CHARSET_UTF8 });

  const length = buf.length;
  buf.release(); // release the buffer since we just needed the length

  return length;
}
/**
   * Throws a RangeError if offset is out of bounds
   * @param {Buffer} buffer buffer we're operating on
   * @param {integer} offset user supplied offset
   * @param {integer} byteLength number of bytes needed in range
   * @throws {RangeError}
   */


function checkOffset(buffer, offset, byteLength) {
  const endOffset = buffer.length - byteLength;

  if (offset < 0 || offset > endOffset) {
    throw new RangeError(`The value of "offset" is out of range. It must be >= 0 and <= ${endOffset}. Received ${offset}`);
  }
}
/**
   * @param {integer} value user-supplied value
   * @param {integer} min minimum valid value
   * @param {integer} max maximum valid value
   * @throws {RangeError}
   */


function checkValue(value, min, max) {
  if (value < min || value > max) {
    throw new RangeError(`The value of "value" is out of range. It must be >= ${min} and <= ${max}. Received ${value}`);
  }
}

let bufferWarningAlreadyEmitted = false;
let nodeModulesCheckCounter = 0;
const bufferWarning = 'Buffer() is deprecated due to security and usability ' + 'issues. Please use the Buffer.alloc(), ' + 'Buffer.allocUnsafe(), or Buffer.from() methods instead.';

function showFlaggedDeprecation() {
  if (bufferWarningAlreadyEmitted || ++nodeModulesCheckCounter > 10000 || isInsideNodeModules()) {
    // We don't emit a warning, because we either:
    // - Already did so, or
    // - Already checked too many times whether a call is coming
    //   from node_modules and want to stop slowing down things, or
    // - The code is inside `node_modules`.
    return;
  }

  process.emitWarning(bufferWarning, 'DeprecationWarning', 'DEP0005');
  bufferWarningAlreadyEmitted = true;
}

// Copyright Node.js contributors. All rights reserved.
const {
  ALL_PROPERTIES: ALL_PROPERTIES$2,
  ONLY_ENUMERABLE: ONLY_ENUMERABLE$2 } =
propertyFilter;
const BooleanPrototype = Boolean.prototype;
const DatePrototype = Date.prototype;
const ErrorPrototype = Error.prototype;
const NumberPrototype = Number.prototype;
const MapPrototype = Map.prototype;
const RegExpPrototype = RegExp.prototype;
const StringPrototype = String.prototype;
const SetPrototype = Set.prototype;
const SymbolPrototype = Symbol.prototype;
const isIos = ['ipad', 'iphone'].includes("android");
const {
  ERR_INVALID_ARG_TYPE } =
codes;
const hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
const propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
let hexSlice = uncurryThis(BufferModule.Buffer.prototype.hexSlice);
const builtInObjects = new Set(Object.getOwnPropertyNames(global).filter(e => /^([A-Z][a-z]+)+$/.test(e)));
const inspectDefaultOptions = Object.seal({
  showHidden: false,
  depth: 2,
  colors: false,
  customInspect: true,
  showProxy: false,
  maxArrayLength: 100,
  breakLength: 80,
  compact: 3,
  sorted: false,
  getters: false });

const kObjectType = 0;
const kArrayType = 1;
const kArrayExtrasType = 2;
/* eslint-disable no-control-regex */

const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c]/g;
/* eslint-enable no-control-regex */

const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const kMinLineLength = 16; // Constants to map the iterator state.

const kWeak = 0;
const kIterator = 1;
const kMapEntries = 2; // Escaped special characters. Use empty strings to fill up unused entries.

/* eslint-disable quotes */

const meta = ['\\u0000', '\\u0001', '\\u0002', '\\u0003', '\\u0004', '\\u0005', '\\u0006', '\\u0007', '\\b', '\\t', '\\n', '\\u000b', '\\f', '\\r', '\\u000e', '\\u000f', '\\u0010', '\\u0011', '\\u0012', '\\u0013', '\\u0014', '\\u0015', '\\u0016', '\\u0017', '\\u0018', '\\u0019', '\\u001a', '\\u001b', '\\u001c', '\\u001d', '\\u001e', '\\u001f', '', '', '', '', '', '', '', "\\'", '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '\\\\'];
/* eslint-enable quotes */

function getUserOptions(ctx) {
  const obj = {
    stylize: ctx.stylize };


  for (const key of Object.keys(inspectDefaultOptions)) {
    obj[key] = ctx[key];
  }

  if (ctx.userOptions === undefined) {
    return obj;
  }

  return { ...obj,
    ...ctx.userOptions };

}
/**
   * Echos the value of any input. Tries to print the value out
   * in the best way possible given the different types.
   *
   * @param {any} value The value to print out.
   * @param {Object} opts Optional options object that alters the output.
   * @return {string} The string representation of `value`
   */


function inspect(value, opts) {
  // Default options
  const ctx = {
    budget: {},
    indentationLvl: 0,
    seen: [],
    currentDepth: 0,
    stylize: stylizeNoColor,
    showHidden: inspectDefaultOptions.showHidden,
    depth: inspectDefaultOptions.depth,
    colors: inspectDefaultOptions.colors,
    customInspect: inspectDefaultOptions.customInspect,
    showProxy: inspectDefaultOptions.showProxy,
    maxArrayLength: inspectDefaultOptions.maxArrayLength,
    breakLength: inspectDefaultOptions.breakLength,
    compact: inspectDefaultOptions.compact,
    sorted: inspectDefaultOptions.sorted,
    getters: inspectDefaultOptions.getters };


  if (arguments.length > 1) {
    // Legacy...
    if (arguments.length > 2) {
      if (arguments[2] !== undefined) {
        ctx.depth = arguments[2];
      }

      if (arguments.length > 3 && arguments[3] !== undefined) {
        ctx.colors = arguments[3];
      }
    } // Set user-specified options


    if (typeof opts === 'boolean') {
      ctx.showHidden = opts;
    } else if (opts) {
      const optKeys = Object.keys(opts);

      for (const key of optKeys) {
        // TODO(BridgeAR): Find a solution what to do about stylize. Either make
        // this function public or add a new API with a similar or better
        // functionality.
        if (hasOwnProperty(inspectDefaultOptions, key) || key === 'stylize') {
          ctx[key] = opts[key];
        } else if (ctx.userOptions === undefined) {
          // This is required to pass through the actual user input.
          ctx.userOptions = opts;
        }
      }
    }
  }

  if (ctx.colors) {
    ctx.stylize = stylizeWithColor;
  }

  if (ctx.maxArrayLength === null) {
    ctx.maxArrayLength = Infinity;
  }

  return formatValue(ctx, value, 0);
}
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, 'defaultOptions', {
  get() {
    return inspectDefaultOptions;
  },

  set(options) {
    if (options === null || typeof options !== 'object') {
      throw new ERR_INVALID_ARG_TYPE('options', 'Object', options);
    }

    Object.assign(inspectDefaultOptions, options);
  } });

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = Object.assign(Object.create(null), {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39] });
// Don't use 'blue' not visible on cmd.exe

inspect.styles = Object.assign(Object.create(null), {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  boolean: 'yellow',
  undefined: 'grey',
  null: 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  // "name": intentionally not styling
  regexp: 'red',
  module: 'underline' });


function addQuotes(str, quotes) {
  if (quotes === -1) {
    return `"${str}"`;
  }

  if (quotes === -2) {
    return `\`${str}\``;
  }

  return `'${str}'`;
}

const escapeFn = str => meta[str.charCodeAt(0)]; // Escape control characters, single quotes and the backslash.
// This is similar to JSON stringify escaping.


function strEscape(str) {
  let escapeTest = strEscapeSequencesRegExp;
  let escapeReplace = strEscapeSequencesReplacer;
  let singleQuote = 39; // Check for double quotes. If not present, do not escape single quotes and
  // instead wrap the text in double quotes. If double quotes exist, check for
  // backticks. If they do not exist, use those as fallback instead of the
  // double quotes.
  // eslint-disable-next-line quotes

  if (str.includes("'")) {
    // This invalidates the charCode and therefore can not be matched for
    // anymore.
    if (!str.includes('"')) {
      singleQuote = -1;
    } else if (!str.includes('`') && !str.includes('${')) {
      singleQuote = -2;
    }

    if (singleQuote !== 39) {
      escapeTest = strEscapeSequencesRegExpSingle;
      escapeReplace = strEscapeSequencesReplacerSingle;
    }
  } // Some magic numbers that worked out fine while benchmarking with v8 6.0


  if (str.length < 5000 && !escapeTest.test(str)) {
    return addQuotes(str, singleQuote);
  }

  if (str.length > 100) {
    str = str.replace(escapeReplace, escapeFn);
    return addQuotes(str, singleQuote);
  }

  let result = '';
  let last = 0;
  const lastIndex = str.length;

  for (let i = 0; i < lastIndex; i++) {
    const point = str.charCodeAt(i);

    if (point === singleQuote || point === 92 || point < 32) {
      if (last === i) {
        result += meta[point];
      } else {
        result += `${str.slice(last, i)}${meta[point]}`;
      }

      last = i + 1;
    }
  }

  if (last !== lastIndex) {
    result += str.slice(last);
  }

  return addQuotes(result, singleQuote);
}

function stylizeWithColor(str, styleType) {
  const style = inspect.styles[styleType];

  if (style !== undefined) {
    const color = inspect.colors[style];
    return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
  }

  return str;
}

function stylizeNoColor(str) {
  return str;
} // Return a new empty array to push in the results of the default formatter.


function getEmptyFormatArray() {
  return [];
}

function getConstructorName(obj, _ctx) {
  let firstProto; // const tmp = obj;

  while (obj) {
    const descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');

    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value.name;
    }

    obj = Object.getPrototypeOf(obj);

    if (firstProto === undefined) {
      firstProto = obj;
    }
  }

  if (firstProto === null) {
    return null;
  }
  /*
     @todo this calls into native, can we replace this somehow?
    return `${internalGetConstructorName(tmp)} <${inspect(firstProto, {
    	...ctx,
    	customInspect: false
    })}>`;
    */


  return null;
}

function getPrefix(constructor, tag, fallback) {
  if (constructor === null) {
    if (tag !== '') {
      return `[${fallback}: null prototype] [${tag}] `;
    }

    return `[${fallback}: null prototype] `;
  }

  if (tag !== '' && constructor !== tag) {
    return `${constructor} [${tag}] `;
  }

  return `${constructor} `;
} // Look up the keys of the object.


function getKeys(value, showHidden) {
  let keys;
  const symbols = Object.getOwnPropertySymbols(value);

  if (showHidden) {
    keys = Object.getOwnPropertyNames(value);

    if (symbols.length !== 0) {
      keys.push(...symbols);
    }
  } else {
    // This might throw if `value` is a Module Namespace Object from an
    // unevaluated module, but we don't want to perform the actual type
    // check because it's expensive.
    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209
    // and modify this logic as needed.
    try {
      keys = Object.keys(value);
    } catch (err) {
      // @fixme how to du isModuleNamespaceObject?

      /*
      assert(isNativeError(err) && err.name === 'ReferenceError' &&
      			 isModuleNamespaceObject(value));
      */
      keys = Object.getOwnPropertyNames(value);
    }

    if (symbols.length !== 0) {
      keys.push(...symbols.filter(key => propertyIsEnumerable(value, key)));
    }
  }

  return keys;
}

function getCtxStyle(value, constructor, tag) {
  let fallback = '';

  if (constructor === null) {
    fallback = 'Object';
  }

  return getPrefix(constructor, tag, fallback);
}

function findTypedConstructor(value) {
  for (const [check, clazz] of [[isUint8Array, Uint8Array], [isUint8ClampedArray, Uint8ClampedArray], [isUint16Array, Uint16Array], [isUint32Array, Uint32Array], [isInt8Array, Int8Array], [isInt16Array, Int16Array], [isInt32Array, Int32Array], [isFloat32Array, Float32Array], [isFloat64Array, Float64Array]]) {
    if (check(value)) {
      return clazz;
    }
  }
}

let lazyNullPrototypeCache; // Creates a subclass and name
// the constructor as `${clazz} : null prototype`

function clazzWithNullPrototype(clazz, name) {
  if (lazyNullPrototypeCache === undefined) {
    lazyNullPrototypeCache = new Map();
  } else {
    const cachedClass = lazyNullPrototypeCache.get(clazz);

    if (cachedClass !== undefined) {
      return cachedClass;
    }
  }

  class NullPrototype extends clazz {
    get [Symbol.toStringTag]() {
      return '';
    }}



  Object.defineProperty(NullPrototype.prototype.constructor, 'name', {
    value: `[${name}: null prototype]` });

  lazyNullPrototypeCache.set(clazz, NullPrototype);
  return NullPrototype;
}

function noPrototypeIterator(ctx, value, recurseTimes) {
  let newVal;

  if (isSet(value)) {
    const clazz = clazzWithNullPrototype(Set, 'Set');
    newVal = new clazz(SetPrototype.values(value));
  } else if (isMap(value)) {
    const clazz = clazzWithNullPrototype(Map, 'Map');
    newVal = new clazz(MapPrototype.entries(value));
  } else if (Array.isArray(value)) {
    const clazz = clazzWithNullPrototype(Array, 'Array');
    newVal = new clazz(value.length);
  } else if (isTypedArray(value)) {
    const constructor = findTypedConstructor(value);
    const clazz = clazzWithNullPrototype(constructor, constructor.name);
    newVal = new clazz(value);
  }

  if (newVal !== undefined) {
    Object.defineProperties(newVal, Object.getOwnPropertyDescriptors(value));
    return formatRaw(ctx, newVal, recurseTimes);
  }
}

function formatValue(ctx, value, recurseTimes, typedArray) {
  // Primitive types cannot have properties.
  if (typeof value !== 'object' && typeof value !== 'function') {
    return formatPrimitive(ctx.stylize, value, ctx);
  }

  if (value === null) {
    return ctx.stylize('null', 'null');
  } // Memorize the context for custom inspection on proxies.


  const context = value;
  /*
                         @fixme check for proxies
                         // Always check for proxies to prevent side effects and to prevent triggering
                         // any proxy handlers.
                         const proxy = getProxyDetails(value);
                         if (proxy !== undefined) {
                         	if (ctx.showProxy) {
                         		return formatProxy(ctx, proxy, recurseTimes);
                         	}
                         	value = proxy[0];
                         }
                         */
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it.

  if (ctx.customInspect) {
    const maybeCustom = value[customInspectSymbol];

    if (typeof maybeCustom === 'function' // Filter out the util module, its inspect function is special.
    && maybeCustom !== inspect // Also filter out any prototype objects using the circular check.
    && !(value.constructor && value.constructor.prototype === value)) {
      // This makes sure the recurseTimes are reported as before while using
      // a counter internally.
      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
      const ret = maybeCustom.call(context, depth, getUserOptions(ctx)); // If the custom inspection method returned `this`, don't go into
      // infinite recursion.

      if (ret !== context) {
        if (typeof ret !== 'string') {
          return formatValue(ctx, ret, recurseTimes);
        }

        return ret.replace(/\n/g, `\n${' '.repeat(ctx.indentationLvl)}`);
      }
    }
  } // Using an array here is actually better for the average case than using
  // a Set. `seen` will only check for the depth and will never grow too large.


  if (ctx.seen.includes(value)) {
    let index = 1;

    if (ctx.circular === undefined) {
      ctx.circular = new Map([[value, index]]);
    } else {
      index = ctx.circular.get(value);

      if (index === undefined) {
        index = ctx.circular.size + 1;
        ctx.circular.set(value, index);
      }
    }

    return ctx.stylize(`[Circular *${index}]`, 'special');
  }

  return formatRaw(ctx, value, recurseTimes, typedArray);
}

function formatRaw(ctx, value, recurseTimes, typedArray) {
  let keys;
  const constructor = getConstructorName(value);
  let tag = value[Symbol.toStringTag]; // Only list the tag in case it's non-enumerable / not an own property.
  // Otherwise we'd print this twice.

  if (typeof tag !== 'string' || tag !== '' && (ctx.showHidden ? hasOwnProperty : propertyIsEnumerable)(value, Symbol.toStringTag)) {
    tag = '';
  }

  let base = '';
  let formatter = getEmptyFormatArray;
  let braces;
  let noIterator = true;
  let i = 0;
  const filter = ctx.showHidden ? ALL_PROPERTIES$2 : ONLY_ENUMERABLE$2;
  let extrasType = kObjectType; // Iterators and the rest are split to reduce checks.

  if (value[Symbol.iterator]) {
    noIterator = false;

    if (Array.isArray(value)) {
      keys = getOwnNonIndexProperties(value, filter); // Only set the constructor for non ordinary ("Array [...]") arrays.

      const prefix = getPrefix(constructor, tag, 'Array');
      braces = [`${prefix === 'Array ' ? '' : prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0) {
        return `${braces[0]}]`;
      }

      extrasType = kArrayExtrasType;
      formatter = formatArray;
    } else if (isSet(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Set');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatSet;
    } else if (isMap(value)) {
      keys = getKeys(value, ctx.showHidden);
      const prefix = getPrefix(constructor, tag, 'Map');

      if (value.size === 0 && keys.length === 0) {
        return `${prefix}{}`;
      }

      braces = [`${prefix}{`, '}'];
      formatter = formatMap;
    } else if (isTypedArray(value)) {
      keys = getOwnNonIndexProperties(value, filter);
      const prefix = constructor !== null ? getPrefix(constructor, tag) : getPrefix(constructor, tag, findTypedConstructor(value).name);
      braces = [`${prefix}[`, ']'];

      if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
        return `${braces[0]}]`;
      }

      formatter = formatTypedArray;
      extrasType = kArrayExtrasType;
    } else if (isMapIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Map', tag);
      formatter = formatIterator;
    } else if (isSetIterator(value)) {
      keys = getKeys(value, ctx.showHidden);
      braces = getIteratorBraces('Set', tag);
      formatter = formatIterator;
    } else {
      noIterator = true;
    }
  }

  if (noIterator) {
    keys = getKeys(value, ctx.showHidden);
    braces = ['{', '}'];

    if (constructor === 'Object') {
      if (isArgumentsObject(value)) {
        braces[0] = '[Arguments] {';
      } else if (tag !== '') {
        braces[0] = `${getPrefix(constructor, tag, 'Object')}{`;
      }

      if (keys.length === 0) {
        return `${braces[0]}}`;
      }
    } else if (typeof value === 'function') {
      base = getFunctionBase(value, constructor, tag);

      if (keys.length === 0) {
        return ctx.stylize(base, 'special');
      }
    } else if (isRegExp(value)) {
      // Make RegExps say that they are RegExps
      // eslint-disable-next-line security/detect-non-literal-regexp
      const regExp = constructor !== null ? value : new RegExp(value);
      base = RegExpPrototype.toString.call(regExp);
      const prefix = getPrefix(constructor, tag, 'RegExp');

      if (prefix !== 'RegExp ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0 || recurseTimes > ctx.depth && ctx.depth !== null) {
        return ctx.stylize(base, 'regexp');
      }
    } else if (isDate(value)) {
      // Make dates with properties first say the date
      base = Number.isNaN(DatePrototype.getTime.call(value)) ? DatePrototype.toString.call(value) : DatePrototype.toISOString.call(value);
      const prefix = getPrefix(constructor, tag, 'Date');

      if (prefix !== 'Date ') {
        base = `${prefix}${base}`;
      }

      if (keys.length === 0) {
        return ctx.stylize(base, 'date');
      }
    } else if (isError(value)) {
      base = formatError(value, constructor, tag, ctx);

      if (keys.length === 0) {
        return base;
      } else if (isIos) {
        const nativeErrorProps = ['line', 'column', 'sourceURL'];

        if (keys.every(key => nativeErrorProps.includes(key))) {
          return base;
        }
      }
    } else if (isAnyArrayBuffer(value)) {
      // Fast path for ArrayBuffer and SharedArrayBuffer.
      // Can't do the same for DataView because it has a non-primitive
      // .buffer property that we need to recurse for.
      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' : 'SharedArrayBuffer';
      const prefix = getPrefix(constructor, tag, arrayType);

      if (typedArray === undefined) {
        formatter = formatArrayBuffer;
      } else if (keys.length === 0) {
        return `${prefix}{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
      }

      braces[0] = `${prefix}{`;
      keys.unshift('byteLength');
    } else if (isDataView(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'DataView')}{`; // .buffer goes last, it's not a primitive like the others.

      keys.unshift('byteLength', 'byteOffset', 'buffer');
    } else if (isPromise(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'Promise')}{`;
      formatter = formatPromise;
    } else if (isWeakSet(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakSet')}{`;
      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
    } else if (isWeakMap(value)) {
      braces[0] = `${getPrefix(constructor, tag, 'WeakMap')}{`;
      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
      /*
                                                                          * @fixme how to do isModuleNamespaceObject?
                                                                         } else if (isModuleNamespaceObject(value)) {
                                                                         	braces[0] = `[${tag}] {`;
                                                                         	formatter = formatNamespaceObject;
                                                                         */
    } else if (isBoxedPrimitive(value)) {
      base = getBoxedBase(value, ctx, keys, constructor, tag);

      if (keys.length === 0) {
        return base;
      }
    } else {
      // The input prototype got manipulated. Special handle these. We have to
      // rebuild the information so we are able to display everything.
      if (constructor === null) {
        const specialIterator = noPrototypeIterator(ctx, value, recurseTimes);

        if (specialIterator) {
          return specialIterator;
        }
      }

      if (isMapIterator(value)) {
        braces = getIteratorBraces('Map', tag);
        formatter = formatIterator;
      } else if (isSetIterator(value)) {
        braces = getIteratorBraces('Set', tag);
        formatter = formatIterator; // Handle other regular objects again.
      } else {
        if (keys.length === 0) {
          return `${getCtxStyle(value, constructor, tag)}{}`;
        }

        braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
      }
    }
  }

  if (recurseTimes > ctx.depth && ctx.depth !== null) {
    let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);

    if (constructor !== null) {
      constructorName = `[${constructorName}]`;
    }

    return ctx.stylize(constructorName, 'special');
  }

  recurseTimes += 1;
  ctx.seen.push(value);
  ctx.currentDepth = recurseTimes;
  let output;
  const indentationLvl = ctx.indentationLvl;

  try {
    output = formatter(ctx, value, recurseTimes, keys, braces);

    for (i = 0; i < keys.length; i++) {
      output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
    }
  } catch (err) {
    const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
    return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
  }

  if (ctx.circular !== undefined) {
    const index = ctx.circular.get(value);

    if (index !== undefined) {
      const reference = ctx.stylize(`<ref *${index}>`, 'special'); // Add reference always to the very beginning of the output.

      if (ctx.compact !== true) {
        base = base === '' ? reference : `${reference} ${base}`;
      } else {
        braces[0] = `${reference} ${braces[0]}`;
      }
    }
  }

  ctx.seen.pop();

  if (ctx.sorted) {
    const comparator = ctx.sorted === true ? undefined : ctx.sorted;

    if (extrasType === kObjectType) {
      output = output.sort(comparator);
    } else if (keys.length > 1) {
      const sorted = output.slice(output.length - keys.length).sort(comparator);
      output.splice(output.length - keys.length, keys.length, ...sorted);
    }
  }

  const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
  const budget = ctx.budget[ctx.indentationLvl] || 0;
  const newLength = budget + res.length;
  ctx.budget[ctx.indentationLvl] = newLength; // If any indentationLvl exceeds this limit, limit further inspecting to the
  // minimum. Otherwise the recursive algorithm might continue inspecting the
  // object even though the maximum string size (~2 ** 28 on 32 bit systems and
  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at
  // exactly 2 ** 27 but a bit higher. This depends on the object shape.
  // This limit also makes sure that huge objects don't block the event loop
  // significantly.

  if (newLength > 2 ** 27) {
    ctx.depth = -1;
  }

  return res;
}

function getIteratorBraces(type, tag) {
  if (tag !== `${type} Iterator`) {
    if (tag !== '') {
      tag += '] [';
    }

    tag += `${type} Iterator`;
  }

  return [`[${tag}] {`, '}'];
}

function getBoxedBase(value, ctx, keys, constructor, tag) {
  let fn;
  let type;

  if (isNumberObject(value)) {
    fn = NumberPrototype;
    type = 'Number';
  } else if (isStringObject(value)) {
    fn = StringPrototype;
    type = 'String'; // For boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    // Make boxed primitive Strings look like such

    keys.splice(0, value.length);
  } else if (isBooleanObject(value)) {
    fn = BooleanPrototype;
    type = 'Boolean';
  } else {
    fn = SymbolPrototype;
    type = 'Symbol';
  }

  let base = `[${type}`;

  if (type !== constructor) {
    if (constructor === null) {
      base += ' (null prototype)';
    } else {
      base += ` (${constructor})`;
    }
  }

  base += `: ${formatPrimitive(stylizeNoColor, fn.valueOf(value), ctx)}]`;

  if (tag !== '' && tag !== constructor) {
    base += ` [${tag}]`;
  }

  if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
    return base;
  }

  return ctx.stylize(base, type.toLowerCase());
}

function getFunctionBase(value, constructor, tag) {
  let type = 'Function';

  if (isGeneratorFunction(value)) {
    type = `Generator${type}`;
  }

  if (isAsyncFunction(value)) {
    type = `Async${type}`;
  }

  let base = `[${type}`;

  if (constructor === null) {
    base += ' (null prototype)';
  }

  if (value.name === '') {
    base += ' (anonymous)';
  } else {
    base += `: ${value.name}`;
  }

  base += ']';

  if (constructor !== type && constructor !== null) {
    base += ` ${constructor}`;
  }

  if (tag !== '' && constructor !== tag) {
    base += ` [${tag}]`;
  }

  return base;
}

function formatError(err, constructor, tag, ctx) {
  let stack = err.stack || ErrorPrototype.toString.call(err); // try to normalize JavaScriptCore stack to match v8

  if (isIos) {
    const lines = stack.split('\n');
    stack = `${err.name}: ${err.message}`;

    if (lines.length > 0) {
      stack += lines.map(stackLine => {
        const atSymbolIndex = stackLine.indexOf('@');
        const source = stackLine.slice(atSymbolIndex + 1);
        const sourcePattern = /(.*):(\d+):(\d+)/;
        let symbolName = 'unknown';

        if (atSymbolIndex !== -1) {
          symbolName = stackLine.slice(0, atSymbolIndex);
        }

        const sourceMatch = source.match(sourcePattern);

        if (sourceMatch) {
          let filePath = sourceMatch[1];
          const lineNumber = sourceMatch[2];
          const column = sourceMatch[3];

          if (filePath.startsWith('file:')) {
            filePath = filePath.replace(`file://${Ti.Filesystem.resourcesDirectory}`, '');
          }

          return `\n    at ${symbolName} (${filePath}:${lineNumber}:${column})`;
        } else {
          return `\n    at ${symbolName} (${source})`;
        }
      }).join('');
    }
  } // A stack trace may contain arbitrary data. Only manipulate the output
  // for "regular errors" (errors that "look normal") for now.


  const name = err.name || 'Error';
  let len = name.length;

  if (constructor === null || name.endsWith('Error') && stack.startsWith(name) && (stack.length === len || stack[len] === ':' || stack[len] === '\n')) {
    let fallback = 'Error';

    if (constructor === null) {
      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
      fallback = start && start[1] || '';
      len = fallback.length;
      fallback = fallback || 'Error';
    }

    const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);

    if (name !== prefix) {
      if (prefix.includes(name)) {
        if (len === 0) {
          stack = `${prefix}: ${stack}`;
        } else {
          stack = `${prefix}${stack.slice(len)}`;
        }
      } else {
        stack = `${prefix} [${name}]${stack.slice(len)}`;
      }
    }
  } // Ignore the error message if it's contained in the stack.


  let pos = err.message && stack.indexOf(err.message) || -1;

  if (pos !== -1) {
    pos += err.message.length;
  } // Wrap the error in brackets in case it has no stack trace.


  let stackStart = stack.indexOf('\n    at', pos);

  if (stackStart === -1) {
    stack = `[${stack}]`;
  } else if (ctx.colors) {
    // Highlight userland code and node modules.
    let newStack = stack.slice(0, stackStart);
    const lines = stack.slice(stackStart + 1).split('\n');

    for (const line of lines) {
      // This adds underscores to all node_modules to quickly identify them.
      let nodeModule;
      newStack += '\n';
      let pos = 0;

      while (nodeModule = nodeModulesRegExp.exec(line)) {
        // '/node_modules/'.length === 14
        newStack += line.slice(pos, nodeModule.index + 14);
        newStack += ctx.stylize(nodeModule[1], 'module');
        pos = nodeModule.index + nodeModule[0].length;
      }

      newStack += pos === 0 ? line : line.slice(pos);
    }

    stack = newStack;
  } // The message and the stack have to be indented as well!


  if (ctx.indentationLvl !== 0) {
    const indentation = ' '.repeat(ctx.indentationLvl);
    stack = stack.replace(/\n/g, `\n${indentation}`);
  }

  return stack;
}

function formatPromise(ctx, _value, _recurseTimes) {
  // Node calls into native to get promise details which we can't do
  return [ctx.stylize('<unknown>', 'special')];
}

function formatProperty(ctx, value, recurseTimes, key, type) {
  let name, str;
  let extra = ' ';
  const desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key],
    enumerable: true };


  if (desc.value !== undefined) {
    const diff = type !== kObjectType || ctx.compact !== true ? 2 : 3;
    ctx.indentationLvl += diff;
    str = formatValue(ctx, desc.value, recurseTimes);

    if (diff === 3) {
      const len = ctx.colors ? removeColors(str).length : str.length;

      if (ctx.breakLength < len) {
        extra = `\n${' '.repeat(ctx.indentationLvl)}`;
      }
    }

    ctx.indentationLvl -= diff;
  } else if (desc.get !== undefined) {
    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';
    const s = ctx.stylize;
    const sp = 'special';

    if (ctx.getters && (ctx.getters === true || ctx.getters === 'get' && desc.set === undefined || ctx.getters === 'set' && desc.set !== undefined)) {
      try {
        const tmp = value[key];
        ctx.indentationLvl += 2;

        if (tmp === null) {
          str = `${s(`[${label}:`, sp)} ${s('null', 'null')}${s(']', sp)}`;
        } else if (typeof tmp === 'object') {
          str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
        } else {
          const primitive = formatPrimitive(s, tmp, ctx);
          str = `${s(`[${label}:`, sp)} ${primitive}${s(']', sp)}`;
        }

        ctx.indentationLvl -= 2;
      } catch (err) {
        const message = `<Inspection threw (${err.message})>`;
        str = `${s(`[${label}:`, sp)} ${message}${s(']', sp)}`;
      }
    } else {
      str = ctx.stylize(`[${label}]`, sp);
    }
  } else if (desc.set !== undefined) {
    str = ctx.stylize('[Setter]', 'special');
  } else {
    str = ctx.stylize('undefined', 'undefined');
  }

  if (type === kArrayType) {
    return str;
  }

  if (typeof key === 'symbol') {
    const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
    name = `[${ctx.stylize(tmp, 'symbol')}]`;
  } else if (desc.enumerable === false) {
    name = `[${key.replace(strEscapeSequencesReplacer, escapeFn)}]`;
  } else if (keyStrRegExp.test(key)) {
    name = ctx.stylize(key, 'name');
  } else {
    name = ctx.stylize(strEscape(key), 'string');
  }

  return `${name}:${extra}${str}`;
}

function groupArrayElements(ctx, output, value) {
  let totalLength = 0;
  let maxLength = 0;
  let i = 0;
  let outputLength = output.length;

  if (ctx.maxArrayLength < output.length) {
    // This makes sure the "... n more items" part is not taken into account.
    outputLength--;
  }

  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.

  const dataLen = new Array(outputLength); // Calculate the total length of all output entries and the individual max
  // entries length of all output entries. We have to remove colors first,
  // otherwise the length would not be calculated properly.

  for (; i < outputLength; i++) {
    const len = ctx.colors ? removeColors(output[i]).length : output[i].length;
    dataLen[i] = len;
    totalLength += len + separatorSpace;

    if (maxLength < len) {
      maxLength = len;
    }
  } // Add two to `maxLength` as we add a single whitespace character plus a comma
  // in-between two entries.


  const actualMax = maxLength + separatorSpace; // Check if at least three entries fit next to each other and prevent grouping
  // of arrays that contains entries of very different length (i.e., if a single
  // entry is longer than 1/5 of all other entries combined). Otherwise the
  // space in-between small entries would be enormous.

  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
    const approxCharHeights = 2.5;
    const averageBias = Math.sqrt(actualMax - totalLength / output.length);
    const biasedMax = Math.max(actualMax - 3 - averageBias, 1); // Dynamically check how many columns seem possible.

    const columns = Math.min( // Ideally a square should be drawn. We expect a character to be about 2.5
    // times as high as wide. This is the area formula to calculate a square
    // which contains n rectangles of size `actualMax * approxCharHeights`.
    // Divide that by `actualMax` to receive the correct number of columns.
    // The added bias increases the columns for short entries.
    Math.round(Math.sqrt(approxCharHeights * biasedMax * outputLength) / biasedMax), // Do not exceed the breakLength.
    Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), // Limit array grouping for small `compact` modes as the user requested
    // minimal grouping.
    ctx.compact * 4, // Limit the columns to a maximum of fifteen.
    15); // Return with the original output if no grouping should happen.

    if (columns <= 1) {
      return output;
    }

    const tmp = [];
    const maxLineLength = [];

    for (let i = 0; i < columns; i++) {
      let lineMaxLength = 0;

      for (let j = i; j < output.length; j += columns) {
        if (dataLen[j] > lineMaxLength) {
          lineMaxLength = dataLen[j];
        }
      }

      lineMaxLength += separatorSpace;
      maxLineLength[i] = lineMaxLength;
    }

    let order = 'padStart';

    if (value !== undefined) {
      for (let i = 0; i < output.length; i++) {
        if (typeof value[i] !== 'number') {
          order = 'padEnd';
          break;
        }
      }
    } // Each iteration creates a single line of grouped entries.


    for (let i = 0; i < outputLength; i += columns) {
      // The last lines may contain less entries than columns.
      const max = Math.min(i + columns, outputLength);
      let str = '';
      let j = i;

      for (; j < max - 1; j++) {
        // Calculate extra color padding in case it's active. This has to be
        // done line by line as some lines might contain more colors than
        // others.
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
        str += `${output[j]}, `[order](padding, ' ');
      }

      if (order === 'padStart') {
        const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - separatorSpace;
        str += output[j].padStart(padding, ' ');
      } else {
        str += output[j];
      }

      tmp.push(str);
    }

    if (ctx.maxArrayLength < output.length) {
      tmp.push(output[outputLength]);
    }

    output = tmp;
  }

  return output;
}

function handleMaxCallStackSize(ctx, err, constructorName, indentationLvl) {
  if (isStackOverflowError(err)) {
    ctx.seen.pop();
    ctx.indentationLvl = indentationLvl;
    return ctx.stylize(`[${constructorName}: Inspection interrupted 'prematurely. Maximum call stack size exceeded.]`, 'special');
  }

  throw err;
}

function formatNumber(fn, value) {
  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.
  return fn(Object.is(value, -0) ? '-0' : `${value}`, 'number');
}

function formatBigInt(fn, value) {
  return fn(`${value}n`, 'bigint');
}

function formatPrimitive(fn, value, ctx) {
  if (typeof value === 'string') {
    if (ctx.compact !== true && value.length > kMinLineLength && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
      return value.split(/\n/).map(line => fn(strEscape(line), 'string')).join(` +\n${' '.repeat(ctx.indentationLvl + 2)}`);
    }

    return fn(strEscape(value), 'string');
  }

  if (typeof value === 'number') {
    return formatNumber(fn, value);
  }
  /*
    if (typeof value === 'bigint') {
    	return formatBigInt(fn, value);
    }
    */


  if (typeof value === 'boolean') {
    return fn(`${value}`, 'boolean');
  }

  if (typeof value === 'undefined') {
    return fn('undefined', 'undefined');
  } // es6 symbol primitive


  return fn(SymbolPrototype.toString.call(value), 'symbol');
} // The array is sparse and/or has extra keys


function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
  const keys = Object.keys(value);
  let index = i;

  for (; i < keys.length && output.length < maxLength; i++) {
    const key = keys[i];
    const tmp = +key; // Arrays can only have up to 2^32 - 1 entries

    if (tmp > 2 ** 32 - 2) {
      break;
    }

    if (`${index}` !== key) {
      if (!numberRegExp.test(key)) {
        break;
      }

      const emptyItems = tmp - index;
      const ending = emptyItems > 1 ? 's' : '';
      const message = `<${emptyItems} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
      index = tmp;

      if (output.length === maxLength) {
        break;
      }
    }

    output.push(formatProperty(ctx, value, recurseTimes, key, kArrayType));
    index++;
  }

  const remaining = value.length - index;

  if (output.length !== maxLength) {
    if (remaining > 0) {
      const ending = remaining > 1 ? 's' : '';
      const message = `<${remaining} empty item${ending}>`;
      output.push(ctx.stylize(message, 'undefined'));
    }
  } else if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatArrayBuffer(ctx, value) {
  const buffer = new Uint8Array(value);
  /*
                                        // @fixme rollup cannot handle lazy loaded modules, maybe move to webpack?
                                        if (hexSlice === undefined) {
                                        	hexSlice = uncurryThis(require('../../buffer').default.Buffer.prototype.hexSlice);
                                        }
                                        */

  let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, '$1 ').trim();
  const remaining = buffer.length - ctx.maxArrayLength;

  if (remaining > 0) {
    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;
  }

  return [`${ctx.stylize('[Uint8Contents]', 'special')}: <${str}>`];
}

function formatArray(ctx, value, recurseTimes) {
  const valLen = value.length;
  const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
  const remaining = valLen - len;
  const output = [];

  for (var i = 0; i < len; i++) {
    // Special handle sparse arrays.
    if (!hasOwnProperty(value, i)) {
      return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
    }

    output.push(formatProperty(ctx, value, recurseTimes, i, kArrayType));
  }

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatTypedArray(ctx, value, recurseTimes) {
  const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  const remaining = value.length - maxLength;
  const output = new Array(maxLength);
  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ? formatNumber : formatBigInt;

  for (let i = 0; i < maxLength; ++i) {
    output[i] = elementFormatter(ctx.stylize, value[i]);
  }

  if (remaining > 0) {
    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;
  }

  if (ctx.showHidden) {
    // .buffer goes last, it's not a primitive like the others.
    ctx.indentationLvl += 2;

    for (const key of ['BYTES_PER_ELEMENT', 'length', 'byteLength', 'byteOffset', 'buffer']) {
      const str = formatValue(ctx, value[key], recurseTimes, true);
      output.push(`[${key}]: ${str}`);
    }

    ctx.indentationLvl -= 2;
  }

  return output;
}

function formatSet(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const v of value) {
    output.push(formatValue(ctx, v, recurseTimes));
  }

  ctx.indentationLvl -= 2; // With `showHidden`, `length` will display as a hidden property for
  // arrays. For consistency's sake, do the same for `size`, even though this
  // property isn't selected by Object.getOwnPropertyNames().

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatMap(ctx, value, recurseTimes) {
  const output = [];
  ctx.indentationLvl += 2;

  for (const [k, v] of value) {
    output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
  }

  ctx.indentationLvl -= 2; // See comment in formatSet

  if (ctx.showHidden) {
    output.push(`[size]: ${ctx.stylize(`${value.size}`, 'number')}`);
  }

  return output;
}

function formatSetIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
  const maxLength = Math.min(maxArrayLength, entries.length);
  let output = new Array(maxLength);
  ctx.indentationLvl += 2;

  for (var i = 0; i < maxLength; i++) {
    output[i] = formatValue(ctx, entries[i], recurseTimes);
  }

  ctx.indentationLvl -= 2;

  if (state === kWeak && !ctx.sorted) {
    // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.
    output = output.sort();
  }

  const remaining = entries.length - maxLength;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatMapIterInner(ctx, recurseTimes, entries, state) {
  const maxArrayLength = Math.max(ctx.maxArrayLength, 0); // Entries exist as [key1, val1, key2, val2, ...]

  const len = entries.length / 2;
  const remaining = len - maxArrayLength;
  const maxLength = Math.min(maxArrayLength, len);
  let output = new Array(maxLength);
  let i = 0;
  ctx.indentationLvl += 2;

  if (state === kWeak) {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      output[i] = `${formatValue(ctx, entries[pos], recurseTimes)}` + ` => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
    } // Sort all entries to have a halfway reliable output (if more entries than
    // retrieved ones exist, we can not reliably return the same output) if the
    // output is not sorted anyway.


    if (!ctx.sorted) {
      output = output.sort();
    }
  } else {
    for (; i < maxLength; i++) {
      const pos = i * 2;
      const res = [formatValue(ctx, entries[pos], recurseTimes), formatValue(ctx, entries[pos + 1], recurseTimes)];
      output[i] = reduceToSingleString(ctx, res, '', ['[', ']'], kArrayExtrasType, recurseTimes);
    }
  }

  ctx.indentationLvl -= 2;

  if (remaining > 0) {
    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);
  }

  return output;
}

function formatWeakCollection(ctx) {
  return [ctx.stylize('<items unknown>', 'special')];
}

function formatWeakSet(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatWeakMap(ctx, _value, _recurseTimes) {
  // Node calls into native to get a preview of actual values which we can't do
  return formatWeakCollection(ctx);
}

function formatIterator(ctx, value, recurseTimes, _keys, braces) {
  const entries = [];
  let isKeyValue = false;
  let result = value.next();

  while (!result.done) {
    const currentEntry = result.value;
    entries.push(currentEntry);

    if (currentEntry[0] !== currentEntry[1]) {
      isKeyValue = true;
    }

    result = value.next();
  }

  if (isKeyValue) {
    // Mark entry iterators as such.
    braces[0] = braces[0].replace(/ Iterator] {$/, ' Entries] {');
    return formatMapIterInner(ctx, recurseTimes, entries, kMapEntries);
  }

  return formatSetIterInner(ctx, recurseTimes, entries, kIterator);
}

function isBelowBreakLength(ctx, output, start, base) {
  // Each entry is separated by at least a comma. Thus, we start with a total
  // length of at least `output.length`. In addition, some cases have a
  // whitespace in-between each other that is added to the total as well.
  let totalLength = output.length + start;

  if (totalLength + output.length > ctx.breakLength) {
    return false;
  }

  for (var i = 0; i < output.length; i++) {
    if (ctx.colors) {
      totalLength += removeColors(output[i]).length;
    } else {
      totalLength += output[i].length;
    }

    if (totalLength > ctx.breakLength) {
      return false;
    }
  } // Do not line up properties on the same line if `base` contains line breaks.


  return base === '' || !base.includes('\n');
}

function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
  if (ctx.compact !== true) {
    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {
      // Memorize the original output length. In case the the output is grouped,
      // prevent lining up the entries on a single line.
      const entries = output.length; // Group array elements together if the array contains at least six
      // separate entries.

      if (extrasType === kArrayExtrasType && entries > 6) {
        output = groupArrayElements(ctx, output, value);
      } // `ctx.currentDepth` is set to the most inner depth of the currently
      // inspected object part while `recurseTimes` is the actual current depth
      // that is inspected.
      //
      // Example:
      //
      // const a = { first: [ 1, 2, 3 ], second: { inner: [ 1, 2, 3 ] } }
      //
      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max
      // depth of 1.
      //
      // Consolidate all entries of the local most inner depth up to
      // `ctx.compact`, as long as the properties are smaller than
      // `ctx.breakLength`.


      if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
        // Line up all entries on a single line in case the entries do not
        // exceed `breakLength`. Add 10 as constant to start next to all other
        // factors that may reduce `breakLength`.
        const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;

        if (isBelowBreakLength(ctx, output, start, base)) {
          return `${base ? `${base} ` : ''}${braces[0]} ${join(output, ', ')} ${braces[1]}`;
        }
      }
    } // Line up each entry on an individual line.


    const indentation = `\n${' '.repeat(ctx.indentationLvl)}`;
    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` + `${join(output, `,${indentation}  `)}${indentation}${braces[1]}`;
  } // Line up all entries on a single line in case the entries do not exceed
  // `breakLength`.


  if (isBelowBreakLength(ctx, output, 0, base)) {
    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output, ', ')} ` + braces[1];
  }

  const indentation = ' '.repeat(ctx.indentationLvl); // If the opening "brace" is too large, like in the case of "Set {",
  // we need to force the first item to be on the next line or the
  // items will not line up correctly.

  const ln = base === '' && braces[0].length === 1 ? ' ' : `${base ? ` ${base}` : ''}\n${indentation}  `; // Line up each entry on an individual line.

  return `${braces[0]}${ln}${join(output, `,\n${indentation}  `)} ${braces[1]}`;
}

function format(...args) {
  return formatWithOptions(undefined, ...args);
}

const firstErrorLine = error => error.message.split('\n')[0];

let CIRCULAR_ERROR_MESSAGE;

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        const a = {};
        a.a = a;
        JSON.stringify(a);
      } catch (e) {
        CIRCULAR_ERROR_MESSAGE = firstErrorLine(e);
      }
    }

    if (err.name === 'TypeError' && firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }

    throw err;
  }
}
/* eslint-disable max-depth */


function formatWithOptions(inspectOptions, ...args) {
  const first = args[0];
  let a = 0;
  let str = '';
  let join = '';

  if (typeof first === 'string') {
    if (args.length === 1) {
      return first;
    }

    let tempStr;
    let lastPos = 0;

    for (var i = 0; i < first.length - 1; i++) {
      if (first.charCodeAt(i) === 37) {
        // '%'
        const nextChar = first.charCodeAt(++i);

        if (a + 1 !== args.length) {
          switch (nextChar) {
            case 115:
              // 's'
              const tempArg = args[++a];

              if (typeof tempArg === 'number') {
                tempStr = formatNumber(stylizeNoColor, tempArg);
                /*
                                                                 } else if (typeof tempArg === 'bigint') {
                                                                 	tempStr = `${tempArg}n`;
                                                                 */
              } else {
                let constr;

                if (typeof tempArg !== 'object' || tempArg === null || typeof tempArg.toString === 'function' && (hasOwnProperty(tempArg, 'toString') // A direct own property on the constructor prototype in
                // case the constructor is not an built-in object.
                || (constr = tempArg.constructor) && !builtInObjects.has(constr.name) && constr.prototype && hasOwnProperty(constr.prototype, 'toString'))) {
                  tempStr = String(tempArg);
                } else {
                  tempStr = inspect(tempArg, { ...inspectOptions,
                    compact: 3,
                    colors: false,
                    depth: 0 });

                }
              }

              break;

            case 106:
              // 'j'
              tempStr = tryStringify(args[++a]);
              break;

            case 100:
              // 'd'
              const tempNum = args[++a];
              /*
                                         if (typeof tempNum === 'bigint') {
                                         	tempStr = `${tempNum}n`;
                                         } else
                                         */

              if (typeof tempNum === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, Number(tempNum));
              }

              break;

            case 79:
              // 'O'
              tempStr = inspect(args[++a], inspectOptions);
              break;

            case 111:
              // 'o'
              {
                tempStr = inspect(args[++a], { ...inspectOptions,
                  showHidden: true,
                  showProxy: true,
                  depth: 4 });

                break;
              }

            case 105:
              // 'i'
              const tempInteger = args[++a];
              /*
                                             if (typeof tempInteger === 'bigint') {
                                             	tempStr = `${tempInteger}n`;
                                             } else */

              if (typeof tempInteger === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseInt(tempInteger));
              }

              break;

            case 102:
              // 'f'
              const tempFloat = args[++a];

              if (typeof tempFloat === 'symbol') {
                tempStr = 'NaN';
              } else {
                tempStr = formatNumber(stylizeNoColor, parseFloat(tempFloat));
              }

              break;

            case 37:
              // '%'
              str += first.slice(lastPos, i);
              lastPos = i + 1;
              continue;

            default:
              // Any other character is not a correct placeholder
              continue;}


          if (lastPos !== i - 1) {
            str += first.slice(lastPos, i - 1);
          }

          str += tempStr;
          lastPos = i + 1;
        } else if (nextChar === 37) {
          str += first.slice(lastPos, i);
          lastPos = i + 1;
        }
      }
    }

    if (lastPos !== 0) {
      a++;
      join = ' ';

      if (lastPos < first.length) {
        str += first.slice(lastPos);
      }
    }
  }

  while (a < args.length) {
    const value = args[a];
    str += join;
    str += typeof value !== 'string' ? inspect(value, inspectOptions) : value;
    join = ' ';
    a++;
  }

  return str;
}
/* eslint-enable max-depth */

function noop() {}

function logTime(self, label, logData) {
  label = `${label}`;

  const startTime = self._times.get(label);

  if (!startTime) {
    process.emitWarning(`Label "${label}" does not exist`);
    return true;
  }

  const duration = Date.now() - startTime;

  if (logData) {
    self.log(`${label}: ${duration}ms`, ...logData);
  } else {
    self.log(`${label}: ${duration}ms`);
  }

  return false;
}

const kColorInspectOptions = {
  colors: true };

const kNoColorInspectOptions = {};
let tableWarned; // boolean flag for one-time warning about console.table not being implemented
// Make a function that can serve as the callback passed to `stream.write()`.

function createWriteErrorHandler(stream) {
  return err => {
    // This conditional evaluates to true if and only if there was an error
    // that was not already emitted (which happens when the _write callback
    // is invoked asynchronously).
    if (err !== null && !stream._writableState.errorEmitted) {
      // If there was an error, it will be emitted on `stream` as
      // an `error` event. Adding a `once` listener will keep that error
      // from becoming an uncaught exception, but since the handler is
      // removed after the event, non-console.* writes won't be affected.
      // we are only adding noop if there is no one else listening for 'error'
      if (stream.listenerCount('error') === 0) {
        stream.once('error', noop);
      }
    }
  };
}

class Console {
  constructor(options, stderr, ignoreErrors) {
    if (options && options.apiName === 'Ti.API') {
      // Passing in Ti.API module where we retain log levels
      this._apiModule = options;
    } else {
      // Node.JS streams
      if (!options || typeof options.write === 'function') {
        // no args, or first arg is a stream
        options = {
          stdout: options,
          stderr,
          ignoreErrors };

      }

      this._stdout = options.stdout; // TODO: enforce has write function?

      this._stderr = options.stderr || this._stdout;
      this._ignoreErrors = options.ignoreErrors !== false;

      if (this._ignoreErrors) {
        this._stdoutErrorHandler = createWriteErrorHandler(this._stdout);
        this._stderrErrorHandler = createWriteErrorHandler(this._stderr);
      }

      this._colorMode = options.colorMode || 'auto'; // TODO: enforce boolean or 'auto'

      this._inspectOptions = options.inspectOptions; // TODO: enforce undefined or typeof 'object'
    }

    this._times = new Map();
    this._counts = new Map();
    this._groupIndent = '';
  }

  _writeToConsole(level, string) {
    if (this._groupIndent.length !== 0) {
      if (string.includes('\n')) {
        string = string.replace(/\n/g, `\n${this._groupIndent}`);
      }

      string = this._groupIndent + string;
    } // Support wrapping Ti.API (which retains log level)


    if (this._apiModule) {
      this._apiModule[level](string);
    } else {
      // Support Node.JS streams like stdout/stderr which don't have log levels
      const useStdErr = level === 'warn' || level === 'error' || level === 'trace';
      const stream = useStdErr ? this._stderr : this._stdout;

      if (this._ignoreErrors === false) {
        return stream.write(string);
      } // There may be an error occurring synchronously (e.g. for files or TTYs
      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems), so
      // handle both situations.


      try {
        // Add and later remove a noop error handler to catch synchronous errors.
        if (stream.listenerCount('error') === 0) {
          stream.once('error', noop);
        }

        const errorHandler = useStdErr ? this._stderrErrorHandler : this._stdoutErrorHandler;
        stream.write(string, errorHandler);
      } catch (e) {
        // Console is a debugging utility, so it swallowing errors is not desirable
        // even in edge cases such as low stack space.
        if (isStackOverflowError(e)) {
          throw e;
        } // Sorry, there's no proper way to pass along the error here.

      } finally {
        stream.removeListener && stream.removeListener('error', noop);
      }
    }
  }

  info(...args) {
    this._writeToConsole('info', formatWithOptions(kColorInspectOptions, ...args));
  }

  warn(...args) {
    this._writeToConsole('warn', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  error(...args) {
    this._writeToConsole('error', formatWithOptions(kNoColorInspectOptions, ...args));
  }

  debug(...args) {
    this._writeToConsole('debug', formatWithOptions(kColorInspectOptions, ...args));
  }

  trace(...args) {
    this._writeToConsole('trace', formatWithOptions(kColorInspectOptions, ...args));
  }

  clear() {} // no-op


  group(...data) {
    if (data.length > 0) {
      this.log(...data);
    }

    this._groupIndent += '  ';
  }

  groupEnd() {
    this._groupIndent = this._groupIndent.slice(0, this._groupIndent.length - 2);
  }

  dir(obj, options) {
    this._writeToConsole('info', inspect(obj, {
      customInspect: false,
      ...options }));

  }

  assert(value, ...args) {
    if (!value) {
      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;
      this.warn(...args); // The arguments will be formatted in warn() again
    }
  }

  count(label = 'default') {
    // Ensures that label is a string, and only things that can be
    // coerced to strings. e.g. Symbol is not allowed
    label = `${label}`;

    let count = this._counts.get(label);

    if (count === undefined) {
      count = 1;
    } else {
      count++;
    }

    this._counts.set(label, count);

    this.log(`${label}: ${count}`);
  }

  countReset(label = 'default') {
    if (!this._counts.has(label)) {
      process.emitWarning(`Count for '${label}' does not exist`);
      return;
    }

    this._counts.delete(`${label}`);
  }

  time(label = 'default') {
    label = `${label}`;

    if (this._times.has(label)) {
      process.emitWarning(`Label ${label}" already exists`);
      return;
    }

    this._times.set(label, Date.now());
  }

  timeEnd(label = 'default') {
    const warned = logTime(this, label);

    if (!warned) {
      this._times.delete(label);
    }
  }

  timeLog(label = 'default', ...logData) {
    logTime(this, label, logData);
  } // TODO: implement console.table()


  table() {
    if (!tableWarned) {
      tableWarned = true;
      process.emitWarning('"console.table" is not yet implemented in Titanium!');
    }
  }}



Console.prototype.log = Console.prototype.info; // Treat log as alias to info

Console.prototype.dirxml = Console.prototype.log; // Treat dirxml as alias to log

Console.prototype.groupCollapsed = Console.prototype.group;
const globalConsole = new Console(Ti.API);
globalConsole.Console = Console;
global.console = globalConsole;

/**
                                 * Appcelerator Titanium Mobile
                                 * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
                                 * Licensed under the terms of the Apache Public License
                                 * Please see the LICENSE included with this distribution for details.
                                 */

/* globals OS_ANDROID */
{
  Date.prototype.toLocaleDateString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const mergedOptions = Object.assign({
      dateStyle: 'short' },
    properties.options);
    const formatter = new Intl.DateTimeFormat(properties.locale, mergedOptions);
    return formatter.format(this);
  };

  Date.prototype.toLocaleTimeString = function () {
    const properties = Intl.DateTimeFormat._makeTiCreationPropertiesFrom(arguments);

    const mergedOptions = Object.assign({
      timeStyle: 'short' },
    properties.options);
    const formatter = new Intl.DateTimeFormat(properties.locale, mergedOptions);
    return formatter.format(this);
  };

  Date.prototype.toLocaleString = Date.prototype.toLocaleDateString;
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */
// Add a toJSON() method to all Error objects needed to output non-enumerable properties.
// The JSON.stringify() will automatically call this method if it exists to provide custom output.
// Notes:
// - In V8, all Error properties are not enumerable. We need this or else stringify() will return "{}".
// - In JavaScriptCore, only the "stack" property is not enumerable. We want to reveal this.
if (typeof Error.prototype.toJSON !== 'function') {
  Error.prototype.toJSON = function () {
    var properties = {};
    Object.getOwnPropertyNames(this).forEach(function (name) {
      properties[name] = this[name];
    }, this);
    return properties;
  };
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */

/* globals OS_ANDROID */

/**
                          * Generates a "creation" properties dictionary for Titanium's Collator, DateTimeFormat, and NumberFormat proxies
                          * from the given Intl type's constructor arguments.
                          * @param {Object[]} args
                          * The arguments array that was passed into Intl Collator, DateTimeFormat, or NumberFormat type's constructor.
                          * @param {Function} supportedFormatLocalesFunction Reference to a supportedLocalesOf() function.
                          * @return {Object} Returns a properties dictionary to be passed into a Titanium proxy's constructor.
                          */

function makeTiFormatCreationPropertiesFrom(args, supportedFormatLocalesFunction) {
  const properties = {};

  if (args.length >= 1) {
    if (typeof args[0] === 'string') {
      properties.locale = args[0];
    } else if (Array.isArray(args[0])) {
      const supportedLocales = supportedFormatLocalesFunction(args[0]);

      if (supportedLocales.length > 0) {
        properties.locale = supportedLocales[0];
      }
    }
  }

  if (args.length >= 2 && typeof args[1] === 'object') {
    properties.options = args[1];
  }

  return properties;
} // Add "Intl" APIs missing on Android.


{
  // Set up an "Intl.Collator" type which wraps our undocumented "Ti.Locale.Collator" proxy.
  function TiCollator() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedCollatorLocales);
    const collator = new Ti.Locale.Collator(properties);
    collator.compare = collator.compare.bind(collator);
    return collator;
  }

  TiCollator.supportedLocalesOf = Ti.Locale.getSupportedCollatorLocales; // Set up an "Intl.DateTimeFormat" type which wraps our undocumented "Ti.Locale.DateTimeFormat" proxy.

  function TiDateTimeFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedDateTimeFormatLocales);
    return new Ti.Locale.DateTimeFormat(properties);
  }

  TiDateTimeFormat._makeTiCreationPropertiesFrom = args => {
    return makeTiFormatCreationPropertiesFrom(args, Ti.Locale.getSupportedDateTimeFormatLocales);
  };

  TiDateTimeFormat.supportedLocalesOf = Ti.Locale.getSupportedDateTimeFormatLocales; // Set up an "Intl.NumberFormat" type which wraps our undocumented "Ti.Locale.NumberFormat" proxy.

  function TiNumberFormat() {
    const properties = makeTiFormatCreationPropertiesFrom(arguments, Ti.Locale.getSupportedNumberFormatLocales);
    return new Ti.Locale.NumberFormat(properties);
  }

  TiNumberFormat.supportedLocalesOf = Ti.Locale.getSupportedNumberFormatLocales; // Make our custom "Intl" module available globally.

  commonjsGlobal.Intl = {
    Collator: TiCollator,
    DateTimeFormat: TiDateTimeFormat,
    NumberFormat: TiNumberFormat,
    getCanonicalLocales: Ti.Locale.getCanonicalLocales };

}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */

/* globals OS_ANDROID */
{
  Number.prototype.toLocaleString = function () {
    const formatter = new Intl.NumberFormat(...arguments);
    return formatter.format(this.valueOf());
  };
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2020 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   */

/* globals OS_ANDROID */
{
  String.prototype.localeCompare = function (compareString, locales, options) {
    const collator = new Intl.Collator(locales, options);
    return collator.compare(this, compareString);
  };

  String.prototype.toLocaleLowerCase = function (locale) {
    return Ti.Locale.makeLowerCase(this, locale);
  };

  String.prototype.toLocaleUpperCase = function (locale) {
    return Ti.Locale.makeUpperCase(this, locale);
  };
}

/**
   * This file is used to hijack the standard require to allow for JS
   * implementations of "core" modules.
   *
   * You add a binding from the "core" module id to the under the hood JS
   * implementation. We then intercept require calls to handle requests for these modules
   * and lazily load the file.
   */

/**
       * Used by @function bindObjectToCoreModuleId
       * @type {map<string, object>}
       */
const bindings = new Map();
/**
                             * Used by @function redirectCoreModuleIdToPath
                             * @type {map<string, string>}
                             */

const redirects = new Map();
/**
                              * Does the request look like a typical core module? (no '.' or '/' characters)
                              * @param {string} path original require path/id
                              * @returns {boolean}
                              */

function isHijackableModuleId(path) {
  if (!path || path.length < 1) {
    return false;
  }

  const firstChar = path.charAt(0);
  return firstChar !== '.' && firstChar !== '/';
} // Hack require to point to this as a core module "binding"


const originalRequire = global.require; // This works for iOS as-is, and also intercepts the call on Android for ti.main.js (the first file executed)

global.require = function (moduleId) {
  if (bindings.has(moduleId)) {
    return bindings.get(moduleId);
  }

  if (redirects.has(moduleId)) {
    moduleId = redirects.get(moduleId);
  }

  return originalRequire(moduleId);
};

{
  // ... but we still need to hack it when requiring from other files for Android
  const originalModuleRequire = global.Module.prototype.require;

  global.Module.prototype.require = function (path, context) {
    if (bindings.has(path)) {
      return bindings.get(path);
    }

    if (redirects.has(path)) {
      path = redirects.get(path);
    }

    return originalModuleRequire.call(this, path, context);
  };
}
/**
   * Registers a binding from a short module id to an already loaded/constructed object/value to export for that core module id
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {*} binding an already constructured value/object to return
   */


function register(moduleId, binding) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    redirects.delete(moduleId);
  } else if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  bindings.set(moduleId, binding);
}
/**
   * Registers a binding from a short module id to the full under the hood filepath if given a string.
   * This allows for lazy instantiation of the module on-demand
   *
   * @param {string} moduleId the module id to "hijack"
   * @param {string} filepath the full filepath to require under the hood.
   *                              This should be an already resolved absolute path,
   *                              as otherwise the context of the call could change what gets loaded!
   */

function redirect(moduleId, filepath) {
  if (!isHijackableModuleId(moduleId)) {
    throw new Error(`Cannot register for relative/absolute file paths; no leading '.' or '/' allowed (was given ${moduleId})`);
  }

  if (bindings.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
    bindings.delete(moduleId);
  } else if (redirects.has(moduleId)) {
    Ti.API.warn(`Another binding has already registered for module id: '${moduleId}', it will be overwritten...`);
  }

  redirects.set(moduleId, filepath);
}
const binding = {
  register,
  redirect };

global.binding = binding;

// Load all JavaScript extensions/polyfills
register('console', globalConsole);

/**
                                     * Appcelerator Titanium Mobile
                                     * Copyright (c) 2019-Present by Axway, Inc. All Rights Reserved.
                                     * Licensed under the terms of the Apache Public License
                                     * Please see the LICENSE included with this distribution for details.
                                     */

/* globals OS_IOS, OS_VERSION_MAJOR */
const buffer = Ti.createBuffer({
  value: '' });

const blob = buffer.toBlob();
// https://developer.mozilla.org/en-US/docs/Web/API/Blob/arrayBuffer


blob.constructor.prototype.arrayBuffer = function () {
  return new Promise((resolve, reject) => {
    let buf;

    try {
      buf = this.toArrayBuffer();
    } catch (err) {
      return reject(err);
    }

    resolve(buf);
  });
};

/**
    * This script is used at runtime for Ti.UI.fetchSemanticColor - as well as at build time by both iOS/Android.
    * It provides a common interface for handling colors and converting to necessary string forms.
    */

const HEX_3_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F3

const HEX_4_REGEX = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i; // i.e. #0F38

const HEX_6_REGEX = /^#?([a-f\d]){6}$/i; // i.e. #00FF33

const HEX_8_REGEX = /^#?([a-f\d]){8}$/i; // i.e. #00FF3388

/**
 * @param {number} integer in range of 0-255
 * @returns {string} 2-character hex string value
 */

function paddedHex(integer) {
  const str = integer.toString(16);

  if (str.length === 1) {
    return `0${str}`;
  }

  return str;
}

class Color {
  /**
              * @param {number} r red value in range 0-255
              * @param {number} g green value in range 0-255
              * @param {number} b blue value in range 0-255
              * @param {number} [a=1.0] alpha value in range 0.0-1.0
              */
  constructor(r, g, b, a = 1.0) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.alpha = a;
  }
  /**
     * indicates if this is a fully opaque color (alpha is 1.0 or was undefined)
     * @returns {boolean}
     */


  isOpaque() {
    return this.alpha === 1.0;
  }
  /**
     * Converts the alpha value into equivalent hex string value properly.
     * @returns {string}
     */


  alphaHex() {
    // need to round to avoid nonsensical values like '7f.8' for a 0.5 alpha
    return paddedHex(Math.round(this.alpha * 255.0));
  }
  /**
     * Discards any alpha value. To be used internally, not external api. Does not provide leading '#' symbol.
     * @returns {string}
     */


  _toRGBHexString() {
    return `${paddedHex(this.r)}${paddedHex(this.g)}${paddedHex(this.b)}`;
  }
  /**
     * Used by CSS.
     * Converts this color to a hex string with leading '#' symbol and 6- or 8-
     * hexadecimal characters (depending on if alpha is 1.0)
     * @returns {string}
     */


  toRGBAHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this._toRGBHexString()}${this.alphaHex()}`;
  }
  /**
     * Used by Android/iOS
     * Converts this color to a hex string with leading '#' symbol and 6- or 8-
     * hexadecimal characters (depending on if alpha is 1.0). Alpha is the first entry (if there is alpha.)
     * @returns {string}
     */


  toARGBHexString() {
    if (this.isOpaque()) {
      return `#${this._toRGBHexString()}`;
    }

    return `#${this.alphaHex()}${this._toRGBHexString()}`;
  }
  /**
     * For commonality with native iOS TiColor proxy. Produces an AARRGGBB (or RRGGBB if full alpha) hex string
     * @returns {string}
     */


  toHex() {
    return this.toARGBHexString();
  }
  /**
     * Converts this color to an rgba expression. This expression is more consistent across platforms.
     * (whereas iOS/Android differ in expecttaiosn for hex strings.)
     * @returns {string}
     */


  toRGBAString() {
    return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.alpha.toFixed(3)})`;
  }
  /**
     * @returns {Color}
     */


  static fallback() {
    return new Color(0, 0, 0); // return black to match native impl in iOS
  }
  /**
     * The supplied hex string MUST be in form '#000000' (i.e. leading pound symbol, 6 hex characters after)
     * @param {string} hex hexadecimal color string
     * @param {number} [alpha] alpha value
     * @returns {Color}
     */


  static fromHex6String(hex, alpha) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const r = parseInt(hex.substr(startIndex, 2), 16);
    const g = parseInt(hex.substr(startIndex + 2, 2), 16);
    const b = parseInt(hex.substr(startIndex + 4, 2), 16);
    return new Color(r, g, b, alpha);
  }
  /**
     * The supplied hex string MUST be in form '#00000000' (i.e. leading pound symbol, 8 hex characters after)
     * @param {string} hex hexadecimal color string
     * @returns {Color}
     */


  static fromHex8String(hex) {
    const startIndex = hex.startsWith('#') ? 1 : 0;
    const alpha = parseInt(hex.substr(startIndex, 2), 16); // alpha is now 0-255

    const r = parseInt(hex.substr(startIndex + 2, 2), 16);
    const g = parseInt(hex.substr(startIndex + 4, 2), 16);
    const b = parseInt(hex.substr(startIndex + 6, 2), 16);
    return new Color(r, g, b, alpha / 255.0); // convert to 0.0-1.0 (percent)
  }
  /**
     * Note that the hex value can contain alpha, but must follow the CSS standard of #RRGGBBAA (NOT the Android standard of #AARRGGBB)
     * @param {string|object} entry possible hex string or an object
     * @param {string|number} [hex.alpha] alpha value in percent (0.0-100.0) when hex is an object
    	 * @param {string} [hex.color] hex string for the base color when hex is an object
     * @returns {Color}
     * @throws if entry has both an explicit alpha value AND a hex string containing an alpha value
     */


  static fromSemanticColorsEntry(entry) {
    let color = entry;
    let alpha = 1.0;
    let hadAlpha = false;

    if (Object.prototype.hasOwnProperty.call(entry, 'alpha')) {
      alpha = parseFloat(entry.alpha) / 100.0; // convert from 0-100 range to 0-1 range

      hadAlpha = true;
      color = entry.color; // if it has an alpha property assume it has a color property too!
    } // expand the shorter hex string forms to 6 or 8 digits


    if (color.length === 3) {
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      color = color.replace(HEX_3_REGEX, (m, r, g, b) => r + r + g + g + b + b);
    } else if (color.length === 4) {
      // Expand shorthand form (e.g. "03F8") to full form (e.g. "0033FF88")
      color = color.replace(HEX_4_REGEX, (m, a, r, g, b) => a + a + r + r + g + g + b + b);
    }

    if (HEX_6_REGEX.exec(color)) {
      return Color.fromHex6String(color, alpha);
    }

    if (HEX_8_REGEX.exec(color)) {
      if (hadAlpha) {
        throw new Error(`Color ${entry} had an explicit alpha value AND a hex value containing alpha. Use one or the other.`);
      }

      return Color.fromHex8String(color);
    } // uh-oh, something is up!


    return Color.fallback();
  }}



var color = Color;

/**
                    * Appcelerator Titanium Mobile
                    * Copyright (c) 2019-2020 by Axway, Inc. All Rights Reserved.
                    * Licensed under the terms of the Apache Public License
                    * Please see the LICENSE included with this distribution for details.
                    */
// Ti.UI within this file, we must call kroll.binding to get the Titanium
// namespace that is passed in with require and that deal with the .UI
// namespace that is on that directly.

const UI = kroll.binding('Titanium').Titanium.UI; // Make our read-only constants
// TODO: Remove in SDK 10, DEPRECATED in 9.1.0

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_LIGHT', {
  value: 'light',
  writable: false });

Object.defineProperty(UI, 'SEMANTIC_COLOR_TYPE_DARK', {
  value: 'dark',
  writable: false });

Object.defineProperty(UI, 'semanticColorType', {
  get: () => {
    // TODO: Guard against ios < 13 and Android api < 29?
    // Assume "light" mode unless we explicitly know it's dark
    if (Ti.UI.userInterfaceStyle === Ti.UI.USER_INTERFACE_STYLE_DARK) {
      return UI.SEMANTIC_COLOR_TYPE_DARK;
    }

    return UI.SEMANTIC_COLOR_TYPE_LIGHT;
  } });
// on Android/iOS < 13, we need to roll our own fetchSemanticColor impl
// on iOS 13+, we have a native version

{

  let colorset;

  UI.fetchSemanticColor = function fetchSemanticColor(colorName) {
    if (!colorset) {
      try {
        const colorsetFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, 'semantic.colors.json');

        if (colorsetFile.exists()) {
          colorset = JSON.parse(colorsetFile.read().text);
        }
      } catch (error) {
        // We should probably throw an Error here (or return a fallback color!)
        console.error('Failed to load colors file \'semantic.colors.json\'');
        return color.fallback().toHex();
      }
    }

    try {
      if (!colorset[colorName]) {
        if (true) {
          // if it's not in the semantic colors and we're on Android, it may be a Ti.Android.R.color value
          const systemColorId = Ti.Android.R.color[colorName];

          if (systemColorId) {
            const resourceColor = Ti.UI.Android.getColorResource(systemColorId);

            if (resourceColor) {
              return resourceColor.toHex();
            }
          }
        }

        return color.fallback().toHex();
      }

      const entry = colorset[colorName][UI.semanticColorType];
      const colorObj = color.fromSemanticColorsEntry(entry); // For now, return a string on iOS < 13, Android so we can pass the result directly to the UI property we want to set
      // Otherwise we need to modify the Android APIs to accept fake/real Ti.UI.Color instances and convert it to it's own internal
      // Color representation

      return colorObj.toRGBAString(); // If there's an entry, use the more exact rgba function over 8-char ARGB hex. Hard to convert things like 75% alpha properly.
    } catch (error) {
      console.error(`Failed to lookup color for ${colorName}`);
    }

    return color.fallback().toHex();
  };
}

/**
   * @param {EventEmitter} emitter the EventEmitter instance to use to register for it's events
   * @param {string} eventName the name of the event to register for
   * @param {function} listener the listener callback/function to invoke when the event is emitted
   * @param {boolean} prepend whether to prepend or append the listener
   * @returns {EventEmitter}
   */
function _addListener(emitter, eventName, listener, prepend) {
  if (!emitter._eventsToListeners) {
    // no events/listeners registered
    emitter._eventsToListeners = {}; // initialize it
  } // if there's someone listening to 'newListener' events, emit that **before** we add the listener (to avoid infinite recursion)


  if (emitter._eventsToListeners.newListener) {
    emitter.emit('newListener', eventName, listener);
  }

  const eventListeners = emitter._eventsToListeners[eventName] || [];

  if (prepend) {
    eventListeners.unshift(listener);
  } else {
    eventListeners.push(listener);
  }

  emitter._eventsToListeners[eventName] = eventListeners; // Check max listeners and spit out warning if >

  const max = emitter.getMaxListeners();
  const length = eventListeners.length;

  if (max > 0 && length > max) {
    const w = new Error(`Possible EventEmitter memory leak detected. ${length} ${eventName} listeners added. Use emitter.setMaxListeners() to increase limit`);
    w.name = 'MaxListenersExceededWarning';
    w.emitter = emitter;
    w.type = eventName;
    w.count = length;
    process.emitWarning(w);
  }

  return emitter;
}

function onceWrap(emitter, eventName, listener) {
  function wrapper(...args) {
    this.emitter.removeListener(this.eventName, this.wrappedFunc); // remove ourselves

    this.listener.apply(this.emitter, args); // then forward the event callback
  } // we have to use bind with a custom 'this', because events fire with 'this' pointing at the emitter


  const wrapperThis = {
    emitter,
    eventName,
    listener };

  const bound = wrapper.bind(wrapperThis); // bind to force "this" to refer to our custom object tracking the wrapper/emitter/listener

  bound.listener = listener; // have to add listener property for "unwrapping"

  wrapperThis.wrappedFunc = bound;
  return bound;
} // many consumers make use of this via util.inherits, which does not chain constructor calls!
// so we need to be aware that _eventsToListeners maye be null/undefined on instances, and check in methods before accessing it


class EventEmitter {
  constructor() {
    this._eventsToListeners = {};
    this._maxListeners = undefined;
  }

  addListener(eventName, listener) {
    return _addListener(this, eventName, listener, false);
  }

  on(eventName, listener) {
    return this.addListener(eventName, listener);
  }

  prependListener(eventName, listener) {
    return _addListener(this, eventName, listener, true);
  }

  once(eventName, listener) {
    this.on(eventName, onceWrap(this, eventName, listener));
  }

  prependOnceListener(eventName, listener) {
    this.prependListener(eventName, onceWrap(this, eventName, listener));
  }

  removeListener(eventName, listener) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return this;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    const length = eventListeners.length;
    let foundIndex = -1;
    let unwrappedListener; // Need to search LIFO, and need to handle wrapped functions (once wrappers)

    for (let i = length - 1; i >= 0; i--) {
      if (eventListeners[i] === listener || eventListeners[i].listener === listener) {
        foundIndex = i;
        unwrappedListener = eventListeners[i].listener;
        break;
      }
    }

    if (foundIndex !== -1) {
      if (length === 1) {
        // length was 1 and we want to remove last entry, so delete the event type from our listener mapping now!
        delete this._eventsToListeners[eventName];
      } else {
        // we had 2+ listeners, so store array without this given listener
        eventListeners.splice(foundIndex, 1); // modifies in place, no need to assign to this.listeners[eventName]
      } // Don't emit if there's no listeners for 'removeListener' type!


      if (this._eventsToListeners.removeListener) {
        this.emit('removeListener', eventName, unwrappedListener || listener);
      }
    }

    return this;
  }

  off(eventName, listener) {
    return this.removeListener(eventName, listener);
  }

  emit(eventName, ...args) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return false;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];

    for (const listener of eventListeners.slice()) {
      // must operate on copy because listeners ,ay get remove as side-effect of calling
      listener.call(this, ...args);
    }

    return eventListeners.length !== 0;
  }

  listenerCount(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return 0;
    }

    const eventListeners = this._eventsToListeners[eventName] || [];
    return eventListeners.length;
  }

  eventNames() {
    return Object.getOwnPropertyNames(this._eventsToListeners || {});
  }

  listeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    } // Need to "unwrap" once wrappers!


    const raw = this._eventsToListeners[eventName] || [];
    return raw.map(l => l.listener || l); // here we unwrap the once wrapper if there is one or fall back to listener function
  }

  rawListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      return [];
    }

    return (this._eventsToListeners[eventName] || []).slice(0); // return a copy
  }

  getMaxListeners() {
    return this._maxListeners || EventEmitter.defaultMaxListeners;
  }

  setMaxListeners(n) {
    this._maxListeners = n; // TODO: Type check n, make sure >= 0 (o equals no limit)

    return this;
  }

  removeAllListeners(eventName) {
    if (!this._eventsToListeners) {
      // no events/listeners registered
      this._eventsToListeners = {}; // initialize it
    }

    if (!this._eventsToListeners.removeListener) {
      // no need to emit! we can just wipe!
      if (eventName === undefined) {
        // remove every type!
        this._eventsToListeners = {};
      } else {
        // remove specific type
        delete this._eventsToListeners[eventName];
      }

      return this;
    } // yuck, we'll have to emit 'removeListener' events as we go


    if (eventName === undefined) {
      // Remove all types (but do 'removeListener' last!)
      const names = Object.keys(this._eventsToListeners).filter(name => name !== 'removeListener');
      names.forEach(name => this.removeAllListeners(name));
      this.removeAllListeners('removeListener');
      this._eventsToListeners = {};
    } else {
      // remove listeners for one type, back to front (Last-in, first-out, except where prepend f-ed it up)
      const listeners = this._eventsToListeners[eventName] || [];

      for (let i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(eventName, listeners[i]);
      }
    }

    return this;
  }}


EventEmitter.defaultMaxListeners = 10;

EventEmitter.listenerCount = function (emitter, eventName) {
  return emitter.listenerCount(eventName);
};

EventEmitter.EventEmitter = EventEmitter;

/**
                                           * @param  {*} arg passed in argument value
                                           * @param  {string} name name of the argument
                                           * @param  {string} typename i.e. 'string', 'Function' (value is compared to typeof after lowercasing)
                                           * @return {void}
                                           * @throws {TypeError}
                                           */
function assertArgumentType(arg, name, typename) {
  const type = typeof arg;

  if (type !== typename.toLowerCase()) {
    throw new TypeError(`The "${name}" argument must be of type ${typename}. Received type ${type}`);
  }
}

const startTime = Date.now();
/**
                               * This function 'standardizes' the reported architectures to the equivalents reported by Node.js
                               * node values: 'arm', 'arm64', 'ia32', 'mips', 'mipsel', 'ppc', 'ppc64', 's390', 's390x', 'x32', and 'x64'.
                               * iOS values: "arm64", "armv7", "x86_64", "i386", "Unknown"
                               * Android values: "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64", "unknown"
                               * Windows values: "x64", "ia64", "ARM", "x86", "unknown"
                               * @param {string} original original architecture reported by Ti.Platform
                               * @returns {string}
                               */

function standardizeArch(original) {
  switch (original) {
    // coerce 'armv7', 'armeabi', 'armeabi-v7a', 'ARM' -> 'arm'
    // 'armeabi' is a dead ABI for Android, removed in NDK r17
    case 'armv7':
    case 'armeabi':
    case 'armeabi-v7a':
    case 'ARM':
      return 'arm';
    // coerce 'arm64-v8a' -> 'arm64'

    case 'arm64-v8a':
      return 'arm64';
    // coerce 'i386', 'x86' -> 'ia32'

    case 'i386':
    case 'x86':
      return 'ia32';
    // coerce 'x86_64', 'ia64', 'x64' -> 'x64'

    case 'x86_64':
    case 'ia64':
      return 'x64';
    // coerce 'mips64' -> 'mips' // 'mips' and 'mips64' are dead ABIs for Android, removed in NDK r17

    case 'mips64':
      return 'mips';
    // coerce 'Unknown' -> 'unknown'

    case 'Unknown':
      return 'unknown';

    default:
      return original;}

}

const process$1 = new EventEmitter();

process$1.abort = () => {}; // TODO: Do we have equivalent of forcibly killing the process? We have restart, but I think we just want a no-op stub here


process$1.arch = standardizeArch(Ti.Platform.architecture);
process$1.argv = []; // TODO: What makes sense here? path to titanium cli for first arg? path to ti.main/app.js for second?

Object.defineProperty(process$1, 'argv0', {
  value: '',
  // TODO: Path to .app on iOS?
  writable: false,
  enumerable: true,
  configurable: false });


process$1.binding = () => {
  throw new Error('process.binding is unsupported and not user-facing API');
};

process$1.channel = undefined;

process$1.chdir = () => {
  throw new Error('process.chdir is unsupported');
};

process$1.config = {};
process$1.connected = false;

process$1.cpuUsage = () => {
  // FIXME: Can we look at OS.cpus to get this data?
  return {
    user: 0,
    system: 0 };

};

process$1.cwd = () => __dirname;

Object.defineProperty(process$1, 'debugPort', {
  get: function () {
    let value = 0; // default to 0

    try {
      if ("android" === 'android') {
        const assets = kroll.binding('assets');
        const json = assets.readAsset('deploy.json');

        if (json) {
          const deployData = JSON.parse(json);

          if (deployData.debuggerPort !== -1) {
            // -1 means not set (not in debug mode)
            value = deployData.debuggerPort;
          }
        }
      }
    } catch (error) {} // ignore
    // overwrite this getter with static value


    Object.defineProperty(this, 'debugPort', {
      value: value,
      writable: true,
      enumerable: true,
      configurable: true });

    return value;
  },
  enumerable: true,
  configurable: true });


process$1.disconnect = () => {}; // no-op


process$1.dlopen = () => {
  throw new Error('process.dlopen is not supported');
};

process$1.emitWarning = function (warning, options, code, ctor) {
  // eslint-disable-line no-unused-vars
  let type;
  let detail;

  if (typeof options === 'string') {
    type = options;
  } else if (typeof options === 'object') {
    type = options.type;
    code = options.code;
    detail = options.detail;
  }

  if (typeof warning === 'string') {
    // TODO: make use of `ctor` arg for limiting stack traces? Can only really be used on V8
    // set stack trace limit to 0, then call Error.captureStackTrace(warning, ctor);
    warning = new Error(warning);
    warning.name = type || 'Warning';

    if (code !== undefined) {
      warning.code = code;
    }

    if (detail !== undefined) {
      warning.detail = detail;
    }
  } // TODO: Throw TypeError if not an instanceof Error at this point!


  const isDeprecation = warning.name === 'DeprecationWarning';

  if (isDeprecation && process$1.noDeprecation) {
    return; // ignore
  }

  if (isDeprecation && process$1.throwDeprecation) {
    throw warning;
  }

  this.emit('warning', warning);
};

function loadEnvJson() {
  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, '_env_.json');

    if (jsonFile.exists()) {
      return JSON.parse(jsonFile.read().text);
    }
  } catch (error) {
    Ti.API.error(`Failed to read "_env_.json". Reason: ${error.message}`);
  }

  return {};
}

Object.defineProperty(process$1, 'env', {
  get: function () {
    delete this.env;
    return this.env = loadEnvJson();
  },
  enumerable: true,
  configurable: true });

process$1.execArgv = [];
process$1.execPath = ''; // FIXME: What makes sense here? Path to titanium CLI here?

process$1.exit = () => {
  throw new Error('process.exit is not supported');
};

process$1.exitCode = undefined;
process$1.noDeprecation = false;
process$1.pid = 0; // FIXME: Should we try and adopt 'ipad'/'iphone' to 'darwin'? or 'ios'?

process$1.platform = "android";
process$1.ppid = 0; // TODO: Add release property (Object)
// TODO: Can we expose stdout/stderr/stdin natively?
// Don't wrap console.log/error because technically global console wraps process.stdout/stderr (or should)

process$1.stderr = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.error(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.stdout = {
  isTTY: false,
  writable: true,
  write: (chunk, encoding, callback) => {
    Ti.API.info(chunk);

    if (callback) {
      callback();
    }

    return true;
  } };

process$1.title = Ti.App.name;
process$1.throwDeprecation = false;
process$1.traceDeprecation = false;

process$1.umask = () => 0; // just always return 0


process$1.uptime = () => {
  const diffMs = Date.now() - startTime;
  return diffMs / 1000.0; // convert to "seconds" with fractions
};

process$1.version = "9.2.1";
process$1.versions = {
  modules: '',
  // TODO: Report module api version (for current platform!)
  v8: '',
  // TODO: report android's v8 version (if on Android!)
  jsc: '' // TODO: report javascriptcore version for iOS/WIndows?
  // TODO: Report ios/Android/Windows platform versions?
};

process$1[Symbol.toStringTag] = 'process';
global.process = process$1; // handle spitting out warnings

const WARNING_PREFIX = `(titanium:${process$1.pid}) `;
process$1.on('warning', warning => {
  const isDeprecation = warning.name === 'DeprecationWarning'; // if we're not doing deprecations, ignore!

  if (isDeprecation && process$1.noDeprecation) {
    return;
  } // TODO: Check process.traceDeprecation and if set, include stack trace in message!


  let msg = WARNING_PREFIX;

  if (warning.code !== undefined) {
    msg += `[${warning.code}] `;
  }

  if (warning.toString) {
    msg += warning.toString();
  }

  if (warning.detail) {
    msg += `\n${warning.detail}`;
  }

  console.error(msg);
});
let uncaughtExceptionCallback = null;

process$1.hasUncaughtExceptionCaptureCallback = () => uncaughtExceptionCallback !== null;

process$1.setUncaughtExceptionCaptureCallback = fn => {
  if (fn === null) {
    uncaughtExceptionCallback = null;
    return;
  }

  assertArgumentType(fn, 'fn', 'function');

  if (uncaughtExceptionCallback !== null) {
    throw new Error('`process.setUncaughtExceptionCaptureCallback()` was called while a capture callback was already active');
  }

  uncaughtExceptionCallback = fn;
};

Ti.App.addEventListener('uncaughtException', function (event) {
  // Create an Error instance that wraps the data from the event
  // ideally we'd just forward along the original Error!
  const error = new Error(event.message);
  error.stack = event.backtrace;
  error.fileName = event.sourceName;
  error.lineNumber = event.line;
  error.columnNumber = event.lineOffset;

  if (process$1.hasUncaughtExceptionCaptureCallback()) {
    return uncaughtExceptionCallback(error);
  } // otherwise forward the event!


  process$1.emit('uncaughtException', error);
});
// JS engine should be able to optimize easier

class CallbackWithArgs {
  constructor(func, args) {
    this.func = func;
    this.args = args;
  }

  run() {
    if (this.args) {
      this.func.apply(null, this.args);
    } else {
      this.fun();
    }
  }}

// nextTick vs setImmediate should be handled in a semi-smart way
// Basically nextTick needs to drain the full queue (and can cause infinite loops if nextTick callback calls nextTick!)
// Then we should go through the "immediate" queue
// http://plafer.github.io/2015/09/08/nextTick-vs-setImmediate/


const tickQueue = [];
const immediateQueue = [];
let drainingTickQueue = false;
let drainQueuesTimeout = null;
/**
                                * Iteratively runs all "ticks" until there are no more.
                                * This can cause infinite recursion if a tick schedules another forever.
                                */

function drainTickQueue() {
  if (drainingTickQueue) {
    return;
  }

  drainingTickQueue = true;

  while (tickQueue.length) {
    const tick = tickQueue.shift();
    tick.run();
  }

  drainingTickQueue = false;
}

function drainQueues() {
  // drain the full tick queue first...
  drainTickQueue(); // tick queue should be empty!

  const immediatesRemaining = processImmediateQueue();

  if (immediatesRemaining !== 0) {
    // re-schedule draining our queues, as we have at least one more "immediate" to handle
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  } else {
    drainQueuesTimeout = null;
  }
}
/**
   * Attempts to process "immediates" (in a much more leisurely way than ticks)
   * We give a 100ms window to run them in before re-scheduling the timeout to process them again.
   * If any ticks are added during invocation of immediate, we drain the tick queue fully before
   * proceeding to next immediate (if we still have time in our window).
   * @returns {number} number of remaining immediates to be processed
   */


function processImmediateQueue() {
  const immediateDeadline = Date.now() + 100; // give us up to 100ms to process immediates

  while (immediateQueue.length && Date.now() < immediateDeadline) {
    const immediate = immediateQueue.shift();
    immediate.run();

    if (tickQueue.length > 0) {
      // they added a tick! drain the tick queue before we do anything else (this *may* eat up our deadline/window to process any more immediates)
      drainTickQueue();
    }
  }

  return immediateQueue.length;
}

process$1.nextTick = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  tickQueue.push(new CallbackWithArgs(callback, args));

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }
};

global.setImmediate = function (callback, ...args) {
  assertArgumentType(callback, 'callback', 'function');
  const immediate = new CallbackWithArgs(callback, args);
  immediateQueue.push(immediate);

  if (!drainQueuesTimeout) {
    drainQueuesTimeout = setTimeout(drainQueues, 0);
  }

  return immediate;
};

global.clearImmediate = function (immediate) {
  const index = immediateQueue.indexOf(immediate);

  if (index !== -1) {
    immediateQueue.splice(index, 1);
  }
};

const FORWARD_SLASH = 47; // '/'

const BACKWARD_SLASH = 92; // '\\'

/**
 * Is this [a-zA-Z]?
 * @param  {number}  charCode value from String.charCodeAt()
 * @return {Boolean}          [description]
 */

function isWindowsDeviceName(charCode) {
  return charCode >= 65 && charCode <= 90 || charCode >= 97 && charCode <= 122;
}
/**
   * [isAbsolute description]
   * @param  {boolean} isPosix whether this impl is for POSIX or not
   * @param  {string} filepath   input file path
   * @return {Boolean}          [description]
   */


function isAbsolute(isPosix, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length; // empty string special case

  if (length === 0) {
    return false;
  }

  const firstChar = filepath.charCodeAt(0);

  if (firstChar === FORWARD_SLASH) {
    return true;
  } // we already did our checks for posix


  if (isPosix) {
    return false;
  } // win32 from here on out


  if (firstChar === BACKWARD_SLASH) {
    return true;
  }

  if (length > 2 && isWindowsDeviceName(firstChar) && filepath.charAt(1) === ':') {
    const thirdChar = filepath.charAt(2);
    return thirdChar === '/' || thirdChar === '\\';
  }

  return false;
}
/**
   * [dirname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function dirname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const length = filepath.length;

  if (length === 0) {
    return '.';
  } // ignore trailing separator


  let fromIndex = length - 1;
  const hadTrailing = filepath.endsWith(separator);

  if (hadTrailing) {
    fromIndex--;
  }

  const foundIndex = filepath.lastIndexOf(separator, fromIndex); // no separators

  if (foundIndex === -1) {
    // handle special case of root windows paths
    if (length >= 2 && separator === '\\' && filepath.charAt(1) === ':') {
      const firstChar = filepath.charCodeAt(0);

      if (isWindowsDeviceName(firstChar)) {
        return filepath; // it's a root windows path
      }
    }

    return '.';
  } // only found root separator


  if (foundIndex === 0) {
    return separator; // if it was '/', return that
  } // Handle special case of '//something'


  if (foundIndex === 1 && separator === '/' && filepath.charAt(0) === '/') {
    return '//';
  }

  return filepath.slice(0, foundIndex);
}
/**
   * [extname description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @return {string}            [description]
   */


function extname(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const index = filepath.lastIndexOf('.');

  if (index === -1 || index === 0) {
    return '';
  } // ignore trailing separator


  let endIndex = filepath.length;

  if (filepath.endsWith(separator)) {
    endIndex--;
  }

  return filepath.slice(index, endIndex);
}

function lastIndexWin32Separator(filepath, index) {
  for (let i = index; i >= 0; i--) {
    const char = filepath.charCodeAt(i);

    if (char === BACKWARD_SLASH || char === FORWARD_SLASH) {
      return i;
    }
  }

  return -1;
}
/**
   * [basename description]
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath   input file path
   * @param  {string} [ext]      file extension to drop if it exists
   * @return {string}            [description]
   */


function basename(separator, filepath, ext) {
  assertArgumentType(filepath, 'path', 'string');

  if (ext !== undefined) {
    assertArgumentType(ext, 'ext', 'string');
  }

  const length = filepath.length;

  if (length === 0) {
    return '';
  }

  const isPosix = separator === '/';
  let endIndex = length; // drop trailing separator (if there is one)

  const lastCharCode = filepath.charCodeAt(length - 1);

  if (lastCharCode === FORWARD_SLASH || !isPosix && lastCharCode === BACKWARD_SLASH) {
    endIndex--;
  } // Find last occurence of separator


  let lastIndex = -1;

  if (isPosix) {
    lastIndex = filepath.lastIndexOf(separator, endIndex - 1);
  } else {
    // On win32, handle *either* separator!
    lastIndex = lastIndexWin32Separator(filepath, endIndex - 1); // handle special case of root path like 'C:' or 'C:\\'

    if ((lastIndex === 2 || lastIndex === -1) && filepath.charAt(1) === ':' && isWindowsDeviceName(filepath.charCodeAt(0))) {
      return '';
    }
  } // Take from last occurrence of separator to end of string (or beginning to end if not found)


  const base = filepath.slice(lastIndex + 1, endIndex); // drop trailing extension (if specified)

  if (ext === undefined) {
    return base;
  }

  return base.endsWith(ext) ? base.slice(0, base.length - ext.length) : base;
}
/**
   * The `path.normalize()` method normalizes the given path, resolving '..' and '.' segments.
   *
   * When multiple, sequential path segment separation characters are found (e.g.
   * / on POSIX and either \ or / on Windows), they are replaced by a single
   * instance of the platform-specific path segment separator (/ on POSIX and \
   * on Windows). Trailing separators are preserved.
   *
   * If the path is a zero-length string, '.' is returned, representing the
   * current working directory.
   *
   * @param  {string} separator  platform-specific file separator
   * @param  {string} filepath  input file path
   * @return {string} [description]
   */


function normalize(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');

  if (filepath.length === 0) {
    return '.';
  } // Windows can handle '/' or '\\' and both should be turned into separator


  const isWindows = separator === '\\';

  if (isWindows) {
    filepath = filepath.replace(/\//g, separator);
  }

  const hadLeading = filepath.startsWith(separator); // On Windows, need to handle UNC paths (\\host-name\\resource\\dir) special to retain leading double backslash

  const isUNC = hadLeading && isWindows && filepath.length > 2 && filepath.charAt(1) === '\\';
  const hadTrailing = filepath.endsWith(separator);
  const parts = filepath.split(separator);
  const result = [];

  for (const segment of parts) {
    if (segment.length !== 0 && segment !== '.') {
      if (segment === '..') {
        result.pop(); // FIXME: What if this goes above root? Should we throw an error?
      } else {
        result.push(segment);
      }
    }
  }

  let normalized = hadLeading ? separator : '';
  normalized += result.join(separator);

  if (hadTrailing) {
    normalized += separator;
  }

  if (isUNC) {
    normalized = '\\' + normalized;
  }

  return normalized;
}
/**
   * [assertSegment description]
   * @param  {*} segment [description]
   * @return {void}         [description]
   */


function assertSegment(segment) {
  if (typeof segment !== 'string') {
    throw new TypeError(`Path must be a string. Received ${segment}`);
  }
}
/**
   * The `path.join()` method joins all given path segments together using the
   * platform-specific separator as a delimiter, then normalizes the resulting path.
   * Zero-length path segments are ignored. If the joined path string is a zero-
   * length string then '.' will be returned, representing the current working directory.
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       The joined filepath
   */


function join$1(separator, paths) {
  const result = []; // naive impl: just join all the paths with separator

  for (const segment of paths) {
    assertSegment(segment);

    if (segment.length !== 0) {
      result.push(segment);
    }
  }

  return normalize(separator, result.join(separator));
}
/**
   * The `path.resolve()` method resolves a sequence of paths or path segments into an absolute path.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string[]} paths [description]
   * @return {string}       [description]
   */


function resolve(separator, paths) {
  let resolved = '';
  let hitRoot = false;
  const isPosix = separator === '/'; // go from right to left until we hit absolute path/root

  for (let i = paths.length - 1; i >= 0; i--) {
    const segment = paths[i];
    assertSegment(segment);

    if (segment.length === 0) {
      continue; // skip empty
    }

    resolved = segment + separator + resolved; // prepend new segment

    if (isAbsolute(isPosix, segment)) {
      // have we backed into an absolute path?
      hitRoot = true;
      break;
    }
  } // if we didn't hit root, prepend cwd


  if (!hitRoot) {
    resolved = process.cwd() + separator + resolved;
  }

  const normalized = normalize(separator, resolved);

  if (normalized.charAt(normalized.length - 1) === separator) {
    // FIXME: Handle UNC paths on Windows as well, so we don't trim trailing separator on something like '\\\\host-name\\resource\\'
    // Don't remove trailing separator if this is root path on windows!
    if (!isPosix && normalized.length === 3 && normalized.charAt(1) === ':' && isWindowsDeviceName(normalized.charCodeAt(0))) {
      return normalized;
    } // otherwise trim trailing separator


    return normalized.slice(0, normalized.length - 1);
  }

  return normalized;
}
/**
   * The `path.relative()` method returns the relative path `from` from to `to` based
   * on the current working directory. If from and to each resolve to the same
   * path (after calling `path.resolve()` on each), a zero-length string is returned.
   *
   * If a zero-length string is passed as `from` or `to`, the current working directory
   * will be used instead of the zero-length strings.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {string} from [description]
   * @param  {string} to   [description]
   * @return {string}      [description]
   */


function relative(separator, from, to) {
  assertArgumentType(from, 'from', 'string');
  assertArgumentType(to, 'to', 'string');

  if (from === to) {
    return '';
  }

  from = resolve(separator, [from]);
  to = resolve(separator, [to]);

  if (from === to) {
    return '';
  } // we now have two absolute paths,
  // lets "go up" from `from` until we reach common base dir of `to`
  // const originalFrom = from;


  let upCount = 0;
  let remainingPath = '';

  while (true) {
    if (to.startsWith(from)) {
      // match! record rest...?
      remainingPath = to.slice(from.length);
      break;
    } // FIXME: Break/throw if we hit bad edge case of no common root!


    from = dirname(separator, from);
    upCount++;
  } // remove leading separator from remainingPath if there is any


  if (remainingPath.length > 0) {
    remainingPath = remainingPath.slice(1);
  }

  return ('..' + separator).repeat(upCount) + remainingPath;
}
/**
   * The `path.parse()` method returns an object whose properties represent
   * significant elements of the path. Trailing directory separators are ignored,
   * see `path.sep`.
   *
   * The returned object will have the following properties:
   *
   * - dir <string>
   * - root <string>
   * - base <string>
   * - name <string>
   * - ext <string>
   * @param  {string} separator platform-specific file separator
   * @param  {string} filepath [description]
   * @return {object}
   */


function parse(separator, filepath) {
  assertArgumentType(filepath, 'path', 'string');
  const result = {
    root: '',
    dir: '',
    base: '',
    ext: '',
    name: '' };

  const length = filepath.length;

  if (length === 0) {
    return result;
  } // Cheat and just call our other methods for dirname/basename/extname?


  result.base = basename(separator, filepath);
  result.ext = extname(separator, result.base);
  const baseLength = result.base.length;
  result.name = result.base.slice(0, baseLength - result.ext.length);
  const toSubtract = baseLength === 0 ? 0 : baseLength + 1;
  result.dir = filepath.slice(0, filepath.length - toSubtract); // drop trailing separator!

  const firstCharCode = filepath.charCodeAt(0); // both win32 and POSIX return '/' root

  if (firstCharCode === FORWARD_SLASH) {
    result.root = '/';
    return result;
  } // we're done with POSIX...


  if (separator === '/') {
    return result;
  } // for win32...


  if (firstCharCode === BACKWARD_SLASH) {
    // FIXME: Handle UNC paths like '\\\\host-name\\resource\\file_path'
    // need to retain '\\\\host-name\\resource\\' as root in that case!
    result.root = '\\';
    return result;
  } // check for C: style root


  if (length > 1 && isWindowsDeviceName(firstCharCode) && filepath.charAt(1) === ':') {
    if (length > 2) {
      // is it like C:\\?
      const thirdCharCode = filepath.charCodeAt(2);

      if (thirdCharCode === FORWARD_SLASH || thirdCharCode === BACKWARD_SLASH) {
        result.root = filepath.slice(0, 3);
        return result;
      }
    } // nope, just C:, no trailing separator


    result.root = filepath.slice(0, 2);
  }

  return result;
}
/**
   * The `path.format()` method returns a path string from an object. This is the
   * opposite of `path.parse()`.
   *
   * @param  {string} separator platform-specific file separator
   * @param  {object} pathObject object of format returned by `path.parse()`
   * @param  {string} pathObject.dir directory name
   * @param  {string} pathObject.root file root dir, ignored if `pathObject.dir` is provided
   * @param  {string} pathObject.base file basename
   * @param  {string} pathObject.name basename minus extension, ignored if `pathObject.base` exists
   * @param  {string} pathObject.ext file extension, ignored if `pathObject.base` exists
   * @return {string}
   */


function format$1(separator, pathObject) {
  assertArgumentType(pathObject, 'pathObject', 'object');
  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`; // append base to root if `dir` wasn't specified, or if
  // dir is the root

  if (!pathObject.dir || pathObject.dir === pathObject.root) {
    return `${pathObject.root || ''}${base}`;
  } // combine dir + / + base


  return `${pathObject.dir}${separator}${base}`;
}
/**
   * On Windows systems only, returns an equivalent namespace-prefixed path for
   * the given path. If path is not a string, path will be returned without modifications.
   * See https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file#namespaces
   * @param  {string} filepath [description]
   * @return {string}          [description]
   */


function toNamespacedPath(filepath) {
  if (typeof filepath !== 'string') {
    return filepath;
  }

  if (filepath.length === 0) {
    return '';
  }

  const resolvedPath = resolve('\\', [filepath]);
  const length = resolvedPath.length;

  if (length < 2) {
    // need '\\\\' or 'C:' minimum
    return filepath;
  }

  const firstCharCode = resolvedPath.charCodeAt(0); // if start with '\\\\', prefix with UNC root, drop the slashes

  if (firstCharCode === BACKWARD_SLASH && resolvedPath.charAt(1) === '\\') {
    // return as-is if it's an aready long path ('\\\\?\\' or '\\\\.\\' prefix)
    if (length >= 3) {
      const thirdChar = resolvedPath.charAt(2);

      if (thirdChar === '?' || thirdChar === '.') {
        return filepath;
      }
    }

    return '\\\\?\\UNC\\' + resolvedPath.slice(2);
  } else if (isWindowsDeviceName(firstCharCode) && resolvedPath.charAt(1) === ':') {
    return '\\\\?\\' + resolvedPath;
  }

  return filepath;
}

const Win32Path = {
  sep: '\\',
  delimiter: ';',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join$1(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(false, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format$1(this.sep, pathObject);
  },
  toNamespacedPath: toNamespacedPath };

const PosixPath = {
  sep: '/',
  delimiter: ':',
  basename: function (filepath, ext) {
    return basename(this.sep, filepath, ext);
  },
  normalize: function (filepath) {
    return normalize(this.sep, filepath);
  },
  join: function (...paths) {
    return join$1(this.sep, paths);
  },
  extname: function (filepath) {
    return extname(this.sep, filepath);
  },
  dirname: function (filepath) {
    return dirname(this.sep, filepath);
  },
  isAbsolute: function (filepath) {
    return isAbsolute(true, filepath);
  },
  relative: function (from, to) {
    return relative(this.sep, from, to);
  },
  resolve: function (...paths) {
    return resolve(this.sep, paths);
  },
  parse: function (filepath) {
    return parse(this.sep, filepath);
  },
  format: function (pathObject) {
    return format$1(this.sep, pathObject);
  },
  toNamespacedPath: function (filepath) {
    return filepath; // no-op
  } };

const path = PosixPath;
path.win32 = Win32Path;
path.posix = PosixPath;

const PosixConstants = {
  UV_UDP_REUSEADDR: 4,
  dlopen: {},
  errno: {
    E2BIG: 7,
    EACCES: 13,
    EADDRINUSE: 48,
    EADDRNOTAVAIL: 49,
    EAFNOSUPPORT: 47,
    EAGAIN: 35,
    EALREADY: 37,
    EBADF: 9,
    EBADMSG: 94,
    EBUSY: 16,
    ECANCELED: 89,
    ECHILD: 10,
    ECONNABORTED: 53,
    ECONNREFUSED: 61,
    ECONNRESET: 54,
    EDEADLK: 11,
    EDESTADDRREQ: 39,
    EDOM: 33,
    EDQUOT: 69,
    EEXIST: 17,
    EFAULT: 14,
    EFBIG: 27,
    EHOSTUNREACH: 65,
    EIDRM: 90,
    EILSEQ: 92,
    EINPROGRESS: 36,
    EINTR: 4,
    EINVAL: 22,
    EIO: 5,
    EISCONN: 56,
    EISDIR: 21,
    ELOOP: 62,
    EMFILE: 24,
    EMLINK: 31,
    EMSGSIZE: 40,
    EMULTIHOP: 95,
    ENAMETOOLONG: 63,
    ENETDOWN: 50,
    ENETRESET: 52,
    ENETUNREACH: 51,
    ENFILE: 23,
    ENOBUFS: 55,
    ENODATA: 96,
    ENODEV: 19,
    ENOENT: 2,
    ENOEXEC: 8,
    ENOLCK: 77,
    ENOLINK: 97,
    ENOMEM: 12,
    ENOMSG: 91,
    ENOPROTOOPT: 42,
    ENOSPC: 28,
    ENOSR: 98,
    ENOSTR: 99,
    ENOSYS: 78,
    ENOTCONN: 57,
    ENOTDIR: 20,
    ENOTEMPTY: 66,
    ENOTSOCK: 38,
    ENOTSUP: 45,
    ENOTTY: 25,
    ENXIO: 6,
    EOPNOTSUPP: 102,
    EOVERFLOW: 84,
    EPERM: 1,
    EPIPE: 32,
    EPROTO: 100,
    EPROTONOSUPPORT: 43,
    EPROTOTYPE: 41,
    ERANGE: 34,
    EROFS: 30,
    ESPIPE: 29,
    ESRCH: 3,
    ESTALE: 70,
    ETIME: 101,
    ETIMEDOUT: 60,
    ETXTBSY: 26,
    EWOULDBLOCK: 35,
    EXDEV: 18 },

  signals: {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGILL: 4,
    SIGTRAP: 5,
    SIGABRT: 6,
    SIGIOT: 6,
    SIGBUS: 10,
    SIGFPE: 8,
    SIGKILL: 9,
    SIGUSR1: 30,
    SIGSEGV: 11,
    SIGUSR2: 31,
    SIGPIPE: 13,
    SIGALRM: 14,
    SIGTERM: 15,
    SIGCHLD: 20,
    SIGCONT: 19,
    SIGSTOP: 17,
    SIGTSTP: 18,
    SIGTTIN: 21,
    SIGTTOU: 22,
    SIGURG: 16,
    SIGXCPU: 24,
    SIGXFSZ: 25,
    SIGVTALRM: 26,
    SIGPROF: 27,
    SIGWINCH: 28,
    SIGIO: 23,
    SIGINFO: 29,
    SIGSYS: 12 },

  priority: {
    PRIORITY_LOW: 19,
    PRIORITY_BELOW_NORMAL: 10,
    PRIORITY_NORMAL: 0,
    PRIORITY_ABOVE_NORMAL: -7,
    PRIORITY_HIGH: -14,
    PRIORITY_HIGHEST: -20 } };

// default implementations

const OS = {
  EOL: '\n',
  arch: () => process.arch,
  constants: PosixConstants,
  cpus: () => {
    const count = Ti.Platform.processorCount;
    const array = [];

    for (let i = 0; i < count; i++) {
      array.push({
        model: 'unknown',
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0 } });


    }

    return array;
  },
  endianness: () => {
    // TODO: Cache the value!
    const result = Ti.Codec.getNativeByteOrder();

    if (result === Ti.Codec.LITTLE_ENDIAN) {
      return 'LE';
    }

    return 'BE';
  },
  freemem: () => Ti.Platform.availableMemory,
  getPriority: () => 0,
  // fake it
  homedir: () => Ti.Filesystem.applicationDataDirectory,
  // fake it
  hostname: () => Ti.Platform.address,
  // fake it
  loadavg: () => [0, 0, 0],
  // fake it
  networkInterfaces: () => {},
  // FIXME: What do we do here? We might be able to piece some of this together using Ti.Platform.netmask, Ti.Platform.address
  platform: () => process.platform,
  release: () => Ti.Platform.version,
  setPriority: () => {},
  // no-op, fake it

  /**
   * The `os.tmpdir()` method returns a string specifying the operating system's default directory for temporary files.
   * @return {string} [description]
   */
  tmpdir: () => Ti.Filesystem.tempDirectory,

  /**
                                              * The `os.totalmem()` method returns the total amount of system memory in bytes as an integer.
                                              * @return {integer} [description]
                                              */
  totalmem: () => Ti.Platform.totalMemory,
  type: () => 'Unknown',
  // overridden per-platform at bottom

  /**
   * The `os.uptime()` method returns the system uptime in number of seconds.
   * @return {integer} [description]
   */
  uptime: () => Ti.Platform.uptime,
  userInfo: () => {
    // fake it!
    return {
      uid: -1,
      guid: -1,
      username: Ti.Platform.username,
      homedir: Ti.Filesystem.applicationDataDirectory,
      shell: null };

  } };
// On specific platforms, override implementations because we don't have them
// yet and need to fake it, or to hack them
// I'm also doing this in blocks to assign implementations that don't need to consult platform
// type at runtime (hopefully speeding up execution at runtime)

{
  OS.cpus = () => Ti.Platform.cpus();

  OS.type = () => 'Linux';
}

const tty = {
  isatty: () => false,
  ReadStream: () => {
    throw new Error('tty.ReadStream is not implemented');
  },
  WriteStream: () => {
    throw new Error('tty.WriteStream is not implemented');
  } };


const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const util = {
  format,
  formatWithOptions,
  inspect,
  isArray: Array.isArray,
  isBoolean: value => typeof value === 'boolean',
  isBuffer: BufferModule.Buffer.isBuffer,
  isFunction: value => typeof value === 'function',
  isNull: value => value === null,
  isNullOrUndefined: value => value === undefined || value === null,
  isNumber: value => typeof value === 'number',
  isObject: value => value !== null && typeof value === 'object',
  isPrimitive: value => typeof value !== 'object' && typeof value !== 'function' || value === null,
  isString: value => typeof value === 'string',
  isSymbol: value => typeof value === 'symbol',
  isUndefined: value => value === undefined,
  isRegExp: isRegExp,
  isDate: isDate,
  isError: e => Object.prototype.toString.call(e) === '[object Error]' || e instanceof Error,
  log: string => {
    const date = new Date();
    const time = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`; // Produces output like: "21 Feb 10:04:23 - message"

    console.log(`${date.getDate()} ${MONTHS[date.getMonth()]} ${time} - ${string}`);
  },
  print: (...args) => console.log(args.join('')),
  // FIXME: Shouldn't add trailing newline like console.log does!
  puts: (...args) => console.log(args.join('\n')),
  error: (...args) => console.error(args.join('\n')),
  debug: string => console.error(`DEBUG: ${string}`),
  types };

/**
            * @param {Function} constructor subclass
            * @param {Function} superConstructor base class
            * @returns {void}
            */

util.inherits = function (constructor, superConstructor) {
  assertArgumentType(constructor, 'constructor', 'Function');
  assertArgumentType(superConstructor, 'superConstructor', 'Function');
  assertArgumentType(superConstructor.prototype, 'superConstructor.prototype', 'Object');
  Object.defineProperty(constructor, 'super_', {
    value: superConstructor });

  Object.setPrototypeOf(constructor.prototype, superConstructor.prototype);
};
/**
    * @param {Function} original original function to wrap which is expected to have a final callback argument
    * @returns {Function} function that returns a Promise
    */


util.promisify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    return new Promise((resolve, reject) => {
      original.call(this, ...args, (err, result) => {
        if (err) {
          return reject(err);
        }

        return resolve(result);
      });
    });
  } // TODO: Copy properties from original to wrapped
  // TODO: hook prototype chain up from wrapped to original
  // TODO: Support custom promisify hooks


  return wrapped;
};
/**
    * @param {Function} original original function to convert from async/Promise return value to a callback style
    * @returns {Function} wrapped function
    */


util.callbackify = function (original) {
  assertArgumentType(original, 'original', 'Function');

  function wrapped(...args) {
    const callback = args.pop();
    const promise = original.apply(this, args);
    promise.then(result => {
      // eslint-disable-line promise/always-return
      callback(null, result); // eslint-disable-line promise/no-callback-in-promise
    }).catch(err => {
      if (!err) {
        const wrappedError = new Error('Promise was rejected with falsy value');
        wrappedError.reason = err;
        err = wrappedError;
      }

      callback(err); // eslint-disable-line promise/no-callback-in-promise
    });
  }

  return wrapped;
};
/**
    * @param {Function} func function to deprecate/wrap
    * @param {string} string message to give when deprecation warning is emitted
    * @param {string} code deprecation code to use to group warnings
    * @returns {Function} wrapped function
    */


util.deprecate = function (func, string, code) {
  // eslint-disable-line no-unused-vars
  if (process.noDeprecation) {
    return func; // skip the wrapping!
  } // TODO: Support `code` argument by tracking a map of codes we've warned about


  function wrapped(...args) {
    let warned = false;

    if (!warned) {
      process.emitWarning(string, 'DeprecationWarning');
      warned = true;
    }

    return func.apply(this, args);
  }

  return wrapped;
}; // TODO: Support debuglog? What is our equivalent of process.env('NODE_DEBUG')?


const noop$1 = () => {};

util.debuglog = () => {
  return noop$1;
};

const DEFAULT_MESSAGES = {
  deepStrictEqual: 'Expected values to be strictly deep-equal:',
  strictEqual: 'Expected values to be strictly equal:',
  deepEqual: 'Expected values to be loosely deep-equal:',
  equal: 'Expected values to be loosely equal:',
  notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
  notStrictEqual: 'Expected "actual" to be strictly unequal to:',
  notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
  notEqual: 'Expected "actual" to be loosely unequal to:' };
// Fake enums to use internally

const COMPARE_TYPE = {
  Object: 0,
  Map: 1,
  Set: 2 };

const STRICTNESS = {
  Strict: 0,
  Loose: 1 };


class AssertionError extends Error {
  constructor(options) {
    let {
      actual,
      expected,
      message,
      operator } =
    options;

    if (!message) {
      // FIXME: Generate the rest of the message with diff of actual/expected!
      message = `${DEFAULT_MESSAGES[operator]}\n\n`;
    }

    super(message);
    this.actual = actual;
    this.expected = expected;
    this.operator = operator;
    this.generatedMessage = !message;
    this.name = 'AssertionError [ERR_ASSERTION]';
    this.code = 'ERR_ASSERTION';
  }}

// TODO: Can we define AssertStrict and AssertLoose as subclasses of a base Assert class
// that class holds impls for shared methods, subclasses override specific
// comparisons used (Object.is vs ===)?


const assert$1 = (value, message) => assert$1.ok(value, message);

assert$1.AssertionError = AssertionError;

assert$1.ok = (...args) => {
  const value = args[0];

  if (value) {
    return;
  }

  let message = args[1];
  let generatedMessage = false; // Check if value (1st arg) was not supplied!
  // Have to use ugly hack on args definition to do so

  if (args.length === 0) {
    message = 'No value argument passed to `assert.ok()`';
    generatedMessage = true;
  } else if (message == null) {
    // eslint-disable-line no-eq-null,eqeqeq
    // TODO: generate rest of the message. Node actually reads the input file! The hacked browserify does not do this
    // It treates ok failing like `value == true` failing
    message = 'The expression evaluated to a falsy value:\n\n';
    generatedMessage = true;
  } else if (message instanceof Error) {
    throw message;
  }

  const err = new AssertionError({
    actual: value,
    expected: true,
    message,
    operator: '==' });

  err.generatedMessage = generatedMessage;
  throw err;
};

function throwError(obj) {
  // If message is an Error object, throw that instead!
  if (obj.message instanceof Error) {
    throw obj.message;
  }

  throw new AssertionError(obj);
}

assert$1.equal = (actual, expected, message) => {
  if (actual == expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'equal' });

};

assert$1.strictEqual = (actual, expected, message) => {
  if (Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'strictEqual' });

};

assert$1.notEqual = (actual, expected, message) => {
  if (actual != expected) {
    // eslint-disable-line eqeqeq
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notEqual' });

};

assert$1.notStrictEqual = (actual, expected, message) => {
  if (!Object.is(actual, expected)) {
    // provides SameValue comparison for us
    return;
  }

  throwError({
    actual,
    expected,
    message,
    operator: 'notStrictEqual' });

};

const isPrimitive = value => {
  return typeof value !== 'object' && typeof value !== 'function' || value === null;
};
/**
    * @param {Map} actual map we are comparing
    * @param {Map} expected map we're comparing against
    * @param {STRICTNESS.Loose|strictness.Strict} strictness how to compare
    * @param {object} references memoized references to objects in the deepEqual hierarchy
    * @returns {boolean}
    */


function compareMaps(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of objects we need to test more extensively than using #get()/#has()

  for (const [key, value] of actual) {
    if (typeof key === 'object' && key !== null) {
      // non-null object. We need to do our own checking, not use get()/has()
      looseChecks.add(key);
    } else {
      // handle "primitives"
      if (expected.has(key) && deepEqual(value, expected.get(key), strictness, references)) {
        // yay! a nice easy match - both key and value matched exactly - move on
        continue;
      }

      if (strictness === STRICTNESS.Strict) {
        // if we didn't match key/value perfectly in strict mode, fail right away
        return false;
      } // ok, so it didn't match key/value perfectly - but we're in loose mode, so fall back to try again


      looseChecks.add(key);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // only go through the second Map once!


  for (const [expectedKey, expectedValue] of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedKey === 'object' && expectedKey !== null)) {
      return false;
    } // otherwise, test it // TODO: Wish we could use #find() like on an Array, but Set doesn't have it!


    let found = false;

    for (const key of looseChecks) {
      // if both key and value matches
      if (deepEqual(key, expectedKey, strictness, references) && deepEqual(actual.get(key), expectedValue, strictness, references)) {
        found = true;
        looseChecks.delete(key); // remove from our looseChecks Set since we already matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched keys? if so, fail


  return looseChecks.size === 0;
}
/**
   * @param {Set} actual map we are comparing
   * @param {Set} expected map we're comparing against
   * @param {strictness.Loose|strictness.Strict} strictness how to compare
   * @param {object} references memoized references to objects in the deepEqual hierarchy
   * @returns {boolean}
   */


function compareSets(actual, expected, strictness, references) {
  const looseChecks = new Set(); // keep track of values we need to test more extensively than using #has()

  for (const value of actual) {
    if (typeof value === 'object' && value !== null) {
      // non-null object. We need to do our own checking, not use has()
      looseChecks.add(value);
    } else if (!expected.has(value)) {
      // FIXME: has does "same-value-zero" check, which is like Object.is except for -0/+0 being considered equal
      // so may need to special case that here, that'd have to be in an else below (since has will return true here)
      if (strictness === STRICTNESS.Strict) {
        // failed "same-value" match for primitive in strict mode, so fail right away
        return false;
      } // When doing loose check, we need to fall back to looser check than #has(), so we can't just return false immediately here
      // add to set of values to check more thoroughly


      looseChecks.add(value);
    }
  }

  if (looseChecks.size === 0) {
    // no loose ends to tie up, everything matched
    return true;
  } // Try to whittle down the loose checks set to be empty...
  // only go through the second Set once!


  for (const expectedValue of expected) {
    // if it's not a non-null object in strict mode, fail!
    // (i.e. if it's a primitive that failed a match, don't fall back to more loosely match it)
    // Note that this shouldn't ever happen since we should be returning false immediately above
    if (strictness === STRICTNESS.Strict && !(typeof expectedValue === 'object' && expectedValue !== null)) {
      return false;
    }

    let found = false;

    for (const object of looseChecks) {
      if (deepEqual(object, expectedValue, strictness, references)) {
        found = true; // found a match!

        looseChecks.delete(object); // remove from our looseChecks Set since we matched it

        break;
      }
    } // if not found, we failed to match


    if (!found) {
      return false;
    }
  } // did we leave un-matched values? if so, fail


  return looseChecks.size === 0;
}
/**
   * @param {*} actual value we are comparing
   * @param {*} expected values we're comparing against
   * @param {STRICTNESS.Strict|STRICTNESS.Loose} strictness how strict a comparison to do
   * @param {object} [references] optional object to keep track of circular references in the hierarchy
   * @param {Map<object,number>} [references.actual] mapping from objects visited (on `actual`) to their depth
   * @param {Map<object,number>} [references.expected] mapping from objects visited (on `expected`) to their depth
   * @param {number} [references.depth] The current depth of the hierarchy
   * @returns {boolean}
   */


function deepEqual(actual, expected, strictness, references) {
  // if primitives, compare using Object.is
  // This handles: null, undefined, number, string, boolean
  if (isPrimitive(actual) && isPrimitive(expected)) {
    if (strictness === STRICTNESS.Strict) {
      return Object.is(actual, expected);
    } else {
      return actual == expected; // eslint-disable-line eqeqeq
    }
  } // Now we have various objects/functions:
  // Date, Error, RegExp, Array, Map, Set, Object, Function, Arrow functions, WeakMap, DataView, ArrayBuffer, WeakSet, typed arrays
  // notably, this includes "boxed" primitives created by new Boolean(false), new String('value'), Symbol('whatever'), etc
  // Type tags of objects should be the same


  const actualTag = Object.prototype.toString.call(actual);
  const expectedTag = Object.prototype.toString.call(expected);

  if (actualTag !== expectedTag) {
    return false;
  } // [[Prototype]] of objects are compared using the Strict Equality Comparison.


  if (strictness === STRICTNESS.Strict) {
    // don't check prototype when doing "loose"
    const actualPrototype = Object.getPrototypeOf(actual);
    const expectedPrototype = Object.getPrototypeOf(expected);

    if (actualPrototype !== expectedPrototype) {
      return false;
    }
  }

  let comparison = COMPARE_TYPE.Object;

  if (util.types.isRegExp(actual)) {
    // RegExp source and flags should match
    if (!util.types.isRegExp(expected) || actual.flags !== expected.flags || actual.source !== expected.source) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isDate(actual)) {
    // Date's underlying time should match
    if (!util.types.isDate(expected) || actual.getTime() !== expected.getTime()) {
      return false;
    } // continue on to check properties...

  } else if (actual instanceof Error) {
    // Error's name and message must match
    if (!(expected instanceof Error) || actual.name !== expected.name || actual.message !== expected.message) {
      return false;
    } // continue on to check properties...

  } else if (Array.isArray(actual)) {
    // if array lengths differ, quick fail
    if (!Array.isArray(expected) || actual.length !== expected.length) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isBoxedPrimitive(actual)) {
    if (!util.types.isBoxedPrimitive(expected)) {
      return false;
    } // check that they're the same type of wrapped primitive and then call the relevant valueOf() for that type to compare them!


    if (util.types.isNumberObject(actual) && (!util.types.isNumberObject(expected) || !Object.is(Number.prototype.valueOf.call(actual), Number.prototype.valueOf.call(expected)))) {
      return false;
    } else if (util.types.isStringObject(actual) && (!util.types.isStringObject(expected) || String.prototype.valueOf.call(actual) !== String.prototype.valueOf.call(expected))) {
      return false;
    } else if (util.types.isBooleanObject(actual) && (!util.types.isBooleanObject(expected) || Boolean.prototype.valueOf.call(actual) !== Boolean.prototype.valueOf.call(expected))) {
      return false; // FIXME: Uncomment when we support BigInt cross-platform!
      // } else if (util.types.isBigIntObject(actual)
      // 	&& (!util.types.isBigIntObject(expected)
      // 		|| BigInt.prototype.valueOf.call(actual) !== BigInt.prototype.valueOf.call(expected))) {
      // 	return false;
    } else if (util.types.isSymbolObject(actual) && (!util.types.isSymbolObject(expected) || Symbol.prototype.valueOf.call(actual) !== Symbol.prototype.valueOf.call(expected))) {
      return false;
    } // continue on to check properties...

  } else if (util.types.isSet(actual)) {
    if (!util.types.isSet(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Set; // continue on to check properties...
  } else if (util.types.isMap(actual)) {
    if (!util.types.isMap(expected) || actual.size !== expected.size) {
      return false;
    }

    comparison = COMPARE_TYPE.Map; // continue on to check properties...
  } // Now iterate over properties and compare them!


  const actualKeys = Object.keys(actual); // for an array, this will return the indices that have values

  const expectedKeys = Object.keys(expected); // and it just magically works
  // Must have same number of properties

  if (actualKeys.length !== expectedKeys.length) {
    return false;
  } // Are they the same keys? If one is missing, then no, fail right away


  if (!actualKeys.every(key => Object.prototype.hasOwnProperty.call(expected, key))) {
    return false;
  } // Don't check own symbols when doing "loose"


  if (strictness === STRICTNESS.Strict) {
    const actualSymbols = Object.getOwnPropertySymbols(actual);
    const expectedSymbols = Object.getOwnPropertySymbols(expected); // Must have same number of symbols

    if (actualSymbols.length !== expectedSymbols.length) {
      return false;
    }

    if (actualSymbols.length > 0) {
      // Have to filter them down to enumerable symbols!
      for (const key of actualSymbols) {
        const actualIsEnumerable = Object.prototype.propertyIsEnumerable.call(actual, key);
        const expectedIsEnumerable = Object.prototype.propertyIsEnumerable.call(expected, key);

        if (actualIsEnumerable !== expectedIsEnumerable) {
          return false; // they differ on whetehr symbol is enumerable, fail!
        } else if (actualIsEnumerable) {
          // it's enumerable, add to keys to check
          actualKeys.push(key);
          expectedKeys.push(key);
        }
      }
    }
  } // Avoid circular references!
  // Record map from objects to depth in the hierarchy


  if (references === undefined) {
    references = {
      actual: new Map(),
      expected: new Map(),
      depth: 0 };

  } else {
    // see if we've already recorded these objects.
    // if so, make sure they refer to same depth in object hierarchy
    const memoizedActual = references.actual.get(actual);

    if (memoizedActual !== undefined) {
      const memoizedExpected = references.expected.get(expected);

      if (memoizedExpected !== undefined) {
        return memoizedActual === memoizedExpected;
      }
    }

    references.depth++;
  } // store the object -> depth mapping


  references.actual.set(actual, references.depth);
  references.expected.set(expected, references.depth); // When comparing Maps/Sets, compare elements before custom properties

  let result = true;

  if (comparison === COMPARE_TYPE.Set) {
    result = compareSets(actual, expected, strictness, references);
  } else if (comparison === COMPARE_TYPE.Map) {
    result = compareMaps(actual, expected, strictness, references);
  }

  if (result) {
    // Now loop over keys and compare them to each other!
    for (const key of actualKeys) {
      if (!deepEqual(actual[key], expected[key], strictness, references)) {
        result = false;
        break;
      }
    }
  } // wipe the object to depth mapping for these objects now


  references.actual.delete(actual);
  references.expected.delete(expected);
  return result;
}

assert$1.deepStrictEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepStrictEqual' });

  }
};

assert$1.notDeepStrictEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Strict)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepStrictEqual' });

  }
};

assert$1.deepEqual = (actual, expected, message) => {
  if (!deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'deepEqual' });

  }
};

assert$1.notDeepEqual = (actual, expected, message) => {
  if (deepEqual(actual, expected, STRICTNESS.Loose)) {
    throwError({
      actual,
      expected,
      message,
      operator: 'notDeepEqual' });

  }
};

assert$1.fail = (message = 'Failed') => throwError({
  message });


const NO_EXCEPTION = {};

function execute(fn) {
  assertArgumentType(fn, 'fn', 'Function');

  try {
    fn();
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

function isPromiseLike(fn) {
  return util.types.isPromise(fn) || fn && typeof fn === 'object' && typeof fn.then === 'function';
}

async function executePromise(fn) {
  let promise;
  const fnType = typeof fn;

  if (fnType === 'function') {
    promise = fn();

    if (!isPromiseLike(promise)) {
      throw new TypeError(`Expected instanceof Promise to be returned from the "fn" function but got ${typeof promise}`);
    }
  } else {
    if (!isPromiseLike(fn)) {
      throw new TypeError(`The "fn" argument must be of type Function or Promise. Received type ${fnType}`);
    }

    promise = fn;
  }

  try {
    await promise;
  } catch (e) {
    return e;
  }

  return NO_EXCEPTION;
}

assert$1.throws = (fn, error, message) => {
  const actual = execute(fn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'throws' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert$1.rejects = async function (asyncFn, error, message) {
  const actual = await executePromise(asyncFn);

  if (actual === NO_EXCEPTION) {
    // FIXME: append message if not null
    throwError({
      actual: undefined,
      expected: error,
      message: 'Missing expected exception.',
      operator: 'rejects' });

    return;
  } // They didn't specify how to validate, so just roll with it


  if (!error) {
    return;
  }

  if (!checkError(actual, error, message)) {
    throw actual; // throw the Error it did generate
  }
};

assert$1.doesNotThrow = (fn, error, message) => {
  const actual = execute(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};

assert$1.doesNotReject = async function (fn, error, message) {
  const actual = await executePromise(fn); // no Error, just return

  if (actual === NO_EXCEPTION) {
    return;
  } // They didn't specify how to validate, so just re-throw


  if (!error) {
    throw actual;
  } // If error matches expected, throw an AssertionError


  if (checkError(actual, error)) {
    throwError({
      actual,
      expected: error,
      operator: 'doesNotThrow',
      message: `Got unwanted exception${message ? ': ' + message : '.'}` });

    return;
  } // doesn't match, re-throw


  throw actual;
};
/**
    * @param {Error} actual the actual Error generated by the wrapped function/block
    * @param {object|RegExp|Function|Error|Class} expected The value to test against the Error
    * @param {string} [message] custom message to append
    * @returns {boolean} true if the Error matches the expected value/object
    */


function checkError(actual, expected, message) {
  // What we do here depends on what `expected` is:
  // function - call it to validate
  // object - test properties against actual
  // Regexp - test against actual.toString()
  // Error type - check type matches
  // Error instance - compare properties
  if (typeof expected === 'object') {
    if (util.types.isRegExp(expected)) {
      return expected.test(actual); // does the error match the RegExp expression? if so, pass
    } // Test properties (`expected` is either a generic Object or an Error instance)


    const keys = Object.keys(expected); // If we're testing against an instance of an Error, we need to hack in name/message properties.

    if (expected instanceof Error) {
      keys.unshift('name', 'message'); // we want to compare name and message, but they're not set as enumerable on Error
    }

    for (const key of keys) {
      if (!deepEqual(actual[key], expected[key], STRICTNESS.Strict)) {
        if (!message) {
          // generate a meaningful message! Cheat by treating like equality check of values
          // then steal the message it generated
          try {
            throwError({
              actual: actual[key],
              expected: expected[key],
              operator: 'deepStrictEqual' });

          } catch (err) {
            message = err.message;
          }
        }

        throwError({
          actual,
          expected,
          message,
          operator: 'throws' });

        return false;
      }
    }

    return true; // They all matched, pass!
  } else if (typeof expected === 'function') {
    // if `expected` is a "type" and actual is an instance of that type, then pass
    if (expected.prototype != null && actual instanceof expected) {
      // eslint-disable-line no-eq-null,eqeqeq
      return true;
    } // If `expected` is a subclass of Error but `actual` wasn't an instance of it (above), fail


    if (Object.prototype.isPrototypeOf.call(Error, expected)) {
      return false;
    } // ok, let's assume what's left is that `expected` was a validation function,
    // so call it with empty `this` and single argument of the actual error we received


    return expected.call({}, actual);
  }

  return false;
}

assert$1.ifError = value => {
  if (value === null || value === undefined) {
    return;
  }

  throwError({
    actual: value,
    expected: null,
    message: `ifError got unwanted exception: ${value}`,
    operator: 'ifError' });

}; // Create "strict" copy which overrides "loose" methods to call strict equivalents


assert$1.strict = (value, message) => assert$1.ok(value, message); // "Copy" methods from assert to assert.strict!


Object.assign(assert$1.strict, assert$1); // Override the "loose" methods to point to the strict ones

assert$1.strict.deepEqual = assert$1.deepStrictEqual;
assert$1.strict.notDeepEqual = assert$1.notDeepStrictEqual;
assert$1.strict.equal = assert$1.strictEqual;
assert$1.strict.notEqual = assert$1.notStrictEqual; // hang strict off itself

assert$1.strict.strict = assert$1.strict;

/**
                                           * @param {string} [encoding='utf8'] The character encoding the `StringDecoder` will use.
                                           */
function StringDecoder(encoding = 'utf8') {
  this.encoding = encoding.toLowerCase();

  switch (this.encoding) {
    case 'utf8':
    case 'utf-8':
      this._impl = new Utf8StringDecoder();
      break;

    case 'ucs2':
    case 'ucs-2':
    case 'utf16-le':
    case 'utf16le':
      this._impl = new Utf16StringDecoder();
      break;

    case 'base64':
      this._impl = new Base64StringDecoder();
      break;

    default:
      this._impl = new StringDecoderImpl(this.encoding);
      break;}

}
/**
   * Returns any remaining input stored in the internal buffer as a string.
   * Bytes representing incomplete UTF-8 and UTF-16 characters will be replaced with substitution
   * characters appropriate for the character encoding.
   *
   * If the buffer argument is provided, one final call to stringDecoder.write() is performed before returning the remaining input.
   * @param {Buffer} [buffer] containing the bytes to decode.
   * @returns {string}
   */


StringDecoder.prototype.end = function end(buffer) {
  return this._impl.end(buffer);
};
/**
    * Returns a decoded string, ensuring that any incomplete multibyte characters at the end of the Buffer, or
    * TypedArray, or DataView are omitted from the returned string and stored in an internal buffer for the
    * next call to stringDecoder.write() or stringDecoder.end().
    * @param {Buffer|TypedArray|DataView} buffer containing the bytes to decode.
    * @returns {string}
    */


StringDecoder.prototype.write = function write(buffer) {
  if (typeof buffer === 'string') {
    return buffer;
  } // empty string for empty buffer


  if (buffer.length === 0) {
    return '';
  }

  return this._impl.write(buffer);
};
/**
    * This is the base class. We override parts of it for certain encodings. For ascii/hex/binary/latin1 the impl is super-easy
    */


class StringDecoderImpl {
  constructor(encoding = 'utf8') {
    this.encoding = encoding;
    this.byteCount = 0;
    this.charLength = 1;
  } // the actual underlying implementation!


  end(buffer) {
    if (buffer && buffer.length !== 0) {
      return this.write(buffer);
    }

    return '';
  }

  write(buffer) {
    if (buffer && buffer.length !== 0) {
      return buffer.toString(this.encoding); // single byte character encodings are a cinch
    }

    return ''; // no buffer, or empty
  }}

// For multi-byte encodings, let's implement some base logic...


class MultiByteStringDecoderImpl extends StringDecoderImpl {
  constructor(encoding, bytesPerChar) {
    super(encoding);
    this.incomplete = Buffer.allocUnsafe(bytesPerChar); // temporary incomplete character buffer
  }
  /**
     * @typedef {Object} IncompleteCharObject
     * @property {integer} bytesNeeded bytes missing to complete the character
     * @property {integer} charLength bytes expected to complete the character
     * @property {integer} index location in the buffer where the character starts
     */

  /**
         * Given a Buffer, sees if we have an incomplete "character" at the end of it.
         * Returns info on that:
         * - bytesNeeded: 0-3, number of bytes still remaining
         * - charLength: expected number of bytes for the incomplete character
         * - index: index in the buffer where the incomplete character begins
         * @param {Buffer} _buffer Buffer we are checking to see if it has an incompelte "character" at the end
         * @returns {IncompleteCharObject}
         */


  _checkIncompleteBytes(_buffer) {
    throw new Error('subclasses must override!');
  }

  _incompleteEnd() {
    throw new Error('subclasses must override!');
  }

  _incompleteBufferEmptied() {
    // typically we reset byte count back to 0 and character length to 1
    this.byteCount = 0;
    this.charLength = 1;
  }

  end(buffer) {
    let result = super.end(buffer);

    if (this.byteCount !== 0) {
      // we have incomplete characters!
      result += this._incompleteEnd();
    }

    this._incompleteBufferEmptied(); // reset our internals to "wipe" the incomplete buffer


    return result;
  }

  write(buffer) {
    // first let's see if we had some multi-byte character we didn't finish...
    let char = '';

    if (this.byteCount !== 0) {
      // we still needed some bytes to finish the character
      // How many bytes do we still need? charLength - bytes we received
      const left = this.charLength - this.byteCount; // need 4, have 1? then we have 3 "left"

      const bytesCopied = Math.min(left, buffer.length); // copy up to that many bytes
      // copy bytes from `buffer` to our incomplete buffer

      buffer.copy(this.incomplete, this.byteCount, 0, bytesCopied);
      this.byteCount += bytesCopied; // record how many more bytes we copied...

      if (bytesCopied < left) {
        // still need more bytes to complete!
        return '';
      } // we were able to complete, yay!
      // grab the character we completed


      char = this.incomplete.slice(0, this.charLength).toString(this.encoding); // reset our counters

      this._incompleteBufferEmptied(); // do we have any bytes left in this buffer?


      if (bytesCopied === buffer.length) {
        return char; // if not, return the character we finished!
      } // we still have more bytes, so slice the buffer up


      buffer = buffer.slice(bytesCopied, buffer.length);
    } // check this buffer to see if it indicates we need more bytes?


    const incompleteCharData = this._checkIncompleteBytes(buffer);

    if (incompleteCharData.bytesNeeded === 0) {
      return char + buffer.toString(this.encoding); // no incomplete bytes, return any character we completed plus the buffer
    } // ok so the buffer holds an incomplete character at it's end


    this.charLength = incompleteCharData.charLength; // record how many bytes we need for the 'character'

    const incompleteCharIndex = incompleteCharData.index; // this is the index of the multibyte character that is incomplete
    // copy from index of incomplete character to end of buffer

    const bytesToCopy = buffer.length - incompleteCharIndex;
    buffer.copy(this.incomplete, 0, incompleteCharIndex, buffer.length);
    this.byteCount = bytesToCopy; // record how many bytes we actually copied

    if (bytesToCopy < buffer.length) {
      // buffer had bytes before the incomplete character
      // so smush any character we may have completed with any complete characters in the buffer
      return char + buffer.toString(this.encoding, 0, incompleteCharIndex);
    }

    return char; // any now-completed character that was previously incomplete, possibly empty
  }}



class Utf8StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf8', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length; // FIXME: In Node, they check the last character first!
    // And they rely on Buffer#toString() to handle injecting the '\ufffd' character for busted multi-byte sequences!
    // iOS apparently just returns undefined in that special case and
    // Android differs here because we don't work backwards from the last char
    // Can we cheat here and...
    // see https://github.com/nodejs/string_decoder/blob/master/lib/string_decoder.js#L173-L198
    // - if we see a multi-byte character start, validate the next characters are continuation chars
    // - if they're not replace the sequence with '\ufffd', treat like that multi-byte character was "completed"
    // Note that even if we do hack this, if there's some invalid multi-byte UTF-8 in the buffer that isn't at the last 3 bytes
    // then we're at the mercy of the JS engine/platform code for handling that
    // Here's someone's hack there: https://gist.github.com/oleganza/997155
    // if buffer.length >= 3, check 3rd to last byte

    if (length >= 3) {
      let charLength = checkCharLengthForUTF8(buffer[length - 3]);

      if (charLength === 4) {
        return {
          bytesNeeded: 1,
          // we have 3 last bytes, need 4th
          index: length - 3,
          charLength: 4 };

      }
    } // if buffer.length >= 2, check 2nd to last byte


    if (length >= 2) {
      let charLength = checkCharLengthForUTF8(buffer[length - 2]);

      if (charLength >= 3) {
        return {
          bytesNeeded: charLength - 2,
          // we have 2 bytes of whatever we need
          index: length - 2,
          charLength };

      }
    } // if buffer.length >= 1, check last byte


    if (length >= 1) {
      let charLength = checkCharLengthForUTF8(buffer[length - 1]);

      if (charLength >= 2) {
        return {
          bytesNeeded: charLength - 1,
          // we have 1 byte of whatever we need
          index: length - 1,
          charLength };

      }
    } // base case, no bytes needed - ends on complete character


    return {
      bytesNeeded: 0,
      index: length - 1,
      charLength: 1 };

  }

  _incompleteEnd() {
    return '\ufffd'; // we replace the missing character with a special utf8 char
  }}



class Utf16StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('utf16le', 4);
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 2; // ok, we have a multiple of 2 bytes

    if (modulo === 0) {
      // is the last byte a leading/high surrogate?
      const byte = buffer[buffer.length - 1];

      if (byte >= 0xD8 && byte <= 0xDB) {
        return {
          bytesNeeded: 2,
          charLength: 4,
          index: length - 2 };

      } // we're good, not a surrogate, so we have our needed 2 bytes


      return {
        bytesNeeded: 0,
        charLength: 2 };

    } // ok we have 1 byte left over, assume we need 2 to form the character


    return {
      bytesNeeded: 1,
      index: length - 1,
      charLength: 2 };

  }

  _incompleteEnd() {
    // Just write out the last N bytes, hopefully the engine can handle it for us?
    return this.incomplete.toString('utf16le', 0, this.byteCount);
  }}



class Base64StringDecoder extends MultiByteStringDecoderImpl {
  constructor() {
    super('base64', 3);
    this.charLength = 3; // always 3!
  }

  _checkIncompleteBytes(buffer) {
    const length = buffer.length;
    const modulo = length % 3; // base64 needs 3 bytes always, so if we have that many (or a multiple), we have a complete buffer

    if (modulo === 0) {
      return {
        bytesNeeded: 0,
        charLength: 3 };

    } // ok we have 1 or 2 bytes left over


    return {
      bytesNeeded: 3 - modulo,
      // always need 3, so if we have 1 left over -> need 2
      index: length - modulo,
      charLength: 3 // always need 3
    };

  }

  _incompleteBufferEmptied() {
    this.byteCount = 0;
    this.charLength = 3; // always 3!
  }

  _incompleteEnd() {
    // Just write out the last N bytes, it should insert the '=' placeholders
    // it's not really 'missing'/'incomplete', just needs placeholder insertion
    return this.incomplete.toString('base64', 0, this.byteCount);
  }}



function checkCharLengthForUTF8(byte) {
  // 11110XXX => 1110 => 0x1E
  if (byte >> 3 === 0x1E) {
    return 4;
  } // 1110XXXX => 1110 => 0x1E


  if (byte >> 4 === 0x0E) {
    return 3;
  } // 110XXXXX => 110 => 0x06


  if (byte >> 5 === 0x06) {
    return 2;
  }

  return 1;
}

var StringDecoder$1 = {
  StringDecoder };


const printedWarnings = {};

function oneTimeWarning(key, msg) {
  if (!printedWarnings[key]) {
    console.warn(msg);
    printedWarnings[key] = true;
  }
}
/**
   * Prints a one-time warning message that we do not support the given API and performs an effective no-op
   * @param {string} moduleName name of the module/object
   * @param {string} name name of the function.property we don't support
   * @returns {Function} no-op function
   */


function unsupportedNoop(moduleName, name) {
  return () => {
    const fqn = `${moduleName}.${name}`;
    oneTimeWarning(fqn, `"${fqn}" is not supported yet on Titanium and uses a no-op fallback.`);
    return undefined;
  };
}
/**
   * @param {string} moduleName name of the module/object
   * @param {string} name name of the function.property we don't support
   * @param {Function} callback async callback we call in a quick setTimeout
   */


function asyncUnsupportedNoop(moduleName, name, callback) {
  callback = maybeCallback(callback); // enforce we have a valid callback

  unsupportedNoop(moduleName, name)();
  setTimeout(callback, 1);
} // Used to choose the buffer/chunk size when pumping bytes during copies


const COPY_FILE_CHUNK_SIZE = 8092; // what should we use here?
// Keep track of integer -> FileStream mappings

const fileDescriptors = new Map();
let fileDescriptorCount = 4; // global counter used to report file descriptor integers
// Map file system access flags to Ti.Filesystem.MODE_* constants

const FLAGS_TO_TI_MODE = new Map();
FLAGS_TO_TI_MODE.set('a', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('a+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('ax+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('as+', Ti.Filesystem.MODE_APPEND);
FLAGS_TO_TI_MODE.set('r', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('r+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('rs+', Ti.Filesystem.MODE_READ);
FLAGS_TO_TI_MODE.set('w', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('w+', Ti.Filesystem.MODE_WRITE);
FLAGS_TO_TI_MODE.set('wx+', Ti.Filesystem.MODE_WRITE); // Common errors

const permissionDenied = (syscall, path) => makeError('EACCES', 'permission denied', -13, syscall, path);

const noSuchFile = (syscall, path) => makeError('ENOENT', 'no such file or directory', -2, syscall, path);

const fileAlreadyExists = (syscall, path) => makeError('EEXIST', 'file already exists', -17, syscall, path);

const notADirectory = (syscall, path) => makeError('ENOTDIR', 'not a directory', -20, syscall, path);

const directoryNotEmpty = (syscall, path) => makeError('ENOTEMPTY', 'directory not empty', -66, syscall, path);

const illegalOperationOnADirectory = (syscall, path) => makeError('EISDIR', 'illegal operation on a directory', -21, syscall, path);

const fs = {
  constants: {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1 } };



class Stats {
  constructor(path) {
    this._file = null;
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 0;
    this.uid = 0;
    this.gid = 0;
    this.rdev = 0;
    this.size = 0;
    this.blksize = 4096; // FIXME: https://stackoverflow.com/questions/1315311/what-is-the-block-size-of-the-iphone-filesystem

    this.blocks = 0;
    this.atimeMs = this.mtimeMs = this.ctimeMs = this.birthtimeMs = 0;
    this.atime = this.mtime = this.ctime = this.birthtime = new Date(0);

    if (path) {
      this._file = getTiFileFromPathLikeValue(path); // TODO: use lazy getters here?

      this.ctime = this.birthtime = this._file.createdAt();
      this.atime = this.mtime = this._file.modifiedAt();
      this.atimeMs = this.atime.getTime();
      this.birthtimeMs = this.birthtime.getTime();
      this.ctimeMs = this.ctime.getTime();
      this.mtimeMs = this.mtime.getTime();
      this.size = this._file.size;
      this.blocks = Math.ceil(this.size / this.blksize); // TODO: Can we fake out the mode based on the readonly/writable/executable properties?
    }
  }

  isFile() {
    return this._file.isFile();
  }

  isDirectory() {
    return this._file.isDirectory();
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isSymbolicLink() {
    return this._file.symbolicLink;
  }

  isFIFO() {
    return false;
  }

  isSocket() {
    return false;
  }}



fs.Stats = Stats;

class ReadStream {}

fs.ReadStream = ReadStream;

class WriteStream {}

fs.WriteStream = WriteStream;
/**
                               * @callback statsCallback
                               * @param {Error} err - Error if one occurred
                               * @param {fs.Stats} stats - file stats
                               */

/**
                                   * @param {string|URL|Buffer} path file path
                                   * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
                                   * @param {function} callback async callback
                                   */

fs.access = function (path, mode, callback) {
  if (typeof mode === 'function') {
    callback = mode;
    mode = fs.constants.F_OK;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.accessSync(path, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|URL|Buffer} path file path
    * @param {integer} [mode=fs.constants.F_OK] accessibility mode/check
    */


fs.accessSync = function (path, mode = fs.constants.F_OK) {
  // F_OK is just whether file exists or not, no permissions check
  // R_OK is read check
  // W_OK is write check
  // X_OK is execute check (acts like F_OK on Windows)
  const fileHandle = getTiFileFromPathLikeValue(path);

  if (!fileHandle.exists()) {
    throw noSuchFile('access', path);
  } // TODO: We have no means of testing if a file is readable. It's assumed all files that exist under the app are?


  if (mode & fs.constants.W_OK && !fileHandle.writable) {
    throw permissionDenied('access', path);
  }

  if (mode & fs.constants.X_OK && !fileHandle.executable && fileHandle.isFile()) {
    throw permissionDenied('access', path);
  }
};
/**
    * Asynchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
    * @param {string|Buffer|URL|FileStream} file filepath to file
    * @param {string|Buffer} data data to append to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding='utf8'] encoding to use
    * @param {integer} [options.mode=0o666] mode to create file, if not created
    * @param {string} [options.flag='a'] file system flag
    * @param {Function} callback function to call back with error if failed
    */


fs.appendFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFile(file, data, options, callback);
};
/**
    * Synchronously append data to a file, creating the file if it does not yet exist. data can be a string or a Buffer.
    * @param {string|Buffer|URL|FileStream} file filepath to file
    * @param {string|Buffer} data data to append to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding='utf8'] encoding to use
    * @param {integer} [options.mode=0o666] mode to create file, if not created
    * @param {string} [options.flag='a'] file system flag
    */


fs.appendFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'a' });

  fs.writeFileSync(file, data, options); // TODO: Use Ti.Filesystem.File.append() instead?
};

fs.chmod = (path, mode, callback) => asyncUnsupportedNoop('fs', 'chmod', callback);

fs.chmodSync = unsupportedNoop('fs', 'chmodSync');

fs.chown = (path, uid, gid, callback) => asyncUnsupportedNoop('fs', 'chown', callback);

fs.chownSync = unsupportedNoop('fs', 'chownSync');
/**
                                                    * Callback for functions that can only throw errors
                                                    *
                                                    * @callback errorCallback
                                                    * @param {Error} [err] - Error thrown
                                                    */

/**
                                                        * @param {integer} fd file descriptor
                                                        * @param {errorCallback} callback callback function
                                                        */

fs.close = (fd, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.closeSync(fd);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {integer} fd file descriptor
    */


fs.closeSync = fd => {
  const stream = streamForDescriptor(fd);
  stream.close();
}; // Rather than use a hack to wrap sync version in setTimeout, use actual async APIs!

/**
 * @param {string|Buffer|URL} src source filename to copy
 * @param {string|Buffer|URL} dest destination filename of the copy operation
 * @param {number} [flags=0] modifiers for copy operation
 * @param {errorCallback} callback callback called at end of operation
 */


fs.copyFile = function (src, dest, flags, callback) {
  if (typeof flags === 'function') {
    callback = flags;
    flags = 0;
  }

  callback = maybeCallback(callback); // FIXME: I don't know why, but changing this to use Ti.Filesystem.openStream(mode, path) fails (at least on iOS)

  const srcFile = Ti.Filesystem.getFile(src);
  const srcStream = srcFile.open(Ti.Filesystem.MODE_READ);
  const destFile = Ti.Filesystem.getFile(dest);
  const destStream = destFile.open(Ti.Filesystem.MODE_WRITE);
  pipe(srcStream, destStream, callback);
};
/**
    * @param {string|Buffer|URL} src source filename to copy
    * @param {string|Buffer|URL} dest destination filename of the copy operation
    * @param {number} [flags=0] modifiers for copy operation
    */


fs.copyFileSync = function (src, dest, flags = 0) {
  const srcFile = Ti.Filesystem.getFile(src);

  if (flags === fs.constants.COPYFILE_EXCL && fs.existsSync(dest)) {
    throw fileAlreadyExists('copyFile', dest);
  }

  if (!srcFile.copy(dest)) {
    throw new Error(`Unable to copy ${src} to ${dest}`); // FIXME: What error should we give?
  }
}; // TODO: fs.createReadStream(path, options)
// /**
//  * @param {string|Buffer|URL} path path like
//  * @param {string|object} [options] options, if a string, it's the encoding
//  * @param {string} [options.flags='r'] See support of file system flags.
//  * @param {string} [options.encoding=null] encoding
//  * @param {integer} [options.fd=null] file descriptor, if specified, `path` is ignored
//  * @param {integer} [options.mode=0o666] permissions to set if file is created
//  * @param {boolean} [options.autoClose=true] if false, file descriptor will not be closed; if true even on error it will be closed
//  * @param {integer} [options.start] start index of range of bytes to read from file
//  * @param {integer} [options.end=Infinity] end index of range of bytes to read from file
//  * @param {integer} [options.highWaterMark=64 * 1024]
//  * @returns {fs.ReadStream}
//  */
// fs.createReadStream = (path, options) => {
// 	options = mergeDefaultOptions(options, { flags: 'r', encoding: null, fd: null, mode: 0o666, autoClose: true, end: Infinity, highWaterMark: 64 * 1024 });
// 	// FIXME: If options.fd, use that in place of path!
// 	const tiFile = getTiFileFromPathLikeValue(path);
// };
// TODO: fs.createWriteStream(path, options)

/**
 * @callback existsCallback
 * @param {boolean} exists - whether path exists
 */

/**
     * @param {string} path path to check
     * @param {existsCallback} callback callback function
     * @returns {void}
     */


fs.exists = function (path, callback) {
  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(fs.existsSync(path));
  }, 1);
};
/**
    * @param {string} path path to check
    * @returns {boolean} whether a file or directory exists at that path
    */


fs.existsSync = function (path) {
  try {
    fs.accessSync(path);
    return true;
  } catch (e) {
    return false;
  }
};

fs.fchmod = (fd, mode, callback) => asyncUnsupportedNoop('fs', 'fchmod', callback);

fs.fchmodSync = unsupportedNoop('fs', 'fchmodSync');

fs.fchown = (fd, uid, gid, callback) => asyncUnsupportedNoop('fs', 'fchown', callback);

fs.fchownSync = unsupportedNoop('fs', 'fchownSync');

fs.fdatasync = (fd, callback) => asyncUnsupportedNoop('fs', 'fdatasync', callback);

fs.fdatasyncSync = unsupportedNoop('fs', 'fdatasyncSync');
/**
                                                            * @param {integer} fd file descriptor
                                                            * @param {object} [options] options
                                                            * @param {boolean} [options.bigint] whether stat values should be bigint
                                                            * @param {function} callback async callback function
                                                            */

fs.fstat = (fd, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let stats;

    try {
      stats = fs.fstatSync(fd, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, stats);
  }, 1);
};
/**
    * @param {integer} fd file descriptor
    * @param {object} [_options] options
    * @param {boolean} [_options.bigint] whether stat values should be bigint
    * @returns {fs.Stats} stats for file descriptor
    */


fs.fstatSync = (fd, _options) => {
  const path = pathForFileDescriptor(fd);
  return fs.statSync(path);
}; // TODO: Add versions of these APIs:
// fs.fsync(fd, callback)
// fs.fsyncSync(fd)
// fs.ftruncate(fd[, len], callback)
// fs.ftruncateSync(fd[, len])
// fs.futimes(fd, atime, mtime, callback)
// fs.futimesSync(fd, atime, mtime)
// fs.lchmod(path, mode, callback)
// fs.lchmodSync(path, mode)
// fs.lchown(path, uid, gid, callback)
// fs.lchownSync(path, uid, gid)
// fs.link(existingPath, newPath, callback)
// fs.linkSync(existingPath, newPath)
// FIXME: If symbolic link we need to follow link to target to get stats! Our API doesn't support that!


fs.lstat = (path, options, callback) => fs.stat(path, options, callback);

fs.lstatSync = (path, options) => fs.statSync(path, options);
/**
                                                               * @param {string|Buffer|URL} path file path
                                                               * @param {string|object} [options] options
                                                               * @param {boolean} [options.recursive=false] recursivley create dirs?
                                                               * @param {integer} [options.mode=0o777] permissions
                                                               * @param {errorCallback} callback async callback
                                                               */


fs.mkdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      recursive: false,
      mode: 0o777 };

  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.mkdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null);
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {string|object} [options] options
    * @param {boolean} [options.recursive=false] recursivley create dirs?
    * @param {integer} [options.mode=0o777] permissions
    */


fs.mkdirSync = (path, options) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (typeof options === 'number') {
    options = {
      recursive: false,
      mode: options };

  } else {
    options = mergeDefaultOptions(options, {
      recursive: false,
      mode: 0o777 });

  }

  if (!tiFile.createDirectory(options.recursive) && !options.recursive) {
    if (tiFile.exists()) {
      // already existed!
      throw fileAlreadyExists('mkdir', path);
    } // We failed, probably because we didn't ask for recursive and parent doesn't exist, so reproduce node's error


    throw noSuchFile('mkdir', path);
  }
};
/**
    * @callback tempDirCallback
    * @param {Error} err - Error if one occurred
    * @param {string} folder - generated folder name
    */

/**
        * @param {string} prefix directory name prefix
        * @param {string|object} [options] options
        * @param {string} [options.encoding='utf-8'] prefix encoding
        * @param {tempDirCallback} callback async callback
        */


fs.mkdtemp = (prefix, options, callback) => {
  assertArgumentType(prefix, 'prefix', 'string');

  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });
  // try to be all async

  const tryMkdtemp = () => {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;
    fs.mkdir(path, 0o700, err => {
      if (err) {
        if (err.code === 'EEXIST') {
          // retry!
          setTimeout(tryMkdtemp, 1);
          return;
        } // bubble up error


        callback(err);
        return;
      } // succeeded! Hurray!


      callback(null, path);
    });
  };

  setTimeout(tryMkdtemp, 1);
};
/**
    * Creates a unique temporary directory.
    * @param {string} prefix directory name prefix
    * @param {string|object} [options] options
    * @param {string} [options.encoding='utf-8'] prefix encoding
    * @returns {string} path to created directory
    */


fs.mkdtempSync = (prefix, options) => {
  assertArgumentType(prefix, 'prefix', 'string');
  options = mergeDefaultOptions(options, {
    encoding: 'utf-8' });

  let retryCount = 0;
  const MAX_RETRIES = 100;

  while (retryCount < MAX_RETRIES) {
    const generated = randomCharacters(6, options.encoding); // generate six random characters

    const path = `${prefix}${generated}`;

    try {
      fs.mkdirSync(path, 0o700); // don't try recursive

      return path;
    } catch (e) {
      if (e.code !== 'EEXIST') {
        throw e; // bubble up error
      } // name was not unique, so retry


      retryCount++;
    }
  }

  throw new Error(`Failed to create a unique directory name with prefix ${prefix}`);
};
/**
    * @callback fileDescriptorCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} fileDescriptor - generated file descriptor
    */

/**
        * @param {string|Buffer|URL} path path to file
        * @param {string} [flags='r'] file system access flags
        * @param {integer} [mode=0o666] file mode to use when creating file
        * @param {fileDescriptorCallback} callback async callback
        */


fs.open = (path, flags, mode, callback) => {
  // flags and mode are optional, we need to handle if not supplied!
  if (typeof flags === 'function') {
    callback = flags;
    flags = 'r';
    mode = 0o666;
  } else if (typeof mode === 'function') {
    callback = mode;
    mode = 0o666;
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let fileDescriptor;

    try {
      fileDescriptor = fs.openSync(path, flags, mode);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, fileDescriptor);
  }, 1);
};
/**
    * @param {string|Buffer|URL} path path to file
    * @param {string} [flags='r'] file system access flags
    * @param {integer} [_mode=0o666] file mode to use when creating file
    * @returns {integer}
    */


fs.openSync = (path, flags = 'r', _mode = 0o666) => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.exists()) {
    // TODO: Support creating file with specific mode
    oneTimeWarning('fs.openSync.mode', 'fs.openSync\'s mode parameter is unsupported in Titanium and will be ignored');

    if (!tiFile.createFile()) {
      // Oh crap, we failed to create the file. why?
      if (!tiFile.parent.exists()) {
        // parent does not exist!
        throw noSuchFile('open', path);
      }

      throw new Error(`failed to create file at path ${path}`);
    }
  } else if (flags) {
    // file/dir exists...
    if ((flags.charAt(0) === 'w' || flags.charAt(0) === 'a') && tiFile.isDirectory()) {
      // If user is trying to write or append and it's a directory, fail
      throw illegalOperationOnADirectory('open', path);
    }

    if (flags.length > 1 && flags.charAt(1) === 'x') {
      // If user has "exclusive" flag on, fail if file already exists
      throw fileAlreadyExists('open', path);
    }
  }

  const tiMode = FLAGS_TO_TI_MODE.get(flags);

  if (tiMode === undefined) {
    // TODO: Make use of common error type/code for this once we have internal/errors.js
    const err = new TypeError(`The value "${String(flags)}" is invalid for option "flags"`);
    err.code = 'ERR_INVALID_OPT_VALUE';
    throw err;
  }

  return createFileDescriptor(path, tiFile.open(tiMode));
};
/**
    * @callback readCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} bytesRead - number of bytes read
    * @param {Buffer} buffer buffer
    */

/**
        * @param {integer} fd file descriptor
        * @param {Buffer|Ti.Buffer} buffer buffer to read into
        * @param {integer} offset the offset in the buffer to start writing at.
        * @param {integer} length integer specifying the number of bytes to read.
        * @param {integer} position where to begin reading from in the file
        * @param {readCallback} callback async callback
        */


fs.read = (fd, buffer, offset, length, position, callback) => {
  callback = maybeCallback(callback);
  const tiFileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  tiFileStream.read(buffer.toTiBuffer(), offset, length, readObj => {
    if (!readObj.success) {
      callback(new Error(readObj.error));
      return;
    }

    callback(null, readObj.bytesProcessed, buffer);
  });
};
/**
    * @param {integer} fd file descriptor
    * @param {Buffer|Ti.Buffer} buffer buffer to read into
    * @param {integer} offset the offset in the buffer to start writing at.
    * @param {integer} length integer specifying the number of bytes to read.
    * @param {integer} _position where to begin reading from in the file
    * @returns {integer} bytes read
    */


fs.readSync = (fd, buffer, offset, length, _position) => {
  const fileStream = streamForDescriptor(fd);

  if (!Buffer.isBuffer(buffer)) {
    buffer = Buffer.from(buffer);
  } // FIXME: Allow using position argument!


  if (_position !== null) {
    oneTimeWarning('fs.readSync.position', 'fs.readSync\'s position argument is unsupported by Titanium and will be treated as null');
  }

  return fileStream.read(buffer.toTiBuffer(), offset, length);
};
/**
    * @callback filesCallback
    * @param {Error} err - Error if one occurred
    * @param {string[]|Buffer[]|fs.Dirent[]} files - file listing
    */

/**
        * @param {string} path directory to list
        * @param {string|object} [options] optional options
        * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
        * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
        * @param {filesCallback} callback async callback
        */


fs.readdir = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    let result;

    try {
      result = fs.readdirSync(path, options);
    } catch (e) {
      callback(e);
      return;
    }

    callback(null, result);
  }, 1);
};
/**
    * @param {string} filepath directory to list
    * @param {string|object} [options] optional options
    * @param {string} [options.encoding='utf8'] encoding to use for filenames, if `'buffer'`, returns `Buffer` objects
    * @param {boolean} [options.withFileTypes=false] if true, returns `fs.Dirent` objects
    * @returns {string[]|Buffer[]|fs.Dirent[]}
    */


fs.readdirSync = (filepath, options) => {
  const file = getTiFileFromPathLikeValue(filepath);

  if (!file.exists()) {
    throw noSuchFile('scandir', filepath);
  }

  if (!file.isDirectory()) {
    throw notADirectory('scandir', filepath);
  }

  options = mergeDefaultOptions(options, {
    encoding: 'utf-8',
    withFileTypes: false });

  const listing = file.getDirectoryListing();

  if (options.withFileTypes === true) {
    // TODO: if options.withFileTypes === true, return fs.Dirent objects
    oneTimeWarning('fs.readdir\'s options.withFileTypes is unsupported by Titanium and strings will be returned');
  } else if (options.encoding === 'buffer') {
    return listing.map(name => Buffer.from(name));
  }

  return listing;
};
/**
    * @callback readFilePostOpenCallback
    * @param {Error} err - Error if one occurred
    * @param {Ti.Buffer} buffer
    */

/**
        * @param {integer} fileDescriptor file descriptor
        * @param {readFilePostOpenCallback} callback async callback
        */


function readFilePostOpen(fileDescriptor, callback) {
  callback = maybeCallback(callback);
  fs.fstat(fileDescriptor, (err, stats) => {
    if (err) {
      callback(err);
      return;
    }

    const fileSize = stats.size; // Create a Ti.Buffer to read into

    const buffer = Ti.createBuffer({
      length: fileSize });
    // Use Ti.Stream.readAll(sourceStream, buffer, callback) which spins off a separate thread to read in while loop!

    const sourceStream = streamForDescriptor(fileDescriptor);
    Ti.Stream.readAll(sourceStream, buffer, readAllObj => {
      if (!readAllObj.success) {
        callback(new Error(readAllObj.error));
        return;
      }

      callback(null, buffer);
    });
  });
}
/**
   * @callback readFileCallback
   * @param {Error} err - Error if one occurred
   * @param {string|Buffer} data
   */

/**
       * Asynchronously read entire contents of file
       * @param {string|Buffer|URL|integer} path filename or file descriptor
       * @param {object|string} [options] options
       * @param {string} [options.encoding=null] encoding to use
       * @param {string} [options.flag='r'] file system flag
       * @param {readFileCallback} callback async callback
       */


fs.readFile = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {
      encoding: null,
      flag: 'r' };

  } else {
    options = mergeDefaultOptions(options, {
      encoding: null,
      flag: 'r' });

  }

  callback = maybeCallback(callback);
  const wasFileDescriptor = typeof path === 'number';
  let fileDescriptor = path; // may be overriden later

  /**
   * @param {Error} err possible Error
   * @param {Ti.Buffer} buffer Ti.Buffer instance
   */

  const handleBuffer = (err, buffer) => {
    if (err) {
      callback(err);
      return;
    } // fs.closeSync if it was not originally a file descriptor


    if (!wasFileDescriptor) {
      fs.closeSync(fileDescriptor);
    } // TODO: trim buffer if we didn't read full size?


    callback(null, encodeBuffer(options.encoding, buffer));
  };

  if (!wasFileDescriptor) {
    fs.open(path, options.flag, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      readFilePostOpen(fd, handleBuffer);
    });
  } else {
    readFilePostOpen(path, handleBuffer);
  }
};
/**
    * Returns the contents of the path.
    * @param {string|Buffer|URL|integer} path path to file
    * @param {object|string} [options] options
    * @param {string} [options.encoding=null] encoding to use
    * @param {string} [options.flag='r'] file system flag
    * @returns {string|Buffer} string if encoding is specified, otherwise Buffer
    */


fs.readFileSync = (path, options) => {
  options = mergeDefaultOptions(options, {
    encoding: null,
    flag: 'r' });

  const wasFileDescriptor = typeof path === 'number';
  const fileDescriptor = wasFileDescriptor ? path : fs.openSync(path, options.flag); // use default mode

  const tiFileStream = streamForDescriptor(fileDescriptor); // Just use our own API that reads full stream in

  const buffer = Ti.Stream.readAll(tiFileStream); // fs.closeSync if it was not originally a file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  } // TODO: trim buffer if we didn't read full size?


  return encodeBuffer(options.encoding, buffer);
}; // TODO: fs.readlink(path[, options], callback)
// TODO: fs.readlinkSync(path[, options])

/**
 * @callback realpathCallback
 * @param {Error} err - Error if one occurred
 * @param {string|Buffer} resolvedPath the resolved path
 */

/**
     * @param {string|Buffer|URL} filepath original filepath
     * @param {object} [options] optiosn object
     * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
     * @param {realpathCallback} callback async callback
     */


fs.realpath = (filepath, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });

  setTimeout(() => {
    // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.
    const result = path.normalize(filepath);
    fs.exists(result, resultExists => {
      if (resultExists) {
        if (options.encoding === 'buffer') {
          return callback(null, Buffer.from(result));
        }

        return callback(null, result);
      } // this path doesn't exist, try each segment until we find first that doesn't


      const segments = result.split(path.sep); // FIXME: Drop last segment as we already know the full path doesn't exist?

      let partialFilePath = '';
      let index = 0; // handle typical case of empty first segment so we don't need to do an async setTimeout to get to first real case

      if (segments[index].length === 0) {
        index++;
      }

      setTimeout(tryPath, 1);

      function tryPath() {
        if (index >= segments.length) {
          // don't run past end of segments, throw error for resolved path
          return callback(noSuchFile(result));
        } // grab next segment


        const segment = segments[index++];

        if (segment.length === 0) {
          // if it's an empty segment...
          // try again at next index
          return setTimeout(tryPath, 1);
        } // normal case


        partialFilePath += path.sep + segment; // check if path up to this point exists...

        fs.exists(partialFilePath, partialExists => {
          if (!partialExists) {
            // nope, throw the Error
            return callback(noSuchFile('lstat', partialFilePath));
          } // try again at next depth of dir tree


          setTimeout(tryPath, 1);
        });
      }
    });
  }, 1);
};

fs.realpath.native = (path, options, callback) => {
  fs.realpath(path, options, callback);
};
/**
    * @param {string|Buffer|URL} filepath original filepath
    * @param {object} [options] options object
    * @param {string} [options.encoding='utf8'] encoding used for returned object. If 'buffer", we'll return a Buffer in palce of a string
    * @returns {string|Buffer}
    */


fs.realpathSync = (filepath, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8' });
  // FIXME: This assumes no symlinks, which we really don't have full support for in our SDK anyways.

  const result = path.normalize(filepath);

  if (!fs.existsSync(result)) {
    // this path doesn't exist, try each segment until we find first that doesn't
    const segments = result.split(path.sep);
    let partialFilePath = '';

    for (const segment of segments) {
      if (segment.length === 0) {
        continue;
      }

      partialFilePath += path.sep + segment;

      if (!fs.existsSync(partialFilePath)) {
        throw noSuchFile('lstat', partialFilePath);
      }
    }
  }

  if (options.encoding === 'buffer') {
    return Buffer.from(result);
  }

  return result;
};

fs.realpathSync.native = (path, options) => {
  fs.realpathSync(path, options);
};
/**
    * @param {string|Buffer|URL} oldPath source filepath
    * @param {string|Buffer|URL} newPath destination filepath
    * @param {errorCallback} callback async callback
    */


fs.rename = (oldPath, newPath, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.renameSync(oldPath, newPath);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} oldPath source filepath
    * @param {string|Buffer|URL} newPath destination filepath
    */


fs.renameSync = (oldPath, newPath) => {
  const tiFile = getTiFileFromPathLikeValue(oldPath); // src doesn't actually exist?

  if (!tiFile.exists()) {
    const err = noSuchFile('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  const destFile = getTiFileFromPathLikeValue(newPath);

  if (destFile.isDirectory()) {
    // dest is a directory that already exists
    const err = illegalOperationOnADirectory('rename', oldPath);
    err.message = `${err.message} -> '${newPath}'`;
    err.dest = newPath;
    throw err;
  }

  let tempPath;

  if (destFile.isFile()) {
    // destination file exists, we should overwrite
    // Our APIs will fail if we try, so first let's make a backup copy and delete the the original
    tempPath = path.join(fs.mkdtempSync(path.join(Ti.Filesystem.tempDirectory, 'rename-')), path.basename(newPath));
    destFile.move(tempPath);
  }

  let success = false;

  try {
    success = tiFile.move(newPath);
  } finally {
    if (tempPath) {
      // we temporarily copied the existing destination to back it up...
      if (success) {
        // move worked, so we can wipe it away whenever...
        fs.unlink(tempPath, _err => {});
      } else {
        // move it back, because we failed!
        const tmpFile = getTiFileFromPathLikeValue(tempPath);
        tmpFile.move(newPath);
      }
    }
  }
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {errorCallback} callback async callback
    */


fs.rmdir = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.rmdirSync(path);
    } catch (e) {
      callback(e);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    */


fs.rmdirSync = path => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteDirectory(false)) {
    // do not delete contents!
    // we failed to delete, but why?
    // does it exist?
    if (!tiFile.exists()) {
      throw noSuchFile('rmdir', path);
    } // is it a file?


    if (tiFile.isFile()) {
      throw notADirectory('rmdir', path);
    } // is it not empty?


    const subFiles = tiFile.getDirectoryListing();

    if (subFiles && subFiles.length > 0) {
      throw directoryNotEmpty('rmdir', path);
    }
  }
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {object} [options] options
    * @param {boolean} [options.bigint] whether stat values should be bigint
    * @param {statsCallback} callback async callback
    */


fs.stat = (path, options, callback) => {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  callback = maybeCallback(callback);
  setTimeout(() => {
    callback(null, new fs.Stats(path));
  }, 1);
};
/**
    * @param {string|Buffer|URL|integer} path filepath or file descriptor
    * @param {object} [_options] options
    * @param {boolean} [_options.bigint] whether stat values should be bigint
    * @returns {fs.Stats}
    */


fs.statSync = (path, _options) => new fs.Stats(path);

fs.symlink = (target, path, type, callback) => asyncUnsupportedNoop('fs', 'symlink', callback);

fs.symlinkSync = unsupportedNoop('fs', 'symlinkSync');
/**
                                                        * @param {string} path file path
                                                        * @param {integer} [len=0] bytes to trim to
                                                        * @param {errorCallback} callback async callback
                                                        */

fs.truncate = (path, len, callback) => {
  callback = maybeCallback(callback || len);

  if (typeof len !== 'number') {
    len = 0;
  }

  if (len <= 0) {
    fs.writeFile(path, '', callback); // empty the file

    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  fs.open(path, (err, fd) => {
    if (err) {
      return callback(err);
    }

    const buffer = Buffer.alloc(len);
    fs.read(fd, buffer, 0, len, null, (err, bytesRead, buffer) => {
      if (err) {
        fs.closeSync(fd);
        return callback(err);
      }

      fs.close(fd, err => {
        if (err) {
          return callback(err);
        }

        fs.writeFile(path, buffer, callback);
      });
    });
  });
};
/**
    * @param {string} path file path
    * @param {integer} [len=0] bytes to trim to
    */


fs.truncateSync = (path, len = 0) => {
  if (len <= 0) {
    // empty the file
    fs.writeFileSync(path, '');
    return;
  } // we have to retain some of the file!
  // yuck, so let's read what we need to retain, then overwrite file with it


  const fd = fs.openSync(path);
  const buffer = Buffer.alloc(len);
  fs.readSync(fd, buffer, 0, len, null);
  fs.closeSync(fd);
  fs.writeFileSync(path, buffer);
};
/**
    * @param {string|Buffer|URL} path file path
    * @param {errorCallback} callback async callback
    */


fs.unlink = (path, callback) => {
  callback = maybeCallback(callback);
  setTimeout(() => {
    try {
      fs.unlinkSync(path);
    } catch (err) {
      callback(err);
      return;
    }

    callback();
  }, 1);
};
/**
    * @param {string|Buffer|URL} path file path
    * @returns {undefined}
    */


fs.unlinkSync = path => {
  const tiFile = getTiFileFromPathLikeValue(path);

  if (!tiFile.deleteFile()) {
    // we failed, but why?
    if (!tiFile.exists()) {
      throw noSuchFile('unlink', path);
    }

    if (tiFile.isDirectory()) {
      throw illegalOperationOnADirectory('unlink', path);
    }
  }
};

fs.unwatchFile = unsupportedNoop('fs', 'unwatchFile');

fs.utimes = (path, atime, mtime, callback) => asyncUnsupportedNoop('fs', 'utimes', callback);

fs.utimesSync = unsupportedNoop('fs', 'utimesSync');
fs.watch = unsupportedNoop('fs', 'watch');
fs.watchFile = unsupportedNoop('fs', 'watchFile');
/**
                                                    * @param {string|Buffer|URL|integer} file file path or descriptor
                                                    * @param {string|Buffer|TypedArray|DataView} data data to write
                                                    * @param {object|string} [options] options, encoding if string
                                                    * @param {string|null} [options.encoding='utf-8'] options
                                                    * @param {object} [options.mode=0o666] options
                                                    * @param {object} [options.flag='w'] options
                                                    * @param {errorCallback} callback async callback
                                                    */

fs.writeFile = (file, data, options, callback) => {
  callback = maybeCallback(callback || options);
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  let fileDescriptor = file; // may be overriden later

  const finish = err => {
    if (err) {
      callback(err);
      return;
    }

    if (wasFileDescriptor) {
      callback();
      return;
    } // fs.close if it was not originally a file descriptor


    fs.close(fileDescriptor, callback);
  };

  if (!wasFileDescriptor) {
    fs.open(file, options.flag, options.mode, (err, fd) => {
      if (err) {
        callback(err);
        return;
      }

      fileDescriptor = fd;
      fs.write(fileDescriptor, data, finish);
    });
  } else {
    fs.write(fileDescriptor, data, finish);
  }
};
/**
    * @param {string|Buffer|URL|integer} file file path or descriptor
    * @param {string|Buffer|TypedArray|DataView} data data to write
    * @param {object|string} [options] options, encoding if string
    * @param {string} [options.encoding='utf-8'] options
    * @param {object} [options.mode=0o666] options
    * @param {object} [options.flag='w'] options
    */


fs.writeFileSync = (file, data, options) => {
  options = mergeDefaultOptions(options, {
    encoding: 'utf8',
    mode: 0o666,
    flag: 'w' });
  // Turn into file descriptor

  const wasFileDescriptor = typeof file === 'number';
  const fileDescriptor = wasFileDescriptor ? file : fs.openSync(file, options.flag, options.mode); // if data is a string, make it a buffer first

  if (!Buffer.isBuffer(data)) {
    data = Buffer.from('' + data, options.encoding); // force data to be a string, handles case where it's undefined and writes 'undefined' to file!
  }

  fs.writeSync(fileDescriptor, data); // close if user didn't give us file descriptor

  if (!wasFileDescriptor) {
    fs.closeSync(fileDescriptor);
  }
};
/**
    * @callback writeTiFileStreamCallback
    * @param {Error} err - Error if one occurred
    * @param {integer} written - bytes written
    */

/**
        * @param {Ti.Filesystem.FileStream} tiFileStream file stream
        * @param {Buffer} buffer buffer we're writing
        * @param {writeTiFileStreamCallback} callback async callback
        */


function writeTiFileStream(tiFileStream, buffer, callback) {
  callback = maybeCallback(callback);
  Ti.Stream.write(tiFileStream, buffer.toTiBuffer(), writeObj => {
    if (!writeObj.success) {
      callback(new Error(writeObj.error));
      return;
    }

    callback(null, writeObj.bytesProcessed);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {string|Buffer} buffer contents to write: Buffer or string
   * @param {integer} [offset] offset within Buffer to write; OR offset from the beginning of the file where this data should be written (if string)
   * @param {string|integer} [length] length of bytes to write if Buffer; OR expected string encoding
   * @param {writeCallback|integer} [position] offset from the beginning of the file where this data should be written (if Buffer); OR async callback if string
   * @param {writeCallback} [callback] async callback (if Buffer)
   */


fs.write = (fd, buffer, offset, length, position, callback) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    writeBuffer(fd, buffer, offset, length, position, callback);
  } else {
    writeString(fd, buffer, offset, length, position);
  }
};
/**
    * @param {integer} fd file descriptor
    * @param {string|Buffer} buffer contents to write
    * @param {integer} [offset] offset from the beginning of the file where this data should be written
    * @param {string|integer} [length]  expected string encoding
    * @param {integer} [position] position
    * @returns {integer} number of bytes written
    */


fs.writeSync = (fd, buffer, offset, length, position) => {
  const isBuffer = Buffer.isBuffer(buffer);

  if (isBuffer) {
    return writeBufferSync(fd, buffer, offset, length);
  }

  return writeStringSync(fd, buffer, offset, length);
}; // TODO: Add FileHandle class to match Node's wrapper for file descriptors. Re-purpose our own wrapper?
// TODO: Add the fs.promises API!
// TODO: Define fs.Dirent class, which can simply wrap a Ti.Filesystem.File (and is very similar to fs.Stats!)
// Helper functions
// --------------------------------------------------------

/**
 * Tracks the pairing of the number we use to represent the file externally, the filepath it's pointing at, and the stream pointing at it.
 */


class FileDescriptor {
  constructor(number, path, stream) {
    this.path = path;
    this.number = number;
    this.stream = stream;
  }}


/**
      * @param {Ti.IOStream} srcStream input stream we're reading from
      * @param {Ti.IOStream} destStream output stream we're writing to
      * @param {errorCallback} callback async callback
      */


function pipe(srcStream, destStream, callback) {
  {
    // Android is probably better off with Ti.Stream.writeStream, less overhead back and forth the bridge
    // Though Android does support the Ti.Stream.pump/Ti.Stream.write pattern using both APIs async
    pipeViaWriteStream(srcStream, destStream, callback);
    return;
  } // iOS has some... issues with writeStream calling the callback every iteration of the loop *and* at the end
}
/**
   * @param {Ti.IOStream} srcStream input stream we're reading from
   * @param {Ti.IOStream} destStream output stream we're writing to
   * @param {errorCallback} callback async callback
   */


function pipeViaWriteStream(srcStream, destStream, callback) {
  Ti.Stream.writeStream(srcStream, destStream, COPY_FILE_CHUNK_SIZE, result => {
    if (!result.success) {
      return callback(new Error(result.error));
    } // Android will only call this at the end or error, so we can safely assume we're done here.
    // iOS will call per loop iteration, see https://jira.appcelerator.org/browse/TIMOB-27320


    callback();
  });
}
/**
   * @param {string|Buffer|URL} path file path
   * @param {Ti.Filesystem.FileStream} fileStream file stream
   * @returns {integer} file descriptor
   */


function createFileDescriptor(path, fileStream) {
  const pointer = fileDescriptorCount++; // increment global counter

  const fd = new FileDescriptor(pointer, path, fileStream);
  fileDescriptors.set(pointer, fd); // use it to refer to this file stream as the "descriptor"

  return pointer;
}
/**
   * @param {integer} fd file descriptor
   * @returns {Ti.Filesystem.FileStream} matching stream
   */


function streamForDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.stream;
}
/**
   * @param {integer} fd file descriptor
   * @returns {string} matching stream
   */


function pathForFileDescriptor(fd) {
  const wrapper = fileDescriptors.get(fd);
  return wrapper.path;
}
/**
   * Used to merge the user-supplied options with the defaults for a function. Special cases a string to be encoding.
   * @param {*} options user-supplied options
   * @param {object} defaults defaults to use
   * @return {object}
   */


function mergeDefaultOptions(options, defaults) {
  if (options === null) {
    return defaults;
  }

  const optionsType = typeof options;

  switch (optionsType) {
    case 'undefined':
    case 'function':
      return defaults;

    case 'string':
      // Use copy of defaults but with encoding set to the 'options' value!
      const merged = Object.assign({}, defaults);
      merged.encoding = options;
      return merged;

    case 'object':
      return options;

    default:
      assertArgumentType(options, 'options', 'object');
      return null;
    // should never get reached
  }
}
/**
   * Enforces that we have a valid callback function. Throws TypeError if not.
   * @param {*} cb possible callback function
   * @returns {Function}
   * @throws {TypeError}
   */


function maybeCallback(cb) {
  if (typeof cb === 'function') {
    return cb;
  }

  const err = new TypeError(`Callback must be a function. Received ${cb}`);
  err.code = 'ERR_INVALID_CALLBACK';
  throw err;
}
/**
   * returns randomly generated characters of given length 1-16
   * @param {integer} length 1 - 16
   * @param {string} [_encoding='utf8'] encoding of the string generated
   * @returns {string}
   */


function randomCharacters(length, _encoding = 'utf8') {
  // FIXME: use the encoding specified!
  return (Math.random().toString(36) + '00000000000000000').slice(2, length + 2);
}

function makeError(code, message, errno, syscall, path) {
  const error = new Error(`${code}: ${message}, ${syscall} '${path}'`);
  error.errno = errno;
  error.syscall = syscall;
  error.code = code;
  error.path = path;
  return error;
}
/**
   * @param {string} encoding what we're encoding to
   * @param {Ti.Buffer} tiBuffer Ti.Buffer instance
   * @returns {Buffer} node-compatible Buffer instance
   */


function encodeBuffer(encoding, tiBuffer) {
  switch (encoding) {
    case 'buffer':
    case null:
    case undefined:
      // In this case we're always reading a file into a Ti.Buffer
      // Wrapping Ti.Buffer is super-slow and should really only be if we're going to write to it
      // Go the faster path by converting to ArrayBuffer and wrapping that
      // TODO: Explicitly release the blob after conversion?
      return Buffer.from(tiBuffer.toBlob().toArrayBuffer());

    default:
      // here' were converting to a string based on encoding. Internally our faster Buffer impl still delegates to Ti.Buffer in most cases
      // so I don't think there's much benefit from converting to ArrayBuffer first
      return Buffer.from(tiBuffer).toString(encoding);}

}
/**
   * @param {string|Buffer|URL} path file path
   * @return {Ti.Filesystem.File}
   */


function getTiFileFromPathLikeValue(path) {
  // This is a hack that is likely to work in most cases?
  // Basically assumes Buffer is holding a utf-8 string filename/path
  // Node just copies the bytes from the buffer as-is on the native side and adds a null terminator
  if (Buffer.isBuffer(path)) {
    path = path.toString(); // assumes utf-8 string
  } // FIXME: Handle URLs! We don't have an URL shim yet, so no way to handle those yet


  assertArgumentType(path, 'path', 'string');
  return Ti.Filesystem.getFile(path);
}
/**
   * @callback writeBufferCallback
   * @param {Error} err - Error if one occurred
   * @param {integer} written - bytes written
   * @param {Buffer} buffer - original Buffer being written
   */

/**
       * @param {integer} fd file descriptor
       * @param {Buffer} buffer contents to write
       * @param {integer} [offset] offset within Buffer to write
       * @param {integer} [length] length of bytes to write if Buffer
       * @param {integer} [position] offset from the beginning of the file where this data should be written
       * @param {writeBufferCallback} callback async callback
       */


function writeBuffer(fd, buffer, offset, length, position, callback) {
  callback = maybeCallback(callback || position || length || offset);

  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }

  if (typeof position !== 'number') {
    position = null;
  } // ok now what?


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, buffer);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {Buffer} buffer contents to write
   * @param {integer} [offset] offset within Buffer to write
   * @param {integer} [length] length of bytes to write if Buffer
   * @param {integer} [position] offset from the beginning of the file where this data should be written
   * @returns {integer} number of bytes written
   */


function writeBufferSync(fd, buffer, offset, length, position) {
  if (typeof offset !== 'number') {
    offset = 0;
  }

  if (typeof length !== 'number') {
    length = buffer.length - offset;
  }


  const tiFileStream = streamForDescriptor(fd); // Make use of the buffer slice that's specified by offset/length

  if (offset !== 0 || length !== buffer.length) {
    buffer = buffer.slice(offset, length);
  } // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow


  return tiFileStream.write(buffer.toTiBuffer());
}
/**
   * @callback writeStringCallback
   * @param {Error} err - Error if one occurred
   * @param {integer} written - bytes written
   * @param {string} string - original string being written
   */

/**
       * @param {integer} fd file descriptor
       * @param {string} string contents to write
       * @param {integer} [position] offset from the beginning of the file where this data should be written
       * @param {string} [encoding='utf8'] expected string encoding
       * @param {writeStringCallback} [callback] async callback
       */


function writeString(fd, string, position, encoding, callback) {
  callback = maybeCallback(callback || encoding || position); // position could be: number, function (callback)

  if (typeof position !== 'number') {
    position = null;
  } // encoding could be: function (callback) or string


  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  writeTiFileStream(tiFileStream, buffer, (err, bytesProcessed) => {
    if (err) {
      callback(err);
      return;
    }

    callback(null, bytesProcessed, string);
  });
}
/**
   * @param {integer} fd file descriptor
   * @param {string} string contents to write
   * @param {integer} [position] offset from the beginning of the file where this data should be written
   * @param {string} [encoding='utf8'] expected string encoding
   * @returns {integer} number of bytes written
   */


function writeStringSync(fd, string, position, encoding) {

  if (typeof encoding !== 'string') {
    encoding = 'utf8';
  }

  const tiFileStream = streamForDescriptor(fd);
  string += ''; // coerce to string

  const buffer = Buffer.from(string, encoding); // TODO: Support use of position argument. I assume we'd need a way to add a method to move to stream position somehow

  return tiFileStream.write(buffer.toTiBuffer());
}

function Stream(opts) {
  // FIXME: Can't call EventEmitter as a function!
  this._eventsToListeners = {};
  this._maxListeners = undefined; // EventEmitter.call(this, opts);
  // TODO: Provide more than an empty class?
}

Object.setPrototypeOf(Stream.prototype, EventEmitter.prototype);
Object.setPrototypeOf(Stream, EventEmitter); // Use util.inherits?

function Readable(options) {
  if (!(this instanceof Readable)) {
    return new Readable(options);
  } // TODO: readableState?


  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') {
      this._read = options.read;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }
  }

  Stream.call(this);
}

util.inherits(Readable, Stream);

Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

Readable.prototype._read = function (n) {
  throw new Error('method not implemented: _read()');
};

function Writable(options) {
  const isDuplex = this instanceof Duplex;

  if (!isDuplex && !(this instanceof Writable)) {
    return new Writable(options);
  }

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') {
      this._write = options.write;
    }

    if (typeof options.writev === 'function') {
      this._writev = options.writev;
    }

    if (typeof options.destroy === 'function') {
      this._destroy = options.destroy;
    }

    if (typeof options.final === 'function') {
      this._final = options.final;
    }
  }

  Stream.call(this);
}

util.inherits(Writable, Stream);

function Duplex(options) {
  if (!(this instanceof Duplex)) {
    return new Duplex(options);
  }

  Readable.call(this, options);
  Writable.call(this, options); // TODO: Provide more than an empty class!

  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) {
      this.readable = false;
    }

    if (options.writable === false) {
      this.writable = false;
    }

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false; // this.once('end', onend);
    }
  }
}

util.inherits(Duplex, Readable); // Copy Writable methods to Duplex (basically the odd double-inheritance)

const writableMethods = Object.keys(Writable.prototype);

for (let i = 0; i < writableMethods.length; i++) {
  const method = writableMethods;

  if (!Duplex.prototype[method]) {
    Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) {
    return new Transform(options);
  }

  Duplex.call(this, options); // TODO: Provide more than an empty class!

  if (options) {
    if (typeof options.transform === 'function') {
      this._transform = options.transform;
    }

    if (typeof options.flush === 'function') {
      this._flush = options.flush;
    }
  } // When the writable side finishes, then flush out anything remaining.
  // this.on('prefinish', prefinish);

}

util.inherits(Transform, Duplex);
Stream.Stream = Stream; // legacy compat

Stream.Transform = Transform;
Stream.Readable = Readable;
Stream.Writable = Writable;
Stream.Duplex = Duplex; // Stream.PassThrough = PassThrough;

// Load all the node compatible core modules
register('path', path);
register('os', OS);
register('tty', tty);
register('util', util);
register('assert', assert$1);
register('events', EventEmitter);
register('buffer', BufferModule);
register('string_decoder', StringDecoder$1);
register('fs', fs);
register('stream', Stream); // Register require('buffer').Buffer as global

global.Buffer = BufferModule.Buffer;

/**
                                      * Appcelerator Titanium Mobile
                                      * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
                                      * Licensed under the terms of the Apache Public License
                                      * Please see the LICENSE included with this distribution for details.
                                      *
                                      * Description:
                                      * This script loads all JavaScript files ending with the name "*.bootstrap.js" and then executes them.
                                      * The main intention of this feature is to allow JavaScript files to kick-off functionality or
                                      * display UI to the end-user before the "app.js" gets loaded. This feature is the CommonJS
                                      * equivalent to Titanium's Android module onAppCreate() or iOS module load() features.
                                      *
                                      * Use-Cases:
                                      * - Automatically kick-off analytics functionality on app startup.
                                      * - Ensure "Google Play Services" is installed/updated on app startup on Android.
                                      */

/**
                                          * Attempts to load all bootstraps from a "bootstrap.json" file created by the app build system.
                                          * This is an optional feature and is the fastest method of acquiring boostraps configured for the app.
                                          * This JSON file, if provided, must be in the same directory as this script.
                                          * @returns {string[]}
                                          * Returns an array of require() compatible strings if bootstraps were successfully loaded from JSON.
                                          * Returns an empty array if JSON file was found, but no bootstraps were configured for the app.
                                          * Returns null if JSON file was not found.
                                          */
function fetchScriptsFromJson() {
  const JSON_FILE_NAME = 'bootstrap.json';

  try {
    const jsonFile = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory, `ti.internal/${JSON_FILE_NAME}`);

    if (jsonFile.exists()) {
      const settings = JSON.parse(jsonFile.read().text);

      if (Array.isArray(settings.scripts)) {
        return settings.scripts;
      }

      return [];
    }
  } catch (error) {
    Ti.API.error(`Failed to read "${JSON_FILE_NAME}". Reason: ${error.message}`);
  }

  return null;
}
/**
   * Recursively searches the "Resources" directory for all "*.bootstrap.js" files.
   * @returns {Array.<string>}
   * Returns an array of require() compatible strings for each bootstrap found in the search.
   * Returns an empty array if no bootstrap files were found.
   */


function fetchScriptsFromResourcesDirectory() {
  const resourceDirectory = Ti.Filesystem.getFile(Ti.Filesystem.resourcesDirectory);
  const resourceDirectoryPathLength = resourceDirectory.nativePath.length;
  const bootstrapScripts = [];

  function loadFrom(file) {
    if (file) {
      if (file.isDirectory()) {
        // This is a directory. Recursively look for bootstrap files under it.
        const fileNameArray = file.getDirectoryListing();

        if (fileNameArray) {
          for (let index = 0; index < fileNameArray.length; index++) {
            loadFrom(Ti.Filesystem.getFile(file.nativePath, fileNameArray[index]));
          }
        }
      } else if (file.name.search(/.bootstrap.js$/) >= 0) {
        // This is a bootstrap file.
        // Convert its path to something loadable via require() and add it to the array.
        let bootstrapPath = file.nativePath;
        bootstrapPath = bootstrapPath.substr(resourceDirectoryPathLength, bootstrapPath.length - resourceDirectoryPathLength - '.js'.length);
        bootstrapScripts.push(bootstrapPath);
      }
    }
  }

  loadFrom(resourceDirectory);
  return bootstrapScripts;
}
/**
   * Non-blocking function which loads and executes all bootstrap scripts configured for the app.
   * @param {function} finished Callback to be invoked once all bootstraps have finished executing. Cannot be null.
   */


function loadAsync(finished) {
  // Acquire an array of all bootstrap scripts included with the app.
  // - For best performance, attempt to fetch scripts via an optional JSON file created by the build system.
  // - If JSON file not found (will return null), then search "Resources" directory for bootstrap files.
  let bootstrapScripts = fetchScriptsFromJson();

  if (!bootstrapScripts) {
    bootstrapScripts = fetchScriptsFromResourcesDirectory();
  } // Do not continue if no bootstraps were found.


  if (!bootstrapScripts || bootstrapScripts.length <= 0) {
    finished();
    return;
  } // Sort the bootstraps so that they'll be loaded in a consistent order between platforms.


  bootstrapScripts.sort(); // Loads all bootstrap scripts found.

  function loadBootstrapScripts(finished) {
    let bootstrapIndex = 0;

    function doLoad() {
      // Attempt to load all bootstrap scripts.
      while (bootstrapIndex < bootstrapScripts.length) {
        // Load the next bootstrap.
        const fileName = bootstrapScripts[bootstrapIndex];

        const bootstrap = require(fileName); // eslint-disable-line security/detect-non-literal-require
        // Invoke the bootstrap's execute() method if it has one. (This is optional.)
        // We must wait for the given callback to be invoked before loading the next script.
        // Note: This is expected to be used to display UI to the end-user.


        if (bootstrap.execute) {
          bootstrap.execute(onBootstrapExecutionFinished);
          return;
        } // We're done with the current bootstrap. Time to load the next one.


        bootstrapIndex++;
      } // Invoke given callback to inform caller that all loading is done.


      finished();
    }

    function onBootstrapExecutionFinished() {
      // Last bootstrap has finished execution. Time to load the next one.
      // Note: Add a tiny delay so whatever UI the last bootstrap loaded has time to close.
      bootstrapIndex++;
      setTimeout(() => doLoad(), 1);
    }

    doLoad();
  } // We've finished loading/executing all bootstrap scripts.
  // Inform caller by invoking the callback given to loadAsync().


  loadBootstrapScripts(finished);
}

/**
   * Appcelerator Titanium Mobile
   * Copyright (c) 2018 by Axway, Inc. All Rights Reserved.
   * Licensed under the terms of the Apache Public License
   * Please see the LICENSE included with this distribution for details.
   *
   * This script is loaded on app startup on all platforms. It is used to do the following:
   * - Provide consistent startup behavior between platforms, such as logging Titanium version.
   * - Load Titanium's core JavaScript extensions shared by all platforms.
   * - Provide "*.bootstrap.js" script support. (Similar to native module onAppCreate()/load() support.)
   * - Load the app developer's main "app.js" script after doing all of the above.
   */
// Log the app name, app version, and Titanium version on startup.
Ti.API.info(`${Ti.App.name} ${Ti.App.version} (Powered by Titanium ${"9.2.1"}.${"19122961e3"})`); // Attempt to load crash analytics module.
// NOTE: This should be the first module that loads on startup.

try {
  require('com.appcelerator.aca');
} catch (e) {} // Could not load module, silently ignore exception.
loadAsync(function () {
  // We've finished loading/executing all bootstrap scripts.
  // We can now proceed to run the main "app.js" script.
  require('./app'); // This event is to be fired after "app.js" execution. Reasons:
  // - Allow system to queue startup related events until "app.js" has had a chance to add listeners.
  // - For Alloy apps, we now know that Alloy has been initialized and its globals were added.


  Ti.App.fireEvent('started');
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRpLm1haW4uanMiXSwibmFtZXMiOlsiY29tbW9uanNHbG9iYWwiLCJnbG9iYWxUaGlzIiwid2luZG93IiwiZ2xvYmFsIiwic2VsZiIsIk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiT1NfVkVSU0lPTl9NQUpPUiIsIlRpIiwiUGxhdGZvcm0iLCJ2ZXJzaW9uTWFqb3IiLCJPU19WRVJTSU9OX01JTk9SIiwidmVyc2lvbk1pbm9yIiwiT1NfVkVSU0lPTl9QQVRDSCIsInZlcnNpb25QYXRjaCIsImtOb2RlTW9kdWxlc1JFIiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsImZvciIsImlzQnVmZmVyIiwiY29sb3JSZWdFeHAiLCJyZW1vdmVDb2xvcnMiLCJzdHIiLCJyZXBsYWNlIiwiaXNFcnJvciIsImUiLCJpc05hdGl2ZUVycm9yIiwiRXJyb3IiLCJnZXRTdHJ1Y3R1cmVkU3RhY2siLCJTdGFja1RyYWNlRXJyb3IiLCJwcmVwYXJlU3RhY2tUcmFjZSIsImVyciIsInRyYWNlIiwic3RhY2tUcmFjZUxpbWl0IiwiSW5maW5pdHkiLCJpc0luc2lkZU5vZGVNb2R1bGVzIiwidW5kZWZpbmVkIiwic3RhY2siLCJzdGFja0ZyYW1lcyIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwibGluZUluZm8iLCJtYXRjaCIsImZpbGVuYW1lIiwicHVzaCIsImdldEZpbGVOYW1lIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJhbWUiLCJ0ZXN0Iiwiam9pbiIsIm91dHB1dCIsInNlcGFyYXRvciIsImxlbmd0aCIsImxhc3RJbmRleCIsImkiLCJ1bmN1cnJ5VGhpcyIsImYiLCJjYWxsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJBTExfUFJPUEVSVElFUyIsIk9OTFlfRU5VTUVSQUJMRSIsInByb3BlcnR5RmlsdGVyIiwiZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzIiwib2JqIiwiZmlsdGVyIiwicHJvcHMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsImlzQWxsRGlnaXRzIiwicyIsImNvZGUiLCJjaGFyQ29kZUF0IiwiVHlwZWRBcnJheVByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiVWludDhBcnJheSIsInByb3RvdHlwZSIsIlR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRvU3RyaW5nVGFnIiwiZ2V0IiwiaXNPYmplY3QiLCJpc0Z1bmN0aW9uIiwiY2hlY2tQcm90b3R5cGUiLCJuYW1lIiwidG9TdHJpbmciLCJpc0FueUFycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FyZ3VtZW50c09iamVjdCIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0FzeW5jRnVuY3Rpb24iLCJpc0JpZ0ludDY0QXJyYXkiLCJpc0JpZ1VpbnQ2NEFycmF5IiwiaXNCb29sZWFuT2JqZWN0IiwiaXNCb3hlZFByaW1pdGl2ZSIsImlzTnVtYmVyT2JqZWN0IiwiaXNTdHJpbmdPYmplY3QiLCJpc1N5bWJvbE9iamVjdCIsImlzRGF0YVZpZXciLCJpc0RhdGUiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNHZW5lcmF0b3JGdW5jdGlvbiIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc01hcCIsImlzTWFwSXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsImluY2x1ZGVzIiwiaXNQcm9taXNlIiwiaXNSZWdFeHAiLCJpc1NldCIsImlzU2V0SXRlcmF0b3IiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImlzVHlwZWRBcnJheSIsImlzQnVpbHRJblR5cGVkQXJyYXkiLCJpc1VpbnQ4QXJyYXkiLCJpc1VpbnQ4Q2xhbXBlZEFycmF5IiwiaXNVaW50MTZBcnJheSIsImlzVWludDMyQXJyYXkiLCJpc1dlYWtNYXAiLCJpc1dlYWtTZXQiLCJ0eXBlcyIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImVycm9yIiwibGF6eUVycm9yIiwiY29kZXMiLCJFUlJfSU5URVJOQUxfQVNTRVJUSU9OIiwiYXNzZXJ0IiwibWVzc2FnZSIsImZhaWwiLCJtZXNzYWdlcyIsIk1hcCIsIlN5c3RlbUVycm9yIiwiRSIsInN5bSIsInZhbCIsImRlZiIsIm90aGVyQ2xhc3NlcyIsInNldCIsIm1ha2VOb2RlRXJyb3JXaXRoQ29kZSIsImZvckVhY2giLCJjbGF6eiIsIkJhc2UiLCJOb2RlRXJyb3IiLCJhcmdzIiwiZ2V0TWVzc2FnZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsImFkZENvZGVUb05hbWUiLCJtc2ciLCJleHBlY3RlZExlbmd0aCIsInVuc2hpZnQiLCJmb3JtYXQiLCJSYW5nZUVycm9yIiwic3VmZml4IiwiZXhwZWN0ZWQiLCJhY3R1YWwiLCJkZXRlcm1pbmVyIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwib25lT2YiLCJ0eXBlIiwiVHlwZUVycm9yIiwibWF4U3RhY2tfRXJyb3JOYW1lIiwibWF4U3RhY2tfRXJyb3JNZXNzYWdlIiwiaXNTdGFja092ZXJmbG93RXJyb3IiLCJvdmVyZmxvd1N0YWNrIiwidGhpbmciLCJsZW4iLCJtYXAiLCJTdHJpbmciLCJzbGljZSIsIkZhc3RCdWZmZXIiLCJzdHJpbmdUb0hleEJ5dGVzIiwiYnl0ZUFycmF5IiwibnVtZXJpY1ZhbHVlIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJOdW1iZXIiLCJpc05hTiIsIlNsb3dCdWZmZXIiLCJ0aUJ1ZmZlciIsInN0YXJ0IiwiYnl0ZU9mZnNldCIsIl90aUJ1ZmZlciIsImZyb21UaUJ1ZmZlciIsIlByb3h5IiwiYXJyYXlJbmRleEhhbmRsZXIiLCJmcm9tU3RyaW5nIiwiZW5jb2RpbmciLCJCdWZmZXIiLCJpc0VuY29kaW5nIiwidG9Mb3dlckNhc2UiLCJibG9iIiwiVXRpbHMiLCJiYXNlNjRkZWNvZGUiLCJibG9iU3RyZWFtIiwiU3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwic291cmNlIiwibW9kZSIsIk1PREVfUkVBRCIsImJ1ZmZlciIsInJlYWRBbGwiLCJjbG9zZSIsImJ5dGVzIiwiY3JlYXRlQnVmZmVyIiwiZ2V0VGlDb2RlY0NoYXJzZXQiLCJmcm9tIiwiX3NsaWNlIiwib2Zmc2V0IiwiX2ZpbGwiLCJlbmQiLCJ2YWx1ZVR5cGUiLCJidWZUb0ZpbGxXaXRoIiwiZmlsbEJ1Zkxlbmd0aCIsImZpbGwiLCJmaWxsQ2hhciIsImdldEFkanVzdGVkSW5kZXgiLCJpbmRleCIsInNldEFkanVzdGVkSW5kZXgiLCJzcmMiLCJudW1CeXRlcyIsInRvVGlCdWZmZXIiLCJjbG9uZSIsInRhcmdldCIsInByb3BLZXkiLCJyZWNlaXZlciIsIm51bSIsImlzU2FmZUludGVnZXIiLCJSZWZsZWN0IiwiaGFzIiwiYnVmIiwiVElfQ09ERUNfTUFQIiwiQ29kZWMiLCJDSEFSU0VUX1VURjgiLCJDSEFSU0VUX1VURjE2TEUiLCJDSEFSU0VUX0lTT19MQVRJTl8xIiwiQ0hBUlNFVF9BU0NJSSIsIkFMTF9QUk9QRVJUSUVTJDEiLCJPTkxZX0VOVU1FUkFCTEUkMSIsIlZBTElEX0VOQ09ESU5HUyIsImRvdWJsZUFycmF5IiwiRmxvYXQ2NEFycmF5IiwidWludDhEb3VibGVBcnJheSIsImZsb2F0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ1aW50OEZsb2F0QXJyYXkiLCJCdWZmZXIkMSIsInBvb2xTaXplIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFwaU5hbWUiLCJzaG93RmxhZ2dlZERlcHJlY2F0aW9uIiwiYWxsb2MiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tQXJyYXkiLCJmcm9tQnVmZmVyIiwibWF4TGVuZ3RoIiwiYnl0ZUxlbmd0aCIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsInRvQXJyYXlCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImNvcHkiLCJzZXRQcm90b3R5cGVPZiIsImNvbXBhcmUiLCJ0YXJnZXRTdGFydCIsInRhcmdldEVuZCIsInNvdXJjZVN0YXJ0Iiwic291cmNlRW5kIiwiYnVmMSIsInNvdXJjZUxlbmd0aCIsImRlc3QiLCJkZXN0TGVuZ3RoIiwiTWF0aCIsIm1pbiIsInRhcmdldFZhbHVlIiwic291cmNlVmFsdWUiLCJyZW1haW5pbmciLCJzb3VyY2VMZW4iLCJlbnRyaWVzIiwibmV4dEluZGV4IiwiZW50cnlJdGVyYXRvciIsIm5leHQiLCJyZXN1bHQiLCJkb25lIiwiaXRlcmF0b3IiLCJlcXVhbHMiLCJvdGhlckJ1ZmZlciIsIm9mZnNldFR5cGUiLCJUeXBlZEFycmF5UHJvdG90eXBlJDEiLCJUeXBlZEFycmF5UHJvdG9fYnl0ZUxlbmd0aCIsIlR5cGVkQXJyYXlGaWxsIiwiYnl0ZUxlbiIsImZpbGxMZW5ndGgiLCJpbmRleE9mIiwibWF0Y2hMZW5ndGgiLCJjdXJyZW50SW5kZXgiLCJ0aGlzTGVuZ3RoIiwiZmlyc3RNYXRjaCIsImZpcnN0Qnl0ZU1hdGNoIiwieCIsIm15SXRlcmF0b3IiLCJyZWFkRG91YmxlQkUiLCJjaGVja09mZnNldCIsInJlYWREb3VibGVMRSIsInJlYWRGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkSW50OCIsInVuc2lnbmVkVmFsdWUiLCJyZWFkVUludDgiLCJ1bnNpZ25lZFRvU2lnbmVkIiwicmVhZEludDE2QkUiLCJyZWFkVUludDE2QkUiLCJyZWFkSW50MTZMRSIsInJlYWRVSW50MTZMRSIsInJlYWRJbnQzMkJFIiwicmVhZFVJbnQzMkJFIiwicmVhZEludDMyTEUiLCJyZWFkVUludDMyTEUiLCJyZWFkSW50QkUiLCJyZWFkVUludEJFIiwicmVhZEludExFIiwicmVhZFVJbnRMRSIsIm11bHRpcGxpZXIiLCJzdWJhcnJheSIsInN3YXAxNiIsImZpcnN0Iiwic2Vjb25kIiwic3dhcDMyIiwidGhpcmQiLCJmb3VydGgiLCJzd2FwNjQiLCJmaWZ0aCIsInNpeHRoIiwic2V2ZW50aCIsImVpZ2h0aCIsInRvSlNPTiIsImRhdGEiLCJiYXNlNjRlbmNvZGUiLCJ0b0Jsb2IiLCJoZXhTbGljZSIsImxhdGluMVN0cmluZyIsImZyb21DaGFyQ29kZSIsImFzY2lpIiwidWNzMlNsaWNlIiwiaGV4U3RyIiwiaGV4Iiwib3V0IiwiYnl0ZTEiLCJieXRlMiIsImNvZGVfdW5pdCIsImZyb21Db2RlUG9pbnQiLCJjb3B5QnVmZmVyIiwic3JjTGVuZ3RoIiwiZGVzdEluZGV4IiwidmFsdWVzIiwid3JpdGUiLCJzdHJpbmciLCJ3cml0ZURvdWJsZUJFIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRmxvYXRMRSIsIndyaXRlSW50OCIsImNoZWNrVmFsdWUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDMyQkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludEJFIiwibWluTWF4QmFzZSIsInBvdyIsImJ5dGVWYWx1ZSIsIndyaXRlSW50TEUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQzMkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50TEUiLCJhbGxvY1Vuc2FmZVNsb3ciLCJ1dGY4Qnl0ZUxlbmd0aCIsImNoYXJBdCIsImZsb29yIiwiYnVmMiIsImNvbmNhdCIsImxpc3QiLCJ0b3RhbExlbmd0aCIsInBvc2l0aW9uIiwiSU5TUEVDVF9NQVhfQllURVMiLCJyZWN1cnNlVGltZXMiLCJjdHgiLCJtYXgiLCJhY3R1YWxNYXgiLCJ0cmltIiwiZXh0cmFzIiwic2hvd0hpZGRlbiIsInJlZHVjZSIsImNyZWF0ZSIsImluc3BlY3QiLCJicmVha0xlbmd0aCIsImNvbXBhY3QiLCJBcnJheUJ1ZmZlcklzVmlldyIsIkJ1ZmZlck1vZHVsZSIsInRyYW5zY29kZSIsIl9zb3VyY2UiLCJfZnJvbUVuY29kaW5nIiwiX3RvRW5jb2RpbmciLCJrTWF4TGVuZ3RoIiwia1N0cmluZ01heExlbmd0aCIsImNvbnN0YW50cyIsIk1BWF9MRU5HVEgiLCJNQVhfU1RSSU5HX0xFTkdUSCIsInNpbmdsZUJ5dGUiLCJiaXRMZW5ndGgiLCJtYXhQb3NpdGl2ZVZhbHVlIiwibWF4VW5zaWduZWRWYWx1ZSIsInJlbGVhc2UiLCJlbmRPZmZzZXQiLCJidWZmZXJXYXJuaW5nQWxyZWFkeUVtaXR0ZWQiLCJub2RlTW9kdWxlc0NoZWNrQ291bnRlciIsImJ1ZmZlcldhcm5pbmciLCJwcm9jZXNzIiwiZW1pdFdhcm5pbmciLCJBTExfUFJPUEVSVElFUyQyIiwiT05MWV9FTlVNRVJBQkxFJDIiLCJCb29sZWFuUHJvdG90eXBlIiwiQm9vbGVhbiIsIkRhdGVQcm90b3R5cGUiLCJEYXRlIiwiRXJyb3JQcm90b3R5cGUiLCJOdW1iZXJQcm90b3R5cGUiLCJNYXBQcm90b3R5cGUiLCJSZWdFeHBQcm90b3R5cGUiLCJSZWdFeHAiLCJTdHJpbmdQcm90b3R5cGUiLCJTZXRQcm90b3R5cGUiLCJTZXQiLCJTeW1ib2xQcm90b3R5cGUiLCJpc0lvcyIsIkVSUl9JTlZBTElEX0FSR19UWVBFIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImJ1aWx0SW5PYmplY3RzIiwiaW5zcGVjdERlZmF1bHRPcHRpb25zIiwic2VhbCIsImRlcHRoIiwiY29sb3JzIiwiY3VzdG9tSW5zcGVjdCIsInNob3dQcm94eSIsIm1heEFycmF5TGVuZ3RoIiwic29ydGVkIiwiZ2V0dGVycyIsImtPYmplY3RUeXBlIiwia0FycmF5VHlwZSIsImtBcnJheUV4dHJhc1R5cGUiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAiLCJzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciIsInN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSIsInN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyU2luZ2xlIiwia2V5U3RyUmVnRXhwIiwibnVtYmVyUmVnRXhwIiwibm9kZU1vZHVsZXNSZWdFeHAiLCJrTWluTGluZUxlbmd0aCIsImtXZWFrIiwia0l0ZXJhdG9yIiwia01hcEVudHJpZXMiLCJtZXRhIiwiZ2V0VXNlck9wdGlvbnMiLCJzdHlsaXplIiwidXNlck9wdGlvbnMiLCJvcHRzIiwiYnVkZ2V0IiwiaW5kZW50YXRpb25MdmwiLCJzZWVuIiwiY3VycmVudERlcHRoIiwic3R5bGl6ZU5vQ29sb3IiLCJvcHRLZXlzIiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiY3VzdG9tIiwib3B0aW9ucyIsImFzc2lnbiIsImJvbGQiLCJpdGFsaWMiLCJ1bmRlcmxpbmUiLCJpbnZlcnNlIiwid2hpdGUiLCJncmV5IiwiYmxhY2siLCJibHVlIiwiY3lhbiIsImdyZWVuIiwibWFnZW50YSIsInJlZCIsInllbGxvdyIsInN0eWxlcyIsInNwZWNpYWwiLCJudW1iZXIiLCJiaWdpbnQiLCJib29sZWFuIiwibnVsbCIsInN5bWJvbCIsImRhdGUiLCJyZWdleHAiLCJtb2R1bGUiLCJhZGRRdW90ZXMiLCJxdW90ZXMiLCJlc2NhcGVGbiIsInN0ckVzY2FwZSIsImVzY2FwZVRlc3QiLCJlc2NhcGVSZXBsYWNlIiwic2luZ2xlUXVvdGUiLCJsYXN0IiwicG9pbnQiLCJzdHlsZVR5cGUiLCJzdHlsZSIsImNvbG9yIiwiZ2V0RW1wdHlGb3JtYXRBcnJheSIsImdldENvbnN0cnVjdG9yTmFtZSIsIl9jdHgiLCJmaXJzdFByb3RvIiwiZGVzY3JpcHRvciIsImdldFByZWZpeCIsInRhZyIsImZhbGxiYWNrIiwiZ2V0S2V5cyIsInN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRDdHhTdHlsZSIsImZpbmRUeXBlZENvbnN0cnVjdG9yIiwiY2hlY2siLCJVaW50OENsYW1wZWRBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsImxhenlOdWxsUHJvdG90eXBlQ2FjaGUiLCJjbGF6eldpdGhOdWxsUHJvdG90eXBlIiwiY2FjaGVkQ2xhc3MiLCJOdWxsUHJvdG90eXBlIiwibm9Qcm90b3R5cGVJdGVyYXRvciIsIm5ld1ZhbCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJmb3JtYXRSYXciLCJ0eXBlZEFycmF5IiwiZm9ybWF0UHJpbWl0aXZlIiwiY29udGV4dCIsIm1heWJlQ3VzdG9tIiwicmV0IiwicmVwZWF0IiwiY2lyY3VsYXIiLCJzaXplIiwiYmFzZSIsImZvcm1hdHRlciIsImJyYWNlcyIsIm5vSXRlcmF0b3IiLCJleHRyYXNUeXBlIiwicHJlZml4IiwiZm9ybWF0QXJyYXkiLCJmb3JtYXRTZXQiLCJmb3JtYXRNYXAiLCJmb3JtYXRUeXBlZEFycmF5IiwiZ2V0SXRlcmF0b3JCcmFjZXMiLCJmb3JtYXRJdGVyYXRvciIsImdldEZ1bmN0aW9uQmFzZSIsInJlZ0V4cCIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsImZvcm1hdEVycm9yIiwibmF0aXZlRXJyb3JQcm9wcyIsImV2ZXJ5IiwiYXJyYXlUeXBlIiwiZm9ybWF0QXJyYXlCdWZmZXIiLCJmb3JtYXROdW1iZXIiLCJmb3JtYXRQcm9taXNlIiwiZm9ybWF0V2Vha1NldCIsImZvcm1hdFdlYWtDb2xsZWN0aW9uIiwiZm9ybWF0V2Vha01hcCIsImdldEJveGVkQmFzZSIsInNwZWNpYWxJdGVyYXRvciIsImNvbnN0cnVjdG9yTmFtZSIsImZvcm1hdFByb3BlcnR5IiwiaGFuZGxlTWF4Q2FsbFN0YWNrU2l6ZSIsInJlZmVyZW5jZSIsInBvcCIsImNvbXBhcmF0b3IiLCJzb3J0Iiwic3BsaWNlIiwicmVzIiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJuZXdMZW5ndGgiLCJmbiIsInZhbHVlT2YiLCJzdGFja0xpbmUiLCJhdFN5bWJvbEluZGV4Iiwic291cmNlUGF0dGVybiIsInN5bWJvbE5hbWUiLCJzb3VyY2VNYXRjaCIsImZpbGVQYXRoIiwibGluZU51bWJlciIsImNvbHVtbiIsIkZpbGVzeXN0ZW0iLCJyZXNvdXJjZXNEaXJlY3RvcnkiLCJwb3MiLCJzdGFja1N0YXJ0IiwibmV3U3RhY2siLCJub2RlTW9kdWxlIiwiZXhlYyIsImluZGVudGF0aW9uIiwiX3ZhbHVlIiwiX3JlY3Vyc2VUaW1lcyIsImV4dHJhIiwiZGVzYyIsImRpZmYiLCJsYWJlbCIsInNwIiwidG1wIiwicHJpbWl0aXZlIiwiZ3JvdXBBcnJheUVsZW1lbnRzIiwib3V0cHV0TGVuZ3RoIiwic2VwYXJhdG9yU3BhY2UiLCJkYXRhTGVuIiwiYXBwcm94Q2hhckhlaWdodHMiLCJhdmVyYWdlQmlhcyIsInNxcnQiLCJiaWFzZWRNYXgiLCJjb2x1bW5zIiwicm91bmQiLCJtYXhMaW5lTGVuZ3RoIiwibGluZU1heExlbmd0aCIsImoiLCJvcmRlciIsInBhZGRpbmciLCJwYWRTdGFydCIsImlzIiwiZm9ybWF0QmlnSW50IiwiZm9ybWF0U3BlY2lhbEFycmF5IiwiZW1wdHlJdGVtcyIsImVuZGluZyIsInZhbExlbiIsImVsZW1lbnRGb3JtYXR0ZXIiLCJ2IiwiayIsImZvcm1hdFNldEl0ZXJJbm5lciIsInN0YXRlIiwiZm9ybWF0TWFwSXRlcklubmVyIiwiX2tleXMiLCJpc0tleVZhbHVlIiwiY3VycmVudEVudHJ5IiwiaXNCZWxvd0JyZWFrTGVuZ3RoIiwibG4iLCJmb3JtYXRXaXRoT3B0aW9ucyIsImZpcnN0RXJyb3JMaW5lIiwiQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSIsInRyeVN0cmluZ2lmeSIsIkpTT04iLCJzdHJpbmdpZnkiLCJhIiwiaW5zcGVjdE9wdGlvbnMiLCJ0ZW1wU3RyIiwibGFzdFBvcyIsIm5leHRDaGFyIiwidGVtcEFyZyIsImNvbnN0ciIsInRlbXBOdW0iLCJ0ZW1wSW50ZWdlciIsInRlbXBGbG9hdCIsInBhcnNlRmxvYXQiLCJub29wIiwibG9nVGltZSIsImxvZ0RhdGEiLCJzdGFydFRpbWUiLCJfdGltZXMiLCJkdXJhdGlvbiIsIm5vdyIsImxvZyIsImtDb2xvckluc3BlY3RPcHRpb25zIiwia05vQ29sb3JJbnNwZWN0T3B0aW9ucyIsInRhYmxlV2FybmVkIiwiY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIiLCJzdHJlYW0iLCJfd3JpdGFibGVTdGF0ZSIsImVycm9yRW1pdHRlZCIsImxpc3RlbmVyQ291bnQiLCJvbmNlIiwiQ29uc29sZSIsInN0ZGVyciIsImlnbm9yZUVycm9ycyIsIl9hcGlNb2R1bGUiLCJzdGRvdXQiLCJfc3Rkb3V0IiwiX3N0ZGVyciIsIl9pZ25vcmVFcnJvcnMiLCJfc3Rkb3V0RXJyb3JIYW5kbGVyIiwiX3N0ZGVyckVycm9ySGFuZGxlciIsIl9jb2xvck1vZGUiLCJjb2xvck1vZGUiLCJfaW5zcGVjdE9wdGlvbnMiLCJfY291bnRzIiwiX2dyb3VwSW5kZW50IiwiX3dyaXRlVG9Db25zb2xlIiwibGV2ZWwiLCJ1c2VTdGRFcnIiLCJlcnJvckhhbmRsZXIiLCJyZW1vdmVMaXN0ZW5lciIsImluZm8iLCJ3YXJuIiwiZGVidWciLCJjbGVhciIsImdyb3VwIiwiZ3JvdXBFbmQiLCJkaXIiLCJjb3VudCIsImNvdW50UmVzZXQiLCJkZWxldGUiLCJ0aW1lIiwidGltZUVuZCIsIndhcm5lZCIsInRpbWVMb2ciLCJ0YWJsZSIsImRpcnhtbCIsImdyb3VwQ29sbGFwc2VkIiwiZ2xvYmFsQ29uc29sZSIsIkFQSSIsImNvbnNvbGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJwcm9wZXJ0aWVzIiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20iLCJtZXJnZWRPcHRpb25zIiwiZGF0ZVN0eWxlIiwibG9jYWxlIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwidGltZVN0eWxlIiwidG9Mb2NhbGVTdHJpbmciLCJtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tIiwic3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIiwic3VwcG9ydGVkTG9jYWxlcyIsIlRpQ29sbGF0b3IiLCJMb2NhbGUiLCJnZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXMiLCJjb2xsYXRvciIsIkNvbGxhdG9yIiwiYmluZCIsInN1cHBvcnRlZExvY2FsZXNPZiIsIlRpRGF0ZVRpbWVGb3JtYXQiLCJnZXRTdXBwb3J0ZWREYXRlVGltZUZvcm1hdExvY2FsZXMiLCJUaU51bWJlckZvcm1hdCIsImdldFN1cHBvcnRlZE51bWJlckZvcm1hdExvY2FsZXMiLCJOdW1iZXJGb3JtYXQiLCJnZXRDYW5vbmljYWxMb2NhbGVzIiwibG9jYWxlQ29tcGFyZSIsImNvbXBhcmVTdHJpbmciLCJsb2NhbGVzIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJtYWtlTG93ZXJDYXNlIiwidG9Mb2NhbGVVcHBlckNhc2UiLCJtYWtlVXBwZXJDYXNlIiwiYmluZGluZ3MiLCJyZWRpcmVjdHMiLCJpc0hpamFja2FibGVNb2R1bGVJZCIsInBhdGgiLCJmaXJzdENoYXIiLCJvcmlnaW5hbFJlcXVpcmUiLCJyZXF1aXJlIiwibW9kdWxlSWQiLCJvcmlnaW5hbE1vZHVsZVJlcXVpcmUiLCJNb2R1bGUiLCJyZWdpc3RlciIsImJpbmRpbmciLCJyZWRpcmVjdCIsImZpbGVwYXRoIiwiYXJyYXlCdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkhFWF8zX1JFR0VYIiwiSEVYXzRfUkVHRVgiLCJIRVhfNl9SRUdFWCIsIkhFWF84X1JFR0VYIiwicGFkZGVkSGV4IiwiaW50ZWdlciIsIkNvbG9yIiwiciIsImciLCJiIiwiYWxwaGEiLCJpc09wYXF1ZSIsImFscGhhSGV4IiwiX3RvUkdCSGV4U3RyaW5nIiwidG9SR0JBSGV4U3RyaW5nIiwidG9BUkdCSGV4U3RyaW5nIiwidG9IZXgiLCJ0b1JHQkFTdHJpbmciLCJ0b0ZpeGVkIiwiZnJvbUhleDZTdHJpbmciLCJzdGFydEluZGV4IiwiZnJvbUhleDhTdHJpbmciLCJmcm9tU2VtYW50aWNDb2xvcnNFbnRyeSIsImVudHJ5IiwiaGFkQWxwaGEiLCJtIiwiVUkiLCJrcm9sbCIsIlRpdGFuaXVtIiwidXNlckludGVyZmFjZVN0eWxlIiwiVVNFUl9JTlRFUkZBQ0VfU1RZTEVfREFSSyIsIlNFTUFOVElDX0NPTE9SX1RZUEVfREFSSyIsIlNFTUFOVElDX0NPTE9SX1RZUEVfTElHSFQiLCJjb2xvcnNldCIsImZldGNoU2VtYW50aWNDb2xvciIsImNvbG9yTmFtZSIsImNvbG9yc2V0RmlsZSIsImdldEZpbGUiLCJleGlzdHMiLCJwYXJzZSIsInJlYWQiLCJ0ZXh0Iiwic3lzdGVtQ29sb3JJZCIsIkFuZHJvaWQiLCJSIiwicmVzb3VyY2VDb2xvciIsImdldENvbG9yUmVzb3VyY2UiLCJzZW1hbnRpY0NvbG9yVHlwZSIsImNvbG9yT2JqIiwiX2FkZExpc3RlbmVyIiwiZW1pdHRlciIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwicHJlcGVuZCIsIl9ldmVudHNUb0xpc3RlbmVycyIsIm5ld0xpc3RlbmVyIiwiZW1pdCIsImV2ZW50TGlzdGVuZXJzIiwiZ2V0TWF4TGlzdGVuZXJzIiwidyIsIm9uY2VXcmFwIiwid3JhcHBlciIsIndyYXBwZWRGdW5jIiwid3JhcHBlclRoaXMiLCJib3VuZCIsIkV2ZW50RW1pdHRlciIsIl9tYXhMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImZvdW5kSW5kZXgiLCJ1bndyYXBwZWRMaXN0ZW5lciIsIm9mZiIsImV2ZW50TmFtZXMiLCJsaXN0ZW5lcnMiLCJyYXciLCJsIiwicmF3TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsInNldE1heExpc3RlbmVycyIsIm4iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJuYW1lcyIsImFzc2VydEFyZ3VtZW50VHlwZSIsInR5cGVuYW1lIiwic3RhbmRhcmRpemVBcmNoIiwib3JpZ2luYWwiLCJwcm9jZXNzJDEiLCJhYm9ydCIsImFyY2giLCJhcmNoaXRlY3R1cmUiLCJhcmd2IiwiY2hhbm5lbCIsImNoZGlyIiwiY29uZmlnIiwiY29ubmVjdGVkIiwiY3B1VXNhZ2UiLCJ1c2VyIiwic3lzdGVtIiwiY3dkIiwiX19kaXJuYW1lIiwiYXNzZXRzIiwianNvbiIsInJlYWRBc3NldCIsImRlcGxveURhdGEiLCJkZWJ1Z2dlclBvcnQiLCJkaXNjb25uZWN0IiwiZGxvcGVuIiwid2FybmluZyIsImN0b3IiLCJkZXRhaWwiLCJpc0RlcHJlY2F0aW9uIiwibm9EZXByZWNhdGlvbiIsInRocm93RGVwcmVjYXRpb24iLCJsb2FkRW52SnNvbiIsImpzb25GaWxlIiwiZW52IiwiZXhlY0FyZ3YiLCJleGVjUGF0aCIsImV4aXQiLCJleGl0Q29kZSIsInBpZCIsInBsYXRmb3JtIiwicHBpZCIsImlzVFRZIiwiY2h1bmsiLCJjYWxsYmFjayIsInRpdGxlIiwiQXBwIiwidHJhY2VEZXByZWNhdGlvbiIsInVtYXNrIiwidXB0aW1lIiwiZGlmZk1zIiwidmVyc2lvbiIsInZlcnNpb25zIiwibW9kdWxlcyIsInY4IiwianNjIiwiV0FSTklOR19QUkVGSVgiLCJ1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrIiwiaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2siLCJzZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjayIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImJhY2t0cmFjZSIsImZpbGVOYW1lIiwic291cmNlTmFtZSIsImNvbHVtbk51bWJlciIsImxpbmVPZmZzZXQiLCJDYWxsYmFja1dpdGhBcmdzIiwiZnVuYyIsInJ1biIsImZ1biIsInRpY2tRdWV1ZSIsImltbWVkaWF0ZVF1ZXVlIiwiZHJhaW5pbmdUaWNrUXVldWUiLCJkcmFpblF1ZXVlc1RpbWVvdXQiLCJkcmFpblRpY2tRdWV1ZSIsInRpY2siLCJzaGlmdCIsImRyYWluUXVldWVzIiwiaW1tZWRpYXRlc1JlbWFpbmluZyIsInByb2Nlc3NJbW1lZGlhdGVRdWV1ZSIsInNldFRpbWVvdXQiLCJpbW1lZGlhdGVEZWFkbGluZSIsImltbWVkaWF0ZSIsIm5leHRUaWNrIiwic2V0SW1tZWRpYXRlIiwiY2xlYXJJbW1lZGlhdGUiLCJGT1JXQVJEX1NMQVNIIiwiQkFDS1dBUkRfU0xBU0giLCJpc1dpbmRvd3NEZXZpY2VOYW1lIiwiY2hhckNvZGUiLCJpc0Fic29sdXRlIiwiaXNQb3NpeCIsInRoaXJkQ2hhciIsImRpcm5hbWUiLCJmcm9tSW5kZXgiLCJoYWRUcmFpbGluZyIsImxhc3RJbmRleE9mIiwiZXh0bmFtZSIsImVuZEluZGV4IiwibGFzdEluZGV4V2luMzJTZXBhcmF0b3IiLCJjaGFyIiwiYmFzZW5hbWUiLCJleHQiLCJsYXN0Q2hhckNvZGUiLCJub3JtYWxpemUiLCJpc1dpbmRvd3MiLCJoYWRMZWFkaW5nIiwiaXNVTkMiLCJwYXJ0cyIsInNlZ21lbnQiLCJub3JtYWxpemVkIiwiYXNzZXJ0U2VnbWVudCIsImpvaW4kMSIsInBhdGhzIiwicmVzb2x2ZWQiLCJoaXRSb290IiwicmVsYXRpdmUiLCJ0byIsInVwQ291bnQiLCJyZW1haW5pbmdQYXRoIiwicm9vdCIsImJhc2VMZW5ndGgiLCJ0b1N1YnRyYWN0IiwiZmlyc3RDaGFyQ29kZSIsInRoaXJkQ2hhckNvZGUiLCJmb3JtYXQkMSIsInBhdGhPYmplY3QiLCJ0b05hbWVzcGFjZWRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiV2luMzJQYXRoIiwic2VwIiwiZGVsaW1pdGVyIiwiUG9zaXhQYXRoIiwid2luMzIiLCJwb3NpeCIsIlBvc2l4Q29uc3RhbnRzIiwiVVZfVURQX1JFVVNFQUREUiIsImVycm5vIiwiRTJCSUciLCJFQUNDRVMiLCJFQUREUklOVVNFIiwiRUFERFJOT1RBVkFJTCIsIkVBRk5PU1VQUE9SVCIsIkVBR0FJTiIsIkVBTFJFQURZIiwiRUJBREYiLCJFQkFETVNHIiwiRUJVU1kiLCJFQ0FOQ0VMRUQiLCJFQ0hJTEQiLCJFQ09OTkFCT1JURUQiLCJFQ09OTlJFRlVTRUQiLCJFQ09OTlJFU0VUIiwiRURFQURMSyIsIkVERVNUQUREUlJFUSIsIkVET00iLCJFRFFVT1QiLCJFRVhJU1QiLCJFRkFVTFQiLCJFRkJJRyIsIkVIT1NUVU5SRUFDSCIsIkVJRFJNIiwiRUlMU0VRIiwiRUlOUFJPR1JFU1MiLCJFSU5UUiIsIkVJTlZBTCIsIkVJTyIsIkVJU0NPTk4iLCJFSVNESVIiLCJFTE9PUCIsIkVNRklMRSIsIkVNTElOSyIsIkVNU0dTSVpFIiwiRU1VTFRJSE9QIiwiRU5BTUVUT09MT05HIiwiRU5FVERPV04iLCJFTkVUUkVTRVQiLCJFTkVUVU5SRUFDSCIsIkVORklMRSIsIkVOT0JVRlMiLCJFTk9EQVRBIiwiRU5PREVWIiwiRU5PRU5UIiwiRU5PRVhFQyIsIkVOT0xDSyIsIkVOT0xJTksiLCJFTk9NRU0iLCJFTk9NU0ciLCJFTk9QUk9UT09QVCIsIkVOT1NQQyIsIkVOT1NSIiwiRU5PU1RSIiwiRU5PU1lTIiwiRU5PVENPTk4iLCJFTk9URElSIiwiRU5PVEVNUFRZIiwiRU5PVFNPQ0siLCJFTk9UU1VQIiwiRU5PVFRZIiwiRU5YSU8iLCJFT1BOT1RTVVBQIiwiRU9WRVJGTE9XIiwiRVBFUk0iLCJFUElQRSIsIkVQUk9UTyIsIkVQUk9UT05PU1VQUE9SVCIsIkVQUk9UT1RZUEUiLCJFUkFOR0UiLCJFUk9GUyIsIkVTUElQRSIsIkVTUkNIIiwiRVNUQUxFIiwiRVRJTUUiLCJFVElNRURPVVQiLCJFVFhUQlNZIiwiRVdPVUxEQkxPQ0siLCJFWERFViIsInNpZ25hbHMiLCJTSUdIVVAiLCJTSUdJTlQiLCJTSUdRVUlUIiwiU0lHSUxMIiwiU0lHVFJBUCIsIlNJR0FCUlQiLCJTSUdJT1QiLCJTSUdCVVMiLCJTSUdGUEUiLCJTSUdLSUxMIiwiU0lHVVNSMSIsIlNJR1NFR1YiLCJTSUdVU1IyIiwiU0lHUElQRSIsIlNJR0FMUk0iLCJTSUdURVJNIiwiU0lHQ0hMRCIsIlNJR0NPTlQiLCJTSUdTVE9QIiwiU0lHVFNUUCIsIlNJR1RUSU4iLCJTSUdUVE9VIiwiU0lHVVJHIiwiU0lHWENQVSIsIlNJR1hGU1oiLCJTSUdWVEFMUk0iLCJTSUdQUk9GIiwiU0lHV0lOQ0giLCJTSUdJTyIsIlNJR0lORk8iLCJTSUdTWVMiLCJwcmlvcml0eSIsIlBSSU9SSVRZX0xPVyIsIlBSSU9SSVRZX0JFTE9XX05PUk1BTCIsIlBSSU9SSVRZX05PUk1BTCIsIlBSSU9SSVRZX0FCT1ZFX05PUk1BTCIsIlBSSU9SSVRZX0hJR0giLCJQUklPUklUWV9ISUdIRVNUIiwiT1MiLCJFT0wiLCJjcHVzIiwicHJvY2Vzc29yQ291bnQiLCJhcnJheSIsIm1vZGVsIiwic3BlZWQiLCJ0aW1lcyIsIm5pY2UiLCJzeXMiLCJpZGxlIiwiaXJxIiwiZW5kaWFubmVzcyIsImdldE5hdGl2ZUJ5dGVPcmRlciIsIkxJVFRMRV9FTkRJQU4iLCJmcmVlbWVtIiwiYXZhaWxhYmxlTWVtb3J5IiwiZ2V0UHJpb3JpdHkiLCJob21lZGlyIiwiYXBwbGljYXRpb25EYXRhRGlyZWN0b3J5IiwiaG9zdG5hbWUiLCJhZGRyZXNzIiwibG9hZGF2ZyIsIm5ldHdvcmtJbnRlcmZhY2VzIiwic2V0UHJpb3JpdHkiLCJ0bXBkaXIiLCJ0ZW1wRGlyZWN0b3J5IiwidG90YWxtZW0iLCJ0b3RhbE1lbW9yeSIsInVzZXJJbmZvIiwidWlkIiwiZ3VpZCIsInVzZXJuYW1lIiwic2hlbGwiLCJ0dHkiLCJpc2F0dHkiLCJSZWFkU3RyZWFtIiwiV3JpdGVTdHJlYW0iLCJNT05USFMiLCJ1dGlsIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc051bWJlciIsImlzUHJpbWl0aXZlIiwiaXNTdHJpbmciLCJpc1N5bWJvbCIsImlzVW5kZWZpbmVkIiwiZ2V0SG91cnMiLCJnZXRNaW51dGVzIiwiZ2V0U2Vjb25kcyIsImdldERhdGUiLCJnZXRNb250aCIsInByaW50IiwicHV0cyIsImluaGVyaXRzIiwic3VwZXJDb25zdHJ1Y3RvciIsInByb21pc2lmeSIsIndyYXBwZWQiLCJjYWxsYmFja2lmeSIsInByb21pc2UiLCJ0aGVuIiwiY2F0Y2giLCJ3cmFwcGVkRXJyb3IiLCJyZWFzb24iLCJkZXByZWNhdGUiLCJub29wJDEiLCJkZWJ1Z2xvZyIsIkRFRkFVTFRfTUVTU0FHRVMiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3RFcXVhbCIsImRlZXBFcXVhbCIsImVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwibm90U3RyaWN0RXF1YWwiLCJub3REZWVwRXF1YWwiLCJub3RFcXVhbCIsIkNPTVBBUkVfVFlQRSIsIlNUUklDVE5FU1MiLCJTdHJpY3QiLCJMb29zZSIsIkFzc2VydGlvbkVycm9yIiwib3BlcmF0b3IiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiYXNzZXJ0JDEiLCJvayIsInRocm93RXJyb3IiLCJjb21wYXJlTWFwcyIsInN0cmljdG5lc3MiLCJyZWZlcmVuY2VzIiwibG9vc2VDaGVja3MiLCJhZGQiLCJleHBlY3RlZEtleSIsImV4cGVjdGVkVmFsdWUiLCJmb3VuZCIsImNvbXBhcmVTZXRzIiwib2JqZWN0IiwiYWN0dWFsVGFnIiwiZXhwZWN0ZWRUYWciLCJhY3R1YWxQcm90b3R5cGUiLCJleHBlY3RlZFByb3RvdHlwZSIsImNvbXBhcmlzb24iLCJmbGFncyIsImFjdHVhbEtleXMiLCJleHBlY3RlZEtleXMiLCJhY3R1YWxTeW1ib2xzIiwiZXhwZWN0ZWRTeW1ib2xzIiwiYWN0dWFsSXNFbnVtZXJhYmxlIiwiZXhwZWN0ZWRJc0VudW1lcmFibGUiLCJtZW1vaXplZEFjdHVhbCIsIm1lbW9pemVkRXhwZWN0ZWQiLCJOT19FWENFUFRJT04iLCJleGVjdXRlIiwiaXNQcm9taXNlTGlrZSIsImV4ZWN1dGVQcm9taXNlIiwiZm5UeXBlIiwidGhyb3dzIiwiY2hlY2tFcnJvciIsInJlamVjdHMiLCJhc3luY0ZuIiwiZG9lc05vdFRocm93IiwiZG9lc05vdFJlamVjdCIsImlzUHJvdG90eXBlT2YiLCJpZkVycm9yIiwic3RyaWN0IiwiU3RyaW5nRGVjb2RlciIsIl9pbXBsIiwiVXRmOFN0cmluZ0RlY29kZXIiLCJVdGYxNlN0cmluZ0RlY29kZXIiLCJCYXNlNjRTdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlckltcGwiLCJieXRlQ291bnQiLCJjaGFyTGVuZ3RoIiwiTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwiLCJieXRlc1BlckNoYXIiLCJpbmNvbXBsZXRlIiwiX2NoZWNrSW5jb21wbGV0ZUJ5dGVzIiwiX2J1ZmZlciIsIl9pbmNvbXBsZXRlRW5kIiwiX2luY29tcGxldGVCdWZmZXJFbXB0aWVkIiwibGVmdCIsImJ5dGVzQ29waWVkIiwiaW5jb21wbGV0ZUNoYXJEYXRhIiwiYnl0ZXNOZWVkZWQiLCJpbmNvbXBsZXRlQ2hhckluZGV4IiwiYnl0ZXNUb0NvcHkiLCJjaGVja0NoYXJMZW5ndGhGb3JVVEY4IiwibW9kdWxvIiwiYnl0ZSIsIlN0cmluZ0RlY29kZXIkMSIsInByaW50ZWRXYXJuaW5ncyIsIm9uZVRpbWVXYXJuaW5nIiwidW5zdXBwb3J0ZWROb29wIiwibW9kdWxlTmFtZSIsImZxbiIsImFzeW5jVW5zdXBwb3J0ZWROb29wIiwibWF5YmVDYWxsYmFjayIsIkNPUFlfRklMRV9DSFVOS19TSVpFIiwiZmlsZURlc2NyaXB0b3JzIiwiZmlsZURlc2NyaXB0b3JDb3VudCIsIkZMQUdTX1RPX1RJX01PREUiLCJNT0RFX0FQUEVORCIsIk1PREVfV1JJVEUiLCJwZXJtaXNzaW9uRGVuaWVkIiwic3lzY2FsbCIsIm1ha2VFcnJvciIsIm5vU3VjaEZpbGUiLCJmaWxlQWxyZWFkeUV4aXN0cyIsIm5vdEFEaXJlY3RvcnkiLCJkaXJlY3RvcnlOb3RFbXB0eSIsImlsbGVnYWxPcGVyYXRpb25PbkFEaXJlY3RvcnkiLCJmcyIsIk9fUkRPTkxZIiwiT19XUk9OTFkiLCJPX1JEV1IiLCJTX0lGTVQiLCJTX0lGUkVHIiwiU19JRkRJUiIsIlNfSUZDSFIiLCJTX0lGQkxLIiwiU19JRklGTyIsIlNfSUZMTksiLCJTX0lGU09DSyIsIk9fQ1JFQVQiLCJPX0VYQ0wiLCJPX05PQ1RUWSIsIk9fVFJVTkMiLCJPX0FQUEVORCIsIk9fRElSRUNUT1JZIiwiT19OT0ZPTExPVyIsIk9fU1lOQyIsIk9fRFNZTkMiLCJPX1NZTUxJTksiLCJPX05PTkJMT0NLIiwiU19JUldYVSIsIlNfSVJVU1IiLCJTX0lXVVNSIiwiU19JWFVTUiIsIlNfSVJXWEciLCJTX0lSR1JQIiwiU19JV0dSUCIsIlNfSVhHUlAiLCJTX0lSV1hPIiwiU19JUk9USCIsIlNfSVdPVEgiLCJTX0lYT1RIIiwiRl9PSyIsIlJfT0siLCJXX09LIiwiWF9PSyIsIlVWX0ZTX0NPUFlGSUxFX0VYQ0wiLCJDT1BZRklMRV9FWENMIiwiU3RhdHMiLCJfZmlsZSIsImRldiIsImlubyIsIm5saW5rIiwiZ2lkIiwicmRldiIsImJsa3NpemUiLCJibG9ja3MiLCJhdGltZU1zIiwibXRpbWVNcyIsImN0aW1lTXMiLCJiaXJ0aHRpbWVNcyIsImF0aW1lIiwibXRpbWUiLCJjdGltZSIsImJpcnRodGltZSIsImdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlIiwiY3JlYXRlZEF0IiwibW9kaWZpZWRBdCIsImNlaWwiLCJpc0ZpbGUiLCJpc0RpcmVjdG9yeSIsImlzQmxvY2tEZXZpY2UiLCJpc0NoYXJhY3RlckRldmljZSIsImlzU3ltYm9saWNMaW5rIiwic3ltYm9saWNMaW5rIiwiaXNGSUZPIiwiaXNTb2NrZXQiLCJhY2Nlc3MiLCJhY2Nlc3NTeW5jIiwiZmlsZUhhbmRsZSIsImV4ZWN1dGFibGUiLCJhcHBlbmRGaWxlIiwiZmlsZSIsIm1lcmdlRGVmYXVsdE9wdGlvbnMiLCJmbGFnIiwid3JpdGVGaWxlIiwiYXBwZW5kRmlsZVN5bmMiLCJ3cml0ZUZpbGVTeW5jIiwiY2htb2QiLCJjaG1vZFN5bmMiLCJjaG93biIsImNob3duU3luYyIsImZkIiwiY2xvc2VTeW5jIiwic3RyZWFtRm9yRGVzY3JpcHRvciIsImNvcHlGaWxlIiwic3JjRmlsZSIsInNyY1N0cmVhbSIsIm9wZW4iLCJkZXN0RmlsZSIsImRlc3RTdHJlYW0iLCJwaXBlIiwiY29weUZpbGVTeW5jIiwiZXhpc3RzU3luYyIsImZjaG1vZCIsImZjaG1vZFN5bmMiLCJmY2hvd24iLCJmY2hvd25TeW5jIiwiZmRhdGFzeW5jIiwiZmRhdGFzeW5jU3luYyIsImZzdGF0Iiwic3RhdHMiLCJmc3RhdFN5bmMiLCJfb3B0aW9ucyIsInBhdGhGb3JGaWxlRGVzY3JpcHRvciIsInN0YXRTeW5jIiwibHN0YXQiLCJzdGF0IiwibHN0YXRTeW5jIiwibWtkaXIiLCJyZWN1cnNpdmUiLCJta2RpclN5bmMiLCJ0aUZpbGUiLCJjcmVhdGVEaXJlY3RvcnkiLCJta2R0ZW1wIiwidHJ5TWtkdGVtcCIsImdlbmVyYXRlZCIsInJhbmRvbUNoYXJhY3RlcnMiLCJta2R0ZW1wU3luYyIsInJldHJ5Q291bnQiLCJNQVhfUkVUUklFUyIsImZpbGVEZXNjcmlwdG9yIiwib3BlblN5bmMiLCJfbW9kZSIsImNyZWF0ZUZpbGUiLCJwYXJlbnQiLCJ0aU1vZGUiLCJjcmVhdGVGaWxlRGVzY3JpcHRvciIsInRpRmlsZVN0cmVhbSIsInJlYWRPYmoiLCJzdWNjZXNzIiwiYnl0ZXNQcm9jZXNzZWQiLCJyZWFkU3luYyIsIl9wb3NpdGlvbiIsImZpbGVTdHJlYW0iLCJyZWFkZGlyIiwicmVhZGRpclN5bmMiLCJ3aXRoRmlsZVR5cGVzIiwibGlzdGluZyIsImdldERpcmVjdG9yeUxpc3RpbmciLCJyZWFkRmlsZVBvc3RPcGVuIiwiZmlsZVNpemUiLCJzb3VyY2VTdHJlYW0iLCJyZWFkQWxsT2JqIiwicmVhZEZpbGUiLCJ3YXNGaWxlRGVzY3JpcHRvciIsImhhbmRsZUJ1ZmZlciIsImVuY29kZUJ1ZmZlciIsInJlYWRGaWxlU3luYyIsInJlYWxwYXRoIiwicmVzdWx0RXhpc3RzIiwic2VnbWVudHMiLCJwYXJ0aWFsRmlsZVBhdGgiLCJ0cnlQYXRoIiwicGFydGlhbEV4aXN0cyIsIm5hdGl2ZSIsInJlYWxwYXRoU3luYyIsInJlbmFtZSIsIm9sZFBhdGgiLCJuZXdQYXRoIiwicmVuYW1lU3luYyIsInRlbXBQYXRoIiwibW92ZSIsInVubGluayIsIl9lcnIiLCJ0bXBGaWxlIiwicm1kaXIiLCJybWRpclN5bmMiLCJkZWxldGVEaXJlY3RvcnkiLCJzdWJGaWxlcyIsInN5bWxpbmsiLCJzeW1saW5rU3luYyIsInRydW5jYXRlIiwiYnl0ZXNSZWFkIiwidHJ1bmNhdGVTeW5jIiwidW5saW5rU3luYyIsImRlbGV0ZUZpbGUiLCJ1bndhdGNoRmlsZSIsInV0aW1lcyIsInV0aW1lc1N5bmMiLCJ3YXRjaCIsIndhdGNoRmlsZSIsImZpbmlzaCIsIndyaXRlU3luYyIsIndyaXRlVGlGaWxlU3RyZWFtIiwid3JpdGVPYmoiLCJ3cml0ZUJ1ZmZlciIsIndyaXRlU3RyaW5nIiwid3JpdGVCdWZmZXJTeW5jIiwid3JpdGVTdHJpbmdTeW5jIiwiRmlsZURlc2NyaXB0b3IiLCJwaXBlVmlhV3JpdGVTdHJlYW0iLCJ3cml0ZVN0cmVhbSIsInBvaW50ZXIiLCJkZWZhdWx0cyIsIm9wdGlvbnNUeXBlIiwibWVyZ2VkIiwiY2IiLCJfZW5jb2RpbmciLCJyYW5kb20iLCJSZWFkYWJsZSIsInJlYWRhYmxlIiwiX3JlYWQiLCJkZXN0cm95IiwiX2Rlc3Ryb3kiLCJXcml0YWJsZSIsImlzRHVwbGV4IiwiRHVwbGV4IiwiX3dyaXRlIiwid3JpdGV2IiwiX3dyaXRldiIsImZpbmFsIiwiX2ZpbmFsIiwiYWxsb3dIYWxmT3BlbiIsIndyaXRhYmxlTWV0aG9kcyIsIm1ldGhvZCIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybSIsIl90cmFuc2Zvcm0iLCJmbHVzaCIsIl9mbHVzaCIsImZldGNoU2NyaXB0c0Zyb21Kc29uIiwiSlNPTl9GSUxFX05BTUUiLCJzZXR0aW5ncyIsInNjcmlwdHMiLCJmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5IiwicmVzb3VyY2VEaXJlY3RvcnkiLCJyZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGgiLCJuYXRpdmVQYXRoIiwiYm9vdHN0cmFwU2NyaXB0cyIsImxvYWRGcm9tIiwiZmlsZU5hbWVBcnJheSIsInNlYXJjaCIsImJvb3RzdHJhcFBhdGgiLCJsb2FkQXN5bmMiLCJmaW5pc2hlZCIsImxvYWRCb290c3RyYXBTY3JpcHRzIiwiYm9vdHN0cmFwSW5kZXgiLCJkb0xvYWQiLCJib290c3RyYXAiLCJvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkIiwiZmlyZUV2ZW50Il0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxJQUFJQSxjQUFjLEdBQUcsT0FBT0MsVUFBUCxLQUFzQixXQUF0QixHQUFvQ0EsVUFBcEMsR0FBaUQsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixHQUFnQ0EsTUFBaEMsR0FBeUMsT0FBT0MsSUFBUCxLQUFnQixXQUFoQixHQUE4QkEsSUFBOUIsR0FBcUMsRUFBN0w7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBOztBQUVBQyxNQUFNLENBQUNDLGdCQUFQLENBQXdCTixjQUF4QixFQUF3QztBQUN0QyxnQkFBYztBQUNaTyxJQUFBQSxLQUFLLEVBQUUsSUFESztBQUVaQyxJQUFBQSxRQUFRLEVBQUUsS0FGRSxFQUR3Qjs7QUFLdEMsWUFBVTtBQUNSRCxJQUFBQSxLQUFLLEVBQUUsS0FEQztBQUVSQyxJQUFBQSxRQUFRLEVBQUUsS0FGRixFQUw0Qjs7QUFTdENDLEVBQUFBLGdCQUFnQixFQUFFO0FBQ2hCRixJQUFBQSxLQUFLLEVBQUVHLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZQyxZQURIO0FBRWhCSixJQUFBQSxRQUFRLEVBQUUsS0FGTSxFQVRvQjs7QUFhdENLLEVBQUFBLGdCQUFnQixFQUFFO0FBQ2hCTixJQUFBQSxLQUFLLEVBQUVHLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZRyxZQURIO0FBRWhCTixJQUFBQSxRQUFRLEVBQUUsS0FGTSxFQWJvQjs7QUFpQnRDTyxFQUFBQSxnQkFBZ0IsRUFBRTtBQUNoQlIsSUFBQUEsS0FBSyxFQUFFRyxFQUFFLENBQUNDLFFBQUgsQ0FBWUssWUFESDtBQUVoQlIsSUFBQUEsUUFBUSxFQUFFLEtBRk0sRUFqQm9CLEVBQXhDOzs7O0FBdUJBO0FBQ0EsTUFBTVMsY0FBYyxHQUFHLDZCQUF2QjtBQUNBLE1BQU1DLG1CQUFtQixHQUFHQyxNQUFNLENBQUNDLEdBQVAsQ0FBVyw0QkFBWCxDQUE1QjtBQUNBLE1BQU1DLFFBQVEsR0FBR0YsTUFBTSxDQUFDQyxHQUFQLENBQVcsMEJBQVgsQ0FBakI7QUFDQSxNQUFNRSxXQUFXLEdBQUcsaUJBQXBCLEMsQ0FBdUM7O0FBRXZDLFNBQVNDLFlBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCO0FBQ3pCLFNBQU9BLEdBQUcsQ0FBQ0MsT0FBSixDQUFZSCxXQUFaLEVBQXlCLEVBQXpCLENBQVA7QUFDRDtBQUNELFNBQVNJLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQU9DLGFBQWEsQ0FBQ0QsQ0FBRCxDQUFiLElBQW9CQSxDQUFDLFlBQVlFLEtBQXhDO0FBQ0Q7QUFDRCxJQUFJQyxrQkFBSjs7QUFFQSxNQUFNQyxlQUFOLFNBQThCRixLQUE5QixDQUFvQzs7QUFFcENFLGVBQWUsQ0FBQ0MsaUJBQWhCLEdBQW9DLENBQUNDLEdBQUQsRUFBTUMsS0FBTixLQUFnQkEsS0FBcEQ7O0FBRUFILGVBQWUsQ0FBQ0ksZUFBaEIsR0FBa0NDLFFBQWxDO0FBQ0EsU0FBU0MsbUJBQVQsR0FBK0I7QUFDN0IsTUFBSVAsa0JBQWtCLEtBQUtRLFNBQTNCLEVBQXNDO0FBQ3BDUixJQUFBQSxrQkFBa0IsR0FBRyxNQUFNLElBQUlDLGVBQUosR0FBc0JRLEtBQWpEO0FBQ0Q7O0FBRUQsTUFBSUEsS0FBSyxHQUFHVCxrQkFBa0IsRUFBOUIsQ0FMNkIsQ0FLSzs7QUFFbEMsTUFBSSxPQUFPUyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFVBQU1DLFdBQVcsR0FBRyxFQUFwQjtBQUNBLFVBQU1DLEtBQUssR0FBR0YsS0FBSyxDQUFDRyxLQUFOLENBQVksSUFBWixDQUFkOztBQUVBLFNBQUssTUFBTUMsSUFBWCxJQUFtQkYsS0FBbkIsRUFBMEI7QUFDeEIsWUFBTUcsUUFBUSxHQUFHRCxJQUFJLENBQUNFLEtBQUwsQ0FBVyx1QkFBWCxDQUFqQjs7QUFFQSxVQUFJRCxRQUFKLEVBQWM7QUFDWixjQUFNRSxRQUFRLEdBQUdGLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWW5CLE9BQVosQ0FBb0IsU0FBcEIsRUFBK0IsRUFBL0IsQ0FBakI7QUFDQWUsUUFBQUEsV0FBVyxDQUFDTyxJQUFaLENBQWlCO0FBQ2ZDLFVBQUFBLFdBQVcsRUFBRSxNQUFNRixRQURKLEVBQWpCOztBQUdEO0FBQ0Y7O0FBRURQLElBQUFBLEtBQUssR0FBR0MsV0FBUjtBQUNELEdBdkI0QixDQXVCM0I7QUFDRjs7O0FBR0EsTUFBSVMsS0FBSyxDQUFDQyxPQUFOLENBQWNYLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixTQUFLLE1BQU1ZLEtBQVgsSUFBb0JaLEtBQXBCLEVBQTJCO0FBQ3pCLFlBQU1PLFFBQVEsR0FBR0ssS0FBSyxDQUFDSCxXQUFOLEVBQWpCLENBRHlCLENBQ2E7QUFDdEM7O0FBRUEsVUFBSSxDQUFDLFNBQVNJLElBQVQsQ0FBY04sUUFBZCxDQUFMLEVBQThCO0FBQzVCO0FBQ0Q7O0FBRUQsYUFBTzdCLGNBQWMsQ0FBQ21DLElBQWYsQ0FBb0JOLFFBQXBCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sS0FBUDtBQUNEO0FBQ0QsU0FBU08sSUFBVCxDQUFjQyxNQUFkLEVBQXNCQyxTQUF0QixFQUFpQztBQUMvQixNQUFJL0IsR0FBRyxHQUFHLEVBQVY7O0FBRUEsTUFBSThCLE1BQU0sQ0FBQ0UsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUN2QixVQUFNQyxTQUFTLEdBQUdILE1BQU0sQ0FBQ0UsTUFBUCxHQUFnQixDQUFsQzs7QUFFQSxTQUFLLElBQUlFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELFNBQXBCLEVBQStCQyxDQUFDLEVBQWhDLEVBQW9DO0FBQ2xDO0FBQ0FsQyxNQUFBQSxHQUFHLElBQUk4QixNQUFNLENBQUNJLENBQUQsQ0FBYjtBQUNBbEMsTUFBQUEsR0FBRyxJQUFJK0IsU0FBUDtBQUNEOztBQUVEL0IsSUFBQUEsR0FBRyxJQUFJOEIsTUFBTSxDQUFDRyxTQUFELENBQWI7QUFDRDs7QUFFRCxTQUFPakMsR0FBUDtBQUNEO0FBQ0QsU0FBU21DLFdBQVQsQ0FBcUJDLENBQXJCLEVBQXdCO0FBQ3RCLFNBQU8sWUFBWTtBQUNqQixXQUFPQSxDQUFDLENBQUNDLElBQUYsQ0FBT0MsS0FBUCxDQUFhRixDQUFiLEVBQWdCRyxTQUFoQixDQUFQO0FBQ0QsR0FGRDtBQUdEO0FBQ0QsTUFBTUMsY0FBYyxHQUFHLENBQXZCO0FBQ0EsTUFBTUMsZUFBZSxHQUFHLENBQXhCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHO0FBQ3JCRixFQUFBQSxjQURxQjtBQUVyQkMsRUFBQUEsZUFGcUIsRUFBdkI7O0FBSUEsU0FBU0Usd0JBQVQsQ0FBa0NDLEdBQWxDLEVBQXVDQyxNQUF2QyxFQUErQztBQUM3QyxRQUFNQyxLQUFLLEdBQUcsRUFBZDtBQUNBLFFBQU1DLElBQUksR0FBR0YsTUFBTSxLQUFLSixlQUFYLEdBQTZCNUQsTUFBTSxDQUFDa0UsSUFBUCxDQUFZSCxHQUFaLENBQTdCLEdBQWdEL0QsTUFBTSxDQUFDbUUsbUJBQVAsQ0FBMkJKLEdBQTNCLENBQTdEOztBQUVBLE9BQUssSUFBSVYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2EsSUFBSSxDQUFDZixNQUF6QixFQUFpQyxFQUFFRSxDQUFuQyxFQUFzQztBQUNwQyxVQUFNZSxHQUFHLEdBQUdGLElBQUksQ0FBQ2IsQ0FBRCxDQUFoQjs7QUFFQSxRQUFJLENBQUNnQixXQUFXLENBQUNELEdBQUQsQ0FBaEIsRUFBdUI7QUFDckJILE1BQUFBLEtBQUssQ0FBQ3ZCLElBQU4sQ0FBVzBCLEdBQVg7QUFDRDtBQUNGOztBQUVELFNBQU9ILEtBQVA7QUFDRDs7QUFFRCxTQUFTSSxXQUFULENBQXFCQyxDQUFyQixFQUF3QjtBQUN0QixNQUFJQSxDQUFDLENBQUNuQixNQUFGLEtBQWEsQ0FBakIsRUFBb0I7QUFDbEIsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaUIsQ0FBQyxDQUFDbkIsTUFBdEIsRUFBOEIsRUFBRUUsQ0FBaEMsRUFBbUM7QUFDakMsVUFBTWtCLElBQUksR0FBR0QsQ0FBQyxDQUFDRSxVQUFGLENBQWFuQixDQUFiLENBQWI7O0FBRUEsUUFBSWtCLElBQUksR0FBRyxFQUFQLElBQWFBLElBQUksR0FBRyxFQUF4QixFQUE0QjtBQUMxQixhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVEO0FBQ0EsTUFBTUUsbUJBQW1CLEdBQUd6RSxNQUFNLENBQUMwRSxjQUFQLENBQXNCQyxVQUFVLENBQUNDLFNBQWpDLENBQTVCO0FBQ0EsTUFBTUMsMkJBQTJCLEdBQUd2QixXQUFXLENBQUN0RCxNQUFNLENBQUM4RSx3QkFBUCxDQUFnQ0wsbUJBQWhDLEVBQXFEM0QsTUFBTSxDQUFDaUUsV0FBNUQsRUFBeUVDLEdBQTFFLENBQS9DOztBQUVBLFNBQVNDLFFBQVQsQ0FBa0IvRSxLQUFsQixFQUF5QjtBQUN2QixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsUUFBeEI7QUFDRDs7QUFFRCxTQUFTZ0YsVUFBVCxDQUFvQmhGLEtBQXBCLEVBQTJCO0FBQ3pCLFNBQU8sT0FBT0EsS0FBUCxLQUFpQixVQUF4QjtBQUNEOztBQUVELFNBQVNpRixjQUFULENBQXdCakYsS0FBeEIsRUFBK0JrRixJQUEvQixFQUFxQztBQUNuQyxTQUFPcEYsTUFBTSxDQUFDNEUsU0FBUCxDQUFpQlMsUUFBakIsQ0FBMEI3QixJQUExQixDQUErQnRELEtBQS9CLE1BQTJDLFdBQVVrRixJQUFLLEdBQWpFO0FBQ0Q7O0FBRUQsU0FBU0UsZ0JBQVQsQ0FBMEJwRixLQUExQixFQUFpQztBQUMvQixNQUFJcUYsYUFBYSxDQUFDckYsS0FBRCxDQUFqQixFQUEwQjtBQUN4QixXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPc0YsbUJBQW1CLENBQUN0RixLQUFELENBQTFCO0FBQ0Q7QUFDRCxTQUFTdUYsaUJBQVQsQ0FBMkJ2RixLQUEzQixFQUFrQztBQUNoQyxTQUFPK0UsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLFdBQVIsQ0FBeEM7QUFDRDtBQUNELFNBQVNxRixhQUFULENBQXVCckYsS0FBdkIsRUFBOEI7QUFDNUIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxhQUFSLENBQXhDO0FBQ0QsQyxDQUFDOztBQUVGLE1BQU13RixpQkFBaUIsR0FBR0MsV0FBVyxDQUFDQyxNQUF0QztBQUNBLFNBQVNDLGVBQVQsQ0FBeUIzRixLQUF6QixFQUFnQztBQUM5QixTQUFPZ0YsVUFBVSxDQUFDaEYsS0FBRCxDQUFWLElBQXFCaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLGVBQVIsQ0FBMUM7QUFDRDtBQUNELFNBQVM0RixlQUFULENBQXlCNUYsS0FBekIsRUFBZ0M7QUFDOUIsU0FBTzJFLDJCQUEyQixDQUFDM0UsS0FBRCxDQUEzQixLQUF1QyxlQUE5QztBQUNEO0FBQ0QsU0FBUzZGLGdCQUFULENBQTBCN0YsS0FBMUIsRUFBaUM7QUFDL0IsU0FBTzJFLDJCQUEyQixDQUFDM0UsS0FBRCxDQUEzQixLQUF1QyxnQkFBOUM7QUFDRDtBQUNELFNBQVM4RixlQUFULENBQXlCOUYsS0FBekIsRUFBZ0M7QUFDOUIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxTQUFSLENBQXhDO0FBQ0Q7QUFDRCxTQUFTK0YsZ0JBQVQsQ0FBMEIvRixLQUExQixFQUFpQztBQUMvQixNQUFJLENBQUMrRSxRQUFRLENBQUMvRSxLQUFELENBQWIsRUFBc0I7QUFDcEIsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBT2dHLGNBQWMsQ0FBQ2hHLEtBQUQsQ0FBZCxJQUF5QmlHLGNBQWMsQ0FBQ2pHLEtBQUQsQ0FBdkMsSUFBa0Q4RixlQUFlLENBQUM5RixLQUFELENBQWpFLENBQXlFO0FBQXpFLEtBQ0prRyxjQUFjLENBQUNsRyxLQUFELENBRGpCO0FBRUQ7QUFDRCxTQUFTbUcsVUFBVCxDQUFvQm5HLEtBQXBCLEVBQTJCO0FBQ3pCLFNBQU8rRSxRQUFRLENBQUMvRSxLQUFELENBQVIsSUFBbUJpRixjQUFjLENBQUNqRixLQUFELEVBQVEsVUFBUixDQUF4QztBQUNEO0FBQ0QsU0FBU29HLE1BQVQsQ0FBZ0JwRyxLQUFoQixFQUF1QjtBQUNyQixTQUFPK0UsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLE1BQVIsQ0FBeEM7QUFDRCxDLENBQUM7O0FBRUYsU0FBU3FHLGNBQVQsQ0FBd0JyRyxLQUF4QixFQUErQjtBQUM3QixTQUFPMkUsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDLGNBQTlDO0FBQ0Q7QUFDRCxTQUFTc0csY0FBVCxDQUF3QnRHLEtBQXhCLEVBQStCO0FBQzdCLFNBQU8yRSwyQkFBMkIsQ0FBQzNFLEtBQUQsQ0FBM0IsS0FBdUMsY0FBOUM7QUFDRDtBQUNELFNBQVN1RyxtQkFBVCxDQUE2QnZHLEtBQTdCLEVBQW9DO0FBQ2xDLFNBQU9nRixVQUFVLENBQUNoRixLQUFELENBQVYsSUFBcUJpRixjQUFjLENBQUNqRixLQUFELEVBQVEsbUJBQVIsQ0FBMUM7QUFDRDtBQUNELFNBQVN3RyxpQkFBVCxDQUEyQnhHLEtBQTNCLEVBQWtDO0FBQ2hDLFNBQU8rRSxRQUFRLENBQUMvRSxLQUFELENBQVIsSUFBbUJpRixjQUFjLENBQUNqRixLQUFELEVBQVEsV0FBUixDQUF4QztBQUNEO0FBQ0QsU0FBU3lHLFdBQVQsQ0FBcUJ6RyxLQUFyQixFQUE0QjtBQUMxQixTQUFPMkUsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDLFdBQTlDO0FBQ0Q7QUFDRCxTQUFTMEcsWUFBVCxDQUFzQjFHLEtBQXRCLEVBQTZCO0FBQzNCLFNBQU8yRSwyQkFBMkIsQ0FBQzNFLEtBQUQsQ0FBM0IsS0FBdUMsWUFBOUM7QUFDRDtBQUNELFNBQVMyRyxZQUFULENBQXNCM0csS0FBdEIsRUFBNkI7QUFDM0IsU0FBTzJFLDJCQUEyQixDQUFDM0UsS0FBRCxDQUEzQixLQUF1QyxZQUE5QztBQUNEO0FBQ0QsU0FBUzRHLEtBQVQsQ0FBZTVHLEtBQWYsRUFBc0I7QUFDcEIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxLQUFSLENBQXhDO0FBQ0Q7QUFDRCxTQUFTNkcsYUFBVCxDQUF1QjdHLEtBQXZCLEVBQThCO0FBQzVCLE1BQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixXQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFNMEUsU0FBUyxHQUFHNUUsTUFBTSxDQUFDMEUsY0FBUCxDQUFzQnhFLEtBQXRCLENBQWxCO0FBQ0EsU0FBTzBFLFNBQVMsSUFBSUEsU0FBUyxDQUFDOUQsTUFBTSxDQUFDaUUsV0FBUixDQUFULEtBQWtDLGNBQXREO0FBQ0QsQyxDQUFDOztBQUVGLFNBQVN4RCxhQUFULENBQXVCckIsS0FBdkIsRUFBOEI7QUFDNUI7QUFDQSxNQUFJLEVBQUVBLEtBQUssWUFBWXNCLEtBQW5CLENBQUosRUFBK0I7QUFDN0IsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDdEIsS0FBRCxJQUFVLENBQUNBLEtBQUssQ0FBQzhHLFdBQXJCLEVBQWtDO0FBQ2hDLFdBQU8sS0FBUDtBQUNEOztBQUVELFNBQU8sQ0FBQyxPQUFELEVBQVUsV0FBVixFQUF1QixZQUF2QixFQUFxQyxnQkFBckMsRUFBdUQsYUFBdkQsRUFBc0UsV0FBdEUsRUFBbUYsVUFBbkYsRUFBK0ZDLFFBQS9GLENBQXdHL0csS0FBSyxDQUFDOEcsV0FBTixDQUFrQjVCLElBQTFILENBQVA7QUFDRDtBQUNELFNBQVNjLGNBQVQsQ0FBd0JoRyxLQUF4QixFQUErQjtBQUM3QixTQUFPK0UsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLFFBQVIsQ0FBeEM7QUFDRDtBQUNELFNBQVNnSCxTQUFULENBQW1CaEgsS0FBbkIsRUFBMEI7QUFDeEIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxTQUFSLENBQXhDO0FBQ0QsQyxDQUFDOztBQUVGLFNBQVNpSCxRQUFULENBQWtCakgsS0FBbEIsRUFBeUI7QUFDdkIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxRQUFSLENBQXhDO0FBQ0Q7QUFDRCxTQUFTa0gsS0FBVCxDQUFlbEgsS0FBZixFQUFzQjtBQUNwQixTQUFPK0UsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLEtBQVIsQ0FBeEM7QUFDRDtBQUNELFNBQVNtSCxhQUFULENBQXVCbkgsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFdBQU8sS0FBUDtBQUNEOztBQUVELFFBQU0wRSxTQUFTLEdBQUc1RSxNQUFNLENBQUMwRSxjQUFQLENBQXNCeEUsS0FBdEIsQ0FBbEI7QUFDQSxTQUFPMEUsU0FBUyxJQUFJQSxTQUFTLENBQUM5RCxNQUFNLENBQUNpRSxXQUFSLENBQVQsS0FBa0MsY0FBdEQ7QUFDRDtBQUNELFNBQVNTLG1CQUFULENBQTZCdEYsS0FBN0IsRUFBb0M7QUFDbEMsTUFBSSxDQUFDSixNQUFNLENBQUN3SCxpQkFBWixFQUErQjtBQUM3QixXQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFPckMsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLG1CQUFSLENBQXhDO0FBQ0Q7QUFDRCxTQUFTaUcsY0FBVCxDQUF3QmpHLEtBQXhCLEVBQStCO0FBQzdCLFNBQU8rRSxRQUFRLENBQUMvRSxLQUFELENBQVIsSUFBbUJpRixjQUFjLENBQUNqRixLQUFELEVBQVEsUUFBUixDQUF4QztBQUNEO0FBQ0QsU0FBU2tHLGNBQVQsQ0FBd0JsRyxLQUF4QixFQUErQjtBQUM3QixTQUFPK0UsUUFBUSxDQUFDL0UsS0FBRCxDQUFSLElBQW1CaUYsY0FBYyxDQUFDakYsS0FBRCxFQUFRLFFBQVIsQ0FBeEM7QUFDRDtBQUNELFNBQVNxSCxZQUFULENBQXNCckgsS0FBdEIsRUFBNkI7QUFDM0IsUUFBTXNILG1CQUFtQixHQUFHM0MsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDK0IsU0FBbkU7O0FBRUEsTUFBSXVGLG1CQUFKLEVBQXlCO0FBQ3ZCLFdBQU8sSUFBUDtBQUNEOztBQUVELFNBQU90SCxLQUFLLENBQUNjLFFBQUQsQ0FBTCxLQUFvQixJQUEzQjtBQUNEO0FBQ0QsU0FBU3lHLFlBQVQsQ0FBc0J2SCxLQUF0QixFQUE2QjtBQUMzQixTQUFPMkUsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDLFlBQTlDO0FBQ0Q7QUFDRCxTQUFTd0gsbUJBQVQsQ0FBNkJ4SCxLQUE3QixFQUFvQztBQUNsQyxTQUFPMkUsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDLG1CQUE5QztBQUNEO0FBQ0QsU0FBU3lILGFBQVQsQ0FBdUJ6SCxLQUF2QixFQUE4QjtBQUM1QixTQUFPMkUsMkJBQTJCLENBQUMzRSxLQUFELENBQTNCLEtBQXVDLGFBQTlDO0FBQ0Q7QUFDRCxTQUFTMEgsYUFBVCxDQUF1QjFILEtBQXZCLEVBQThCO0FBQzVCLFNBQU8yRSwyQkFBMkIsQ0FBQzNFLEtBQUQsQ0FBM0IsS0FBdUMsYUFBOUM7QUFDRDtBQUNELFNBQVMySCxTQUFULENBQW1CM0gsS0FBbkIsRUFBMEI7QUFDeEIsU0FBTytFLFFBQVEsQ0FBQy9FLEtBQUQsQ0FBUixJQUFtQmlGLGNBQWMsQ0FBQ2pGLEtBQUQsRUFBUSxTQUFSLENBQXhDO0FBQ0Q7QUFDRCxTQUFTNEgsU0FBVCxDQUFtQjVILEtBQW5CLEVBQTBCO0FBQ3hCLFNBQU8rRSxRQUFRLENBQUMvRSxLQUFELENBQVIsSUFBbUJpRixjQUFjLENBQUNqRixLQUFELEVBQVEsU0FBUixDQUF4QztBQUNELEMsQ0FBQzs7QUFFRixJQUFJNkgsS0FBSyxHQUFHLGFBQWEvSCxNQUFNLENBQUNnSSxNQUFQLENBQWM7QUFDdENDLEVBQUFBLFNBQVMsRUFBRSxJQUQyQjtBQUV0QzNDLEVBQUFBLGdCQUFnQixFQUFFQSxnQkFGb0I7QUFHdENHLEVBQUFBLGlCQUFpQixFQUFFQSxpQkFIbUI7QUFJdENGLEVBQUFBLGFBQWEsRUFBRUEsYUFKdUI7QUFLdENHLEVBQUFBLGlCQUFpQixFQUFFQSxpQkFMbUI7QUFNdENHLEVBQUFBLGVBQWUsRUFBRUEsZUFOcUI7QUFPdENDLEVBQUFBLGVBQWUsRUFBRUEsZUFQcUI7QUFRdENDLEVBQUFBLGdCQUFnQixFQUFFQSxnQkFSb0I7QUFTdENDLEVBQUFBLGVBQWUsRUFBRUEsZUFUcUI7QUFVdENDLEVBQUFBLGdCQUFnQixFQUFFQSxnQkFWb0I7QUFXdENJLEVBQUFBLFVBQVUsRUFBRUEsVUFYMEI7QUFZdENDLEVBQUFBLE1BQU0sRUFBRUEsTUFaOEI7QUFhdENDLEVBQUFBLGNBQWMsRUFBRUEsY0Fic0I7QUFjdENDLEVBQUFBLGNBQWMsRUFBRUEsY0Fkc0I7QUFldENDLEVBQUFBLG1CQUFtQixFQUFFQSxtQkFmaUI7QUFnQnRDQyxFQUFBQSxpQkFBaUIsRUFBRUEsaUJBaEJtQjtBQWlCdENDLEVBQUFBLFdBQVcsRUFBRUEsV0FqQnlCO0FBa0J0Q0MsRUFBQUEsWUFBWSxFQUFFQSxZQWxCd0I7QUFtQnRDQyxFQUFBQSxZQUFZLEVBQUVBLFlBbkJ3QjtBQW9CdENDLEVBQUFBLEtBQUssRUFBRUEsS0FwQitCO0FBcUJ0Q0MsRUFBQUEsYUFBYSxFQUFFQSxhQXJCdUI7QUFzQnRDeEYsRUFBQUEsYUFBYSxFQUFFQSxhQXRCdUI7QUF1QnRDMkUsRUFBQUEsY0FBYyxFQUFFQSxjQXZCc0I7QUF3QnRDZ0IsRUFBQUEsU0FBUyxFQUFFQSxTQXhCMkI7QUF5QnRDQyxFQUFBQSxRQUFRLEVBQUVBLFFBekI0QjtBQTBCdENDLEVBQUFBLEtBQUssRUFBRUEsS0ExQitCO0FBMkJ0Q0MsRUFBQUEsYUFBYSxFQUFFQSxhQTNCdUI7QUE0QnRDN0IsRUFBQUEsbUJBQW1CLEVBQUVBLG1CQTVCaUI7QUE2QnRDVyxFQUFBQSxjQUFjLEVBQUVBLGNBN0JzQjtBQThCdENDLEVBQUFBLGNBQWMsRUFBRUEsY0E5QnNCO0FBK0J0Q21CLEVBQUFBLFlBQVksRUFBRUEsWUEvQndCO0FBZ0N0Q0UsRUFBQUEsWUFBWSxFQUFFQSxZQWhDd0I7QUFpQ3RDQyxFQUFBQSxtQkFBbUIsRUFBRUEsbUJBakNpQjtBQWtDdENDLEVBQUFBLGFBQWEsRUFBRUEsYUFsQ3VCO0FBbUN0Q0MsRUFBQUEsYUFBYSxFQUFFQSxhQW5DdUI7QUFvQ3RDQyxFQUFBQSxTQUFTLEVBQUVBLFNBcEMyQjtBQXFDdENDLEVBQUFBLFNBQVMsRUFBRUEsU0FyQzJCLEVBQWQsQ0FBekI7OztBQXdDQTtBQUNBLElBQUlJLEtBQUo7O0FBRUEsU0FBU0MsU0FBVCxHQUFxQjtBQUNuQixNQUFJLENBQUNELEtBQUwsRUFBWTtBQUNWO0FBQ0E7QUFDQUEsSUFBQUEsS0FBSyxHQUFHRSxLQUFLLENBQUNDLHNCQUFkO0FBQ0Q7O0FBRUQsU0FBT0gsS0FBUDtBQUNEOztBQUVELFNBQVNJLE1BQVQsQ0FBZ0JwSSxLQUFoQixFQUF1QnFJLE9BQXZCLEVBQWdDO0FBQzlCLE1BQUksQ0FBQ3JJLEtBQUwsRUFBWTtBQUNWLFVBQU1tSSxzQkFBc0IsR0FBR0YsU0FBUyxFQUF4QztBQUNBLFVBQU0sSUFBSUUsc0JBQUosQ0FBMkJFLE9BQTNCLENBQU47QUFDRDtBQUNGOztBQUVELFNBQVNDLElBQVQsQ0FBY0QsT0FBZCxFQUF1QjtBQUNyQixRQUFNRixzQkFBc0IsR0FBR0YsU0FBUyxFQUF4QztBQUNBLFFBQU0sSUFBSUUsc0JBQUosQ0FBMkJFLE9BQTNCLENBQU47QUFDRDs7QUFFREQsTUFBTSxDQUFDRSxJQUFQLEdBQWNBLElBQWQ7O0FBRUE7QUFDQSxNQUFNQyxRQUFRLEdBQUcsSUFBSUMsR0FBSixFQUFqQjtBQUNBLE1BQU1OLEtBQUssR0FBRyxFQUFkLEMsQ0FBa0I7O0FBRWxCLE1BQU1PLFdBQU4sU0FBMEJuSCxLQUExQixDQUFnQyxFLENBQUc7OztBQUduQyxTQUFTb0gsQ0FBVCxDQUFXQyxHQUFYLEVBQWdCQyxHQUFoQixFQUFxQkMsR0FBckIsRUFBMEIsR0FBR0MsWUFBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBUCxFQUFBQSxRQUFRLENBQUNRLEdBQVQsQ0FBYUosR0FBYixFQUFrQkMsR0FBbEI7O0FBRUEsTUFBSUMsR0FBRyxLQUFLSixXQUFaLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBSW5ILEtBQUosQ0FBVSxrREFBVixDQUFOO0FBQ0QsR0FGRCxNQUVPO0FBQ0x1SCxJQUFBQSxHQUFHLEdBQUdHLHFCQUFxQixDQUFDSCxHQUFELEVBQU1GLEdBQU4sQ0FBM0I7QUFDRDs7QUFFRCxNQUFJRyxZQUFZLENBQUM3RixNQUFiLEtBQXdCLENBQTVCLEVBQStCO0FBQzdCNkYsSUFBQUEsWUFBWSxDQUFDRyxPQUFiLENBQXFCQyxLQUFLLElBQUk7QUFDNUJMLE1BQUFBLEdBQUcsQ0FBQ0ssS0FBSyxDQUFDaEUsSUFBUCxDQUFILEdBQWtCOEQscUJBQXFCLENBQUNFLEtBQUQsRUFBUVAsR0FBUixDQUF2QztBQUNELEtBRkQ7QUFHRDs7QUFFRFQsRUFBQUEsS0FBSyxDQUFDUyxHQUFELENBQUwsR0FBYUUsR0FBYjtBQUNEOztBQUVELFNBQVNHLHFCQUFULENBQStCRyxJQUEvQixFQUFxQ2pGLEdBQXJDLEVBQTBDO0FBQ3hDLFNBQU8sTUFBTWtGLFNBQU4sU0FBd0JELElBQXhCLENBQTZCO0FBQ2xDckMsSUFBQUEsV0FBVyxDQUFDLEdBQUd1QyxJQUFKLEVBQVU7QUFDbkI7QUFDQSxZQUFNaEIsT0FBTyxHQUFHaUIsVUFBVSxDQUFDcEYsR0FBRCxFQUFNbUYsSUFBTixFQUFZLElBQVosQ0FBMUI7QUFDQXZKLE1BQUFBLE1BQU0sQ0FBQ3lKLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsU0FBNUIsRUFBdUM7QUFDckN2SixRQUFBQSxLQUFLLEVBQUVxSSxPQUQ4QjtBQUVyQ21CLFFBQUFBLFVBQVUsRUFBRSxLQUZ5QjtBQUdyQ3ZKLFFBQUFBLFFBQVEsRUFBRSxJQUgyQjtBQUlyQ3dKLFFBQUFBLFlBQVksRUFBRSxJQUp1QixFQUF2Qzs7QUFNQUMsTUFBQUEsYUFBYSxDQUFDLElBQUQsRUFBTyxNQUFNeEUsSUFBYixFQUFtQmhCLEdBQW5CLENBQWI7QUFDRDs7QUFFRCxRQUFJRyxJQUFKLEdBQVc7QUFDVCxhQUFPSCxHQUFQO0FBQ0Q7O0FBRUQsUUFBSUcsSUFBSixDQUFTckUsS0FBVCxFQUFnQjtBQUNkRixNQUFBQSxNQUFNLENBQUN5SixjQUFQLENBQXNCLElBQXRCLEVBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDRSxRQUFBQSxZQUFZLEVBQUUsSUFEb0I7QUFFbENELFFBQUFBLFVBQVUsRUFBRSxJQUZzQjtBQUdsQ3hKLFFBQUFBLEtBSGtDO0FBSWxDQyxRQUFBQSxRQUFRLEVBQUUsSUFKd0IsRUFBcEM7O0FBTUQ7O0FBRURrRixJQUFBQSxRQUFRLEdBQUc7QUFDVCxhQUFRLEdBQUUsS0FBS0QsSUFBSyxLQUFJaEIsR0FBSSxNQUFLLEtBQUttRSxPQUFRLEVBQTlDO0FBQ0QsS0E1QmlDLENBQXBDOzs7QUErQkQ7O0FBRUQsU0FBU2lCLFVBQVQsQ0FBb0JwRixHQUFwQixFQUF5Qm1GLElBQXpCLEVBQStCeEosSUFBL0IsRUFBcUM7QUFDbkMsUUFBTThKLEdBQUcsR0FBR3BCLFFBQVEsQ0FBQ3pELEdBQVQsQ0FBYVosR0FBYixDQUFaO0FBQ0E7Ozs7Ozs7QUFPQSxNQUFJLE9BQU95RixHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0J2QixJQUFBQSxNQUFNLENBQUN1QixHQUFHLENBQUMxRyxNQUFKLElBQWNvRyxJQUFJLENBQUNwRyxNQUFwQixFQUE0QjtBQUNqQyxhQUFRaUIsR0FBSSxvQ0FBbUNtRixJQUFJLENBQUNwRyxNQUFPLGFBQTVELEdBQTRFLDRCQUEyQjBHLEdBQUcsQ0FBQzFHLE1BQU8sSUFENUcsQ0FBTjtBQUVBLFdBQU8wRyxHQUFHLENBQUNwRyxLQUFKLENBQVUxRCxJQUFWLEVBQWdCd0osSUFBaEIsQ0FBUDtBQUNEOztBQUVELFFBQU1PLGNBQWMsR0FBRyxDQUFDRCxHQUFHLENBQUNySCxLQUFKLENBQVUsYUFBVixLQUE0QixFQUE3QixFQUFpQ1csTUFBeEQ7QUFDQW1GLEVBQUFBLE1BQU0sQ0FBQ3dCLGNBQWMsS0FBS1AsSUFBSSxDQUFDcEcsTUFBekIsRUFBa0MsU0FBUWlCLEdBQUksb0NBQW1DbUYsSUFBSSxDQUFDcEcsTUFBTyxhQUE1RCxHQUE0RSw0QkFBMkIyRyxjQUFlLElBQXZKLENBQU47O0FBRUEsTUFBSVAsSUFBSSxDQUFDcEcsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixXQUFPMEcsR0FBUDtBQUNEOztBQUVETixFQUFBQSxJQUFJLENBQUNRLE9BQUwsQ0FBYUYsR0FBYjtBQUNBLFNBQU9HLE1BQU0sQ0FBQ3ZHLEtBQVAsQ0FBYSxJQUFiLEVBQW1COEYsSUFBbkIsQ0FBUCxDQXZCbUMsQ0F1QkY7QUFDakM7QUFDRDs7QUFFRCxTQUFTSyxhQUFULENBQXVCaEksR0FBdkIsRUFBNEJ3RCxJQUE1QixFQUFrQ2IsSUFBbEMsRUFBd0M7QUFDdEM7QUFDQTNDLEVBQUFBLEdBQUcsQ0FBQ3dELElBQUosR0FBWSxHQUFFQSxJQUFLLEtBQUliLElBQUssR0FBNUIsQ0FGc0MsQ0FFTjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTNDLEVBQUFBLEdBQUcsQ0FBQ00sS0FBSixDQVJzQyxDQVEzQjs7QUFFWCxNQUFJa0QsSUFBSSxLQUFLLGFBQWIsRUFBNEI7QUFDMUJwRixJQUFBQSxNQUFNLENBQUN5SixjQUFQLENBQXNCN0gsR0FBdEIsRUFBMkIsTUFBM0IsRUFBbUM7QUFDakMxQixNQUFBQSxLQUFLLEVBQUVrRixJQUQwQjtBQUVqQ3NFLE1BQUFBLFVBQVUsRUFBRSxLQUZxQjtBQUdqQ3ZKLE1BQUFBLFFBQVEsRUFBRSxJQUh1QjtBQUlqQ3dKLE1BQUFBLFlBQVksRUFBRSxJQUptQixFQUFuQzs7QUFNRCxHQVBELE1BT087QUFDTCxXQUFPL0gsR0FBRyxDQUFDd0QsSUFBWDtBQUNEO0FBQ0Y7O0FBRUR3RCxDQUFDLENBQUMsMEJBQUQsRUFBNkI7QUFDOUI7QUFDQSxDQUFDeEQsSUFBSSxHQUFHbkQsU0FBUixLQUFzQjtBQUNwQixNQUFJbUQsSUFBSixFQUFVO0FBQ1IsV0FBUSxJQUFHQSxJQUFLLCtCQUFoQjtBQUNEOztBQUVELFNBQU8sZ0RBQVA7QUFDRCxDQVJBLEVBUUU2RSxVQVJGLENBQUQ7QUFTQXJCLENBQUMsQ0FBQyx3QkFBRCxFQUEyQkwsT0FBTyxJQUFJO0FBQ3JDLFFBQU0yQixNQUFNLEdBQUcsZ0RBQWdELDZDQUFoRCxHQUFnRyxnREFBaEcsR0FBbUosaUNBQWxLO0FBQ0EsU0FBTzNCLE9BQU8sS0FBS3RHLFNBQVosR0FBd0JpSSxNQUF4QixHQUFrQyxHQUFFM0IsT0FBUSxLQUFJMkIsTUFBTyxFQUE5RDtBQUNELENBSEEsRUFHRTFJLEtBSEYsQ0FBRDtBQUlBb0gsQ0FBQyxDQUFDLHNCQUFELEVBQXlCLENBQUN4RCxJQUFELEVBQU8rRSxRQUFQLEVBQWlCQyxNQUFqQixLQUE0QjtBQUNwRDlCLEVBQUFBLE1BQU0sQ0FBQyxPQUFPbEQsSUFBUCxLQUFnQixRQUFqQixFQUEyQiwyQkFBM0IsQ0FBTixDQURvRCxDQUNXOztBQUUvRCxNQUFJaUYsVUFBSjs7QUFFQSxNQUFJLE9BQU9GLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0NBLFFBQVEsQ0FBQ0csVUFBVCxDQUFvQixNQUFwQixDQUFwQyxFQUFpRTtBQUMvREQsSUFBQUEsVUFBVSxHQUFHLGFBQWI7QUFDQUYsSUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUMvSSxPQUFULENBQWlCLE9BQWpCLEVBQTBCLEVBQTFCLENBQVg7QUFDRCxHQUhELE1BR087QUFDTGlKLElBQUFBLFVBQVUsR0FBRyxTQUFiO0FBQ0Q7O0FBRUQsTUFBSVIsR0FBSjs7QUFFQSxNQUFJekUsSUFBSSxDQUFDbUYsUUFBTCxDQUFjLFdBQWQsQ0FBSixFQUFnQztBQUM5QjtBQUNBVixJQUFBQSxHQUFHLEdBQUksT0FBTXpFLElBQUssSUFBR2lGLFVBQVcsSUFBR0csS0FBSyxDQUFDTCxRQUFELEVBQVcsTUFBWCxDQUFtQixFQUEzRDtBQUNELEdBSEQsTUFHTztBQUNMLFVBQU1NLElBQUksR0FBR3JGLElBQUksQ0FBQzZCLFFBQUwsQ0FBYyxHQUFkLElBQXFCLFVBQXJCLEdBQWtDLFVBQS9DO0FBQ0E0QyxJQUFBQSxHQUFHLEdBQUksUUFBT3pFLElBQUssS0FBSXFGLElBQUssSUFBR0osVUFBVyxJQUFHRyxLQUFLLENBQUNMLFFBQUQsRUFBVyxNQUFYLENBQW1CLEVBQXJFO0FBQ0QsR0FwQm1ELENBb0JsRDs7O0FBR0ZOLEVBQUFBLEdBQUcsSUFBSyxtQkFBa0IsT0FBT08sTUFBTyxFQUF4QztBQUNBLFNBQU9QLEdBQVA7QUFDRCxDQXpCQSxFQXlCRWEsU0F6QkYsQ0FBRDtBQTBCQSxJQUFJQyxrQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0E7Ozs7Ozs7OztBQVNBLFNBQVNDLG9CQUFULENBQThCakosR0FBOUIsRUFBbUM7QUFDakMsTUFBSWdKLHFCQUFxQixLQUFLM0ksU0FBOUIsRUFBeUM7QUFDdkMsUUFBSTtBQUNGLGVBQVM2SSxhQUFULEdBQXlCO0FBQ3ZCQSxRQUFBQSxhQUFhO0FBQ2Q7O0FBRURBLE1BQUFBLGFBQWE7QUFDZCxLQU5ELENBTUUsT0FBT3hKLENBQVAsRUFBVTtBQUNWc0osTUFBQUEscUJBQXFCLEdBQUd0SixDQUFDLENBQUNpSCxPQUExQjtBQUNBb0MsTUFBQUEsa0JBQWtCLEdBQUdySixDQUFDLENBQUM4RCxJQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT3hELEdBQUcsQ0FBQ3dELElBQUosS0FBYXVGLGtCQUFiLElBQW1DL0ksR0FBRyxDQUFDMkcsT0FBSixLQUFnQnFDLHFCQUExRDtBQUNEOztBQUVELFNBQVNKLEtBQVQsQ0FBZUwsUUFBZixFQUF5QlksS0FBekIsRUFBZ0M7QUFDOUJ6QyxFQUFBQSxNQUFNLENBQUMsT0FBT3lDLEtBQVAsS0FBaUIsUUFBbEIsRUFBNEIsa0NBQTVCLENBQU47O0FBRUEsTUFBSW5JLEtBQUssQ0FBQ0MsT0FBTixDQUFjc0gsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFVBQU1hLEdBQUcsR0FBR2IsUUFBUSxDQUFDaEgsTUFBckI7QUFDQW1GLElBQUFBLE1BQU0sQ0FBQzBDLEdBQUcsR0FBRyxDQUFQLEVBQVUsbURBQVYsQ0FBTjtBQUNBYixJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ2MsR0FBVCxDQUFhNUgsQ0FBQyxJQUFJNkgsTUFBTSxDQUFDN0gsQ0FBRCxDQUF4QixDQUFYOztBQUVBLFFBQUkySCxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1gsYUFBUSxVQUFTRCxLQUFNLElBQUdaLFFBQVEsQ0FBQ2dCLEtBQVQsQ0FBZSxDQUFmLEVBQWtCSCxHQUFHLEdBQUcsQ0FBeEIsRUFBMkJoSSxJQUEzQixDQUFnQyxJQUFoQyxDQUFzQyxPQUF6RCxHQUFrRW1ILFFBQVEsQ0FBQ2EsR0FBRyxHQUFHLENBQVAsQ0FBakY7QUFDRCxLQUZELE1BRU8sSUFBSUEsR0FBRyxLQUFLLENBQVosRUFBZTtBQUNwQixhQUFRLFVBQVNELEtBQU0sSUFBR1osUUFBUSxDQUFDLENBQUQsQ0FBSSxPQUFNQSxRQUFRLENBQUMsQ0FBRCxDQUFJLEVBQXhEO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsYUFBUSxNQUFLWSxLQUFNLElBQUdaLFFBQVEsQ0FBQyxDQUFELENBQUksRUFBbEM7QUFDRDtBQUNGLEdBWkQsTUFZTztBQUNMLFdBQVEsTUFBS1ksS0FBTSxJQUFHRyxNQUFNLENBQUNmLFFBQUQsQ0FBVyxFQUF2QztBQUNEO0FBQ0Y7O0FBRUQsTUFBTWlCLFVBQU4sU0FBeUJ6RyxVQUF6QixDQUFvQztBQUNwQzs7Ozs7Ozs7QUFRQSxTQUFTMEcsZ0JBQVQsQ0FBMEJuTCxLQUExQixFQUFpQztBQUMvQixRQUFNaUQsTUFBTSxHQUFHakQsS0FBSyxDQUFDaUQsTUFBTixHQUFlLENBQTlCO0FBQ0EsUUFBTW1JLFNBQVMsR0FBRyxFQUFsQjs7QUFFQSxPQUFLLElBQUlqSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixNQUFwQixFQUE0QkUsQ0FBQyxFQUE3QixFQUFpQztBQUMvQixVQUFNa0ksWUFBWSxHQUFHQyxRQUFRLENBQUN0TCxLQUFLLENBQUN1TCxNQUFOLENBQWFwSSxDQUFDLEdBQUcsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FBRCxFQUF5QixFQUF6QixDQUE3Qjs7QUFFQSxRQUFJLENBQUNxSSxNQUFNLENBQUNDLEtBQVAsQ0FBYUosWUFBYixDQUFMLEVBQWlDO0FBQy9CO0FBQ0FELE1BQUFBLFNBQVMsQ0FBQzVJLElBQVYsQ0FBZTZJLFlBQWY7QUFDRDtBQUNGOztBQUVELFNBQU9ELFNBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUEsTUFBTU0sVUFBTixDQUFpQjtBQUNmOzs7Ozs7Ozs7Ozs7O0FBYUE1RSxFQUFBQSxXQUFXLENBQUM2RSxRQUFELEVBQVdDLEtBQUssR0FBRyxDQUFuQixFQUFzQjNJLE1BQU0sR0FBRzBJLFFBQVEsQ0FBQzFJLE1BQVQsR0FBa0IySSxLQUFqRCxFQUF3RDtBQUNqRTlMLElBQUFBLE1BQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0IsSUFBeEIsRUFBOEI7QUFDNUI4TCxNQUFBQSxVQUFVLEVBQUU7QUFDVjdMLFFBQUFBLEtBQUssRUFBRTRMLEtBREcsRUFEZ0I7O0FBSTVCM0ksTUFBQUEsTUFBTSxFQUFFO0FBQ05qRCxRQUFBQSxLQUFLLEVBQUVpRCxNQURELEVBSm9COztBQU81QjZJLE1BQUFBLFNBQVMsRUFBRTtBQUNUOUwsUUFBQUEsS0FBSyxFQUFFMkwsUUFERSxFQVBpQixFQUE5Qjs7O0FBV0Q7QUFDRDs7Ozs7Ozs7O0FBU0EsU0FBT0ksWUFBUCxDQUFvQkosUUFBcEIsRUFBOEJDLEtBQTlCLEVBQXFDM0ksTUFBckMsRUFBNkM7QUFDM0MsV0FBTyxJQUFJK0ksS0FBSixDQUFVLElBQUlOLFVBQUosQ0FBZUMsUUFBZixFQUF5QkMsS0FBekIsRUFBZ0MzSSxNQUFoQyxDQUFWLEVBQW1EZ0osaUJBQW5ELENBQVAsQ0FEMkMsQ0FDbUM7QUFDL0U7O0FBRUQsU0FBT0MsVUFBUCxDQUFrQmxNLEtBQWxCLEVBQXlCbU0sUUFBekIsRUFBbUM7QUFDakMsUUFBSSxDQUFDQyxNQUFNLENBQUNDLFVBQVAsQ0FBa0JGLFFBQWxCLENBQUwsRUFBa0M7QUFDaEMsWUFBTSxJQUFJM0IsU0FBSixDQUFlLHFCQUFvQjJCLFFBQVMsRUFBNUMsQ0FBTjtBQUNEOztBQUVEQSxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ0csV0FBVCxFQUFYOztBQUVBLFFBQUlILFFBQVEsS0FBSyxRQUFqQixFQUEyQjtBQUN6QixZQUFNSSxJQUFJLEdBQUdwTSxFQUFFLENBQUNxTSxLQUFILENBQVNDLFlBQVQsQ0FBc0J6TSxLQUF0QixDQUFiO0FBQ0EsWUFBTTBNLFVBQVUsR0FBR3ZNLEVBQUUsQ0FBQ3dNLE1BQUgsQ0FBVUMsWUFBVixDQUF1QjtBQUN4Q0MsUUFBQUEsTUFBTSxFQUFFTixJQURnQztBQUV4Q08sUUFBQUEsSUFBSSxFQUFFM00sRUFBRSxDQUFDd00sTUFBSCxDQUFVSSxTQUZ3QixFQUF2QixDQUFuQjs7QUFJQSxZQUFNQyxNQUFNLEdBQUc3TSxFQUFFLENBQUN3TSxNQUFILENBQVVNLE9BQVYsQ0FBa0JQLFVBQWxCLENBQWY7QUFDQUEsTUFBQUEsVUFBVSxDQUFDUSxLQUFYO0FBQ0EsYUFBT3hCLFVBQVUsQ0FBQ0ssWUFBWCxDQUF3QmlCLE1BQXhCLENBQVA7QUFDRDs7QUFFRCxRQUFJYixRQUFRLEtBQUssS0FBakIsRUFBd0I7QUFDdEIsWUFBTWdCLEtBQUssR0FBR2hDLGdCQUFnQixDQUFDbkwsS0FBRCxDQUE5QjtBQUNBLFlBQU1pRCxNQUFNLEdBQUdrSyxLQUFLLENBQUNsSyxNQUFyQjtBQUNBLFlBQU0wSSxRQUFRLEdBQUd4TCxFQUFFLENBQUNpTixZQUFILENBQWdCO0FBQy9CbkssUUFBQUEsTUFEK0IsRUFBaEIsQ0FBakI7OztBQUlBLFdBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsTUFBcEIsRUFBNEJFLENBQUMsRUFBN0IsRUFBaUM7QUFDL0J3SSxRQUFBQSxRQUFRLENBQUN4SSxDQUFELENBQVIsR0FBY2dLLEtBQUssQ0FBQ2hLLENBQUQsQ0FBTCxHQUFXLElBQXpCLENBRCtCLENBQ0E7QUFDaEM7O0FBRUQsYUFBT3VJLFVBQVUsQ0FBQ0ssWUFBWCxDQUF3QkosUUFBeEIsQ0FBUDtBQUNEOztBQUVELFVBQU1BLFFBQVEsR0FBR3hMLEVBQUUsQ0FBQ2lOLFlBQUgsQ0FBZ0I7QUFDL0JwTixNQUFBQSxLQUFLLEVBQUVBLEtBRHdCO0FBRS9CdUssTUFBQUEsSUFBSSxFQUFFOEMsaUJBQWlCLENBQUNsQixRQUFELENBRlEsRUFBaEIsQ0FBakI7O0FBSUEsV0FBT1QsVUFBVSxDQUFDSyxZQUFYLENBQXdCSixRQUF4QixDQUFQO0FBQ0QsR0E3RWMsQ0E2RWI7OztBQUdGLE1BQUlxQixNQUFKLEdBQWE7QUFDWDtBQUNBLFdBQU92SSxVQUFVLENBQUM2SSxJQUFYLENBQWdCLElBQWhCLEVBQXNCTixNQUE3QjtBQUNEOztBQUVETyxFQUFBQSxNQUFNLENBQUNDLE1BQUQsRUFBU3ZLLE1BQVQsRUFBaUI7QUFDckIsV0FBT3lJLFVBQVUsQ0FBQ0ssWUFBWCxDQUF3QixLQUFLRCxTQUE3QixFQUF3QzBCLE1BQXhDLEVBQWdEdkssTUFBaEQsQ0FBUDtBQUNEOztBQUVEd0ssRUFBQUEsS0FBSyxDQUFDek4sS0FBRCxFQUFRd04sTUFBUixFQUFnQkUsR0FBaEIsRUFBcUJ2QixRQUFyQixFQUErQjtBQUNsQyxVQUFNd0IsU0FBUyxHQUFHLE9BQU8zTixLQUF6Qjs7QUFFQSxRQUFJMk4sU0FBUyxLQUFLLFFBQWxCLEVBQTRCO0FBQzFCLFlBQU1DLGFBQWEsR0FBR2xDLFVBQVUsQ0FBQ1EsVUFBWCxDQUFzQmxNLEtBQXRCLEVBQTZCbU0sUUFBN0IsQ0FBdEI7QUFDQSxZQUFNMEIsYUFBYSxHQUFHRCxhQUFhLENBQUMzSyxNQUFwQzs7QUFFQSxVQUFJNEssYUFBYSxLQUFLLENBQXRCLEVBQXlCO0FBQ3ZCLGNBQU0sSUFBSXZNLEtBQUosQ0FBVSxvQkFBVixDQUFOO0FBQ0QsT0FOeUIsQ0FNeEI7OztBQUdGLFVBQUl1TSxhQUFhLEtBQUssQ0FBdEIsRUFBeUI7QUFDdkIsYUFBSy9CLFNBQUwsQ0FBZWdDLElBQWYsQ0FBb0JGLGFBQWEsQ0FBQzlCLFNBQWQsQ0FBd0IsQ0FBeEIsQ0FBcEIsRUFBZ0QwQixNQUFoRCxFQUF3REUsR0FBeEQ7O0FBRUEsZUFBTyxJQUFQO0FBQ0QsT0FieUIsQ0FheEI7OztBQUdGLFlBQU16SyxNQUFNLEdBQUd5SyxHQUFHLEdBQUdGLE1BQXJCOztBQUVBLFdBQUssSUFBSXJLLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLE1BQXBCLEVBQTRCRSxDQUFDLEVBQTdCLEVBQWlDO0FBQy9CO0FBQ0EsY0FBTTRLLFFBQVEsR0FBR0gsYUFBYSxDQUFDOUIsU0FBZCxDQUF3QjNJLENBQUMsR0FBRzBLLGFBQTVCLENBQWpCO0FBQ0EsYUFBSy9CLFNBQUwsQ0FBZTNJLENBQUMsR0FBR3FLLE1BQW5CLElBQTZCTyxRQUE3QjtBQUNEOztBQUVELGFBQU8sSUFBUDtBQUNELEtBNUJpQyxDQTRCaEM7OztBQUdGLFNBQUtqQyxTQUFMLENBQWVnQyxJQUFmLENBQW9COU4sS0FBcEIsRUFBMkJ3TixNQUEzQixFQUFtQ0UsR0FBbkM7QUFDRDs7QUFFRE0sRUFBQUEsZ0JBQWdCLENBQUNDLEtBQUQsRUFBUTtBQUN0QixXQUFPRCxnQkFBZ0IsQ0FBQyxJQUFELEVBQU9DLEtBQVAsQ0FBdkI7QUFDRDs7QUFFREMsRUFBQUEsZ0JBQWdCLENBQUNELEtBQUQsRUFBUWpPLEtBQVIsRUFBZTtBQUM3QixXQUFPa08sZ0JBQWdCLENBQUMsSUFBRCxFQUFPRCxLQUFQLEVBQWNqTyxLQUFkLENBQXZCO0FBQ0QsR0FqSWMsQ0FpSWI7OztBQUdGK0ksRUFBQUEsR0FBRyxDQUFDb0YsR0FBRCxFQUFNWCxNQUFNLEdBQUcsQ0FBZixFQUFrQjtBQUNuQixVQUFNWSxRQUFRLEdBQUdELEdBQUcsQ0FBQ2xMLE1BQXJCLENBRG1CLENBQ1U7QUFDN0I7QUFDQTtBQUNBOztBQUVBLFNBQUssSUFBSUUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lMLFFBQXBCLEVBQThCakwsQ0FBQyxFQUEvQixFQUFtQztBQUNqQytLLE1BQUFBLGdCQUFnQixDQUFDLElBQUQsRUFBTy9LLENBQUMsR0FBR3FLLE1BQVgsRUFBbUJXLEdBQUcsQ0FBQ2hMLENBQUQsQ0FBdEIsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Q7Ozs7OztBQU1Ba0wsRUFBQUEsVUFBVSxHQUFHO0FBQ1gsUUFBSSxLQUFLcEwsTUFBTCxLQUFnQixLQUFLNkksU0FBTCxDQUFlN0ksTUFBL0IsSUFBeUMsS0FBSzRJLFVBQUwsS0FBb0IsQ0FBakUsRUFBb0U7QUFDbEUsYUFBTyxLQUFLQyxTQUFaO0FBQ0Q7O0FBRUQsV0FBTyxLQUFLQSxTQUFMLENBQWV3QyxLQUFmLENBQXFCLEtBQUt6QyxVQUExQixFQUFzQyxLQUFLNUksTUFBM0MsQ0FBUDtBQUNELEdBMUpjOztBQTRKZjs7QUFFRixNQUFNZ0osaUJBQWlCLEdBQUc7QUFDeEJuSCxFQUFBQSxHQUFHLENBQUN5SixNQUFELEVBQVNDLE9BQVQsRUFBa0JDLFFBQWxCLEVBQTRCO0FBQzdCLFFBQUksT0FBT0QsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixZQUFNRSxHQUFHLEdBQUdsRCxNQUFNLENBQUNnRCxPQUFELENBQWxCOztBQUVBLFVBQUloRCxNQUFNLENBQUNtRCxhQUFQLENBQXFCRCxHQUFyQixDQUFKLEVBQStCO0FBQzdCLGVBQU9WLGdCQUFnQixDQUFDTyxNQUFELEVBQVNHLEdBQVQsQ0FBdkI7QUFDRDtBQUNGLEtBTkQsTUFNTyxJQUFJRixPQUFPLEtBQUsxTixRQUFoQixFQUEwQjtBQUMvQixhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPOE4sT0FBTyxDQUFDOUosR0FBUixDQUFZeUosTUFBWixFQUFvQkMsT0FBcEIsRUFBNkJDLFFBQTdCLENBQVA7QUFDRCxHQWJ1Qjs7QUFleEIxRixFQUFBQSxHQUFHLENBQUN3RixNQUFELEVBQVNDLE9BQVQsRUFBa0J4TyxLQUFsQixFQUF5QnlPLFFBQXpCLEVBQW1DO0FBQ3BDLFFBQUksT0FBT0QsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixZQUFNRSxHQUFHLEdBQUdsRCxNQUFNLENBQUNnRCxPQUFELENBQWxCOztBQUVBLFVBQUloRCxNQUFNLENBQUNtRCxhQUFQLENBQXFCRCxHQUFyQixDQUFKLEVBQStCO0FBQzdCUixRQUFBQSxnQkFBZ0IsQ0FBQ0ssTUFBRCxFQUFTRyxHQUFULEVBQWMxTyxLQUFkLENBQWhCO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPNE8sT0FBTyxDQUFDN0YsR0FBUixDQUFZd0YsTUFBWixFQUFvQkMsT0FBcEIsRUFBNkJ4TyxLQUE3QixFQUFvQ3lPLFFBQXBDLENBQVA7QUFDRCxHQTFCdUI7O0FBNEJ4QkksRUFBQUEsR0FBRyxDQUFDTixNQUFELEVBQVNySyxHQUFULEVBQWM7QUFDZixRQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixZQUFNd0ssR0FBRyxHQUFHbEQsTUFBTSxDQUFDdEgsR0FBRCxDQUFsQjs7QUFFQSxVQUFJc0gsTUFBTSxDQUFDbUQsYUFBUCxDQUFxQkQsR0FBckIsQ0FBSixFQUErQjtBQUM3QjtBQUNBLGVBQU9BLEdBQUcsSUFBSSxDQUFQLElBQVlBLEdBQUcsR0FBR0gsTUFBTSxDQUFDekMsU0FBUCxDQUFpQjdJLE1BQTFDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPaUIsR0FBRyxJQUFJcUssTUFBZDtBQUNELEdBdkN1QixFQUExQjs7OztBQTJDQSxTQUFTUCxnQkFBVCxDQUEwQmMsR0FBMUIsRUFBK0JiLEtBQS9CLEVBQXNDO0FBQ3BDLE1BQUlBLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYixXQUFPbE0sU0FBUDtBQUNELEdBSG1DLENBR2xDOzs7QUFHRixNQUFJK00sR0FBRyxDQUFDaEQsU0FBUixFQUFtQjtBQUNqQixRQUFJbUMsS0FBSyxJQUFJYSxHQUFHLENBQUNoRCxTQUFKLENBQWM3SSxNQUEzQixFQUFtQztBQUNqQyxhQUFPbEIsU0FBUDtBQUNEOztBQUVELFdBQU8rTSxHQUFHLENBQUNoRCxTQUFKLENBQWNtQyxLQUFLLEdBQUdhLEdBQUcsQ0FBQ2pELFVBQTFCLENBQVA7QUFDRCxHQVptQyxDQVlsQztBQUNGOzs7QUFHQSxTQUFPaUQsR0FBRyxDQUFDYixLQUFELENBQVY7QUFDRDs7QUFFRCxTQUFTQyxnQkFBVCxDQUEwQlksR0FBMUIsRUFBK0JiLEtBQS9CLEVBQXNDak8sS0FBdEMsRUFBNkM7QUFDM0MsTUFBSWlPLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYjtBQUNELEdBSDBDLENBR3pDOzs7QUFHRixNQUFJYSxHQUFHLENBQUNoRCxTQUFSLEVBQW1CO0FBQ2pCLFFBQUltQyxLQUFLLEdBQUdhLEdBQUcsQ0FBQ2hELFNBQUosQ0FBYzdJLE1BQTFCLEVBQWtDO0FBQ2hDNkwsTUFBQUEsR0FBRyxDQUFDaEQsU0FBSixDQUFjbUMsS0FBSyxHQUFHYSxHQUFHLENBQUNqRCxVQUExQixJQUF3QzdMLEtBQXhDO0FBQ0Q7O0FBRUQ7QUFDRCxHQVowQyxDQVl6QztBQUNGOzs7QUFHQThPLEVBQUFBLEdBQUcsQ0FBQ2IsS0FBRCxDQUFILEdBQWFqTyxLQUFiO0FBQ0QsQyxDQUFDOzs7QUFHRixNQUFNK08sWUFBWSxHQUFHLElBQUl2RyxHQUFKLEVBQXJCO0FBQ0F1RyxZQUFZLENBQUNoRyxHQUFiLENBQWlCLE9BQWpCLEVBQTBCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTQyxZQUFuQztBQUNBRixZQUFZLENBQUNoRyxHQUFiLENBQWlCLE1BQWpCLEVBQXlCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTQyxZQUFsQztBQUNBRixZQUFZLENBQUNoRyxHQUFiLENBQWlCLFVBQWpCLEVBQTZCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTRSxlQUF0QztBQUNBSCxZQUFZLENBQUNoRyxHQUFiLENBQWlCLFNBQWpCLEVBQTRCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTRSxlQUFyQztBQUNBSCxZQUFZLENBQUNoRyxHQUFiLENBQWlCLE1BQWpCLEVBQXlCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTRSxlQUFsQztBQUNBSCxZQUFZLENBQUNoRyxHQUFiLENBQWlCLE9BQWpCLEVBQTBCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTRSxlQUFuQztBQUNBSCxZQUFZLENBQUNoRyxHQUFiLENBQWlCLFFBQWpCLEVBQTJCNUksRUFBRSxDQUFDNk8sS0FBSCxDQUFTRyxtQkFBcEM7QUFDQUosWUFBWSxDQUFDaEcsR0FBYixDQUFpQixRQUFqQixFQUEyQjVJLEVBQUUsQ0FBQzZPLEtBQUgsQ0FBU0csbUJBQXBDO0FBQ0FKLFlBQVksQ0FBQ2hHLEdBQWIsQ0FBaUIsT0FBakIsRUFBMEI1SSxFQUFFLENBQUM2TyxLQUFILENBQVNJLGFBQW5DO0FBQ0E7Ozs7O0FBS0EsU0FBUy9CLGlCQUFULENBQTJCbEIsUUFBM0IsRUFBcUM7QUFDbkMsU0FBTzRDLFlBQVksQ0FBQ2pLLEdBQWIsQ0FBaUJxSCxRQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE1BQU07QUFDSjFJLEVBQUFBLGNBQWMsRUFBRTRMLGdCQURaO0FBRUozTCxFQUFBQSxlQUFlLEVBQUU0TCxpQkFGYjtBQUdGM0wsY0FISjtBQUlBLE1BQU00TCxlQUFlLEdBQUcsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQixPQUFoQixFQUF5QixPQUF6QixFQUFrQyxRQUFsQyxFQUE0QyxRQUE1QyxFQUFzRCxRQUF0RCxFQUFnRSxNQUFoRSxFQUF3RSxPQUF4RSxFQUFpRixTQUFqRixFQUE0RixVQUE1RixDQUF4QixDLENBQWlJOztBQUVqSSxNQUFNQyxXQUFXLEdBQUcsSUFBSUMsWUFBSixDQUFpQixDQUFqQixDQUFwQjtBQUNBLE1BQU1DLGdCQUFnQixHQUFHLElBQUlqTCxVQUFKLENBQWUrSyxXQUFXLENBQUN4QyxNQUEzQixDQUF6QixDLENBQTZEOztBQUU3RCxNQUFNMkMsVUFBVSxHQUFHLElBQUlDLFlBQUosQ0FBaUIsQ0FBakIsQ0FBbkI7QUFDQSxNQUFNQyxlQUFlLEdBQUcsSUFBSXBMLFVBQUosQ0FBZWtMLFVBQVUsQ0FBQzNDLE1BQTFCLENBQXhCLEMsQ0FBMkQ7O0FBRTNEOUIsVUFBVSxDQUFDeEcsU0FBWCxDQUFxQm9DLFdBQXJCLEdBQW1DZ0osUUFBbkMsQyxDQUE2Qzs7QUFFN0NBLFFBQVEsQ0FBQ3BMLFNBQVQsR0FBcUJ3RyxVQUFVLENBQUN4RyxTQUFoQyxDLENBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQW9MLFFBQVEsQ0FBQ0MsUUFBVCxHQUFvQixJQUFwQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxTQUFTRCxRQUFULENBQWtCRSxHQUFsQixFQUF1QkMsZ0JBQXZCLEVBQXlDaE4sTUFBekMsRUFBaUQ7QUFDL0MsTUFBSStNLEdBQUcsS0FBS2pPLFNBQVosRUFBdUI7QUFDckI7QUFDRDs7QUFFRCxNQUFJLE9BQU9pTyxHQUFQLEtBQWUsUUFBZixJQUEyQkEsR0FBRyxDQUFDRSxPQUFKLEtBQWdCLFdBQS9DLEVBQTREO0FBQzFEQyxJQUFBQSxzQkFBc0I7O0FBRXRCLFFBQUksT0FBT0gsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFVBQUksT0FBT0MsZ0JBQVAsS0FBNEIsUUFBaEMsRUFBMEM7QUFDeEMsY0FBTSxJQUFJekYsU0FBSixDQUFlLGlFQUFnRSxPQUFPd0YsR0FBSSxFQUExRixDQUFOO0FBQ0Q7O0FBRUQsYUFBT0YsUUFBUSxDQUFDTSxLQUFULENBQWVKLEdBQWYsQ0FBUDtBQUNEOztBQUVELFdBQU9GLFFBQVEsQ0FBQ3hDLElBQVQsQ0FBYzBDLEdBQWQsRUFBbUJDLGdCQUFuQixFQUFxQ2hOLE1BQXJDLENBQVA7QUFDRCxHQWpCOEMsQ0FpQjdDOzs7QUFHRixTQUFPeUksVUFBVSxDQUFDSyxZQUFYLENBQXdCaUUsR0FBeEIsRUFBNkJDLGdCQUE3QixFQUErQ2hOLE1BQS9DLENBQVA7QUFDRDtBQUNEOzs7Ozs7OztBQVFBNk0sUUFBUSxDQUFDeEMsSUFBVCxHQUFnQixVQUFVdE4sS0FBVixFQUFpQmlRLGdCQUFqQixFQUFtQ2hOLE1BQW5DLEVBQTJDO0FBQ3pELFFBQU0wSyxTQUFTLEdBQUcsT0FBTzNOLEtBQXpCOztBQUVBLE1BQUkyTixTQUFTLEtBQUssUUFBbEIsRUFBNEI7QUFDMUIsV0FBT3pCLFVBQVUsQ0FBQ2xNLEtBQUQsRUFBUWlRLGdCQUFSLENBQWpCO0FBQ0QsR0FGRCxNQUVPLElBQUl0QyxTQUFTLEtBQUssUUFBbEIsRUFBNEI7QUFDakMsUUFBSXZJLGdCQUFnQixDQUFDcEYsS0FBRCxDQUFwQixFQUE2QjtBQUMzQixhQUFPcVEsZUFBZSxDQUFDclEsS0FBRCxFQUFRaVEsZ0JBQVIsRUFBMEJoTixNQUExQixDQUF0QjtBQUNEOztBQUVELFFBQUlQLEtBQUssQ0FBQ0MsT0FBTixDQUFjM0MsS0FBZCxLQUF3QkEsS0FBSyxZQUFZeUUsVUFBN0MsRUFBeUQ7QUFDdkQsYUFBTzZMLFNBQVMsQ0FBQ3RRLEtBQUQsQ0FBaEI7QUFDRDs7QUFFRCxRQUFJOFAsUUFBUSxDQUFDaFAsUUFBVCxDQUFrQmQsS0FBbEIsQ0FBSixFQUE4QjtBQUM1QixhQUFPdVEsVUFBVSxDQUFDdlEsS0FBRCxDQUFqQjtBQUNELEtBWGdDLENBVy9COzs7QUFHRixRQUFJQSxLQUFLLENBQUNrUSxPQUFOLElBQWlCbFEsS0FBSyxDQUFDa1EsT0FBTixLQUFrQixXQUF2QyxFQUFvRDtBQUNsRCxhQUFPeEUsVUFBVSxDQUFDSyxZQUFYLENBQXdCL0wsS0FBeEIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBTSxJQUFJd0ssU0FBSixDQUFjLDhGQUFkLENBQU47QUFDRCxDQXpCRDtBQTBCQTs7Ozs7Ozs7QUFRQSxTQUFTNkYsZUFBVCxDQUF5QnhNLEdBQXpCLEVBQThCZ0ksVUFBOUIsRUFBMEM1SSxNQUExQyxFQUFrRDtBQUNoRDtBQUNBLE1BQUk0SSxVQUFVLEtBQUs5SixTQUFuQixFQUE4QjtBQUM1QjhKLElBQUFBLFVBQVUsR0FBRyxDQUFiO0FBQ0QsR0FGRCxNQUVPO0FBQ0xBLElBQUFBLFVBQVUsR0FBRyxDQUFDQSxVQUFkOztBQUVBLFFBQUlMLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhSSxVQUFiLENBQUosRUFBOEI7QUFDNUJBLE1BQUFBLFVBQVUsR0FBRyxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNMkUsU0FBUyxHQUFHM00sR0FBRyxDQUFDNE0sVUFBSixHQUFpQjVFLFVBQW5DOztBQUVBLE1BQUkyRSxTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDakIsVUFBTSxJQUFJdEksS0FBSyxDQUFDd0ksd0JBQVYsQ0FBbUMsUUFBbkMsQ0FBTjtBQUNEOztBQUVELE1BQUl6TixNQUFNLEtBQUtsQixTQUFmLEVBQTBCO0FBQ3hCa0IsSUFBQUEsTUFBTSxHQUFHdU4sU0FBVDtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0F2TixJQUFBQSxNQUFNLEdBQUcsQ0FBQ0EsTUFBVjs7QUFFQSxRQUFJQSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNkLFVBQUlBLE1BQU0sR0FBR3VOLFNBQWIsRUFBd0I7QUFDdEIsY0FBTSxJQUFJdEksS0FBSyxDQUFDd0ksd0JBQVYsQ0FBbUMsUUFBbkMsQ0FBTjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0x6TixNQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFJaUksVUFBSixDQUFlckgsR0FBZixFQUFvQmdJLFVBQXBCLEVBQWdDNUksTUFBaEMsQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQSxTQUFTaUosVUFBVCxDQUFvQmxNLEtBQXBCLEVBQTJCbU0sUUFBUSxHQUFHLE1BQXRDLEVBQThDO0FBQzVDLE1BQUksQ0FBQzJELFFBQVEsQ0FBQ3pELFVBQVQsQ0FBb0JGLFFBQXBCLENBQUwsRUFBb0M7QUFDbEMsVUFBTSxJQUFJM0IsU0FBSixDQUFlLHFCQUFvQjJCLFFBQVMsRUFBNUMsQ0FBTjtBQUNEOztBQUVEQSxFQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ0csV0FBVCxFQUFYOztBQUVBLE1BQUlILFFBQVEsS0FBSyxRQUFqQixFQUEyQjtBQUN6QixVQUFNSSxJQUFJLEdBQUdwTSxFQUFFLENBQUNxTSxLQUFILENBQVNDLFlBQVQsQ0FBc0J6TSxLQUF0QixDQUFiO0FBQ0EsV0FBTyxJQUFJa0wsVUFBSixDQUFlcUIsSUFBSSxDQUFDb0UsYUFBTCxFQUFmLENBQVA7QUFDRDs7QUFFRCxNQUFJeEUsUUFBUSxLQUFLLEtBQWpCLEVBQXdCO0FBQ3RCLFdBQU9tRSxTQUFTLENBQUNuRixnQkFBZ0IsQ0FBQ25MLEtBQUQsQ0FBakIsQ0FBaEI7QUFDRCxHQWQyQyxDQWMxQzs7O0FBR0YsU0FBT3VRLFVBQVUsQ0FBQzdFLFVBQVUsQ0FBQ1EsVUFBWCxDQUFzQmxNLEtBQXRCLEVBQTZCbU0sUUFBN0IsQ0FBRCxDQUFqQjtBQUNEO0FBQ0Q7Ozs7OztBQU1BLFNBQVNtRSxTQUFULENBQW1CdFEsS0FBbkIsRUFBMEI7QUFDeEIsUUFBTWlELE1BQU0sR0FBR2pELEtBQUssQ0FBQ2lELE1BQXJCOztBQUVBLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCLFdBQU8sSUFBSWlJLFVBQUosRUFBUDtBQUNEOztBQUVELFNBQU8sSUFBSUEsVUFBSixDQUFlbEwsS0FBZixDQUFQO0FBQ0Q7QUFDRDs7Ozs7OztBQU9BLFNBQVN1USxVQUFULENBQW9CdlEsS0FBcEIsRUFBMkI7QUFDekIsUUFBTWlELE1BQU0sR0FBR2pELEtBQUssQ0FBQ2lELE1BQXJCOztBQUVBLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCLFdBQU8sSUFBSWlJLFVBQUosRUFBUDtBQUNEOztBQUVELFFBQU04QixNQUFNLEdBQUc4QyxRQUFRLENBQUNjLFdBQVQsQ0FBcUIzTixNQUFyQixDQUFmO0FBQ0FqRCxFQUFBQSxLQUFLLENBQUM2USxJQUFOLENBQVc3RCxNQUFYLEVBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCL0osTUFBekI7QUFDQSxTQUFPK0osTUFBUDtBQUNEOztBQUVEbE4sTUFBTSxDQUFDZ1IsY0FBUCxDQUFzQmhCLFFBQXRCLEVBQWdDckwsVUFBaEMsRSxDQUE2Qzs7QUFFN0M7Ozs7Ozs7Ozs7OztBQVlBcUwsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQnFNLE9BQW5CLEdBQTZCLFVBQVV4QyxNQUFWLEVBQWtCeUMsV0FBbEIsRUFBK0JDLFNBQS9CLEVBQTBDQyxXQUExQyxFQUF1REMsU0FBdkQsRUFBa0U7QUFDN0YsTUFBSSxDQUFDckIsUUFBUSxDQUFDaFAsUUFBVCxDQUFrQnlOLE1BQWxCLENBQUwsRUFBZ0M7QUFDOUIsVUFBTSxJQUFJL0QsU0FBSixDQUFlLGlGQUFnRixPQUFPNEcsSUFBSyxFQUEzRyxDQUFOO0FBQ0Q7O0FBRUQsTUFBSUosV0FBVyxLQUFLalAsU0FBcEIsRUFBK0I7QUFDN0JpUCxJQUFBQSxXQUFXLEdBQUcsQ0FBZDtBQUNEOztBQUVELE1BQUlFLFdBQVcsS0FBS25QLFNBQXBCLEVBQStCO0FBQzdCbVAsSUFBQUEsV0FBVyxHQUFHLENBQWQ7QUFDRDs7QUFFRCxNQUFJRCxTQUFTLEtBQUtsUCxTQUFsQixFQUE2QjtBQUMzQmtQLElBQUFBLFNBQVMsR0FBRzFDLE1BQU0sQ0FBQ3RMLE1BQW5CO0FBQ0Q7O0FBRUQsTUFBSWtPLFNBQVMsS0FBS3BQLFNBQWxCLEVBQTZCO0FBQzNCb1AsSUFBQUEsU0FBUyxHQUFHLEtBQUtsTyxNQUFqQjtBQUNELEdBbkI0RixDQW1CM0Y7OztBQUdGLE1BQUkrTixXQUFXLEdBQUcsQ0FBZCxJQUFtQkUsV0FBVyxHQUFHLENBQWpDLElBQXNDRCxTQUFTLEdBQUcxQyxNQUFNLENBQUN0TCxNQUF6RCxJQUFtRWtPLFNBQVMsR0FBRyxLQUFLbE8sTUFBeEYsRUFBZ0c7QUFDOUYsVUFBTSxJQUFJOEcsVUFBSixDQUFlLG9CQUFmLENBQU4sQ0FEOEYsQ0FDbEQ7QUFDN0MsR0F4QjRGLENBd0IzRjs7O0FBR0YsUUFBTThDLE1BQU0sR0FBRyxLQUFLNUIsS0FBTCxDQUFXaUcsV0FBWCxFQUF3QkMsU0FBeEIsQ0FBZjtBQUNBLFFBQU1FLFlBQVksR0FBR3hFLE1BQU0sQ0FBQzVKLE1BQTVCO0FBQ0EsUUFBTXFPLElBQUksR0FBRy9DLE1BQU0sQ0FBQ3RELEtBQVAsQ0FBYStGLFdBQWIsRUFBMEJDLFNBQTFCLENBQWI7QUFDQSxRQUFNTSxVQUFVLEdBQUdELElBQUksQ0FBQ3JPLE1BQXhCO0FBQ0EsUUFBTUEsTUFBTSxHQUFHdU8sSUFBSSxDQUFDQyxHQUFMLENBQVNKLFlBQVQsRUFBdUJFLFVBQXZCLENBQWY7O0FBRUEsT0FBSyxJQUFJcE8sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsTUFBcEIsRUFBNEJFLENBQUMsRUFBN0IsRUFBaUM7QUFDL0IsVUFBTXVPLFdBQVcsR0FBR0osSUFBSSxDQUFDdEQsZ0JBQUwsQ0FBc0I3SyxDQUF0QixDQUFwQjtBQUNBLFVBQU13TyxXQUFXLEdBQUc5RSxNQUFNLENBQUNtQixnQkFBUCxDQUF3QjdLLENBQXhCLENBQXBCOztBQUVBLFFBQUl1TyxXQUFXLEtBQUtDLFdBQXBCLEVBQWlDO0FBQy9CO0FBQ0EsVUFBSUEsV0FBVyxHQUFHRCxXQUFsQixFQUErQjtBQUM3QixlQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVELGFBQU8sQ0FBUDtBQUNEO0FBQ0YsR0E3QzRGLENBNkMzRjs7O0FBR0YsTUFBSUwsWUFBWSxHQUFHRSxVQUFuQixFQUErQjtBQUM3QixXQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVELE1BQUlGLFlBQVksR0FBR0UsVUFBbkIsRUFBK0I7QUFDN0IsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxDQUFQO0FBQ0QsQ0F6REQ7QUEwREE7Ozs7Ozs7Ozs7QUFVQXpCLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJtTSxJQUFuQixHQUEwQixVQUFVdEMsTUFBVixFQUFrQnlDLFdBQWxCLEVBQStCRSxXQUEvQixFQUE0Q0MsU0FBNUMsRUFBdUQ7QUFDL0UsTUFBSUgsV0FBVyxLQUFLalAsU0FBcEIsRUFBK0I7QUFDN0JpUCxJQUFBQSxXQUFXLEdBQUcsQ0FBZDtBQUNEOztBQUVELE1BQUlFLFdBQVcsS0FBS25QLFNBQXBCLEVBQStCO0FBQzdCbVAsSUFBQUEsV0FBVyxHQUFHLENBQWQ7QUFDRDs7QUFFRCxNQUFJQyxTQUFTLEtBQUtwUCxTQUFsQixFQUE2QjtBQUMzQm9QLElBQUFBLFNBQVMsR0FBRyxLQUFLbE8sTUFBakI7QUFDRDs7QUFFRCxNQUFJaU8sV0FBVyxLQUFLQyxTQUFwQixFQUErQjtBQUM3QixXQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFJNUMsTUFBTSxDQUFDdEwsTUFBUCxLQUFrQixDQUFsQixJQUF1QixLQUFLQSxNQUFMLEtBQWdCLENBQTNDLEVBQThDO0FBQzVDLFdBQU8sQ0FBUDtBQUNELEdBbkI4RSxDQW1CN0U7OztBQUdGLE1BQUlBLE1BQU0sR0FBR2tPLFNBQVMsR0FBR0QsV0FBekIsQ0F0QitFLENBc0J6Qzs7QUFFdEMsUUFBTVUsU0FBUyxHQUFHckQsTUFBTSxDQUFDdEwsTUFBUCxHQUFnQitOLFdBQWxDOztBQUVBLE1BQUkvTixNQUFNLEdBQUcyTyxTQUFiLEVBQXdCO0FBQ3RCVCxJQUFBQSxTQUFTLEdBQUdELFdBQVcsR0FBR1UsU0FBMUI7QUFDQTNPLElBQUFBLE1BQU0sR0FBRzJPLFNBQVQ7QUFDRCxHQTdCOEUsQ0E2QjdFOzs7QUFHRixNQUFJeEQsUUFBUSxHQUFHbkwsTUFBZjtBQUNBLFFBQU00TyxTQUFTLEdBQUcsS0FBSzVPLE1BQUwsR0FBY2lPLFdBQWhDOztBQUVBLE1BQUk5QyxRQUFRLEdBQUd5RCxTQUFmLEVBQTBCO0FBQ3hCekQsSUFBQUEsUUFBUSxHQUFHeUQsU0FBWDtBQUNELEdBckM4RSxDQXFDN0U7QUFDRjs7O0FBR0EsTUFBSWhGLE1BQU0sR0FBRyxJQUFiOztBQUVBLE1BQUlxRSxXQUFXLEtBQUssQ0FBaEIsSUFBcUJDLFNBQVMsR0FBR3RFLE1BQU0sQ0FBQzVKLE1BQTVDLEVBQW9EO0FBQ2xENEosSUFBQUEsTUFBTSxHQUFHLElBQUlwSSxVQUFKLENBQWUsS0FBS3VJLE1BQXBCLEVBQTRCLEtBQUtuQixVQUFMLEdBQWtCcUYsV0FBOUMsRUFBMkQ5QyxRQUEzRCxDQUFUO0FBQ0Q7O0FBRURHLEVBQUFBLE1BQU0sQ0FBQ3hGLEdBQVAsQ0FBVzhELE1BQVgsRUFBbUJtRSxXQUFuQjtBQUNBLFNBQU81QyxRQUFQO0FBQ0QsQ0FqREQ7QUFrREE7Ozs7QUFJQTs7O0FBR0EwQixRQUFRLENBQUNwTCxTQUFULENBQW1Cb04sT0FBbkIsR0FBNkIsWUFBWTtBQUN2QyxRQUFNOUUsTUFBTSxHQUFHLElBQWY7QUFDQSxNQUFJK0UsU0FBUyxHQUFHLENBQWhCO0FBQ0EsUUFBTXJFLEdBQUcsR0FBRyxLQUFLekssTUFBakI7QUFDQSxRQUFNK08sYUFBYSxHQUFHO0FBQ3BCQyxJQUFBQSxJQUFJLEVBQUUsWUFBWTtBQUNoQixVQUFJRixTQUFTLEdBQUdyRSxHQUFoQixFQUFxQjtBQUNuQixjQUFNd0UsTUFBTSxHQUFHO0FBQ2JsUyxVQUFBQSxLQUFLLEVBQUUsQ0FBQytSLFNBQUQsRUFBWS9FLE1BQU0sQ0FBQ2dCLGdCQUFQLENBQXdCK0QsU0FBeEIsQ0FBWixDQURNO0FBRWJJLFVBQUFBLElBQUksRUFBRSxLQUZPLEVBQWY7O0FBSUFKLFFBQUFBLFNBQVM7QUFDVCxlQUFPRyxNQUFQO0FBQ0Q7O0FBRUQsYUFBTztBQUNMbFMsUUFBQUEsS0FBSyxFQUFFK0IsU0FERjtBQUVMb1EsUUFBQUEsSUFBSSxFQUFFLElBRkQsRUFBUDs7QUFJRCxLQWZtQjtBQWdCcEIsS0FBQ3ZSLE1BQU0sQ0FBQ3dSLFFBQVIsR0FBbUIsWUFBWTtBQUM3QixhQUFPLElBQVA7QUFDRCxLQWxCbUIsRUFBdEI7O0FBb0JBLFNBQU9KLGFBQVA7QUFDRCxDQXpCRDs7QUEyQkFsQyxRQUFRLENBQUNwTCxTQUFULENBQW1CMk4sTUFBbkIsR0FBNEIsVUFBVUMsV0FBVixFQUF1QjtBQUNqRCxNQUFJLENBQUN4QyxRQUFRLENBQUNoUCxRQUFULENBQWtCd1IsV0FBbEIsQ0FBTCxFQUFxQztBQUNuQyxVQUFNLElBQUk5SCxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUVELE1BQUk4SCxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDeEIsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBTyxLQUFLdkIsT0FBTCxDQUFhdUIsV0FBYixNQUE4QixDQUFyQztBQUNELENBVkQ7QUFXQTs7Ozs7Ozs7O0FBU0F4QyxRQUFRLENBQUNwTCxTQUFULENBQW1Cb0osSUFBbkIsR0FBMEIsVUFBVTlOLEtBQVYsRUFBaUJ3TixNQUFqQixFQUF5QkUsR0FBekIsRUFBOEJ2QixRQUE5QixFQUF3QztBQUNoRSxRQUFNb0csVUFBVSxHQUFHLE9BQU8vRSxNQUExQjs7QUFFQSxNQUFJK0UsVUFBVSxLQUFLLFdBQW5CLEVBQWdDO0FBQzlCO0FBQ0EvRSxJQUFBQSxNQUFNLEdBQUcsQ0FBVDtBQUNBRSxJQUFBQSxHQUFHLEdBQUcsS0FBS3pLLE1BQVg7QUFDQWtKLElBQUFBLFFBQVEsR0FBRyxNQUFYO0FBQ0QsR0FMRCxNQUtPLElBQUlvRyxVQUFVLEtBQUssUUFBbkIsRUFBNkI7QUFDbEM7QUFDQXBHLElBQUFBLFFBQVEsR0FBR3FCLE1BQVg7QUFDQUEsSUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDQUUsSUFBQUEsR0FBRyxHQUFHLEtBQUt6SyxNQUFYO0FBQ0QsR0FMTSxNQUtBLElBQUksT0FBT3lLLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQztBQUNBdkIsSUFBQUEsUUFBUSxHQUFHdUIsR0FBWDtBQUNBQSxJQUFBQSxHQUFHLEdBQUcsS0FBS3pLLE1BQVg7QUFDRDs7QUFFRCxPQUFLd0ssS0FBTCxDQUFXek4sS0FBWCxFQUFrQndOLE1BQWxCLEVBQTBCRSxHQUExQixFQUErQnZCLFFBQS9COztBQUVBLFNBQU8sSUFBUDtBQUNELENBdEJEOztBQXdCQSxNQUFNcUcscUJBQXFCLEdBQUcxUyxNQUFNLENBQUMwRSxjQUFQLENBQXNCQyxVQUFVLENBQUNDLFNBQWpDLENBQTlCO0FBQ0EsTUFBTStOLDBCQUEwQixHQUFHM1MsTUFBTSxDQUFDOEUsd0JBQVAsQ0FBZ0M0TixxQkFBaEMsRUFBdUQsWUFBdkQsRUFBcUUxTixHQUF4RztBQUNBLE1BQU00TixjQUFjLEdBQUdGLHFCQUFxQixDQUFDMUUsSUFBN0M7O0FBRUFnQyxRQUFRLENBQUNwTCxTQUFULENBQW1CK0ksS0FBbkIsR0FBMkIsVUFBVXpOLEtBQVYsRUFBaUJ3TixNQUFqQixFQUF5QkUsR0FBekIsRUFBOEJ2QixRQUE5QixFQUF3QztBQUNqRSxNQUFJLE9BQU9uTSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCO0FBQ0EsVUFBTTJTLE9BQU8sR0FBR0YsMEJBQTBCLENBQUNuUCxJQUEzQixDQUFnQyxJQUFoQyxDQUFoQjtBQUNBLFVBQU1zUCxVQUFVLEdBQUdsRixHQUFHLEdBQUdGLE1BQXpCOztBQUVBLFFBQUlBLE1BQU0sR0FBR0UsR0FBVCxJQUFnQmtGLFVBQVUsR0FBR3BGLE1BQWIsR0FBc0JtRixPQUExQyxFQUFtRDtBQUNqRCxZQUFNLElBQUl6SyxLQUFLLENBQUN3SSx3QkFBVixFQUFOO0FBQ0Q7O0FBRURnQyxJQUFBQSxjQUFjLENBQUNwUCxJQUFmLENBQW9CLElBQXBCLEVBQTBCdEQsS0FBMUIsRUFBaUN3TixNQUFqQyxFQUF5Q0UsR0FBekM7QUFDRCxHQVZELE1BVU87QUFDTCxVQUFNRSxhQUFhLEdBQUdsQyxVQUFVLENBQUNRLFVBQVgsQ0FBc0JsTSxLQUF0QixFQUE2Qm1NLFFBQTdCLENBQXRCO0FBQ0EsVUFBTTBCLGFBQWEsR0FBR0QsYUFBYSxDQUFDM0ssTUFBcEM7O0FBRUEsUUFBSTRLLGFBQWEsS0FBSyxDQUF0QixFQUF5QjtBQUN2QixZQUFNLElBQUl2TSxLQUFKLENBQVUsb0JBQVYsQ0FBTjtBQUNEOztBQUVELFFBQUl1TSxhQUFhLEtBQUssQ0FBdEIsRUFBeUI7QUFDdkI2RSxNQUFBQSxjQUFjLENBQUNwUCxJQUFmLENBQW9CLElBQXBCLEVBQTBCc0ssYUFBYSxDQUFDOUIsU0FBZCxDQUF3QixDQUF4QixDQUExQixFQUFzRDBCLE1BQXRELEVBQThERSxHQUE5RDtBQUNBLGFBQU8sSUFBUDtBQUNELEtBWEksQ0FXSDs7O0FBR0YsVUFBTXpLLE1BQU0sR0FBR3lLLEdBQUcsR0FBR0YsTUFBckI7O0FBRUEsU0FBSyxJQUFJckssQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsTUFBcEIsRUFBNEJFLENBQUMsRUFBN0IsRUFBaUM7QUFDL0I7QUFDQSxZQUFNNEssUUFBUSxHQUFHSCxhQUFhLENBQUM5QixTQUFkLENBQXdCM0ksQ0FBQyxHQUFHMEssYUFBNUIsQ0FBakI7QUFDQSxXQUFLSyxnQkFBTCxDQUFzQi9LLENBQUMsR0FBR3FLLE1BQTFCLEVBQWtDTyxRQUFsQztBQUNEO0FBQ0Y7QUFDRixDQWpDRDs7QUFtQ0ErQixRQUFRLENBQUNwTCxTQUFULENBQW1CcUMsUUFBbkIsR0FBOEIsVUFBVS9HLEtBQVYsRUFBaUI2TCxVQUFqQixFQUE2Qk0sUUFBN0IsRUFBdUM7QUFDbkUsU0FBTyxLQUFLMEcsT0FBTCxDQUFhN1MsS0FBYixFQUFvQjZMLFVBQXBCLEVBQWdDTSxRQUFoQyxNQUE4QyxDQUFDLENBQXREO0FBQ0QsQ0FGRDtBQUdBOzs7Ozs7OztBQVFBMkQsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQm1PLE9BQW5CLEdBQTZCLFVBQVU3UyxLQUFWLEVBQWlCNkwsVUFBakIsRUFBNkJNLFFBQTdCLEVBQXVDO0FBQ2xFLE1BQUksS0FBS2xKLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckI7QUFDQSxXQUFPLENBQUMsQ0FBUjtBQUNELEdBSmlFLENBSWhFOzs7QUFHRixNQUFJLE9BQU80SSxVQUFQLEtBQXNCLFdBQTFCLEVBQXVDO0FBQ3JDQSxJQUFBQSxVQUFVLEdBQUcsQ0FBYjtBQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9BLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDekM7QUFDQU0sSUFBQUEsUUFBUSxHQUFHTixVQUFYO0FBQ0FBLElBQUFBLFVBQVUsR0FBRyxDQUFiO0FBQ0QsR0FiaUUsQ0FhaEU7OztBQUdGLE1BQUksT0FBT00sUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQ0EsSUFBQUEsUUFBUSxHQUFHLE1BQVg7QUFDRDs7QUFFRCxNQUFJTixVQUFVLEdBQUcsQ0FBakIsRUFBb0I7QUFDbEI7QUFDQUEsSUFBQUEsVUFBVSxHQUFHLEtBQUs1SSxNQUFMLEdBQWM0SSxVQUEzQjs7QUFFQSxRQUFJQSxVQUFVLEdBQUcsQ0FBakIsRUFBb0I7QUFDbEI7QUFDQUEsTUFBQUEsVUFBVSxHQUFHLENBQWI7QUFDRDtBQUNGLEdBUkQsTUFRTyxJQUFJQSxVQUFVLElBQUksS0FBSzVJLE1BQXZCLEVBQStCO0FBQ3BDLFdBQU8sQ0FBQyxDQUFSLENBRG9DLENBQ3pCO0FBQ1o7O0FBRUQsTUFBSSxPQUFPakQsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QkEsSUFBQUEsS0FBSyxJQUFJLElBQVQsQ0FENkIsQ0FDZDtBQUNmO0FBQ0E7O0FBRUEsV0FBTzZTLE9BQU8sQ0FBQyxJQUFELEVBQU83UyxLQUFQLEVBQWM2TCxVQUFkLENBQWQ7QUFDRCxHQXRDaUUsQ0FzQ2hFOzs7QUFHRixNQUFJLE9BQU83TCxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCQSxJQUFBQSxLQUFLLEdBQUdrTSxVQUFVLENBQUNsTSxLQUFELEVBQVFtTSxRQUFSLENBQWxCO0FBQ0QsR0EzQ2lFLENBMkNoRTs7O0FBR0YsUUFBTTJHLFdBQVcsR0FBRzlTLEtBQUssQ0FBQ2lELE1BQTFCOztBQUVBLE1BQUk2UCxXQUFXLEtBQUssQ0FBcEIsRUFBdUI7QUFDckIsV0FBTyxDQUFDLENBQVIsQ0FEcUIsQ0FDVjtBQUNaOztBQUVELE1BQUlBLFdBQVcsS0FBSyxDQUFwQixFQUF1QjtBQUNyQjtBQUNBLFdBQU9ELE9BQU8sQ0FBQyxJQUFELEVBQU83UyxLQUFLLENBQUMsQ0FBRCxDQUFaLEVBQWlCNkwsVUFBakIsQ0FBZDtBQUNEOztBQUVELE1BQUlrSCxZQUFZLEdBQUdsSCxVQUFuQjtBQUNBLFFBQU1tSCxVQUFVLEdBQUcsS0FBSy9QLE1BQXhCOztBQUVBLE1BQUk2UCxXQUFXLEdBQUdFLFVBQWxCLEVBQThCO0FBQzVCLFdBQU8sQ0FBQyxDQUFSLENBRDRCLENBQ2pCO0FBQ1osR0E5RGlFLENBOERoRTtBQUNGOzs7QUFHQUMsRUFBQUEsVUFBVSxFQUFFLE9BQU9GLFlBQVksR0FBR0MsVUFBdEIsRUFBa0M7QUFDNUM7QUFDQTtBQUNBLFFBQUlFLGNBQWMsR0FBR0wsT0FBTyxDQUFDLElBQUQsRUFBTzdTLEtBQUssQ0FBQyxDQUFELENBQVosRUFBaUIrUyxZQUFqQixDQUE1Qjs7QUFFQSxRQUFJRyxjQUFjLEtBQUssQ0FBQyxDQUF4QixFQUEyQjtBQUN6QjtBQUNBLGFBQU8sQ0FBQyxDQUFSO0FBQ0QsS0FSMkMsQ0FRMUM7OztBQUdGLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0wsV0FBcEIsRUFBaUNLLENBQUMsRUFBbEMsRUFBc0M7QUFDcEMsVUFBSUQsY0FBYyxHQUFHQyxDQUFqQixJQUFzQkgsVUFBMUIsRUFBc0M7QUFDcENELFFBQUFBLFlBQVksR0FBR0csY0FBYyxHQUFHLENBQWhDLENBRG9DLENBQ0Q7O0FBRW5DLGlCQUFTRCxVQUFULENBSG9DLENBR2Y7QUFDdEI7O0FBRUQsVUFBSSxLQUFLQyxjQUFjLEdBQUdDLENBQXRCLE1BQTZCblQsS0FBSyxDQUFDbVQsQ0FBRCxDQUF0QyxFQUEyQztBQUN6QztBQUNBSixRQUFBQSxZQUFZLEdBQUdHLGNBQWMsR0FBRyxDQUFoQyxDQUZ5QyxDQUVOOztBQUVuQyxpQkFBU0QsVUFBVCxDQUp5QyxDQUlwQjtBQUN0QjtBQUNGOztBQUVELFdBQU9DLGNBQVAsQ0ExQjRDLENBMEJyQjtBQUN4Qjs7QUFFRCxTQUFPLENBQUMsQ0FBUjtBQUNELENBaEdEOztBQWtHQXBELFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJWLElBQW5CLEdBQTBCLFlBQVk7QUFDcEMsTUFBSStOLFNBQVMsR0FBRyxDQUFoQjtBQUNBLFFBQU1yRSxHQUFHLEdBQUcsS0FBS3pLLE1BQWpCO0FBQ0EsUUFBTW1RLFVBQVUsR0FBRztBQUNqQm5CLElBQUFBLElBQUksRUFBRSxZQUFZO0FBQ2hCLFVBQUlGLFNBQVMsR0FBR3JFLEdBQWhCLEVBQXFCO0FBQ25CLGNBQU13RSxNQUFNLEdBQUc7QUFDYmxTLFVBQUFBLEtBQUssRUFBRStSLFNBRE07QUFFYkksVUFBQUEsSUFBSSxFQUFFLEtBRk8sRUFBZjs7QUFJQUosUUFBQUEsU0FBUztBQUNULGVBQU9HLE1BQVA7QUFDRDs7QUFFRCxhQUFPO0FBQ0xsUyxRQUFBQSxLQUFLLEVBQUUrQixTQURGO0FBRUxvUSxRQUFBQSxJQUFJLEVBQUUsSUFGRCxFQUFQOztBQUlELEtBZmdCO0FBZ0JqQixLQUFDdlIsTUFBTSxDQUFDd1IsUUFBUixHQUFtQixZQUFZO0FBQzdCLGFBQU8sSUFBUDtBQUNELEtBbEJnQixFQUFuQjs7QUFvQkEsU0FBT2dCLFVBQVA7QUFDRCxDQXhCRDtBQXlCQTs7Ozs7O0FBTUF0RCxRQUFRLENBQUNwTCxTQUFULENBQW1CMk8sWUFBbkIsR0FBa0MsVUFBVTdGLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUN0RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYLENBRHNELENBQ3hCO0FBQzlCO0FBQ0E7O0FBRUFrQyxFQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLEdBQXNCLEtBQUtsQyxNQUFNLEVBQVgsQ0FBdEI7QUFDQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBa0MsRUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixHQUFzQixLQUFLbEMsTUFBTSxFQUFYLENBQXRCO0FBQ0FrQyxFQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLEdBQXNCLEtBQUtsQyxNQUFNLEVBQVgsQ0FBdEI7QUFDQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBa0MsRUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixHQUFzQixLQUFLbEMsTUFBTSxFQUFYLENBQXRCO0FBQ0FrQyxFQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLEdBQXNCLEtBQUtsQyxNQUFNLEVBQVgsQ0FBdEI7QUFDQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBLFNBQU9nQyxXQUFXLENBQUMsQ0FBRCxDQUFsQjtBQUNELENBZEQ7QUFlQTs7Ozs7O0FBTUFNLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUI2TyxZQUFuQixHQUFrQyxVQUFVL0YsTUFBTSxHQUFHLENBQW5CLEVBQXNCO0FBQ3REOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVgsQ0FEc0QsQ0FDeEI7QUFDOUI7QUFDQTs7QUFFQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBa0MsRUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixHQUFzQixLQUFLbEMsTUFBTSxFQUFYLENBQXRCO0FBQ0FrQyxFQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLEdBQXNCLEtBQUtsQyxNQUFNLEVBQVgsQ0FBdEI7QUFDQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBa0MsRUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixHQUFzQixLQUFLbEMsTUFBTSxFQUFYLENBQXRCO0FBQ0FrQyxFQUFBQSxnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLEdBQXNCLEtBQUtsQyxNQUFNLEVBQVgsQ0FBdEI7QUFDQWtDLEVBQUFBLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsR0FBc0IsS0FBS2xDLE1BQU0sRUFBWCxDQUF0QjtBQUNBa0MsRUFBQUEsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixHQUFzQixLQUFLbEMsTUFBTSxFQUFYLENBQXRCO0FBQ0EsU0FBT2dDLFdBQVcsQ0FBQyxDQUFELENBQWxCO0FBQ0QsQ0FkRDtBQWVBOzs7Ozs7QUFNQU0sUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjhPLFdBQW5CLEdBQWlDLFVBQVVoRyxNQUFNLEdBQUcsQ0FBbkIsRUFBc0I7QUFDckQ4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWCxDQURxRCxDQUN2QjtBQUM5QjtBQUNBOztBQUVBcUMsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQixLQUFLckMsTUFBTSxFQUFYLENBQXJCO0FBQ0FxQyxFQUFBQSxlQUFlLENBQUMsQ0FBRCxDQUFmLEdBQXFCLEtBQUtyQyxNQUFNLEVBQVgsQ0FBckI7QUFDQXFDLEVBQUFBLGVBQWUsQ0FBQyxDQUFELENBQWYsR0FBcUIsS0FBS3JDLE1BQU0sRUFBWCxDQUFyQjtBQUNBcUMsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQixLQUFLckMsTUFBTSxFQUFYLENBQXJCO0FBQ0EsU0FBT21DLFVBQVUsQ0FBQyxDQUFELENBQWpCO0FBQ0QsQ0FWRDtBQVdBOzs7Ozs7QUFNQUcsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQitPLFdBQW5CLEdBQWlDLFVBQVVqRyxNQUFNLEdBQUcsQ0FBbkIsRUFBc0I7QUFDckQ4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWCxDQURxRCxDQUN2QjtBQUM5QjtBQUNBOztBQUVBcUMsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQixLQUFLckMsTUFBTSxFQUFYLENBQXJCO0FBQ0FxQyxFQUFBQSxlQUFlLENBQUMsQ0FBRCxDQUFmLEdBQXFCLEtBQUtyQyxNQUFNLEVBQVgsQ0FBckI7QUFDQXFDLEVBQUFBLGVBQWUsQ0FBQyxDQUFELENBQWYsR0FBcUIsS0FBS3JDLE1BQU0sRUFBWCxDQUFyQjtBQUNBcUMsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQixLQUFLckMsTUFBTSxFQUFYLENBQXJCO0FBQ0EsU0FBT21DLFVBQVUsQ0FBQyxDQUFELENBQWpCO0FBQ0QsQ0FWRDtBQVdBOzs7Ozs7QUFNQUcsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQmdQLFFBQW5CLEdBQThCLFVBQVVsRyxNQUFNLEdBQUcsQ0FBbkIsRUFBc0I7QUFDbEQsUUFBTW1HLGFBQWEsR0FBRyxLQUFLQyxTQUFMLENBQWVwRyxNQUFmLENBQXRCO0FBQ0EsU0FBT3FHLGdCQUFnQixDQUFDRixhQUFELEVBQWdCLENBQWhCLENBQXZCO0FBQ0QsQ0FIRDtBQUlBOzs7Ozs7QUFNQTdELFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJvUCxXQUFuQixHQUFpQyxVQUFVdEcsTUFBVixFQUFrQjtBQUNqRCxRQUFNbUcsYUFBYSxHQUFHLEtBQUtJLFlBQUwsQ0FBa0J2RyxNQUFsQixDQUF0QjtBQUNBLFNBQU9xRyxnQkFBZ0IsQ0FBQ0YsYUFBRCxFQUFnQixDQUFoQixDQUF2QjtBQUNELENBSEQ7QUFJQTs7Ozs7O0FBTUE3RCxRQUFRLENBQUNwTCxTQUFULENBQW1Cc1AsV0FBbkIsR0FBaUMsVUFBVXhHLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUNyRCxRQUFNbUcsYUFBYSxHQUFHLEtBQUtNLFlBQUwsQ0FBa0J6RyxNQUFsQixDQUF0QjtBQUNBLFNBQU9xRyxnQkFBZ0IsQ0FBQ0YsYUFBRCxFQUFnQixDQUFoQixDQUF2QjtBQUNELENBSEQ7QUFJQTs7Ozs7O0FBTUE3RCxRQUFRLENBQUNwTCxTQUFULENBQW1Cd1AsV0FBbkIsR0FBaUMsVUFBVTFHLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUNyRCxRQUFNbUcsYUFBYSxHQUFHLEtBQUtRLFlBQUwsQ0FBa0IzRyxNQUFsQixDQUF0QjtBQUNBLFNBQU9xRyxnQkFBZ0IsQ0FBQ0YsYUFBRCxFQUFnQixDQUFoQixDQUF2QjtBQUNELENBSEQ7QUFJQTs7Ozs7O0FBTUE3RCxRQUFRLENBQUNwTCxTQUFULENBQW1CMFAsV0FBbkIsR0FBaUMsVUFBVTVHLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUNyRCxRQUFNbUcsYUFBYSxHQUFHLEtBQUtVLFlBQUwsQ0FBa0I3RyxNQUFsQixDQUF0QjtBQUNBLFNBQU9xRyxnQkFBZ0IsQ0FBQ0YsYUFBRCxFQUFnQixDQUFoQixDQUF2QjtBQUNELENBSEQ7QUFJQTs7Ozs7Ozs7QUFRQTdELFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUI0UCxTQUFuQixHQUErQixVQUFVOUcsTUFBVixFQUFrQmlELFVBQWxCLEVBQThCO0FBQzNELFFBQU1rRCxhQUFhLEdBQUcsS0FBS1ksVUFBTCxDQUFnQi9HLE1BQWhCLEVBQXdCaUQsVUFBeEIsQ0FBdEI7QUFDQSxTQUFPb0QsZ0JBQWdCLENBQUNGLGFBQUQsRUFBZ0JsRCxVQUFoQixDQUF2QjtBQUNELENBSEQ7QUFJQTs7Ozs7Ozs7QUFRQVgsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjhQLFNBQW5CLEdBQStCLFVBQVVoSCxNQUFWLEVBQWtCaUQsVUFBbEIsRUFBOEI7QUFDM0QsUUFBTWtELGFBQWEsR0FBRyxLQUFLYyxVQUFMLENBQWdCakgsTUFBaEIsRUFBd0JpRCxVQUF4QixDQUF0QjtBQUNBLFNBQU9vRCxnQkFBZ0IsQ0FBQ0YsYUFBRCxFQUFnQmxELFVBQWhCLENBQXZCO0FBQ0QsQ0FIRDtBQUlBOzs7Ozs7QUFNQVgsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQmtQLFNBQW5CLEdBQStCLFVBQVVwRyxNQUFNLEdBQUcsQ0FBbkIsRUFBc0I7QUFDbkQ4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWDtBQUNBLFNBQU8sS0FBS0EsTUFBTCxDQUFQO0FBQ0QsQ0FIRDtBQUlBOzs7Ozs7QUFNQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJxUCxZQUFuQixHQUFrQyxVQUFVdkcsTUFBTSxHQUFHLENBQW5CLEVBQXNCO0FBQ3REOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVgsQ0FEc0QsQ0FDeEI7O0FBRTlCLFNBQU8sS0FBS0EsTUFBTCxLQUFnQixDQUFoQixHQUFvQixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxDQUEzQjtBQUNELENBSkQ7QUFLQTs7Ozs7O0FBTUFzQyxRQUFRLENBQUNwTCxTQUFULENBQW1CdVAsWUFBbkIsR0FBa0MsVUFBVXpHLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUN0RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYLENBRHNELENBQ3hCOztBQUU5QixTQUFPLEtBQUtBLE1BQUwsSUFBZSxLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQUExQztBQUNELENBSkQ7QUFLQTs7Ozs7O0FBTUFzQyxRQUFRLENBQUNwTCxTQUFULENBQW1CeVAsWUFBbkIsR0FBa0MsVUFBVTNHLE1BQU0sR0FBRyxDQUFuQixFQUFzQjtBQUN0RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EsU0FBTyxLQUFLQSxNQUFMLElBQWUsU0FBZixJQUE0QixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixFQUFwQixHQUF5QixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQUE3QyxHQUFpRCxLQUFLQSxNQUFNLEdBQUcsQ0FBZCxDQUE3RSxDQUFQLENBRnNELENBRWlEO0FBQ3ZHO0FBQ0QsQ0FKRDtBQUtBOzs7Ozs7QUFNQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUIyUCxZQUFuQixHQUFrQyxVQUFVN0csTUFBTSxHQUFHLENBQW5CLEVBQXNCO0FBQ3REOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVg7QUFDQSxTQUFPLENBQUMsS0FBS0EsTUFBTCxJQUFlLEtBQUtBLE1BQU0sR0FBRyxDQUFkLEtBQW9CLENBQW5DLEdBQXVDLEtBQUtBLE1BQU0sR0FBRyxDQUFkLEtBQW9CLEVBQTVELElBQWtFLEtBQUtBLE1BQU0sR0FBRyxDQUFkLElBQW1CLFNBQTVGLENBRnNELENBRWlEO0FBQ3hHLENBSEQ7QUFJQTs7Ozs7OztBQU9Bc0MsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjZQLFVBQW5CLEdBQWdDLFVBQVUvRyxNQUFWLEVBQWtCaUQsVUFBbEIsRUFBOEI7QUFDNUQsTUFBSUEsVUFBVSxJQUFJLENBQWQsSUFBbUJBLFVBQVUsR0FBRyxDQUFwQyxFQUF1QztBQUNyQyxVQUFNLElBQUkxRyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNEOztBQUVEdUosRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZWlELFVBQWYsQ0FBWDtBQUNBLE1BQUl5QixNQUFNLEdBQUcsQ0FBYjtBQUNBLE1BQUl3QyxVQUFVLEdBQUcsQ0FBakIsQ0FQNEQsQ0FPeEM7QUFDcEI7O0FBRUEsT0FBSyxJQUFJdlIsQ0FBQyxHQUFHc04sVUFBVSxHQUFHLENBQTFCLEVBQTZCdE4sQ0FBQyxJQUFJLENBQWxDLEVBQXFDQSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3hDK08sSUFBQUEsTUFBTSxJQUFJLEtBQUtsRSxnQkFBTCxDQUFzQlIsTUFBTSxHQUFHckssQ0FBL0IsSUFBb0N1UixVQUE5QztBQUNBQSxJQUFBQSxVQUFVLElBQUksS0FBZCxDQUZ3QyxDQUVuQjtBQUN0Qjs7QUFFRCxTQUFPeEMsTUFBUDtBQUNELENBaEJEO0FBaUJBOzs7Ozs7O0FBT0FwQyxRQUFRLENBQUNwTCxTQUFULENBQW1CK1AsVUFBbkIsR0FBZ0MsVUFBVWpILE1BQVYsRUFBa0JpRCxVQUFsQixFQUE4QjtBQUM1RCxNQUFJQSxVQUFVLElBQUksQ0FBZCxJQUFtQkEsVUFBVSxHQUFHLENBQXBDLEVBQXVDO0FBQ3JDLFVBQU0sSUFBSTFHLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUR1SixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlaUQsVUFBZixDQUFYO0FBQ0EsTUFBSXlCLE1BQU0sR0FBRyxDQUFiO0FBQ0EsTUFBSXdDLFVBQVUsR0FBRyxDQUFqQixDQVA0RCxDQU94Qzs7QUFFcEIsT0FBSyxJQUFJdlIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NOLFVBQXBCLEVBQWdDdE4sQ0FBQyxFQUFqQyxFQUFxQztBQUNuQytPLElBQUFBLE1BQU0sSUFBSSxLQUFLbEUsZ0JBQUwsQ0FBc0JSLE1BQU0sR0FBR3JLLENBQS9CLElBQW9DdVIsVUFBOUM7QUFDQUEsSUFBQUEsVUFBVSxJQUFJLEtBQWQsQ0FGbUMsQ0FFZDtBQUN0Qjs7QUFFRCxTQUFPeEMsTUFBUDtBQUNELENBZkQ7QUFnQkE7Ozs7Ozs7QUFPQXBDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJ1RyxLQUFuQixHQUEyQixVQUFVVyxLQUFWLEVBQWlCOEIsR0FBakIsRUFBc0I7QUFDL0MsUUFBTXNGLFVBQVUsR0FBRyxLQUFLL1AsTUFBeEI7O0FBRUEsTUFBSSxPQUFPMkksS0FBUCxLQUFpQixXQUFyQixFQUFrQztBQUNoQ0EsSUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRCxHQUZELE1BRU8sSUFBSUEsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNwQkEsSUFBQUEsS0FBSyxHQUFHb0gsVUFBVSxHQUFHcEgsS0FBckI7O0FBRUEsUUFBSUEsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNiO0FBQ0FBLE1BQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLE9BQU84QixHQUFQLEtBQWUsV0FBbkIsRUFBZ0M7QUFDOUJBLElBQUFBLEdBQUcsR0FBR3NGLFVBQU47QUFDRCxHQUZELE1BRU8sSUFBSXRGLEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFDbEJBLElBQUFBLEdBQUcsR0FBR3NGLFVBQVUsR0FBR3RGLEdBQW5CO0FBQ0QsR0FsQjhDLENBa0I3Qzs7O0FBR0YsTUFBSUEsR0FBRyxHQUFHc0YsVUFBVixFQUFzQjtBQUNwQnRGLElBQUFBLEdBQUcsR0FBR3NGLFVBQU47QUFDRCxHQXZCOEMsQ0F1QjdDOzs7QUFHRixNQUFJL1AsTUFBTSxHQUFHeUssR0FBRyxHQUFHOUIsS0FBbkI7O0FBRUEsTUFBSTNJLE1BQU0sSUFBSSxDQUFkLEVBQWlCO0FBQ2ZBLElBQUFBLE1BQU0sR0FBRyxDQUFULENBRGUsQ0FDSDtBQUNiLEdBOUI4QyxDQThCN0M7OztBQUdGLFNBQU8sS0FBS3NLLE1BQUwsQ0FBWSxLQUFLMUIsVUFBTCxHQUFrQkQsS0FBOUIsRUFBcUMzSSxNQUFyQyxDQUFQO0FBQ0QsQ0FsQ0Q7O0FBb0NBNk0sUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjZJLE1BQW5CLEdBQTRCLFVBQVVDLE1BQVYsRUFBa0J2SyxNQUFsQixFQUEwQjtBQUNwRCxTQUFPLElBQUlpSSxVQUFKLENBQWUsS0FBSzhCLE1BQXBCLEVBQTRCUSxNQUE1QixFQUFvQ3ZLLE1BQXBDLENBQVA7QUFDRCxDQUZEO0FBR0E7Ozs7Ozs7QUFPQTZNLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJpUSxRQUFuQixHQUE4QixVQUFVL0ksS0FBVixFQUFpQjhCLEdBQWpCLEVBQXNCO0FBQ2xELFNBQU8sS0FBS3pDLEtBQUwsQ0FBV1csS0FBWCxFQUFrQjhCLEdBQWxCLENBQVA7QUFDRCxDQUZEO0FBR0E7Ozs7Ozs7QUFPQW9DLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJrUSxNQUFuQixHQUE0QixZQUFZO0FBQ3RDLFFBQU0zUixNQUFNLEdBQUcsS0FBS0EsTUFBcEI7O0FBRUEsTUFBSUEsTUFBTSxHQUFHLENBQVQsS0FBZSxDQUFuQixFQUFzQjtBQUNwQixVQUFNLElBQUk4RyxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEOztBQUVELE9BQUssSUFBSTVHLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLE1BQXBCLEVBQTRCRSxDQUFDLElBQUksQ0FBakMsRUFBb0M7QUFDbEMsVUFBTTBSLEtBQUssR0FBRyxLQUFLN0csZ0JBQUwsQ0FBc0I3SyxDQUF0QixDQUFkO0FBQ0EsVUFBTTJSLE1BQU0sR0FBRyxLQUFLOUcsZ0JBQUwsQ0FBc0I3SyxDQUFDLEdBQUcsQ0FBMUIsQ0FBZjtBQUNBLFNBQUsrSyxnQkFBTCxDQUFzQi9LLENBQXRCLEVBQXlCMlIsTUFBekI7QUFDQSxTQUFLNUcsZ0JBQUwsQ0FBc0IvSyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkIwUixLQUE3QjtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBZkQ7QUFnQkE7Ozs7Ozs7QUFPQS9FLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJxUSxNQUFuQixHQUE0QixZQUFZO0FBQ3RDLFFBQU05UixNQUFNLEdBQUcsS0FBS0EsTUFBcEI7O0FBRUEsTUFBSUEsTUFBTSxHQUFHLENBQVQsS0FBZSxDQUFuQixFQUFzQjtBQUNwQixVQUFNLElBQUk4RyxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEOztBQUVELE9BQUssSUFBSTVHLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLE1BQXBCLEVBQTRCRSxDQUFDLElBQUksQ0FBakMsRUFBb0M7QUFDbEMsVUFBTTBSLEtBQUssR0FBRyxLQUFLN0csZ0JBQUwsQ0FBc0I3SyxDQUF0QixDQUFkO0FBQ0EsVUFBTTJSLE1BQU0sR0FBRyxLQUFLOUcsZ0JBQUwsQ0FBc0I3SyxDQUFDLEdBQUcsQ0FBMUIsQ0FBZjtBQUNBLFVBQU02UixLQUFLLEdBQUcsS0FBS2hILGdCQUFMLENBQXNCN0ssQ0FBQyxHQUFHLENBQTFCLENBQWQ7QUFDQSxVQUFNOFIsTUFBTSxHQUFHLEtBQUtqSCxnQkFBTCxDQUFzQjdLLENBQUMsR0FBRyxDQUExQixDQUFmO0FBQ0EsU0FBSytLLGdCQUFMLENBQXNCL0ssQ0FBdEIsRUFBeUI4UixNQUF6QjtBQUNBLFNBQUsvRyxnQkFBTCxDQUFzQi9LLENBQUMsR0FBRyxDQUExQixFQUE2QjZSLEtBQTdCO0FBQ0EsU0FBSzlHLGdCQUFMLENBQXNCL0ssQ0FBQyxHQUFHLENBQTFCLEVBQTZCMlIsTUFBN0I7QUFDQSxTQUFLNUcsZ0JBQUwsQ0FBc0IvSyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkIwUixLQUE3QjtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNELENBbkJEO0FBb0JBOzs7Ozs7O0FBT0EvRSxRQUFRLENBQUNwTCxTQUFULENBQW1Cd1EsTUFBbkIsR0FBNEIsWUFBWTtBQUN0QyxRQUFNalMsTUFBTSxHQUFHLEtBQUtBLE1BQXBCOztBQUVBLE1BQUlBLE1BQU0sR0FBRyxDQUFULEtBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsVUFBTSxJQUFJOEcsVUFBSixDQUFlLDJDQUFmLENBQU47QUFDRDs7QUFFRCxPQUFLLElBQUk1RyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixNQUFwQixFQUE0QkUsQ0FBQyxJQUFJLENBQWpDLEVBQW9DO0FBQ2xDLFVBQU0wUixLQUFLLEdBQUcsS0FBSzdHLGdCQUFMLENBQXNCN0ssQ0FBdEIsQ0FBZDtBQUNBLFVBQU0yUixNQUFNLEdBQUcsS0FBSzlHLGdCQUFMLENBQXNCN0ssQ0FBQyxHQUFHLENBQTFCLENBQWY7QUFDQSxVQUFNNlIsS0FBSyxHQUFHLEtBQUtoSCxnQkFBTCxDQUFzQjdLLENBQUMsR0FBRyxDQUExQixDQUFkO0FBQ0EsVUFBTThSLE1BQU0sR0FBRyxLQUFLakgsZ0JBQUwsQ0FBc0I3SyxDQUFDLEdBQUcsQ0FBMUIsQ0FBZjtBQUNBLFVBQU1nUyxLQUFLLEdBQUcsS0FBS25ILGdCQUFMLENBQXNCN0ssQ0FBQyxHQUFHLENBQTFCLENBQWQ7QUFDQSxVQUFNaVMsS0FBSyxHQUFHLEtBQUtwSCxnQkFBTCxDQUFzQjdLLENBQUMsR0FBRyxDQUExQixDQUFkO0FBQ0EsVUFBTWtTLE9BQU8sR0FBRyxLQUFLckgsZ0JBQUwsQ0FBc0I3SyxDQUFDLEdBQUcsQ0FBMUIsQ0FBaEI7QUFDQSxVQUFNbVMsTUFBTSxHQUFHLEtBQUt0SCxnQkFBTCxDQUFzQjdLLENBQUMsR0FBRyxDQUExQixDQUFmO0FBQ0EsU0FBSytLLGdCQUFMLENBQXNCL0ssQ0FBdEIsRUFBeUJtUyxNQUF6QjtBQUNBLFNBQUtwSCxnQkFBTCxDQUFzQi9LLENBQUMsR0FBRyxDQUExQixFQUE2QmtTLE9BQTdCO0FBQ0EsU0FBS25ILGdCQUFMLENBQXNCL0ssQ0FBQyxHQUFHLENBQTFCLEVBQTZCaVMsS0FBN0I7QUFDQSxTQUFLbEgsZ0JBQUwsQ0FBc0IvSyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkJnUyxLQUE3QjtBQUNBLFNBQUtqSCxnQkFBTCxDQUFzQi9LLENBQUMsR0FBRyxDQUExQixFQUE2QjhSLE1BQTdCO0FBQ0EsU0FBSy9HLGdCQUFMLENBQXNCL0ssQ0FBQyxHQUFHLENBQTFCLEVBQTZCNlIsS0FBN0I7QUFDQSxTQUFLOUcsZ0JBQUwsQ0FBc0IvSyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkIyUixNQUE3QjtBQUNBLFNBQUs1RyxnQkFBTCxDQUFzQi9LLENBQUMsR0FBRyxDQUExQixFQUE2QjBSLEtBQTdCO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0EzQkQ7QUE0QkE7Ozs7O0FBS0EvRSxRQUFRLENBQUNwTCxTQUFULENBQW1CNlEsTUFBbkIsR0FBNEIsWUFBWTtBQUN0QyxTQUFPO0FBQ0xoTCxJQUFBQSxJQUFJLEVBQUUsUUFERDtBQUVMO0FBQ0E7QUFDQWlMLElBQUFBLElBQUksRUFBRSxHQUFHdkssS0FBSCxDQUFTM0gsSUFBVCxDQUFjLElBQWQsQ0FKRCxFQUFQOztBQU1ELENBUEQ7QUFRQTs7Ozs7Ozs7QUFRQXdNLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJTLFFBQW5CLEdBQThCLFVBQVVnSCxRQUFWLEVBQW9CUCxLQUFwQixFQUEyQjhCLEdBQTNCLEVBQWdDO0FBQzVEO0FBQ0EsTUFBSWxLLFNBQVMsQ0FBQ1AsTUFBVixLQUFxQixDQUF6QixFQUE0QjtBQUMxQixXQUFPLEtBQUtvTCxVQUFMLEdBQWtCbEosUUFBbEIsRUFBUDtBQUNEOztBQUVELFFBQU1sQyxNQUFNLEdBQUcsS0FBS0EsTUFBcEI7O0FBRUEsTUFBSTJJLEtBQUssSUFBSTNJLE1BQWIsRUFBcUI7QUFDbkIsV0FBTyxFQUFQLENBRG1CLENBQ1I7QUFDWjs7QUFFRCxNQUFJMkksS0FBSyxHQUFHLENBQVIsSUFBYSxPQUFPQSxLQUFQLEtBQWlCLFFBQWxDLEVBQTRDO0FBQzFDQSxJQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUVELE1BQUk4QixHQUFHLEdBQUd6SyxNQUFOLElBQWdCLE9BQU95SyxHQUFQLEtBQWUsUUFBbkMsRUFBNkM7QUFDM0M7QUFDQUEsSUFBQUEsR0FBRyxHQUFHekssTUFBTjtBQUNELEdBbkIyRCxDQW1CMUQ7OztBQUdGLE1BQUl5SyxHQUFHLElBQUk5QixLQUFYLEVBQWtCO0FBQ2hCLFdBQU8sRUFBUCxDQURnQixDQUNMO0FBQ1osR0F4QjJELENBd0IxRDs7O0FBR0YsTUFBSUEsS0FBSyxLQUFLLENBQVYsSUFBZThCLEdBQUcsS0FBS3pLLE1BQTNCLEVBQW1DO0FBQ2pDLFdBQU8sS0FBS2dJLEtBQUwsQ0FBV1csS0FBWCxFQUFrQjhCLEdBQWxCLEVBQXVCdkksUUFBdkIsQ0FBZ0NnSCxRQUFoQyxDQUFQO0FBQ0QsR0E3QjJELENBNkIxRDs7O0FBR0YsTUFBSUEsUUFBUSxLQUFLcEssU0FBakIsRUFBNEI7QUFDMUJvSyxJQUFBQSxRQUFRLEdBQUcsTUFBWDtBQUNELEdBRkQsTUFFTztBQUNMQSxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ0csV0FBVCxFQUFYLENBREssQ0FDOEI7O0FBRW5DLFFBQUksQ0FBQ3dELFFBQVEsQ0FBQ3pELFVBQVQsQ0FBb0JGLFFBQXBCLENBQUwsRUFBb0M7QUFDbEMsWUFBTSxJQUFJM0IsU0FBSixDQUFlLHFCQUFvQjJCLFFBQVMsRUFBNUMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUEsUUFBUSxLQUFLLE1BQWIsSUFBdUJBLFFBQVEsS0FBSyxPQUF4QyxFQUFpRDtBQUMvQyxXQUFPLEtBQUtrQyxVQUFMLEdBQWtCbEosUUFBbEIsRUFBUCxDQUQrQyxDQUNWO0FBQ3RDOztBQUVELE1BQUlnSCxRQUFRLEtBQUssUUFBakIsRUFBMkI7QUFDekIsV0FBT2hNLEVBQUUsQ0FBQ3FNLEtBQUgsQ0FBU2lKLFlBQVQsQ0FBc0IsS0FBS3BILFVBQUwsR0FBa0JxSCxNQUFsQixFQUF0QixFQUFrRHZRLFFBQWxELEVBQVA7QUFDRDs7QUFFRCxNQUFJZ0gsUUFBUSxLQUFLLEtBQWpCLEVBQXdCO0FBQ3RCLFdBQU8sS0FBS3dKLFFBQUwsQ0FBYyxDQUFkLEVBQWlCMVMsTUFBakIsQ0FBUDtBQUNEOztBQUVELE1BQUlrSixRQUFRLEtBQUssUUFBYixJQUF5QkEsUUFBUSxLQUFLLFFBQTFDLEVBQW9EO0FBQ2xELFFBQUl5SixZQUFZLEdBQUcsRUFBbkI7O0FBRUEsU0FBSyxJQUFJelMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsTUFBcEIsRUFBNEJFLENBQUMsRUFBN0IsRUFBaUM7QUFDL0I7QUFDQXlTLE1BQUFBLFlBQVksSUFBSTVLLE1BQU0sQ0FBQzZLLFlBQVAsQ0FBb0IsS0FBSzdILGdCQUFMLENBQXNCN0ssQ0FBdEIsQ0FBcEIsQ0FBaEI7QUFDRDs7QUFFRCxXQUFPeVMsWUFBUDtBQUNEOztBQUVELE1BQUl6SixRQUFRLEtBQUssT0FBakIsRUFBMEI7QUFDeEIsUUFBSTJKLEtBQUssR0FBRyxFQUFaOztBQUVBLFNBQUssSUFBSTNTLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLE1BQXBCLEVBQTRCRSxDQUFDLEVBQTdCLEVBQWlDO0FBQy9CO0FBQ0EyUyxNQUFBQSxLQUFLLElBQUk5SyxNQUFNLENBQUM2SyxZQUFQLENBQW9CLEtBQUs3SCxnQkFBTCxDQUFzQjdLLENBQXRCLElBQTJCLElBQS9DLENBQVQ7QUFDRDs7QUFFRCxXQUFPMlMsS0FBUDtBQUNELEdBMUUyRCxDQTBFMUQ7OztBQUdGLFNBQU8sS0FBS0MsU0FBTCxDQUFlLENBQWYsRUFBa0I5UyxNQUFsQixDQUFQO0FBQ0QsQ0E5RUQ7O0FBZ0ZBNk0sUUFBUSxDQUFDcEwsU0FBVCxDQUFtQnNKLGdCQUFuQixHQUFzQyxVQUFVQyxLQUFWLEVBQWlCO0FBQ3JELFNBQU8sS0FBS0EsS0FBTCxDQUFQO0FBQ0QsQ0FGRDs7QUFJQTZCLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJ3SixnQkFBbkIsR0FBc0MsVUFBVUQsS0FBVixFQUFpQmpPLEtBQWpCLEVBQXdCO0FBQzVELFNBQU8sS0FBS2lPLEtBQUwsSUFBY2pPLEtBQXJCO0FBQ0QsQ0FGRDs7QUFJQThQLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJpUixRQUFuQixHQUE4QixVQUFVL0osS0FBVixFQUFpQjhCLEdBQWpCLEVBQXNCO0FBQ2xELE1BQUlzSSxNQUFNLEdBQUcsRUFBYjs7QUFFQSxPQUFLLElBQUk3UyxDQUFDLEdBQUd5SSxLQUFiLEVBQW9CekksQ0FBQyxHQUFHdUssR0FBeEIsRUFBNkJ2SyxDQUFDLEVBQTlCLEVBQWtDO0FBQ2hDO0FBQ0EsUUFBSThTLEdBQUcsR0FBRyxDQUFDLEtBQUtqSSxnQkFBTCxDQUFzQjdLLENBQXRCLElBQTJCLElBQTVCLEVBQWtDZ0MsUUFBbEMsQ0FBMkMsRUFBM0MsQ0FBVjtBQUNBOFEsSUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUNoVCxNQUFKLEtBQWUsQ0FBZixHQUFtQixNQUFNZ1QsR0FBekIsR0FBK0JBLEdBQXJDO0FBQ0FELElBQUFBLE1BQU0sSUFBSUMsR0FBVjtBQUNEOztBQUVELFNBQU9ELE1BQVA7QUFDRCxDQVhEOztBQWFBbEcsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQnFSLFNBQW5CLEdBQStCLFVBQVVuSyxLQUFWLEVBQWlCOEIsR0FBakIsRUFBc0I7QUFDbkQsTUFBSXdJLEdBQUcsR0FBRyxFQUFWO0FBQ0EsTUFBSS9TLENBQUMsR0FBR3lJLEtBQVI7O0FBRUEsU0FBT3pJLENBQUMsR0FBR3VLLEdBQVgsRUFBZ0I7QUFDZDtBQUNBLFVBQU15SSxLQUFLLEdBQUcsS0FBS25JLGdCQUFMLENBQXNCN0ssQ0FBQyxFQUF2QixDQUFkO0FBQ0EsVUFBTWlULEtBQUssR0FBRyxLQUFLcEksZ0JBQUwsQ0FBc0I3SyxDQUFDLEVBQXZCLENBQWQ7QUFDQSxVQUFNa1QsU0FBUyxHQUFHLENBQUNELEtBQUssSUFBSSxDQUFWLElBQWVELEtBQWpDLENBSmMsQ0FJMEI7O0FBRXhDRCxJQUFBQSxHQUFHLElBQUlsTCxNQUFNLENBQUNzTCxhQUFQLENBQXFCRCxTQUFyQixDQUFQO0FBQ0Q7O0FBRUQsU0FBT0gsR0FBUDtBQUNELENBZEQ7QUFlQTs7Ozs7O0FBTUFwRyxRQUFRLENBQUNwTCxTQUFULENBQW1CMkosVUFBbkIsR0FBZ0MsWUFBWTtBQUMxQyxRQUFNMUMsUUFBUSxHQUFHeEwsRUFBRSxDQUFDaU4sWUFBSCxDQUFnQjtBQUMvQm5LLElBQUFBLE1BQU0sRUFBRSxLQUFLQSxNQURrQixFQUFoQixDQUFqQjs7QUFHQXNULEVBQUFBLFVBQVUsQ0FBQyxJQUFELEVBQU81SyxRQUFQLEVBQWlCLENBQWpCLEVBQW9CLEtBQUsxSSxNQUF6QixDQUFWO0FBQ0EsU0FBTzBJLFFBQVA7QUFDRCxDQU5EO0FBT0E7Ozs7Ozs7OztBQVNBLFNBQVM0SyxVQUFULENBQW9CcEksR0FBcEIsRUFBeUJtRCxJQUF6QixFQUErQjlELE1BQS9CLEVBQXVDdkssTUFBdkMsRUFBK0M7QUFDN0MsUUFBTXVULFNBQVMsR0FBR3JJLEdBQUcsQ0FBQ2xMLE1BQXRCO0FBQ0EsUUFBTXNPLFVBQVUsR0FBR0QsSUFBSSxDQUFDck8sTUFBeEI7QUFDQSxNQUFJRSxDQUFDLEdBQUcsQ0FBUjs7QUFFQSxTQUFPQSxDQUFDLEdBQUdGLE1BQVgsRUFBbUJFLENBQUMsRUFBcEIsRUFBd0I7QUFDdEIsVUFBTXNULFNBQVMsR0FBR3RULENBQUMsR0FBR3FLLE1BQXRCLENBRHNCLENBQ1E7O0FBRTlCLFFBQUlpSixTQUFTLElBQUlsRixVQUFiLElBQTJCcE8sQ0FBQyxJQUFJcVQsU0FBcEMsRUFBK0M7QUFDN0M7QUFDRDs7QUFFRGxGLElBQUFBLElBQUksQ0FBQ21GLFNBQUQsQ0FBSixHQUFrQnRJLEdBQUcsQ0FBQ2hMLENBQUQsQ0FBckI7QUFDRDs7QUFFRCxTQUFPQSxDQUFQO0FBQ0Q7QUFDRDs7OztBQUlBOzs7QUFHQTJNLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJnUyxNQUFuQixHQUE0QixZQUFZO0FBQ3RDLFFBQU0xSixNQUFNLEdBQUcsSUFBZjtBQUNBLE1BQUkrRSxTQUFTLEdBQUcsQ0FBaEI7QUFDQSxRQUFNckUsR0FBRyxHQUFHLEtBQUt6SyxNQUFqQjtBQUNBLFFBQU1tUSxVQUFVLEdBQUc7QUFDakJuQixJQUFBQSxJQUFJLEVBQUUsWUFBWTtBQUNoQixVQUFJRixTQUFTLEdBQUdyRSxHQUFoQixFQUFxQjtBQUNuQixjQUFNd0UsTUFBTSxHQUFHO0FBQ2JsUyxVQUFBQSxLQUFLLEVBQUVnTixNQUFNLENBQUNnQixnQkFBUCxDQUF3QitELFNBQXhCLENBRE07QUFFYkksVUFBQUEsSUFBSSxFQUFFLEtBRk8sRUFBZjs7QUFJQUosUUFBQUEsU0FBUztBQUNULGVBQU9HLE1BQVA7QUFDRDs7QUFFRCxhQUFPO0FBQ0xsUyxRQUFBQSxLQUFLLEVBQUUrQixTQURGO0FBRUxvUSxRQUFBQSxJQUFJLEVBQUUsSUFGRCxFQUFQOztBQUlELEtBZmdCO0FBZ0JqQixLQUFDdlIsTUFBTSxDQUFDd1IsUUFBUixHQUFtQixZQUFZO0FBQzdCLGFBQU8sSUFBUDtBQUNELEtBbEJnQixFQUFuQjs7QUFvQkEsU0FBT2dCLFVBQVA7QUFDRCxDQXpCRDtBQTBCQTs7OztBQUlBOzs7QUFHQXRELFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUI5RCxNQUFNLENBQUN3UixRQUExQixJQUFzQyxZQUFZO0FBQ2hELFNBQU8sS0FBS3NFLE1BQUwsRUFBUDtBQUNELENBRkQ7QUFHQTs7Ozs7Ozs7Ozs7OztBQWFBNUcsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQmlTLEtBQW5CLEdBQTJCLFVBQVVDLE1BQVYsRUFBa0JwSixNQUFsQixFQUEwQnZLLE1BQTFCLEVBQWtDa0osUUFBbEMsRUFBNEM7QUFDckUsTUFBSSxPQUFPcUIsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QnJCLElBQUFBLFFBQVEsR0FBR3FCLE1BQVg7QUFDQUEsSUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDQXZLLElBQUFBLE1BQU0sR0FBRyxLQUFLQSxNQUFkO0FBQ0QsR0FKRCxNQUlPLElBQUksT0FBT0EsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUNyQ2tKLElBQUFBLFFBQVEsR0FBR2xKLE1BQVg7QUFDQUEsSUFBQUEsTUFBTSxHQUFHLEtBQUtBLE1BQUwsR0FBY3VLLE1BQXZCO0FBQ0QsR0FITSxNQUdBO0FBQ0w7QUFDQSxVQUFNb0UsU0FBUyxHQUFHLEtBQUszTyxNQUFMLEdBQWN1SyxNQUFoQzs7QUFFQSxRQUFJdkssTUFBTSxHQUFHMk8sU0FBYixFQUF3QjtBQUN0QjNPLE1BQUFBLE1BQU0sR0FBRzJPLFNBQVQ7QUFDRDtBQUNGOztBQUVEekYsRUFBQUEsUUFBUSxHQUFHQSxRQUFRLElBQUksTUFBdkIsQ0FqQnFFLENBaUJ0Qzs7QUFFL0IsUUFBTWdDLEdBQUcsR0FBR2pDLFVBQVUsQ0FBQzBLLE1BQUQsRUFBU3pLLFFBQVQsQ0FBdEIsQ0FuQnFFLENBbUIzQjtBQUMxQzs7QUFFQSxTQUFPZ0MsR0FBRyxDQUFDMEMsSUFBSixDQUFTLElBQVQsRUFBZXJELE1BQWYsRUFBdUIsQ0FBdkIsRUFBMEJ2SyxNQUExQixDQUFQO0FBQ0QsQ0F2QkQ7O0FBeUJBNk0sUUFBUSxDQUFDcEwsU0FBVCxDQUFtQm1TLGFBQW5CLEdBQW1DLFVBQVU3VyxLQUFWLEVBQWlCd04sTUFBTSxHQUFHLENBQTFCLEVBQTZCO0FBQzlEOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVg7QUFDQWdDLEVBQUFBLFdBQVcsQ0FBQyxDQUFELENBQVgsR0FBaUJ4UCxLQUFqQjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ2tDLGdCQUFnQixDQUFDLENBQUQsQ0FBaEQ7QUFDQSxPQUFLeEIsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsT0FBS3hCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDa0MsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRDtBQUNBLE9BQUt4QixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ2tDLGdCQUFnQixDQUFDLENBQUQsQ0FBaEQ7QUFDQSxPQUFLeEIsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsT0FBS3hCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDa0MsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRDtBQUNBLE9BQUt4QixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ2tDLGdCQUFnQixDQUFDLENBQUQsQ0FBaEQ7QUFDQSxPQUFLeEIsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsU0FBT2xDLE1BQVAsQ0FYOEQsQ0FXL0M7QUFDaEIsQ0FaRDs7QUFjQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJvUyxhQUFuQixHQUFtQyxVQUFVOVcsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUM5RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0FnQyxFQUFBQSxXQUFXLENBQUMsQ0FBRCxDQUFYLEdBQWlCeFAsS0FBakI7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsT0FBS3hCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDa0MsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRDtBQUNBLE9BQUt4QixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ2tDLGdCQUFnQixDQUFDLENBQUQsQ0FBaEQ7QUFDQSxPQUFLeEIsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsT0FBS3hCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDa0MsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRDtBQUNBLE9BQUt4QixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ2tDLGdCQUFnQixDQUFDLENBQUQsQ0FBaEQ7QUFDQSxPQUFLeEIsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NrQyxnQkFBZ0IsQ0FBQyxDQUFELENBQWhEO0FBQ0EsT0FBS3hCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDa0MsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoRDtBQUNBLFNBQU9sQyxNQUFQLENBWDhELENBVy9DO0FBQ2hCLENBWkQ7O0FBY0FzQyxRQUFRLENBQUNwTCxTQUFULENBQW1CcVMsWUFBbkIsR0FBa0MsVUFBVS9XLEtBQVYsRUFBaUJ3TixNQUFNLEdBQUcsQ0FBMUIsRUFBNkI7QUFDN0Q4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWDtBQUNBbUMsRUFBQUEsVUFBVSxDQUFDLENBQUQsQ0FBVixHQUFnQjNQLEtBQWhCO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDcUMsZUFBZSxDQUFDLENBQUQsQ0FBL0M7QUFDQSxPQUFLM0IsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NxQyxlQUFlLENBQUMsQ0FBRCxDQUEvQztBQUNBLE9BQUszQixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ3FDLGVBQWUsQ0FBQyxDQUFELENBQS9DO0FBQ0EsT0FBSzNCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDcUMsZUFBZSxDQUFDLENBQUQsQ0FBL0M7QUFDQSxTQUFPckMsTUFBUCxDQVA2RCxDQU85QztBQUNoQixDQVJEOztBQVVBc0MsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQnNTLFlBQW5CLEdBQWtDLFVBQVVoWCxLQUFWLEVBQWlCd04sTUFBTSxHQUFHLENBQTFCLEVBQTZCO0FBQzdEOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVg7QUFDQW1DLEVBQUFBLFVBQVUsQ0FBQyxDQUFELENBQVYsR0FBZ0IzUCxLQUFoQjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ3FDLGVBQWUsQ0FBQyxDQUFELENBQS9DO0FBQ0EsT0FBSzNCLGdCQUFMLENBQXNCVixNQUFNLEVBQTVCLEVBQWdDcUMsZUFBZSxDQUFDLENBQUQsQ0FBL0M7QUFDQSxPQUFLM0IsZ0JBQUwsQ0FBc0JWLE1BQU0sRUFBNUIsRUFBZ0NxQyxlQUFlLENBQUMsQ0FBRCxDQUEvQztBQUNBLE9BQUszQixnQkFBTCxDQUFzQlYsTUFBTSxFQUE1QixFQUFnQ3FDLGVBQWUsQ0FBQyxDQUFELENBQS9DO0FBQ0EsU0FBT3JDLE1BQVAsQ0FQNkQsQ0FPOUM7QUFDaEIsQ0FSRDtBQVNBOzs7Ozs7O0FBT0FzQyxRQUFRLENBQUNwTCxTQUFULENBQW1CdVMsU0FBbkIsR0FBK0IsVUFBVWpYLEtBQVYsRUFBaUJ3TixNQUFNLEdBQUcsQ0FBMUIsRUFBNkI7QUFDMUQ4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWDtBQUNBMEosRUFBQUEsVUFBVSxDQUFDbFgsS0FBRCxFQUFRLENBQUMsR0FBVCxFQUFjLEdBQWQsQ0FBVjs7QUFFQSxNQUFJQSxLQUFLLElBQUksQ0FBYixFQUFnQjtBQUNkO0FBQ0EsU0FBS2tPLGdCQUFMLENBQXNCVixNQUF0QixFQUE4QnhOLEtBQTlCO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQSxTQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQXRCLEVBQThCLE9BQU94TixLQUFQLEdBQWUsQ0FBN0MsRUFGSyxDQUU0QztBQUNsRDs7QUFFRCxTQUFPd04sTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FiRDtBQWNBOzs7Ozs7O0FBT0FzQyxRQUFRLENBQUNwTCxTQUFULENBQW1CeVMsWUFBbkIsR0FBa0MsVUFBVW5YLEtBQVYsRUFBaUJ3TixNQUFNLEdBQUcsQ0FBMUIsRUFBNkI7QUFDN0Q4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWDtBQUNBMEosRUFBQUEsVUFBVSxDQUFDbFgsS0FBRCxFQUFRLENBQUMsS0FBVCxFQUFnQixLQUFoQixDQUFWO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUF0QixFQUE4QnhOLEtBQUssS0FBSyxDQUF4QyxFQUg2RCxDQUdqQjs7QUFFNUMsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEdBQUcsQ0FBL0IsRUFBa0N4TixLQUFLLEdBQUcsSUFBMUMsRUFMNkQsQ0FLWjs7QUFFakQsU0FBT3dOLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUkQ7QUFTQTs7Ozs7OztBQU9Bc0MsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjBTLFlBQW5CLEdBQWtDLFVBQVVwWCxLQUFWLEVBQWlCd04sTUFBTSxHQUFHLENBQTFCLEVBQTZCO0FBQzdEOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVg7QUFDQTBKLEVBQUFBLFVBQVUsQ0FBQ2xYLEtBQUQsRUFBUSxDQUFDLEtBQVQsRUFBZ0IsS0FBaEIsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUFLLEdBQUcsSUFBdEM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxDQUE1QztBQUNBLFNBQU93TixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQU5EO0FBT0E7Ozs7Ozs7QUFPQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUIyUyxZQUFuQixHQUFrQyxVQUFVclgsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUM3RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EwSixFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBQyxVQUFULEVBQXFCLFVBQXJCLENBQVY7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQXRCLEVBQThCeE4sS0FBSyxLQUFLLEVBQXhDO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEdBQUcsQ0FBL0IsRUFBa0N4TixLQUFLLEtBQUssRUFBNUM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxDQUE1QztBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHLENBQS9CLEVBQWtDeE4sS0FBSyxHQUFHLElBQTFDO0FBQ0EsU0FBT3dOLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUkQ7QUFTQTs7Ozs7OztBQU9Bc0MsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjRTLFlBQW5CLEdBQWtDLFVBQVV0WCxLQUFWLEVBQWlCd04sTUFBTSxHQUFHLENBQTFCLEVBQTZCO0FBQzdEOEYsRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZSxDQUFmLENBQVg7QUFDQTBKLEVBQUFBLFVBQVUsQ0FBQ2xYLEtBQUQsRUFBUSxDQUFDLFVBQVQsRUFBcUIsVUFBckIsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUFLLEdBQUcsSUFBdEM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxDQUE1QztBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHLENBQS9CLEVBQWtDeE4sS0FBSyxLQUFLLEVBQTVDO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEdBQUcsQ0FBL0IsRUFBa0N4TixLQUFLLEtBQUssRUFBNUM7QUFDQSxTQUFPd04sTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FSRDtBQVNBOzs7Ozs7OztBQVFBc0MsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQjZTLFVBQW5CLEdBQWdDLFVBQVV2WCxLQUFWLEVBQWlCd04sTUFBakIsRUFBeUJpRCxVQUF6QixFQUFxQztBQUNuRSxNQUFJQSxVQUFVLElBQUksQ0FBZCxJQUFtQkEsVUFBVSxHQUFHLENBQXBDLEVBQXVDO0FBQ3JDLFVBQU0sSUFBSTFHLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUR1SixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlaUQsVUFBZixDQUFYO0FBQ0EsUUFBTStHLFVBQVUsR0FBR2hHLElBQUksQ0FBQ2lHLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSWhILFVBQUosR0FBaUIsQ0FBN0IsQ0FBbkI7QUFDQXlHLEVBQUFBLFVBQVUsQ0FBQ2xYLEtBQUQsRUFBUSxDQUFDd1gsVUFBVCxFQUFxQkEsVUFBVSxHQUFHLENBQWxDLENBQVY7O0FBRUEsTUFBSXhYLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYkEsSUFBQUEsS0FBSyxHQUFHd1gsVUFBVSxHQUFHLENBQWIsR0FBaUJ4WCxLQUF6QjtBQUNEOztBQUVELE1BQUkwVSxVQUFVLEdBQUcsQ0FBakI7O0FBRUEsT0FBSyxJQUFJdlIsQ0FBQyxHQUFHc04sVUFBVSxHQUFHLENBQTFCLEVBQTZCdE4sQ0FBQyxJQUFJLENBQWxDLEVBQXFDQSxDQUFDLEVBQXRDLEVBQTBDO0FBQ3hDLFFBQUl1VSxTQUFTLEdBQUcxWCxLQUFLLEdBQUcwVSxVQUFSLEdBQXFCLElBQXJDO0FBQ0EsU0FBS3hHLGdCQUFMLENBQXNCVixNQUFNLEdBQUdySyxDQUEvQixFQUFrQ3VVLFNBQWxDO0FBQ0FoRCxJQUFBQSxVQUFVLElBQUksS0FBZDtBQUNEOztBQUVELFNBQU9sSCxNQUFNLEdBQUdpRCxVQUFoQjtBQUNELENBdEJEO0FBdUJBOzs7Ozs7OztBQVFBWCxRQUFRLENBQUNwTCxTQUFULENBQW1CaVQsVUFBbkIsR0FBZ0MsVUFBVTNYLEtBQVYsRUFBaUJ3TixNQUFqQixFQUF5QmlELFVBQXpCLEVBQXFDO0FBQ25FLE1BQUlBLFVBQVUsSUFBSSxDQUFkLElBQW1CQSxVQUFVLEdBQUcsQ0FBcEMsRUFBdUM7QUFDckMsVUFBTSxJQUFJMUcsVUFBSixDQUFlLG9CQUFmLENBQU47QUFDRDs7QUFFRHVKLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWVpRCxVQUFmLENBQVg7QUFDQSxRQUFNK0csVUFBVSxHQUFHaEcsSUFBSSxDQUFDaUcsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJaEgsVUFBSixHQUFpQixDQUE3QixDQUFuQjtBQUNBeUcsRUFBQUEsVUFBVSxDQUFDbFgsS0FBRCxFQUFRLENBQUN3WCxVQUFULEVBQXFCQSxVQUFVLEdBQUcsQ0FBbEMsQ0FBVjs7QUFFQSxNQUFJeFgsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNiQSxJQUFBQSxLQUFLLEdBQUd3WCxVQUFVLEdBQUcsQ0FBYixHQUFpQnhYLEtBQXpCO0FBQ0Q7O0FBRUQsTUFBSTBVLFVBQVUsR0FBRyxDQUFqQjs7QUFFQSxPQUFLLElBQUl2UixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc04sVUFBcEIsRUFBZ0N0TixDQUFDLEVBQWpDLEVBQXFDO0FBQ25DLFFBQUl1VSxTQUFTLEdBQUcxWCxLQUFLLEdBQUcwVSxVQUFSLEdBQXFCLElBQXJDO0FBQ0EsU0FBS3hHLGdCQUFMLENBQXNCVixNQUFNLEdBQUdySyxDQUEvQixFQUFrQ3VVLFNBQWxDO0FBQ0FoRCxJQUFBQSxVQUFVLElBQUksS0FBZDtBQUNEOztBQUVELFNBQU9sSCxNQUFNLEdBQUdpRCxVQUFoQjtBQUNELENBdEJEO0FBdUJBOzs7Ozs7O0FBT0FYLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJrVCxVQUFuQixHQUFnQyxVQUFVNVgsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUMzRDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EwSixFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBUixFQUFXLEdBQVgsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUE5QjtBQUNBLFNBQU93TixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQUxEO0FBTUE7Ozs7Ozs7QUFPQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJtVCxhQUFuQixHQUFtQyxVQUFVN1gsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUM5RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EwSixFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBUixFQUFXLEtBQVgsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUFLLEtBQUssQ0FBeEM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssR0FBRyxJQUExQztBQUNBLFNBQU93TixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQU5EO0FBT0E7Ozs7Ozs7QUFPQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJvVCxhQUFuQixHQUFtQyxVQUFVOVgsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUM5RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EwSixFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBUixFQUFXLEtBQVgsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUFLLEdBQUcsSUFBdEM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxDQUE1QztBQUNBLFNBQU93TixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQU5EO0FBT0E7Ozs7Ozs7QUFPQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJxVCxhQUFuQixHQUFtQyxVQUFVL1gsS0FBVixFQUFpQndOLE1BQU0sR0FBRyxDQUExQixFQUE2QjtBQUM5RDhGLEVBQUFBLFdBQVcsQ0FBQyxJQUFELEVBQU85RixNQUFQLEVBQWUsQ0FBZixDQUFYO0FBQ0EwSixFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBUixFQUFXLFVBQVgsQ0FBVjtBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBdEIsRUFBOEJ4TixLQUFLLEtBQUssRUFBeEM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxFQUE1QztBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHLENBQS9CLEVBQWtDeE4sS0FBSyxLQUFLLENBQTVDO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEdBQUcsQ0FBL0IsRUFBa0N4TixLQUFLLEdBQUcsSUFBMUM7QUFDQSxTQUFPd04sTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FSRDtBQVNBOzs7Ozs7O0FBT0FzQyxRQUFRLENBQUNwTCxTQUFULENBQW1Cc1QsYUFBbkIsR0FBbUMsVUFBVWhZLEtBQVYsRUFBaUJ3TixNQUFNLEdBQUcsQ0FBMUIsRUFBNkI7QUFDOUQ4RixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlLENBQWYsQ0FBWDtBQUNBMEosRUFBQUEsVUFBVSxDQUFDbFgsS0FBRCxFQUFRLENBQVIsRUFBVyxVQUFYLENBQVY7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQXRCLEVBQThCeE4sS0FBSyxHQUFHLElBQXRDO0FBQ0EsT0FBS2tPLGdCQUFMLENBQXNCVixNQUFNLEdBQUcsQ0FBL0IsRUFBa0N4TixLQUFLLEtBQUssQ0FBNUM7QUFDQSxPQUFLa08sZ0JBQUwsQ0FBc0JWLE1BQU0sR0FBRyxDQUEvQixFQUFrQ3hOLEtBQUssS0FBSyxFQUE1QztBQUNBLE9BQUtrTyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHLENBQS9CLEVBQWtDeE4sS0FBSyxLQUFLLEVBQTVDO0FBQ0EsU0FBT3dOLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUkQ7QUFTQTs7Ozs7Ozs7QUFRQXNDLFFBQVEsQ0FBQ3BMLFNBQVQsQ0FBbUJ1VCxXQUFuQixHQUFpQyxVQUFValksS0FBVixFQUFpQndOLE1BQWpCLEVBQXlCaUQsVUFBekIsRUFBcUM7QUFDcEUsTUFBSUEsVUFBVSxJQUFJLENBQWQsSUFBbUJBLFVBQVUsR0FBRyxDQUFwQyxFQUF1QztBQUNyQyxVQUFNLElBQUkxRyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNEOztBQUVEdUosRUFBQUEsV0FBVyxDQUFDLElBQUQsRUFBTzlGLE1BQVAsRUFBZWlELFVBQWYsQ0FBWDtBQUNBeUcsRUFBQUEsVUFBVSxDQUFDbFgsS0FBRCxFQUFRLENBQVIsRUFBV3dSLElBQUksQ0FBQ2lHLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSWhILFVBQWhCLElBQThCLENBQXpDLENBQVY7QUFDQSxNQUFJaUUsVUFBVSxHQUFHLENBQWpCOztBQUVBLE9BQUssSUFBSXZSLENBQUMsR0FBR3NOLFVBQVUsR0FBRyxDQUExQixFQUE2QnROLENBQUMsSUFBSSxDQUFsQyxFQUFxQ0EsQ0FBQyxFQUF0QyxFQUEwQztBQUN4QyxRQUFJdVUsU0FBUyxHQUFHMVgsS0FBSyxHQUFHMFUsVUFBUixHQUFxQixJQUFyQztBQUNBLFNBQUt4RyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHckssQ0FBL0IsRUFBa0N1VSxTQUFsQztBQUNBaEQsSUFBQUEsVUFBVSxJQUFJLEtBQWQ7QUFDRDs7QUFFRCxTQUFPbEgsTUFBTSxHQUFHaUQsVUFBaEI7QUFDRCxDQWhCRDtBQWlCQTs7Ozs7Ozs7QUFRQVgsUUFBUSxDQUFDcEwsU0FBVCxDQUFtQndULFdBQW5CLEdBQWlDLFVBQVVsWSxLQUFWLEVBQWlCd04sTUFBakIsRUFBeUJpRCxVQUF6QixFQUFxQztBQUNwRSxNQUFJQSxVQUFVLElBQUksQ0FBZCxJQUFtQkEsVUFBVSxHQUFHLENBQXBDLEVBQXVDO0FBQ3JDLFVBQU0sSUFBSTFHLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUR1SixFQUFBQSxXQUFXLENBQUMsSUFBRCxFQUFPOUYsTUFBUCxFQUFlaUQsVUFBZixDQUFYO0FBQ0F5RyxFQUFBQSxVQUFVLENBQUNsWCxLQUFELEVBQVEsQ0FBUixFQUFXd1IsSUFBSSxDQUFDaUcsR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJaEgsVUFBaEIsSUFBOEIsQ0FBekMsQ0FBVjtBQUNBLE1BQUlpRSxVQUFVLEdBQUcsQ0FBakI7O0FBRUEsT0FBSyxJQUFJdlIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NOLFVBQXBCLEVBQWdDdE4sQ0FBQyxFQUFqQyxFQUFxQztBQUNuQyxRQUFJdVUsU0FBUyxHQUFHMVgsS0FBSyxHQUFHMFUsVUFBUixHQUFxQixJQUFyQztBQUNBLFNBQUt4RyxnQkFBTCxDQUFzQlYsTUFBTSxHQUFHckssQ0FBL0IsRUFBa0N1VSxTQUFsQztBQUNBaEQsSUFBQUEsVUFBVSxJQUFJLEtBQWQ7QUFDRDs7QUFFRCxTQUFPbEgsTUFBTSxHQUFHaUQsVUFBaEI7QUFDRCxDQWhCRCxDLENBZ0JHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQVgsUUFBUSxDQUFDYyxXQUFULEdBQXVCLFVBQVUzTixNQUFWLEVBQWtCO0FBQ3ZDLFNBQU8sSUFBSWlJLFVBQUosQ0FBZWpJLE1BQWYsQ0FBUDtBQUNELENBRkQ7O0FBSUE2TSxRQUFRLENBQUNxSSxlQUFULEdBQTJCLFVBQVVsVixNQUFWLEVBQWtCO0FBQzNDLFNBQU82TSxRQUFRLENBQUNjLFdBQVQsQ0FBcUIzTixNQUFyQixDQUFQO0FBQ0QsQ0FGRDs7QUFJQTZNLFFBQVEsQ0FBQ00sS0FBVCxHQUFpQixVQUFVbk4sTUFBVixFQUFrQjZLLElBQUksR0FBRyxDQUF6QixFQUE0QjNCLFFBQVEsR0FBRyxNQUF2QyxFQUErQztBQUM5RCxRQUFNMkMsR0FBRyxHQUFHZ0IsUUFBUSxDQUFDYyxXQUFULENBQXFCM04sTUFBckIsQ0FBWjs7QUFFQSxNQUFJNkssSUFBSSxLQUFLLENBQWIsRUFBZ0I7QUFDZGdCLElBQUFBLEdBQUcsQ0FBQ2hCLElBQUosQ0FBU0EsSUFBVCxFQUFlM0IsUUFBZjtBQUNEOztBQUVELFNBQU8yQyxHQUFQO0FBQ0QsQ0FSRDtBQVNBOzs7Ozs7O0FBT0FnQixRQUFRLENBQUNXLFVBQVQsR0FBc0IsVUFBVW1HLE1BQVYsRUFBa0J6SyxRQUFRLEdBQUcsTUFBN0IsRUFBcUM7QUFDekQsTUFBSSxPQUFPeUssTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixRQUFJOUcsUUFBUSxDQUFDaFAsUUFBVCxDQUFrQjhWLE1BQWxCLENBQUosRUFBK0I7QUFDN0IsYUFBT0EsTUFBTSxDQUFDM1QsTUFBZCxDQUQ2QixDQUNQO0FBQ3ZCOztBQUVELFdBQU8yVCxNQUFNLENBQUNuRyxVQUFkLENBTDhCLENBS0o7QUFDM0I7O0FBRUQsTUFBSXhOLE1BQU0sR0FBRzJULE1BQU0sQ0FBQzNULE1BQXBCOztBQUVBLFVBQVFrSixRQUFRLENBQUNHLFdBQVQsRUFBUjtBQUNFLFNBQUssTUFBTDtBQUNBLFNBQUssT0FBTDtBQUNFLGFBQU84TCxjQUFjLENBQUN4QixNQUFELENBQXJCOztBQUVGLFNBQUssUUFBTDtBQUNBLFNBQUssUUFBTDtBQUNBLFNBQUssT0FBTDtBQUNFLGFBQU8zVCxNQUFQOztBQUVGLFNBQUssT0FBTDtBQUNBLFNBQUssTUFBTDtBQUNBLFNBQUssU0FBTDtBQUNBLFNBQUssVUFBTDtBQUNFLGFBQU8sSUFBSUEsTUFBWDs7QUFFRixTQUFLLEtBQUw7QUFDRSxhQUFPQSxNQUFNLEdBQUcsQ0FBaEI7O0FBRUYsU0FBSyxRQUFMO0FBQ0U7QUFDQSxVQUFJQSxNQUFNLEdBQUcsQ0FBVCxJQUFjMlQsTUFBTSxDQUFDeUIsTUFBUCxDQUFjcFYsTUFBTSxHQUFHLENBQXZCLE1BQThCLEdBQWhELEVBQXFEO0FBQ25EQSxRQUFBQSxNQUFNO0FBQ1A7O0FBRUQsVUFBSUEsTUFBTSxHQUFHLENBQVQsSUFBYzJULE1BQU0sQ0FBQ3lCLE1BQVAsQ0FBY3BWLE1BQU0sR0FBRyxDQUF2QixNQUE4QixHQUFoRCxFQUFxRDtBQUNuREEsUUFBQUEsTUFBTTtBQUNQOztBQUVELGFBQU91TyxJQUFJLENBQUM4RyxLQUFMLENBQVdyVixNQUFNLEdBQUcsQ0FBVCxHQUFhLENBQXhCLENBQVA7QUFDRjtBQTlCRjs7QUFpQ0EsU0FBT21WLGNBQWMsQ0FBQ3hCLE1BQUQsQ0FBckI7QUFDRCxDQTdDRDs7QUErQ0E5RyxRQUFRLENBQUNpQixPQUFULEdBQW1CLFVBQVVLLElBQVYsRUFBZ0JtSCxJQUFoQixFQUFzQjtBQUN2QyxNQUFJLENBQUN6SSxRQUFRLENBQUNoUCxRQUFULENBQWtCc1EsSUFBbEIsQ0FBTCxFQUE4QjtBQUM1QixVQUFNLElBQUk1RyxTQUFKLENBQWUsK0VBQThFLE9BQU80RyxJQUFLLEVBQXpHLENBQU47QUFDRCxHQUhzQyxDQUdyQzs7O0FBR0YsU0FBT0EsSUFBSSxDQUFDTCxPQUFMLENBQWF3SCxJQUFiLENBQVA7QUFDRCxDQVBEO0FBUUE7Ozs7Ozs7QUFPQXpJLFFBQVEsQ0FBQzBJLE1BQVQsR0FBa0IsVUFBVUMsSUFBVixFQUFnQkMsV0FBaEIsRUFBNkI7QUFDN0MsTUFBSSxDQUFDaFcsS0FBSyxDQUFDQyxPQUFOLENBQWM4VixJQUFkLENBQUwsRUFBMEI7QUFDeEIsVUFBTSxJQUFJak8sU0FBSixDQUFjLGdDQUFkLENBQU47QUFDRDs7QUFFRCxNQUFJaU8sSUFBSSxDQUFDeFYsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixXQUFPLElBQUlpSSxVQUFKLEVBQVAsQ0FEcUIsQ0FDSTtBQUMxQixHQVA0QyxDQU8zQzs7O0FBR0YsTUFBSXdOLFdBQVcsS0FBSzNXLFNBQXBCLEVBQStCO0FBQzdCMlcsSUFBQUEsV0FBVyxHQUFHLENBQWQsQ0FENkIsQ0FDWjs7QUFFakIsU0FBSyxJQUFJdlYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NWLElBQUksQ0FBQ3hWLE1BQXpCLEVBQWlDRSxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDdVYsTUFBQUEsV0FBVyxJQUFJRCxJQUFJLENBQUN0VixDQUFELENBQUosQ0FBUUYsTUFBdkI7QUFDRDtBQUNGOztBQUVELFFBQU1pUCxNQUFNLEdBQUdwQyxRQUFRLENBQUNjLFdBQVQsQ0FBcUI4SCxXQUFyQixDQUFmO0FBQ0EsTUFBSUMsUUFBUSxHQUFHLENBQWY7O0FBRUEsT0FBSyxJQUFJeFYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NWLElBQUksQ0FBQ3hWLE1BQXpCLEVBQWlDRSxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFVBQU0yTCxHQUFHLEdBQUcySixJQUFJLENBQUN0VixDQUFELENBQWhCO0FBQ0EyTCxJQUFBQSxHQUFHLENBQUMrQixJQUFKLENBQVNxQixNQUFULEVBQWlCeUcsUUFBakI7QUFDQUEsSUFBQUEsUUFBUSxJQUFJN0osR0FBRyxDQUFDN0wsTUFBaEI7O0FBRUEsUUFBSTBWLFFBQVEsSUFBSUQsV0FBaEIsRUFBNkI7QUFDM0I7QUFDRDtBQUNGOztBQUVELFNBQU94RyxNQUFQO0FBQ0QsQ0FoQ0Q7QUFpQ0E7Ozs7OztBQU1BcEMsUUFBUSxDQUFDekQsVUFBVCxHQUFzQixVQUFVRixRQUFWLEVBQW9CO0FBQ3hDLE1BQUksT0FBT0EsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQyxXQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFPb0QsZUFBZSxDQUFDeEksUUFBaEIsQ0FBeUJvRixRQUFRLENBQUNHLFdBQVQsRUFBekIsQ0FBUDtBQUNELENBTkQ7QUFPQTs7Ozs7O0FBTUF3RCxRQUFRLENBQUNoUCxRQUFULEdBQW9CLFVBQVUrQyxHQUFWLEVBQWU7QUFDakMsU0FBT0EsR0FBRyxLQUFLLElBQVIsSUFBZ0JBLEdBQUcsS0FBSzlCLFNBQXhCLEtBQXNDOEIsR0FBRyxZQUFZaU0sUUFBZixJQUEyQmpNLEdBQUcsQ0FBQy9DLFFBQUQsQ0FBSCxLQUFrQixJQUFuRixDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJOFgsaUJBQWlCLEdBQUcsRUFBeEIsQyxDQUE0Qjs7QUFFNUI5SSxRQUFRLENBQUNwTCxTQUFULENBQW1CL0QsbUJBQW5CLElBQTBDLFVBQVVrWSxZQUFWLEVBQXdCQyxHQUF4QixFQUE2QjtBQUNyRSxRQUFNQyxHQUFHLEdBQUdILGlCQUFaO0FBQ0EsUUFBTUksU0FBUyxHQUFHeEgsSUFBSSxDQUFDQyxHQUFMLENBQVNzSCxHQUFULEVBQWMsS0FBSzlWLE1BQW5CLENBQWxCO0FBQ0EsUUFBTTJPLFNBQVMsR0FBRyxLQUFLM08sTUFBTCxHQUFjOFYsR0FBaEM7QUFDQSxNQUFJOVgsR0FBRyxHQUFHLEtBQUtnSyxLQUFMLENBQVcsQ0FBWCxFQUFjK04sU0FBZCxFQUF5QjdULFFBQXpCLENBQWtDLEtBQWxDLEVBQXlDakUsT0FBekMsQ0FBaUQsU0FBakQsRUFBNEQsS0FBNUQsRUFBbUUrWCxJQUFuRSxFQUFWOztBQUVBLE1BQUlySCxTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDakIzUSxJQUFBQSxHQUFHLElBQUssUUFBTzJRLFNBQVUsYUFBWUEsU0FBUyxHQUFHLENBQVosR0FBZ0IsR0FBaEIsR0FBc0IsRUFBRyxFQUE5RDtBQUNELEdBUm9FLENBUW5FOzs7QUFHRixNQUFJa0gsR0FBSixFQUFTO0FBQ1AsUUFBSUksTUFBTSxHQUFHLEtBQWI7QUFDQSxVQUFNcFYsTUFBTSxHQUFHZ1YsR0FBRyxDQUFDSyxVQUFKLEdBQWlCOUosZ0JBQWpCLEdBQW9DQyxpQkFBbkQ7QUFDQSxVQUFNekwsR0FBRyxHQUFHRCx3QkFBd0IsQ0FBQyxJQUFELEVBQU9FLE1BQVAsQ0FBeEIsQ0FBdUNzVixNQUF2QyxDQUE4QyxDQUFDdlYsR0FBRCxFQUFNSyxHQUFOLEtBQWM7QUFDdEVnVixNQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNBclYsTUFBQUEsR0FBRyxDQUFDSyxHQUFELENBQUgsR0FBVyxLQUFLQSxHQUFMLENBQVg7QUFDQSxhQUFPTCxHQUFQO0FBQ0QsS0FKVyxFQUlUL0QsTUFBTSxDQUFDdVosTUFBUCxDQUFjLElBQWQsQ0FKUyxDQUFaOztBQU1BLFFBQUlILE1BQUosRUFBWTtBQUNWLFVBQUksS0FBS2pXLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckJoQyxRQUFBQSxHQUFHLElBQUksSUFBUDtBQUNELE9BSFMsQ0FHUjtBQUNGOzs7QUFHQUEsTUFBQUEsR0FBRyxJQUFJcVksT0FBTyxDQUFDelYsR0FBRCxFQUFNLEVBQUUsR0FBR2lWLEdBQUw7QUFDbEJTLFFBQUFBLFdBQVcsRUFBRTFYLFFBREs7QUFFbEIyWCxRQUFBQSxPQUFPLEVBQUUsSUFGUyxFQUFOLENBQVA7QUFHSnZPLE1BQUFBLEtBSEksQ0FHRSxFQUhGLEVBR00sQ0FBQyxDQUhQLENBQVA7QUFJRDtBQUNGOztBQUVELFNBQVEsSUFBRyxLQUFLbkUsV0FBTCxDQUFpQjVCLElBQUssSUFBR2pFLEdBQUksR0FBeEM7QUFDRCxDQW5DRDs7QUFxQ0E2TyxRQUFRLENBQUNwTCxTQUFULENBQW1CNFUsT0FBbkIsR0FBNkJ4SixRQUFRLENBQUNwTCxTQUFULENBQW1CL0QsbUJBQW5CLENBQTdCLEMsQ0FBc0U7O0FBRXRFLE1BQU04WSxpQkFBaUIsR0FBR2hVLFdBQVcsQ0FBQ0MsTUFBdEM7O0FBRUFELFdBQVcsQ0FBQ0MsTUFBWixHQUFxQixVQUFVbUYsS0FBVixFQUFpQjtBQUNwQyxTQUFPNE8saUJBQWlCLENBQUM1TyxLQUFELENBQWpCLElBQTRCQSxLQUFLLFlBQVlpRixRQUFwRDtBQUNELENBRkQ7O0FBSUFoUSxNQUFNLENBQUNnUixjQUFQLENBQXNCcEYsVUFBVSxDQUFDaEgsU0FBakMsRUFBNENvTCxRQUFRLENBQUNwTCxTQUFyRDtBQUNBNUUsTUFBTSxDQUFDZ1IsY0FBUCxDQUFzQnBGLFVBQXRCLEVBQWtDb0UsUUFBbEM7QUFDQSxJQUFJNEosWUFBWSxHQUFHO0FBQ2pCdE4sRUFBQUEsTUFBTSxFQUFFMEQsUUFEUztBQUVqQjtBQUNBNkosRUFBQUEsU0FBUyxFQUFFLENBQUNDLE9BQUQsRUFBVUMsYUFBVixFQUF5QkMsV0FBekIsS0FBeUMsQ0FBRSxDQUhyQztBQUlqQmxCLEVBQUFBLGlCQUFpQixFQUFFLEVBSkY7QUFLakJtQixFQUFBQSxVQUFVLEVBQUUsVUFMSztBQU1qQkMsRUFBQUEsZ0JBQWdCLEVBQUUsVUFORDtBQU9qQkMsRUFBQUEsU0FBUyxFQUFFO0FBQ1RDLElBQUFBLFVBQVUsRUFBRSxVQURIO0FBRVRDLElBQUFBLGlCQUFpQixFQUFFLFVBRlYsRUFQTSxFQUFuQjs7O0FBWUE7Ozs7Ozs7O0FBUUEsU0FBU3RILE9BQVQsQ0FBaUI3RixNQUFqQixFQUF5Qm9OLFVBQXpCLEVBQXFDNU0sTUFBckMsRUFBNkM7QUFDM0MsUUFBTXZLLE1BQU0sR0FBRytKLE1BQU0sQ0FBQy9KLE1BQXRCOztBQUVBLE9BQUssSUFBSUUsQ0FBQyxHQUFHcUssTUFBYixFQUFxQnJLLENBQUMsR0FBR0YsTUFBekIsRUFBaUNFLENBQUMsRUFBbEMsRUFBc0M7QUFDcEMsUUFBSTZKLE1BQU0sQ0FBQ2dCLGdCQUFQLENBQXdCN0ssQ0FBeEIsTUFBK0JpWCxVQUFuQyxFQUErQztBQUM3QyxhQUFPalgsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxDQUFDLENBQVI7QUFDRDtBQUNEOzs7Ozs7Ozs7O0FBVUEsU0FBUzBRLGdCQUFULENBQTBCRixhQUExQixFQUF5Q2xELFVBQXpDLEVBQXFEO0FBQ25ELFFBQU00SixTQUFTLEdBQUc1SixVQUFVLEdBQUcsQ0FBL0I7QUFDQSxRQUFNNkosZ0JBQWdCLEdBQUc5SSxJQUFJLENBQUNpRyxHQUFMLENBQVMsQ0FBVCxFQUFZNEMsU0FBUyxHQUFHLENBQXhCLENBQXpCOztBQUVBLE1BQUkxRyxhQUFhLEdBQUcyRyxnQkFBcEIsRUFBc0M7QUFDcEMsV0FBTzNHLGFBQVA7QUFDRDs7QUFFRCxRQUFNNEcsZ0JBQWdCLEdBQUcvSSxJQUFJLENBQUNpRyxHQUFMLENBQVMsQ0FBVCxFQUFZNEMsU0FBWixDQUF6QjtBQUNBMUcsRUFBQUEsYUFBYSxJQUFJNEcsZ0JBQWpCO0FBQ0EsU0FBTzVHLGFBQVA7QUFDRDtBQUNEOzs7Ozs7QUFNQSxTQUFTeUUsY0FBVCxDQUF3QnhCLE1BQXhCLEVBQWdDO0FBQzlCO0FBQ0EsUUFBTTlILEdBQUcsR0FBRzNPLEVBQUUsQ0FBQ2lOLFlBQUgsQ0FBZ0I7QUFDMUJwTixJQUFBQSxLQUFLLEVBQUU0VyxNQURtQjtBQUUxQnJNLElBQUFBLElBQUksRUFBRXBLLEVBQUUsQ0FBQzZPLEtBQUgsQ0FBU0MsWUFGVyxFQUFoQixDQUFaOztBQUlBLFFBQU1oTSxNQUFNLEdBQUc2TCxHQUFHLENBQUM3TCxNQUFuQjtBQUNBNkwsRUFBQUEsR0FBRyxDQUFDMEwsT0FBSixHQVA4QixDQU9mOztBQUVmLFNBQU92WCxNQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBU0EsU0FBU3FRLFdBQVQsQ0FBcUJ0RyxNQUFyQixFQUE2QlEsTUFBN0IsRUFBcUNpRCxVQUFyQyxFQUFpRDtBQUMvQyxRQUFNZ0ssU0FBUyxHQUFHek4sTUFBTSxDQUFDL0osTUFBUCxHQUFnQndOLFVBQWxDOztBQUVBLE1BQUlqRCxNQUFNLEdBQUcsQ0FBVCxJQUFjQSxNQUFNLEdBQUdpTixTQUEzQixFQUFzQztBQUNwQyxVQUFNLElBQUkxUSxVQUFKLENBQWdCLGlFQUFnRTBRLFNBQVUsY0FBYWpOLE1BQU8sRUFBOUcsQ0FBTjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7QUFRQSxTQUFTMEosVUFBVCxDQUFvQmxYLEtBQXBCLEVBQTJCeVIsR0FBM0IsRUFBZ0NzSCxHQUFoQyxFQUFxQztBQUNuQyxNQUFJL1ksS0FBSyxHQUFHeVIsR0FBUixJQUFlelIsS0FBSyxHQUFHK1ksR0FBM0IsRUFBZ0M7QUFDOUIsVUFBTSxJQUFJaFAsVUFBSixDQUFnQix1REFBc0QwSCxHQUFJLFdBQVVzSCxHQUFJLGNBQWEvWSxLQUFNLEVBQTNHLENBQU47QUFDRDtBQUNGOztBQUVELElBQUkwYSwyQkFBMkIsR0FBRyxLQUFsQztBQUNBLElBQUlDLHVCQUF1QixHQUFHLENBQTlCO0FBQ0EsTUFBTUMsYUFBYSxHQUFHLDBEQUEwRCx5Q0FBMUQsR0FBc0cseURBQTVIOztBQUVBLFNBQVN6SyxzQkFBVCxHQUFrQztBQUNoQyxNQUFJdUssMkJBQTJCLElBQUksRUFBRUMsdUJBQUYsR0FBNEIsS0FBM0QsSUFBb0U3WSxtQkFBbUIsRUFBM0YsRUFBK0Y7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQrWSxFQUFBQSxPQUFPLENBQUNDLFdBQVIsQ0FBb0JGLGFBQXBCLEVBQW1DLG9CQUFuQyxFQUF5RCxTQUF6RDtBQUNBRixFQUFBQSwyQkFBMkIsR0FBRyxJQUE5QjtBQUNEOztBQUVEO0FBQ0EsTUFBTTtBQUNKalgsRUFBQUEsY0FBYyxFQUFFc1gsZ0JBRFo7QUFFSnJYLEVBQUFBLGVBQWUsRUFBRXNYLGlCQUZiO0FBR0ZyWCxjQUhKO0FBSUEsTUFBTXNYLGdCQUFnQixHQUFHQyxPQUFPLENBQUN4VyxTQUFqQztBQUNBLE1BQU15VyxhQUFhLEdBQUdDLElBQUksQ0FBQzFXLFNBQTNCO0FBQ0EsTUFBTTJXLGNBQWMsR0FBRy9aLEtBQUssQ0FBQ29ELFNBQTdCO0FBQ0EsTUFBTTRXLGVBQWUsR0FBRzlQLE1BQU0sQ0FBQzlHLFNBQS9CO0FBQ0EsTUFBTTZXLFlBQVksR0FBRy9TLEdBQUcsQ0FBQzlELFNBQXpCO0FBQ0EsTUFBTThXLGVBQWUsR0FBR0MsTUFBTSxDQUFDL1csU0FBL0I7QUFDQSxNQUFNZ1gsZUFBZSxHQUFHMVEsTUFBTSxDQUFDdEcsU0FBL0I7QUFDQSxNQUFNaVgsWUFBWSxHQUFHQyxHQUFHLENBQUNsWCxTQUF6QjtBQUNBLE1BQU1tWCxlQUFlLEdBQUdqYixNQUFNLENBQUM4RCxTQUEvQjtBQUNBLE1BQU1vWCxLQUFLLEdBQUcsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQi9VLFFBQW5CLENBQTRCLFNBQTVCLENBQWQ7QUFDQSxNQUFNO0FBQ0pnVixFQUFBQSxvQkFESTtBQUVGN1QsS0FGSjtBQUdBLE1BQU04VCxjQUFjLEdBQUc1WSxXQUFXLENBQUN0RCxNQUFNLENBQUM0RSxTQUFQLENBQWlCc1gsY0FBbEIsQ0FBbEM7QUFDQSxNQUFNQyxvQkFBb0IsR0FBRzdZLFdBQVcsQ0FBQ3RELE1BQU0sQ0FBQzRFLFNBQVAsQ0FBaUJ1WCxvQkFBbEIsQ0FBeEM7QUFDQSxJQUFJdEcsUUFBUSxHQUFHdlMsV0FBVyxDQUFDc1csWUFBWSxDQUFDdE4sTUFBYixDQUFvQjFILFNBQXBCLENBQThCaVIsUUFBL0IsQ0FBMUI7QUFDQSxNQUFNdUcsY0FBYyxHQUFHLElBQUlOLEdBQUosQ0FBUTliLE1BQU0sQ0FBQ21FLG1CQUFQLENBQTJCckUsTUFBM0IsRUFBbUNrRSxNQUFuQyxDQUEwQzFDLENBQUMsSUFBSSxtQkFBbUJ5QixJQUFuQixDQUF3QnpCLENBQXhCLENBQS9DLENBQVIsQ0FBdkI7QUFDQSxNQUFNK2EscUJBQXFCLEdBQUdyYyxNQUFNLENBQUNzYyxJQUFQLENBQVk7QUFDeENqRCxFQUFBQSxVQUFVLEVBQUUsS0FENEI7QUFFeENrRCxFQUFBQSxLQUFLLEVBQUUsQ0FGaUM7QUFHeENDLEVBQUFBLE1BQU0sRUFBRSxLQUhnQztBQUl4Q0MsRUFBQUEsYUFBYSxFQUFFLElBSnlCO0FBS3hDQyxFQUFBQSxTQUFTLEVBQUUsS0FMNkI7QUFNeENDLEVBQUFBLGNBQWMsRUFBRSxHQU53QjtBQU94Q2xELEVBQUFBLFdBQVcsRUFBRSxFQVAyQjtBQVF4Q0MsRUFBQUEsT0FBTyxFQUFFLENBUitCO0FBU3hDa0QsRUFBQUEsTUFBTSxFQUFFLEtBVGdDO0FBVXhDQyxFQUFBQSxPQUFPLEVBQUUsS0FWK0IsRUFBWixDQUE5Qjs7QUFZQSxNQUFNQyxXQUFXLEdBQUcsQ0FBcEI7QUFDQSxNQUFNQyxVQUFVLEdBQUcsQ0FBbkI7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBRyxDQUF6QjtBQUNBOztBQUVBLE1BQU1DLHdCQUF3QixHQUFHLHFCQUFqQztBQUNBLE1BQU1DLDBCQUEwQixHQUFHLHNCQUFuQztBQUNBLE1BQU1DLDhCQUE4QixHQUFHLGlCQUF2QztBQUNBLE1BQU1DLGdDQUFnQyxHQUFHLGtCQUF6QztBQUNBOztBQUVBLE1BQU1DLFlBQVksR0FBRywwQkFBckI7QUFDQSxNQUFNQyxZQUFZLEdBQUcsbUJBQXJCO0FBQ0EsTUFBTUMsaUJBQWlCLEdBQUcsdUNBQTFCO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLEVBQXZCLEMsQ0FBMkI7O0FBRTNCLE1BQU1DLEtBQUssR0FBRyxDQUFkO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLENBQWxCO0FBQ0EsTUFBTUMsV0FBVyxHQUFHLENBQXBCLEMsQ0FBdUI7O0FBRXZCOztBQUVBLE1BQU1DLElBQUksR0FBRyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLFNBQXZCLEVBQWtDLFNBQWxDLEVBQTZDLFNBQTdDLEVBQXdELFNBQXhELEVBQW1FLFNBQW5FLEVBQThFLFNBQTlFLEVBQXlGLEtBQXpGLEVBQWdHLEtBQWhHLEVBQXVHLEtBQXZHLEVBQThHLFNBQTlHLEVBQXlILEtBQXpILEVBQWdJLEtBQWhJLEVBQXVJLFNBQXZJLEVBQWtKLFNBQWxKLEVBQTZKLFNBQTdKLEVBQXdLLFNBQXhLLEVBQW1MLFNBQW5MLEVBQThMLFNBQTlMLEVBQXlNLFNBQXpNLEVBQW9OLFNBQXBOLEVBQStOLFNBQS9OLEVBQTBPLFNBQTFPLEVBQXFQLFNBQXJQLEVBQWdRLFNBQWhRLEVBQTJRLFNBQTNRLEVBQXNSLFNBQXRSLEVBQWlTLFNBQWpTLEVBQTRTLFNBQTVTLEVBQXVULFNBQXZULEVBQWtVLFNBQWxVLEVBQTZVLEVBQTdVLEVBQWlWLEVBQWpWLEVBQXFWLEVBQXJWLEVBQXlWLEVBQXpWLEVBQTZWLEVBQTdWLEVBQWlXLEVBQWpXLEVBQXFXLEVBQXJXLEVBQXlXLEtBQXpXLEVBQWdYLEVBQWhYLEVBQW9YLEVBQXBYLEVBQXdYLEVBQXhYLEVBQTRYLEVBQTVYLEVBQWdZLEVBQWhZLEVBQW9ZLEVBQXBZLEVBQXdZLEVBQXhZLEVBQTRZLEVBQTVZLEVBQWdaLEVBQWhaLEVBQW9aLEVBQXBaLEVBQXdaLEVBQXhaLEVBQTRaLEVBQTVaLEVBQWdhLEVBQWhhLEVBQW9hLEVBQXBhLEVBQXdhLEVBQXhhLEVBQTRhLEVBQTVhLEVBQWdiLEVBQWhiLEVBQW9iLEVBQXBiLEVBQXdiLEVBQXhiLEVBQTRiLEVBQTViLEVBQWdjLEVBQWhjLEVBQW9jLEVBQXBjLEVBQXdjLEVBQXhjLEVBQTRjLEVBQTVjLEVBQWdkLEVBQWhkLEVBQW9kLEVBQXBkLEVBQXdkLEVBQXhkLEVBQTRkLEVBQTVkLEVBQWdlLEVBQWhlLEVBQW9lLEVBQXBlLEVBQXdlLEVBQXhlLEVBQTRlLEVBQTVlLEVBQWdmLEVBQWhmLEVBQW9mLEVBQXBmLEVBQXdmLEVBQXhmLEVBQTRmLEVBQTVmLEVBQWdnQixFQUFoZ0IsRUFBb2dCLEVBQXBnQixFQUF3Z0IsRUFBeGdCLEVBQTRnQixFQUE1Z0IsRUFBZ2hCLEVBQWhoQixFQUFvaEIsRUFBcGhCLEVBQXdoQixFQUF4aEIsRUFBNGhCLEVBQTVoQixFQUFnaUIsRUFBaGlCLEVBQW9pQixFQUFwaUIsRUFBd2lCLEVBQXhpQixFQUE0aUIsRUFBNWlCLEVBQWdqQixFQUFoakIsRUFBb2pCLEVBQXBqQixFQUF3akIsRUFBeGpCLEVBQTRqQixFQUE1akIsRUFBZ2tCLE1BQWhrQixDQUFiO0FBQ0E7O0FBRUEsU0FBU0MsY0FBVCxDQUF3QjdFLEdBQXhCLEVBQTZCO0FBQzNCLFFBQU1qVixHQUFHLEdBQUc7QUFDVitaLElBQUFBLE9BQU8sRUFBRTlFLEdBQUcsQ0FBQzhFLE9BREgsRUFBWjs7O0FBSUEsT0FBSyxNQUFNMVosR0FBWCxJQUFrQnBFLE1BQU0sQ0FBQ2tFLElBQVAsQ0FBWW1ZLHFCQUFaLENBQWxCLEVBQXNEO0FBQ3BEdFksSUFBQUEsR0FBRyxDQUFDSyxHQUFELENBQUgsR0FBVzRVLEdBQUcsQ0FBQzVVLEdBQUQsQ0FBZDtBQUNEOztBQUVELE1BQUk0VSxHQUFHLENBQUMrRSxXQUFKLEtBQW9COWIsU0FBeEIsRUFBbUM7QUFDakMsV0FBTzhCLEdBQVA7QUFDRDs7QUFFRCxTQUFPLEVBQUUsR0FBR0EsR0FBTDtBQUNMLE9BQUdpVixHQUFHLENBQUMrRSxXQURGLEVBQVA7O0FBR0Q7QUFDRDs7Ozs7Ozs7OztBQVVBLFNBQVN2RSxPQUFULENBQWlCdFosS0FBakIsRUFBd0I4ZCxJQUF4QixFQUE4QjtBQUM1QjtBQUNBLFFBQU1oRixHQUFHLEdBQUc7QUFDVmlGLElBQUFBLE1BQU0sRUFBRSxFQURFO0FBRVZDLElBQUFBLGNBQWMsRUFBRSxDQUZOO0FBR1ZDLElBQUFBLElBQUksRUFBRSxFQUhJO0FBSVZDLElBQUFBLFlBQVksRUFBRSxDQUpKO0FBS1ZOLElBQUFBLE9BQU8sRUFBRU8sY0FMQztBQU1WaEYsSUFBQUEsVUFBVSxFQUFFZ0QscUJBQXFCLENBQUNoRCxVQU54QjtBQU9Wa0QsSUFBQUEsS0FBSyxFQUFFRixxQkFBcUIsQ0FBQ0UsS0FQbkI7QUFRVkMsSUFBQUEsTUFBTSxFQUFFSCxxQkFBcUIsQ0FBQ0csTUFScEI7QUFTVkMsSUFBQUEsYUFBYSxFQUFFSixxQkFBcUIsQ0FBQ0ksYUFUM0I7QUFVVkMsSUFBQUEsU0FBUyxFQUFFTCxxQkFBcUIsQ0FBQ0ssU0FWdkI7QUFXVkMsSUFBQUEsY0FBYyxFQUFFTixxQkFBcUIsQ0FBQ00sY0FYNUI7QUFZVmxELElBQUFBLFdBQVcsRUFBRTRDLHFCQUFxQixDQUFDNUMsV0FaekI7QUFhVkMsSUFBQUEsT0FBTyxFQUFFMkMscUJBQXFCLENBQUMzQyxPQWJyQjtBQWNWa0QsSUFBQUEsTUFBTSxFQUFFUCxxQkFBcUIsQ0FBQ08sTUFkcEI7QUFlVkMsSUFBQUEsT0FBTyxFQUFFUixxQkFBcUIsQ0FBQ1EsT0FmckIsRUFBWjs7O0FBa0JBLE1BQUluWixTQUFTLENBQUNQLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEI7QUFDQSxRQUFJTyxTQUFTLENBQUNQLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsVUFBSU8sU0FBUyxDQUFDLENBQUQsQ0FBVCxLQUFpQnpCLFNBQXJCLEVBQWdDO0FBQzlCK1csUUFBQUEsR0FBRyxDQUFDdUQsS0FBSixHQUFZN1ksU0FBUyxDQUFDLENBQUQsQ0FBckI7QUFDRDs7QUFFRCxVQUFJQSxTQUFTLENBQUNQLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JPLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUJ6QixTQUE3QyxFQUF3RDtBQUN0RCtXLFFBQUFBLEdBQUcsQ0FBQ3dELE1BQUosR0FBYTlZLFNBQVMsQ0FBQyxDQUFELENBQXRCO0FBQ0Q7QUFDRixLQVZ1QixDQVV0Qjs7O0FBR0YsUUFBSSxPQUFPc2EsSUFBUCxLQUFnQixTQUFwQixFQUErQjtBQUM3QmhGLE1BQUFBLEdBQUcsQ0FBQ0ssVUFBSixHQUFpQjJFLElBQWpCO0FBQ0QsS0FGRCxNQUVPLElBQUlBLElBQUosRUFBVTtBQUNmLFlBQU1NLE9BQU8sR0FBR3RlLE1BQU0sQ0FBQ2tFLElBQVAsQ0FBWThaLElBQVosQ0FBaEI7O0FBRUEsV0FBSyxNQUFNNVosR0FBWCxJQUFrQmthLE9BQWxCLEVBQTJCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFlBQUlwQyxjQUFjLENBQUNHLHFCQUFELEVBQXdCalksR0FBeEIsQ0FBZCxJQUE4Q0EsR0FBRyxLQUFLLFNBQTFELEVBQXFFO0FBQ25FNFUsVUFBQUEsR0FBRyxDQUFDNVUsR0FBRCxDQUFILEdBQVc0WixJQUFJLENBQUM1WixHQUFELENBQWY7QUFDRCxTQUZELE1BRU8sSUFBSTRVLEdBQUcsQ0FBQytFLFdBQUosS0FBb0I5YixTQUF4QixFQUFtQztBQUN4QztBQUNBK1csVUFBQUEsR0FBRyxDQUFDK0UsV0FBSixHQUFrQkMsSUFBbEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJaEYsR0FBRyxDQUFDd0QsTUFBUixFQUFnQjtBQUNkeEQsSUFBQUEsR0FBRyxDQUFDOEUsT0FBSixHQUFjUyxnQkFBZDtBQUNEOztBQUVELE1BQUl2RixHQUFHLENBQUMyRCxjQUFKLEtBQXVCLElBQTNCLEVBQWlDO0FBQy9CM0QsSUFBQUEsR0FBRyxDQUFDMkQsY0FBSixHQUFxQjVhLFFBQXJCO0FBQ0Q7O0FBRUQsU0FBT3ljLFdBQVcsQ0FBQ3hGLEdBQUQsRUFBTTlZLEtBQU4sRUFBYSxDQUFiLENBQWxCO0FBQ0Q7QUFDRHNaLE9BQU8sQ0FBQ2lGLE1BQVIsR0FBaUI1ZCxtQkFBakI7QUFDQWIsTUFBTSxDQUFDeUosY0FBUCxDQUFzQitQLE9BQXRCLEVBQStCLGdCQUEvQixFQUFpRDtBQUMvQ3hVLEVBQUFBLEdBQUcsR0FBRztBQUNKLFdBQU9xWCxxQkFBUDtBQUNELEdBSDhDOztBQUsvQ3BULEVBQUFBLEdBQUcsQ0FBQ3lWLE9BQUQsRUFBVTtBQUNYLFFBQUlBLE9BQU8sS0FBSyxJQUFaLElBQW9CLE9BQU9BLE9BQVAsS0FBbUIsUUFBM0MsRUFBcUQ7QUFDbkQsWUFBTSxJQUFJekMsb0JBQUosQ0FBeUIsU0FBekIsRUFBb0MsUUFBcEMsRUFBOEN5QyxPQUE5QyxDQUFOO0FBQ0Q7O0FBRUQxZSxJQUFBQSxNQUFNLENBQUMyZSxNQUFQLENBQWN0QyxxQkFBZCxFQUFxQ3FDLE9BQXJDO0FBQ0QsR0FYOEMsRUFBakQ7O0FBYUk7O0FBRUpsRixPQUFPLENBQUNnRCxNQUFSLEdBQWlCeGMsTUFBTSxDQUFDMmUsTUFBUCxDQUFjM2UsTUFBTSxDQUFDdVosTUFBUCxDQUFjLElBQWQsQ0FBZCxFQUFtQztBQUNsRHFGLEVBQUFBLElBQUksRUFBRSxDQUFDLENBQUQsRUFBSSxFQUFKLENBRDRDO0FBRWxEQyxFQUFBQSxNQUFNLEVBQUUsQ0FBQyxDQUFELEVBQUksRUFBSixDQUYwQztBQUdsREMsRUFBQUEsU0FBUyxFQUFFLENBQUMsQ0FBRCxFQUFJLEVBQUosQ0FIdUM7QUFJbERDLEVBQUFBLE9BQU8sRUFBRSxDQUFDLENBQUQsRUFBSSxFQUFKLENBSnlDO0FBS2xEQyxFQUFBQSxLQUFLLEVBQUUsQ0FBQyxFQUFELEVBQUssRUFBTCxDQUwyQztBQU1sREMsRUFBQUEsSUFBSSxFQUFFLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FONEM7QUFPbERDLEVBQUFBLEtBQUssRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBUDJDO0FBUWxEQyxFQUFBQSxJQUFJLEVBQUUsQ0FBQyxFQUFELEVBQUssRUFBTCxDQVI0QztBQVNsREMsRUFBQUEsSUFBSSxFQUFFLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FUNEM7QUFVbERDLEVBQUFBLEtBQUssRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBVjJDO0FBV2xEQyxFQUFBQSxPQUFPLEVBQUUsQ0FBQyxFQUFELEVBQUssRUFBTCxDQVh5QztBQVlsREMsRUFBQUEsR0FBRyxFQUFFLENBQUMsRUFBRCxFQUFLLEVBQUwsQ0FaNkM7QUFhbERDLEVBQUFBLE1BQU0sRUFBRSxDQUFDLEVBQUQsRUFBSyxFQUFMLENBYjBDLEVBQW5DLENBQWpCO0FBY0k7O0FBRUpoRyxPQUFPLENBQUNpRyxNQUFSLEdBQWlCemYsTUFBTSxDQUFDMmUsTUFBUCxDQUFjM2UsTUFBTSxDQUFDdVosTUFBUCxDQUFjLElBQWQsQ0FBZCxFQUFtQztBQUNsRG1HLEVBQUFBLE9BQU8sRUFBRSxNQUR5QztBQUVsREMsRUFBQUEsTUFBTSxFQUFFLFFBRjBDO0FBR2xEQyxFQUFBQSxNQUFNLEVBQUUsUUFIMEM7QUFJbERDLEVBQUFBLE9BQU8sRUFBRSxRQUp5QztBQUtsRDVkLEVBQUFBLFNBQVMsRUFBRSxNQUx1QztBQU1sRDZkLEVBQUFBLElBQUksRUFBRSxNQU40QztBQU9sRGhKLEVBQUFBLE1BQU0sRUFBRSxPQVAwQztBQVFsRGlKLEVBQUFBLE1BQU0sRUFBRSxPQVIwQztBQVNsREMsRUFBQUEsSUFBSSxFQUFFLFNBVDRDO0FBVWxEO0FBQ0FDLEVBQUFBLE1BQU0sRUFBRSxLQVgwQztBQVlsREMsRUFBQUEsTUFBTSxFQUFFLFdBWjBDLEVBQW5DLENBQWpCOzs7QUFlQSxTQUFTQyxTQUFULENBQW1CaGYsR0FBbkIsRUFBd0JpZixNQUF4QixFQUFnQztBQUM5QixNQUFJQSxNQUFNLEtBQUssQ0FBQyxDQUFoQixFQUFtQjtBQUNqQixXQUFRLElBQUdqZixHQUFJLEdBQWY7QUFDRDs7QUFFRCxNQUFJaWYsTUFBTSxLQUFLLENBQUMsQ0FBaEIsRUFBbUI7QUFDakIsV0FBUSxLQUFJamYsR0FBSSxJQUFoQjtBQUNEOztBQUVELFNBQVEsSUFBR0EsR0FBSSxHQUFmO0FBQ0Q7O0FBRUQsTUFBTWtmLFFBQVEsR0FBR2xmLEdBQUcsSUFBSXljLElBQUksQ0FBQ3pjLEdBQUcsQ0FBQ3FELFVBQUosQ0FBZSxDQUFmLENBQUQsQ0FBNUIsQyxDQUFpRDtBQUNqRDs7O0FBR0EsU0FBUzhiLFNBQVQsQ0FBbUJuZixHQUFuQixFQUF3QjtBQUN0QixNQUFJb2YsVUFBVSxHQUFHdEQsd0JBQWpCO0FBQ0EsTUFBSXVELGFBQWEsR0FBR3RELDBCQUFwQjtBQUNBLE1BQUl1RCxXQUFXLEdBQUcsRUFBbEIsQ0FIc0IsQ0FHQTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJdGYsR0FBRyxDQUFDOEYsUUFBSixDQUFhLEdBQWIsQ0FBSixFQUF1QjtBQUNyQjtBQUNBO0FBQ0EsUUFBSSxDQUFDOUYsR0FBRyxDQUFDOEYsUUFBSixDQUFhLEdBQWIsQ0FBTCxFQUF3QjtBQUN0QndaLE1BQUFBLFdBQVcsR0FBRyxDQUFDLENBQWY7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDdGYsR0FBRyxDQUFDOEYsUUFBSixDQUFhLEdBQWIsQ0FBRCxJQUFzQixDQUFDOUYsR0FBRyxDQUFDOEYsUUFBSixDQUFhLElBQWIsQ0FBM0IsRUFBK0M7QUFDcER3WixNQUFBQSxXQUFXLEdBQUcsQ0FBQyxDQUFmO0FBQ0Q7O0FBRUQsUUFBSUEsV0FBVyxLQUFLLEVBQXBCLEVBQXdCO0FBQ3RCRixNQUFBQSxVQUFVLEdBQUdwRCw4QkFBYjtBQUNBcUQsTUFBQUEsYUFBYSxHQUFHcEQsZ0NBQWhCO0FBQ0Q7QUFDRixHQXRCcUIsQ0FzQnBCOzs7QUFHRixNQUFJamMsR0FBRyxDQUFDZ0MsTUFBSixHQUFhLElBQWIsSUFBcUIsQ0FBQ29kLFVBQVUsQ0FBQ3hkLElBQVgsQ0FBZ0I1QixHQUFoQixDQUExQixFQUFnRDtBQUM5QyxXQUFPZ2YsU0FBUyxDQUFDaGYsR0FBRCxFQUFNc2YsV0FBTixDQUFoQjtBQUNEOztBQUVELE1BQUl0ZixHQUFHLENBQUNnQyxNQUFKLEdBQWEsR0FBakIsRUFBc0I7QUFDcEJoQyxJQUFBQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ0MsT0FBSixDQUFZb2YsYUFBWixFQUEyQkgsUUFBM0IsQ0FBTjtBQUNBLFdBQU9GLFNBQVMsQ0FBQ2hmLEdBQUQsRUFBTXNmLFdBQU4sQ0FBaEI7QUFDRDs7QUFFRCxNQUFJck8sTUFBTSxHQUFHLEVBQWI7QUFDQSxNQUFJc08sSUFBSSxHQUFHLENBQVg7QUFDQSxRQUFNdGQsU0FBUyxHQUFHakMsR0FBRyxDQUFDZ0MsTUFBdEI7O0FBRUEsT0FBSyxJQUFJRSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRCxTQUFwQixFQUErQkMsQ0FBQyxFQUFoQyxFQUFvQztBQUNsQyxVQUFNc2QsS0FBSyxHQUFHeGYsR0FBRyxDQUFDcUQsVUFBSixDQUFlbkIsQ0FBZixDQUFkOztBQUVBLFFBQUlzZCxLQUFLLEtBQUtGLFdBQVYsSUFBeUJFLEtBQUssS0FBSyxFQUFuQyxJQUF5Q0EsS0FBSyxHQUFHLEVBQXJELEVBQXlEO0FBQ3ZELFVBQUlELElBQUksS0FBS3JkLENBQWIsRUFBZ0I7QUFDZCtPLFFBQUFBLE1BQU0sSUFBSXdMLElBQUksQ0FBQytDLEtBQUQsQ0FBZDtBQUNELE9BRkQsTUFFTztBQUNMdk8sUUFBQUEsTUFBTSxJQUFLLEdBQUVqUixHQUFHLENBQUNnSyxLQUFKLENBQVV1VixJQUFWLEVBQWdCcmQsQ0FBaEIsQ0FBbUIsR0FBRXVhLElBQUksQ0FBQytDLEtBQUQsQ0FBUSxFQUE5QztBQUNEOztBQUVERCxNQUFBQSxJQUFJLEdBQUdyZCxDQUFDLEdBQUcsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSXFkLElBQUksS0FBS3RkLFNBQWIsRUFBd0I7QUFDdEJnUCxJQUFBQSxNQUFNLElBQUlqUixHQUFHLENBQUNnSyxLQUFKLENBQVV1VixJQUFWLENBQVY7QUFDRDs7QUFFRCxTQUFPUCxTQUFTLENBQUMvTixNQUFELEVBQVNxTyxXQUFULENBQWhCO0FBQ0Q7O0FBRUQsU0FBU2xDLGdCQUFULENBQTBCcGQsR0FBMUIsRUFBK0J5ZixTQUEvQixFQUEwQztBQUN4QyxRQUFNQyxLQUFLLEdBQUdySCxPQUFPLENBQUNpRyxNQUFSLENBQWVtQixTQUFmLENBQWQ7O0FBRUEsTUFBSUMsS0FBSyxLQUFLNWUsU0FBZCxFQUF5QjtBQUN2QixVQUFNNmUsS0FBSyxHQUFHdEgsT0FBTyxDQUFDZ0QsTUFBUixDQUFlcUUsS0FBZixDQUFkO0FBQ0EsV0FBUSxVQUFTQyxLQUFLLENBQUMsQ0FBRCxDQUFJLElBQUczZixHQUFJLFVBQVMyZixLQUFLLENBQUMsQ0FBRCxDQUFJLEdBQW5EO0FBQ0Q7O0FBRUQsU0FBTzNmLEdBQVA7QUFDRDs7QUFFRCxTQUFTa2QsY0FBVCxDQUF3QmxkLEdBQXhCLEVBQTZCO0FBQzNCLFNBQU9BLEdBQVA7QUFDRCxDLENBQUM7OztBQUdGLFNBQVM0ZixtQkFBVCxHQUErQjtBQUM3QixTQUFPLEVBQVA7QUFDRDs7QUFFRCxTQUFTQyxrQkFBVCxDQUE0QmpkLEdBQTVCLEVBQWlDa2QsSUFBakMsRUFBdUM7QUFDckMsTUFBSUMsVUFBSixDQURxQyxDQUNyQjs7QUFFaEIsU0FBT25kLEdBQVAsRUFBWTtBQUNWLFVBQU1vZCxVQUFVLEdBQUduaEIsTUFBTSxDQUFDOEUsd0JBQVAsQ0FBZ0NmLEdBQWhDLEVBQXFDLGFBQXJDLENBQW5COztBQUVBLFFBQUlvZCxVQUFVLEtBQUtsZixTQUFmLElBQTRCLE9BQU9rZixVQUFVLENBQUNqaEIsS0FBbEIsS0FBNEIsVUFBeEQsSUFBc0VpaEIsVUFBVSxDQUFDamhCLEtBQVgsQ0FBaUJrRixJQUFqQixLQUEwQixFQUFwRyxFQUF3RztBQUN0RyxhQUFPK2IsVUFBVSxDQUFDamhCLEtBQVgsQ0FBaUJrRixJQUF4QjtBQUNEOztBQUVEckIsSUFBQUEsR0FBRyxHQUFHL0QsTUFBTSxDQUFDMEUsY0FBUCxDQUFzQlgsR0FBdEIsQ0FBTjs7QUFFQSxRQUFJbWQsVUFBVSxLQUFLamYsU0FBbkIsRUFBOEI7QUFDNUJpZixNQUFBQSxVQUFVLEdBQUduZCxHQUFiO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJbWQsVUFBVSxLQUFLLElBQW5CLEVBQXlCO0FBQ3ZCLFdBQU8sSUFBUDtBQUNEO0FBQ0Q7Ozs7Ozs7OztBQVNBLFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVNFLFNBQVQsQ0FBbUJwYSxXQUFuQixFQUFnQ3FhLEdBQWhDLEVBQXFDQyxRQUFyQyxFQUErQztBQUM3QyxNQUFJdGEsV0FBVyxLQUFLLElBQXBCLEVBQTBCO0FBQ3hCLFFBQUlxYSxHQUFHLEtBQUssRUFBWixFQUFnQjtBQUNkLGFBQVEsSUFBR0MsUUFBUyxzQkFBcUJELEdBQUksSUFBN0M7QUFDRDs7QUFFRCxXQUFRLElBQUdDLFFBQVMsb0JBQXBCO0FBQ0Q7O0FBRUQsTUFBSUQsR0FBRyxLQUFLLEVBQVIsSUFBY3JhLFdBQVcsS0FBS3FhLEdBQWxDLEVBQXVDO0FBQ3JDLFdBQVEsR0FBRXJhLFdBQVksS0FBSXFhLEdBQUksSUFBOUI7QUFDRDs7QUFFRCxTQUFRLEdBQUVyYSxXQUFZLEdBQXRCO0FBQ0QsQyxDQUFDOzs7QUFHRixTQUFTdWEsT0FBVCxDQUFpQnJoQixLQUFqQixFQUF3Qm1aLFVBQXhCLEVBQW9DO0FBQ2xDLE1BQUluVixJQUFKO0FBQ0EsUUFBTXNkLE9BQU8sR0FBR3hoQixNQUFNLENBQUN5aEIscUJBQVAsQ0FBNkJ2aEIsS0FBN0IsQ0FBaEI7O0FBRUEsTUFBSW1aLFVBQUosRUFBZ0I7QUFDZG5WLElBQUFBLElBQUksR0FBR2xFLE1BQU0sQ0FBQ21FLG1CQUFQLENBQTJCakUsS0FBM0IsQ0FBUDs7QUFFQSxRQUFJc2hCLE9BQU8sQ0FBQ3JlLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEJlLE1BQUFBLElBQUksQ0FBQ3hCLElBQUwsQ0FBVSxHQUFHOGUsT0FBYjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUk7QUFDRnRkLE1BQUFBLElBQUksR0FBR2xFLE1BQU0sQ0FBQ2tFLElBQVAsQ0FBWWhFLEtBQVosQ0FBUDtBQUNELEtBRkQsQ0FFRSxPQUFPMEIsR0FBUCxFQUFZO0FBQ1o7O0FBRUE7Ozs7QUFJQXNDLE1BQUFBLElBQUksR0FBR2xFLE1BQU0sQ0FBQ21FLG1CQUFQLENBQTJCakUsS0FBM0IsQ0FBUDtBQUNEOztBQUVELFFBQUlzaEIsT0FBTyxDQUFDcmUsTUFBUixLQUFtQixDQUF2QixFQUEwQjtBQUN4QmUsTUFBQUEsSUFBSSxDQUFDeEIsSUFBTCxDQUFVLEdBQUc4ZSxPQUFPLENBQUN4ZCxNQUFSLENBQWVJLEdBQUcsSUFBSStYLG9CQUFvQixDQUFDamMsS0FBRCxFQUFRa0UsR0FBUixDQUExQyxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPRixJQUFQO0FBQ0Q7O0FBRUQsU0FBU3dkLFdBQVQsQ0FBcUJ4aEIsS0FBckIsRUFBNEI4RyxXQUE1QixFQUF5Q3FhLEdBQXpDLEVBQThDO0FBQzVDLE1BQUlDLFFBQVEsR0FBRyxFQUFmOztBQUVBLE1BQUl0YSxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDeEJzYSxJQUFBQSxRQUFRLEdBQUcsUUFBWDtBQUNEOztBQUVELFNBQU9GLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUJDLFFBQW5CLENBQWhCO0FBQ0Q7O0FBRUQsU0FBU0ssb0JBQVQsQ0FBOEJ6aEIsS0FBOUIsRUFBcUM7QUFDbkMsT0FBSyxNQUFNLENBQUMwaEIsS0FBRCxFQUFReFksS0FBUixDQUFYLElBQTZCLENBQUMsQ0FBQzNCLFlBQUQsRUFBZTlDLFVBQWYsQ0FBRCxFQUE2QixDQUFDK0MsbUJBQUQsRUFBc0JtYSxpQkFBdEIsQ0FBN0IsRUFBdUUsQ0FBQ2xhLGFBQUQsRUFBZ0JtYSxXQUFoQixDQUF2RSxFQUFxRyxDQUFDbGEsYUFBRCxFQUFnQm1hLFdBQWhCLENBQXJHLEVBQW1JLENBQUNwYixXQUFELEVBQWNxYixTQUFkLENBQW5JLEVBQTZKLENBQUNwYixZQUFELEVBQWVxYixVQUFmLENBQTdKLEVBQXlMLENBQUNwYixZQUFELEVBQWVxYixVQUFmLENBQXpMLEVBQXFOLENBQUMzYixjQUFELEVBQWlCdUosWUFBakIsQ0FBck4sRUFBcVAsQ0FBQ3RKLGNBQUQsRUFBaUJtSixZQUFqQixDQUFyUCxDQUE3QixFQUFtVDtBQUNqVCxRQUFJaVMsS0FBSyxDQUFDMWhCLEtBQUQsQ0FBVCxFQUFrQjtBQUNoQixhQUFPa0osS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJK1ksc0JBQUosQyxDQUE0QjtBQUM1Qjs7QUFFQSxTQUFTQyxzQkFBVCxDQUFnQ2haLEtBQWhDLEVBQXVDaEUsSUFBdkMsRUFBNkM7QUFDM0MsTUFBSStjLHNCQUFzQixLQUFLbGdCLFNBQS9CLEVBQTBDO0FBQ3hDa2dCLElBQUFBLHNCQUFzQixHQUFHLElBQUl6WixHQUFKLEVBQXpCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsVUFBTTJaLFdBQVcsR0FBR0Ysc0JBQXNCLENBQUNuZCxHQUF2QixDQUEyQm9FLEtBQTNCLENBQXBCOztBQUVBLFFBQUlpWixXQUFXLEtBQUtwZ0IsU0FBcEIsRUFBK0I7QUFDN0IsYUFBT29nQixXQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNQyxhQUFOLFNBQTRCbFosS0FBNUIsQ0FBa0M7QUFDaEMsU0FBS3RJLE1BQU0sQ0FBQ2lFLFdBQVosSUFBMkI7QUFDekIsYUFBTyxFQUFQO0FBQ0QsS0FIK0I7Ozs7QUFPbEMvRSxFQUFBQSxNQUFNLENBQUN5SixjQUFQLENBQXNCNlksYUFBYSxDQUFDMWQsU0FBZCxDQUF3Qm9DLFdBQTlDLEVBQTJELE1BQTNELEVBQW1FO0FBQ2pFOUcsSUFBQUEsS0FBSyxFQUFHLElBQUdrRixJQUFLLG1CQURpRCxFQUFuRTs7QUFHQStjLEVBQUFBLHNCQUFzQixDQUFDbFosR0FBdkIsQ0FBMkJHLEtBQTNCLEVBQWtDa1osYUFBbEM7QUFDQSxTQUFPQSxhQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsbUJBQVQsQ0FBNkJ2SixHQUE3QixFQUFrQzlZLEtBQWxDLEVBQXlDNlksWUFBekMsRUFBdUQ7QUFDckQsTUFBSXlKLE1BQUo7O0FBRUEsTUFBSXBiLEtBQUssQ0FBQ2xILEtBQUQsQ0FBVCxFQUFrQjtBQUNoQixVQUFNa0osS0FBSyxHQUFHZ1osc0JBQXNCLENBQUN0RyxHQUFELEVBQU0sS0FBTixDQUFwQztBQUNBMEcsSUFBQUEsTUFBTSxHQUFHLElBQUlwWixLQUFKLENBQVV5UyxZQUFZLENBQUNqRixNQUFiLENBQW9CMVcsS0FBcEIsQ0FBVixDQUFUO0FBQ0QsR0FIRCxNQUdPLElBQUk0RyxLQUFLLENBQUM1RyxLQUFELENBQVQsRUFBa0I7QUFDdkIsVUFBTWtKLEtBQUssR0FBR2daLHNCQUFzQixDQUFDMVosR0FBRCxFQUFNLEtBQU4sQ0FBcEM7QUFDQThaLElBQUFBLE1BQU0sR0FBRyxJQUFJcFosS0FBSixDQUFVcVMsWUFBWSxDQUFDekosT0FBYixDQUFxQjlSLEtBQXJCLENBQVYsQ0FBVDtBQUNELEdBSE0sTUFHQSxJQUFJMEMsS0FBSyxDQUFDQyxPQUFOLENBQWMzQyxLQUFkLENBQUosRUFBMEI7QUFDL0IsVUFBTWtKLEtBQUssR0FBR2daLHNCQUFzQixDQUFDeGYsS0FBRCxFQUFRLE9BQVIsQ0FBcEM7QUFDQTRmLElBQUFBLE1BQU0sR0FBRyxJQUFJcFosS0FBSixDQUFVbEosS0FBSyxDQUFDaUQsTUFBaEIsQ0FBVDtBQUNELEdBSE0sTUFHQSxJQUFJb0UsWUFBWSxDQUFDckgsS0FBRCxDQUFoQixFQUF5QjtBQUM5QixVQUFNOEcsV0FBVyxHQUFHMmEsb0JBQW9CLENBQUN6aEIsS0FBRCxDQUF4QztBQUNBLFVBQU1rSixLQUFLLEdBQUdnWixzQkFBc0IsQ0FBQ3BiLFdBQUQsRUFBY0EsV0FBVyxDQUFDNUIsSUFBMUIsQ0FBcEM7QUFDQW9kLElBQUFBLE1BQU0sR0FBRyxJQUFJcFosS0FBSixDQUFVbEosS0FBVixDQUFUO0FBQ0Q7O0FBRUQsTUFBSXNpQixNQUFNLEtBQUt2Z0IsU0FBZixFQUEwQjtBQUN4QmpDLElBQUFBLE1BQU0sQ0FBQ0MsZ0JBQVAsQ0FBd0J1aUIsTUFBeEIsRUFBZ0N4aUIsTUFBTSxDQUFDeWlCLHlCQUFQLENBQWlDdmlCLEtBQWpDLENBQWhDO0FBQ0EsV0FBT3dpQixTQUFTLENBQUMxSixHQUFELEVBQU13SixNQUFOLEVBQWN6SixZQUFkLENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTeUYsV0FBVCxDQUFxQnhGLEdBQXJCLEVBQTBCOVksS0FBMUIsRUFBaUM2WSxZQUFqQyxFQUErQzRKLFVBQS9DLEVBQTJEO0FBQ3pEO0FBQ0EsTUFBSSxPQUFPemlCLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixVQUFsRCxFQUE4RDtBQUM1RCxXQUFPMGlCLGVBQWUsQ0FBQzVKLEdBQUcsQ0FBQzhFLE9BQUwsRUFBYzVkLEtBQWQsRUFBcUI4WSxHQUFyQixDQUF0QjtBQUNEOztBQUVELE1BQUk5WSxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNsQixXQUFPOFksR0FBRyxDQUFDOEUsT0FBSixDQUFZLE1BQVosRUFBb0IsTUFBcEIsQ0FBUDtBQUNELEdBUndELENBUXZEOzs7QUFHRixRQUFNK0UsT0FBTyxHQUFHM2lCLEtBQWhCO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7O0FBRUEsTUFBSThZLEdBQUcsQ0FBQ3lELGFBQVIsRUFBdUI7QUFDckIsVUFBTXFHLFdBQVcsR0FBRzVpQixLQUFLLENBQUNXLG1CQUFELENBQXpCOztBQUVBLFFBQUksT0FBT2lpQixXQUFQLEtBQXVCLFVBQXZCLENBQWtDO0FBQWxDLE9BQ0RBLFdBQVcsS0FBS3RKLE9BRGYsQ0FDdUI7QUFEdkIsT0FFRCxFQUFFdFosS0FBSyxDQUFDOEcsV0FBTixJQUFxQjlHLEtBQUssQ0FBQzhHLFdBQU4sQ0FBa0JwQyxTQUFsQixLQUFnQzFFLEtBQXZELENBRkgsRUFFa0U7QUFDaEU7QUFDQTtBQUNBLFlBQU1xYyxLQUFLLEdBQUd2RCxHQUFHLENBQUN1RCxLQUFKLEtBQWMsSUFBZCxHQUFxQixJQUFyQixHQUE0QnZELEdBQUcsQ0FBQ3VELEtBQUosR0FBWXhELFlBQXREO0FBQ0EsWUFBTWdLLEdBQUcsR0FBR0QsV0FBVyxDQUFDdGYsSUFBWixDQUFpQnFmLE9BQWpCLEVBQTBCdEcsS0FBMUIsRUFBaUNzQixjQUFjLENBQUM3RSxHQUFELENBQS9DLENBQVosQ0FKZ0UsQ0FJRztBQUNuRTs7QUFFQSxVQUFJK0osR0FBRyxLQUFLRixPQUFaLEVBQXFCO0FBQ25CLFlBQUksT0FBT0UsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLGlCQUFPdkUsV0FBVyxDQUFDeEYsR0FBRCxFQUFNK0osR0FBTixFQUFXaEssWUFBWCxDQUFsQjtBQUNEOztBQUVELGVBQU9nSyxHQUFHLENBQUMzaEIsT0FBSixDQUFZLEtBQVosRUFBb0IsS0FBSSxJQUFJNGhCLE1BQUosQ0FBV2hLLEdBQUcsQ0FBQ2tGLGNBQWYsQ0FBK0IsRUFBdkQsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixHQS9Dd0QsQ0ErQ3ZEO0FBQ0Y7OztBQUdBLE1BQUlsRixHQUFHLENBQUNtRixJQUFKLENBQVNsWCxRQUFULENBQWtCL0csS0FBbEIsQ0FBSixFQUE4QjtBQUM1QixRQUFJaU8sS0FBSyxHQUFHLENBQVo7O0FBRUEsUUFBSTZLLEdBQUcsQ0FBQ2lLLFFBQUosS0FBaUJoaEIsU0FBckIsRUFBZ0M7QUFDOUIrVyxNQUFBQSxHQUFHLENBQUNpSyxRQUFKLEdBQWUsSUFBSXZhLEdBQUosQ0FBUSxDQUFDLENBQUN4SSxLQUFELEVBQVFpTyxLQUFSLENBQUQsQ0FBUixDQUFmO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBLE1BQUFBLEtBQUssR0FBRzZLLEdBQUcsQ0FBQ2lLLFFBQUosQ0FBYWplLEdBQWIsQ0FBaUI5RSxLQUFqQixDQUFSOztBQUVBLFVBQUlpTyxLQUFLLEtBQUtsTSxTQUFkLEVBQXlCO0FBQ3ZCa00sUUFBQUEsS0FBSyxHQUFHNkssR0FBRyxDQUFDaUssUUFBSixDQUFhQyxJQUFiLEdBQW9CLENBQTVCO0FBQ0FsSyxRQUFBQSxHQUFHLENBQUNpSyxRQUFKLENBQWFoYSxHQUFiLENBQWlCL0ksS0FBakIsRUFBd0JpTyxLQUF4QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTzZLLEdBQUcsQ0FBQzhFLE9BQUosQ0FBYSxjQUFhM1AsS0FBTSxHQUFoQyxFQUFvQyxTQUFwQyxDQUFQO0FBQ0Q7O0FBRUQsU0FBT3VVLFNBQVMsQ0FBQzFKLEdBQUQsRUFBTTlZLEtBQU4sRUFBYTZZLFlBQWIsRUFBMkI0SixVQUEzQixDQUFoQjtBQUNEOztBQUVELFNBQVNELFNBQVQsQ0FBbUIxSixHQUFuQixFQUF3QjlZLEtBQXhCLEVBQStCNlksWUFBL0IsRUFBNkM0SixVQUE3QyxFQUF5RDtBQUN2RCxNQUFJemUsSUFBSjtBQUNBLFFBQU04QyxXQUFXLEdBQUdnYSxrQkFBa0IsQ0FBQzlnQixLQUFELENBQXRDO0FBQ0EsTUFBSW1oQixHQUFHLEdBQUduaEIsS0FBSyxDQUFDWSxNQUFNLENBQUNpRSxXQUFSLENBQWYsQ0FIdUQsQ0FHbEI7QUFDckM7O0FBRUEsTUFBSSxPQUFPc2MsR0FBUCxLQUFlLFFBQWYsSUFBMkJBLEdBQUcsS0FBSyxFQUFSLElBQWMsQ0FBQ3JJLEdBQUcsQ0FBQ0ssVUFBSixHQUFpQjZDLGNBQWpCLEdBQWtDQyxvQkFBbkMsRUFBeURqYyxLQUF6RCxFQUFnRVksTUFBTSxDQUFDaUUsV0FBdkUsQ0FBN0MsRUFBa0k7QUFDaElzYyxJQUFBQSxHQUFHLEdBQUcsRUFBTjtBQUNEOztBQUVELE1BQUk4QixJQUFJLEdBQUcsRUFBWDtBQUNBLE1BQUlDLFNBQVMsR0FBR3JDLG1CQUFoQjtBQUNBLE1BQUlzQyxNQUFKO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLElBQWpCO0FBQ0EsTUFBSWpnQixDQUFDLEdBQUcsQ0FBUjtBQUNBLFFBQU1XLE1BQU0sR0FBR2dWLEdBQUcsQ0FBQ0ssVUFBSixHQUFpQjRCLGdCQUFqQixHQUFvQ0MsaUJBQW5EO0FBQ0EsTUFBSXFJLFVBQVUsR0FBR3pHLFdBQWpCLENBaEJ1RCxDQWdCekI7O0FBRTlCLE1BQUk1YyxLQUFLLENBQUNZLE1BQU0sQ0FBQ3dSLFFBQVIsQ0FBVCxFQUE0QjtBQUMxQmdSLElBQUFBLFVBQVUsR0FBRyxLQUFiOztBQUVBLFFBQUkxZ0IsS0FBSyxDQUFDQyxPQUFOLENBQWMzQyxLQUFkLENBQUosRUFBMEI7QUFDeEJnRSxNQUFBQSxJQUFJLEdBQUdKLHdCQUF3QixDQUFDNUQsS0FBRCxFQUFROEQsTUFBUixDQUEvQixDQUR3QixDQUN3Qjs7QUFFaEQsWUFBTXdmLE1BQU0sR0FBR3BDLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUIsT0FBbkIsQ0FBeEI7QUFDQWdDLE1BQUFBLE1BQU0sR0FBRyxDQUFFLEdBQUVHLE1BQU0sS0FBSyxRQUFYLEdBQXNCLEVBQXRCLEdBQTJCQSxNQUFPLEdBQXRDLEVBQTBDLEdBQTFDLENBQVQ7O0FBRUEsVUFBSXRqQixLQUFLLENBQUNpRCxNQUFOLEtBQWlCLENBQWpCLElBQXNCZSxJQUFJLENBQUNmLE1BQUwsS0FBZ0IsQ0FBMUMsRUFBNkM7QUFDM0MsZUFBUSxHQUFFa2dCLE1BQU0sQ0FBQyxDQUFELENBQUksR0FBcEI7QUFDRDs7QUFFREUsTUFBQUEsVUFBVSxHQUFHdkcsZ0JBQWI7QUFDQW9HLE1BQUFBLFNBQVMsR0FBR0ssV0FBWjtBQUNELEtBWkQsTUFZTyxJQUFJcmMsS0FBSyxDQUFDbEgsS0FBRCxDQUFULEVBQWtCO0FBQ3ZCZ0UsTUFBQUEsSUFBSSxHQUFHcWQsT0FBTyxDQUFDcmhCLEtBQUQsRUFBUThZLEdBQUcsQ0FBQ0ssVUFBWixDQUFkO0FBQ0EsWUFBTW1LLE1BQU0sR0FBR3BDLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUIsS0FBbkIsQ0FBeEI7O0FBRUEsVUFBSW5oQixLQUFLLENBQUNnakIsSUFBTixLQUFlLENBQWYsSUFBb0JoZixJQUFJLENBQUNmLE1BQUwsS0FBZ0IsQ0FBeEMsRUFBMkM7QUFDekMsZUFBUSxHQUFFcWdCLE1BQU8sSUFBakI7QUFDRDs7QUFFREgsTUFBQUEsTUFBTSxHQUFHLENBQUUsR0FBRUcsTUFBTyxHQUFYLEVBQWUsR0FBZixDQUFUO0FBQ0FKLE1BQUFBLFNBQVMsR0FBR00sU0FBWjtBQUNELEtBVk0sTUFVQSxJQUFJNWMsS0FBSyxDQUFDNUcsS0FBRCxDQUFULEVBQWtCO0FBQ3ZCZ0UsTUFBQUEsSUFBSSxHQUFHcWQsT0FBTyxDQUFDcmhCLEtBQUQsRUFBUThZLEdBQUcsQ0FBQ0ssVUFBWixDQUFkO0FBQ0EsWUFBTW1LLE1BQU0sR0FBR3BDLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUIsS0FBbkIsQ0FBeEI7O0FBRUEsVUFBSW5oQixLQUFLLENBQUNnakIsSUFBTixLQUFlLENBQWYsSUFBb0JoZixJQUFJLENBQUNmLE1BQUwsS0FBZ0IsQ0FBeEMsRUFBMkM7QUFDekMsZUFBUSxHQUFFcWdCLE1BQU8sSUFBakI7QUFDRDs7QUFFREgsTUFBQUEsTUFBTSxHQUFHLENBQUUsR0FBRUcsTUFBTyxHQUFYLEVBQWUsR0FBZixDQUFUO0FBQ0FKLE1BQUFBLFNBQVMsR0FBR08sU0FBWjtBQUNELEtBVk0sTUFVQSxJQUFJcGMsWUFBWSxDQUFDckgsS0FBRCxDQUFoQixFQUF5QjtBQUM5QmdFLE1BQUFBLElBQUksR0FBR0osd0JBQXdCLENBQUM1RCxLQUFELEVBQVE4RCxNQUFSLENBQS9CO0FBQ0EsWUFBTXdmLE1BQU0sR0FBR3hjLFdBQVcsS0FBSyxJQUFoQixHQUF1Qm9hLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsQ0FBaEMsR0FBcURELFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUJNLG9CQUFvQixDQUFDemhCLEtBQUQsQ0FBcEIsQ0FBNEJrRixJQUEvQyxDQUE3RTtBQUNBaWUsTUFBQUEsTUFBTSxHQUFHLENBQUUsR0FBRUcsTUFBTyxHQUFYLEVBQWUsR0FBZixDQUFUOztBQUVBLFVBQUl0akIsS0FBSyxDQUFDaUQsTUFBTixLQUFpQixDQUFqQixJQUFzQmUsSUFBSSxDQUFDZixNQUFMLEtBQWdCLENBQXRDLElBQTJDLENBQUM2VixHQUFHLENBQUNLLFVBQXBELEVBQWdFO0FBQzlELGVBQVEsR0FBRWdLLE1BQU0sQ0FBQyxDQUFELENBQUksR0FBcEI7QUFDRDs7QUFFREQsTUFBQUEsU0FBUyxHQUFHUSxnQkFBWjtBQUNBTCxNQUFBQSxVQUFVLEdBQUd2RyxnQkFBYjtBQUNELEtBWE0sTUFXQSxJQUFJalcsYUFBYSxDQUFDN0csS0FBRCxDQUFqQixFQUEwQjtBQUMvQmdFLE1BQUFBLElBQUksR0FBR3FkLE9BQU8sQ0FBQ3JoQixLQUFELEVBQVE4WSxHQUFHLENBQUNLLFVBQVosQ0FBZDtBQUNBZ0ssTUFBQUEsTUFBTSxHQUFHUSxpQkFBaUIsQ0FBQyxLQUFELEVBQVF4QyxHQUFSLENBQTFCO0FBQ0ErQixNQUFBQSxTQUFTLEdBQUdVLGNBQVo7QUFDRCxLQUpNLE1BSUEsSUFBSXpjLGFBQWEsQ0FBQ25ILEtBQUQsQ0FBakIsRUFBMEI7QUFDL0JnRSxNQUFBQSxJQUFJLEdBQUdxZCxPQUFPLENBQUNyaEIsS0FBRCxFQUFROFksR0FBRyxDQUFDSyxVQUFaLENBQWQ7QUFDQWdLLE1BQUFBLE1BQU0sR0FBR1EsaUJBQWlCLENBQUMsS0FBRCxFQUFReEMsR0FBUixDQUExQjtBQUNBK0IsTUFBQUEsU0FBUyxHQUFHVSxjQUFaO0FBQ0QsS0FKTSxNQUlBO0FBQ0xSLE1BQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJQSxVQUFKLEVBQWdCO0FBQ2RwZixJQUFBQSxJQUFJLEdBQUdxZCxPQUFPLENBQUNyaEIsS0FBRCxFQUFROFksR0FBRyxDQUFDSyxVQUFaLENBQWQ7QUFDQWdLLElBQUFBLE1BQU0sR0FBRyxDQUFDLEdBQUQsRUFBTSxHQUFOLENBQVQ7O0FBRUEsUUFBSXJjLFdBQVcsS0FBSyxRQUFwQixFQUE4QjtBQUM1QixVQUFJdkIsaUJBQWlCLENBQUN2RixLQUFELENBQXJCLEVBQThCO0FBQzVCbWpCLFFBQUFBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxlQUFaO0FBQ0QsT0FGRCxNQUVPLElBQUloQyxHQUFHLEtBQUssRUFBWixFQUFnQjtBQUNyQmdDLFFBQUFBLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBYSxHQUFFakMsU0FBUyxDQUFDcGEsV0FBRCxFQUFjcWEsR0FBZCxFQUFtQixRQUFuQixDQUE2QixHQUFyRDtBQUNEOztBQUVELFVBQUluZCxJQUFJLENBQUNmLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsZUFBUSxHQUFFa2dCLE1BQU0sQ0FBQyxDQUFELENBQUksR0FBcEI7QUFDRDtBQUNGLEtBVkQsTUFVTyxJQUFJLE9BQU9uakIsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUN0Q2lqQixNQUFBQSxJQUFJLEdBQUdZLGVBQWUsQ0FBQzdqQixLQUFELEVBQVE4RyxXQUFSLEVBQXFCcWEsR0FBckIsQ0FBdEI7O0FBRUEsVUFBSW5kLElBQUksQ0FBQ2YsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixlQUFPNlYsR0FBRyxDQUFDOEUsT0FBSixDQUFZcUYsSUFBWixFQUFrQixTQUFsQixDQUFQO0FBQ0Q7QUFDRixLQU5NLE1BTUEsSUFBSWhjLFFBQVEsQ0FBQ2pILEtBQUQsQ0FBWixFQUFxQjtBQUMxQjtBQUNBO0FBQ0EsWUFBTThqQixNQUFNLEdBQUdoZCxXQUFXLEtBQUssSUFBaEIsR0FBdUI5RyxLQUF2QixHQUErQixJQUFJeWIsTUFBSixDQUFXemIsS0FBWCxDQUE5QztBQUNBaWpCLE1BQUFBLElBQUksR0FBR3pILGVBQWUsQ0FBQ3JXLFFBQWhCLENBQXlCN0IsSUFBekIsQ0FBOEJ3Z0IsTUFBOUIsQ0FBUDtBQUNBLFlBQU1SLE1BQU0sR0FBR3BDLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUIsUUFBbkIsQ0FBeEI7O0FBRUEsVUFBSW1DLE1BQU0sS0FBSyxTQUFmLEVBQTBCO0FBQ3hCTCxRQUFBQSxJQUFJLEdBQUksR0FBRUssTUFBTyxHQUFFTCxJQUFLLEVBQXhCO0FBQ0Q7O0FBRUQsVUFBSWpmLElBQUksQ0FBQ2YsTUFBTCxLQUFnQixDQUFoQixJQUFxQjRWLFlBQVksR0FBR0MsR0FBRyxDQUFDdUQsS0FBbkIsSUFBNEJ2RCxHQUFHLENBQUN1RCxLQUFKLEtBQWMsSUFBbkUsRUFBeUU7QUFDdkUsZUFBT3ZELEdBQUcsQ0FBQzhFLE9BQUosQ0FBWXFGLElBQVosRUFBa0IsUUFBbEIsQ0FBUDtBQUNEO0FBQ0YsS0FkTSxNQWNBLElBQUk3YyxNQUFNLENBQUNwRyxLQUFELENBQVYsRUFBbUI7QUFDeEI7QUFDQWlqQixNQUFBQSxJQUFJLEdBQUd6WCxNQUFNLENBQUNDLEtBQVAsQ0FBYTBQLGFBQWEsQ0FBQzRJLE9BQWQsQ0FBc0J6Z0IsSUFBdEIsQ0FBMkJ0RCxLQUEzQixDQUFiLElBQWtEbWIsYUFBYSxDQUFDaFcsUUFBZCxDQUF1QjdCLElBQXZCLENBQTRCdEQsS0FBNUIsQ0FBbEQsR0FBdUZtYixhQUFhLENBQUM2SSxXQUFkLENBQTBCMWdCLElBQTFCLENBQStCdEQsS0FBL0IsQ0FBOUY7QUFDQSxZQUFNc2pCLE1BQU0sR0FBR3BDLFNBQVMsQ0FBQ3BhLFdBQUQsRUFBY3FhLEdBQWQsRUFBbUIsTUFBbkIsQ0FBeEI7O0FBRUEsVUFBSW1DLE1BQU0sS0FBSyxPQUFmLEVBQXdCO0FBQ3RCTCxRQUFBQSxJQUFJLEdBQUksR0FBRUssTUFBTyxHQUFFTCxJQUFLLEVBQXhCO0FBQ0Q7O0FBRUQsVUFBSWpmLElBQUksQ0FBQ2YsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixlQUFPNlYsR0FBRyxDQUFDOEUsT0FBSixDQUFZcUYsSUFBWixFQUFrQixNQUFsQixDQUFQO0FBQ0Q7QUFDRixLQVpNLE1BWUEsSUFBSTloQixPQUFPLENBQUNuQixLQUFELENBQVgsRUFBb0I7QUFDekJpakIsTUFBQUEsSUFBSSxHQUFHZ0IsV0FBVyxDQUFDamtCLEtBQUQsRUFBUThHLFdBQVIsRUFBcUJxYSxHQUFyQixFQUEwQnJJLEdBQTFCLENBQWxCOztBQUVBLFVBQUk5VSxJQUFJLENBQUNmLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsZUFBT2dnQixJQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUluSCxLQUFKLEVBQVc7QUFDaEIsY0FBTW9JLGdCQUFnQixHQUFHLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsV0FBbkIsQ0FBekI7O0FBRUEsWUFBSWxnQixJQUFJLENBQUNtZ0IsS0FBTCxDQUFXamdCLEdBQUcsSUFBSWdnQixnQkFBZ0IsQ0FBQ25kLFFBQWpCLENBQTBCN0MsR0FBMUIsQ0FBbEIsQ0FBSixFQUF1RDtBQUNyRCxpQkFBTytlLElBQVA7QUFDRDtBQUNGO0FBQ0YsS0FaTSxNQVlBLElBQUk3ZCxnQkFBZ0IsQ0FBQ3BGLEtBQUQsQ0FBcEIsRUFBNkI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsWUFBTW9rQixTQUFTLEdBQUcvZSxhQUFhLENBQUNyRixLQUFELENBQWIsR0FBdUIsYUFBdkIsR0FBdUMsbUJBQXpEO0FBQ0EsWUFBTXNqQixNQUFNLEdBQUdwQyxTQUFTLENBQUNwYSxXQUFELEVBQWNxYSxHQUFkLEVBQW1CaUQsU0FBbkIsQ0FBeEI7O0FBRUEsVUFBSTNCLFVBQVUsS0FBSzFnQixTQUFuQixFQUE4QjtBQUM1Qm1oQixRQUFBQSxTQUFTLEdBQUdtQixpQkFBWjtBQUNELE9BRkQsTUFFTyxJQUFJcmdCLElBQUksQ0FBQ2YsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUM1QixlQUFRLEdBQUVxZ0IsTUFBTyxpQkFBZ0JnQixZQUFZLENBQUN4TCxHQUFHLENBQUM4RSxPQUFMLEVBQWM1ZCxLQUFLLENBQUN5USxVQUFwQixDQUFnQyxJQUE3RTtBQUNEOztBQUVEMFMsTUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUVHLE1BQU8sR0FBdEI7QUFDQXRmLE1BQUFBLElBQUksQ0FBQzZGLE9BQUwsQ0FBYSxZQUFiO0FBQ0QsS0FmTSxNQWVBLElBQUkxRCxVQUFVLENBQUNuRyxLQUFELENBQWQsRUFBdUI7QUFDNUJtakIsTUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUVqQyxTQUFTLENBQUNwYSxXQUFELEVBQWNxYSxHQUFkLEVBQW1CLFVBQW5CLENBQStCLEdBQXZELENBRDRCLENBQytCOztBQUUzRG5kLE1BQUFBLElBQUksQ0FBQzZGLE9BQUwsQ0FBYSxZQUFiLEVBQTJCLFlBQTNCLEVBQXlDLFFBQXpDO0FBQ0QsS0FKTSxNQUlBLElBQUk3QyxTQUFTLENBQUNoSCxLQUFELENBQWIsRUFBc0I7QUFDM0JtakIsTUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUVqQyxTQUFTLENBQUNwYSxXQUFELEVBQWNxYSxHQUFkLEVBQW1CLFNBQW5CLENBQThCLEdBQXREO0FBQ0ErQixNQUFBQSxTQUFTLEdBQUdxQixhQUFaO0FBQ0QsS0FITSxNQUdBLElBQUkzYyxTQUFTLENBQUM1SCxLQUFELENBQWIsRUFBc0I7QUFDM0JtakIsTUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUVqQyxTQUFTLENBQUNwYSxXQUFELEVBQWNxYSxHQUFkLEVBQW1CLFNBQW5CLENBQThCLEdBQXREO0FBQ0ErQixNQUFBQSxTQUFTLEdBQUdwSyxHQUFHLENBQUNLLFVBQUosR0FBaUJxTCxhQUFqQixHQUFpQ0Msb0JBQTdDO0FBQ0QsS0FITSxNQUdBLElBQUk5YyxTQUFTLENBQUMzSCxLQUFELENBQWIsRUFBc0I7QUFDM0JtakIsTUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUVqQyxTQUFTLENBQUNwYSxXQUFELEVBQWNxYSxHQUFkLEVBQW1CLFNBQW5CLENBQThCLEdBQXREO0FBQ0ErQixNQUFBQSxTQUFTLEdBQUdwSyxHQUFHLENBQUNLLFVBQUosR0FBaUJ1TCxhQUFqQixHQUFpQ0Qsb0JBQTdDO0FBQ0E7Ozs7OztBQU1ELEtBVE0sTUFTQSxJQUFJMWUsZ0JBQWdCLENBQUMvRixLQUFELENBQXBCLEVBQTZCO0FBQ2xDaWpCLE1BQUFBLElBQUksR0FBRzBCLFlBQVksQ0FBQzNrQixLQUFELEVBQVE4WSxHQUFSLEVBQWE5VSxJQUFiLEVBQW1COEMsV0FBbkIsRUFBZ0NxYSxHQUFoQyxDQUFuQjs7QUFFQSxVQUFJbmQsSUFBSSxDQUFDZixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGVBQU9nZ0IsSUFBUDtBQUNEO0FBQ0YsS0FOTSxNQU1BO0FBQ0w7QUFDQTtBQUNBLFVBQUluYyxXQUFXLEtBQUssSUFBcEIsRUFBMEI7QUFDeEIsY0FBTThkLGVBQWUsR0FBR3ZDLG1CQUFtQixDQUFDdkosR0FBRCxFQUFNOVksS0FBTixFQUFhNlksWUFBYixDQUEzQzs7QUFFQSxZQUFJK0wsZUFBSixFQUFxQjtBQUNuQixpQkFBT0EsZUFBUDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSS9kLGFBQWEsQ0FBQzdHLEtBQUQsQ0FBakIsRUFBMEI7QUFDeEJtakIsUUFBQUEsTUFBTSxHQUFHUSxpQkFBaUIsQ0FBQyxLQUFELEVBQVF4QyxHQUFSLENBQTFCO0FBQ0ErQixRQUFBQSxTQUFTLEdBQUdVLGNBQVo7QUFDRCxPQUhELE1BR08sSUFBSXpjLGFBQWEsQ0FBQ25ILEtBQUQsQ0FBakIsRUFBMEI7QUFDL0JtakIsUUFBQUEsTUFBTSxHQUFHUSxpQkFBaUIsQ0FBQyxLQUFELEVBQVF4QyxHQUFSLENBQTFCO0FBQ0ErQixRQUFBQSxTQUFTLEdBQUdVLGNBQVosQ0FGK0IsQ0FFSDtBQUM3QixPQUhNLE1BR0E7QUFDTCxZQUFJNWYsSUFBSSxDQUFDZixNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCLGlCQUFRLEdBQUV1ZSxXQUFXLENBQUN4aEIsS0FBRCxFQUFROEcsV0FBUixFQUFxQnFhLEdBQXJCLENBQTBCLElBQS9DO0FBQ0Q7O0FBRURnQyxRQUFBQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQWEsR0FBRTNCLFdBQVcsQ0FBQ3hoQixLQUFELEVBQVE4RyxXQUFSLEVBQXFCcWEsR0FBckIsQ0FBMEIsR0FBcEQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSXRJLFlBQVksR0FBR0MsR0FBRyxDQUFDdUQsS0FBbkIsSUFBNEJ2RCxHQUFHLENBQUN1RCxLQUFKLEtBQWMsSUFBOUMsRUFBb0Q7QUFDbEQsUUFBSXdJLGVBQWUsR0FBR3JELFdBQVcsQ0FBQ3hoQixLQUFELEVBQVE4RyxXQUFSLEVBQXFCcWEsR0FBckIsQ0FBWCxDQUFxQ2xXLEtBQXJDLENBQTJDLENBQTNDLEVBQThDLENBQUMsQ0FBL0MsQ0FBdEI7O0FBRUEsUUFBSW5FLFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUN4QitkLE1BQUFBLGVBQWUsR0FBSSxJQUFHQSxlQUFnQixHQUF0QztBQUNEOztBQUVELFdBQU8vTCxHQUFHLENBQUM4RSxPQUFKLENBQVlpSCxlQUFaLEVBQTZCLFNBQTdCLENBQVA7QUFDRDs7QUFFRGhNLEVBQUFBLFlBQVksSUFBSSxDQUFoQjtBQUNBQyxFQUFBQSxHQUFHLENBQUNtRixJQUFKLENBQVN6YixJQUFULENBQWN4QyxLQUFkO0FBQ0E4WSxFQUFBQSxHQUFHLENBQUNvRixZQUFKLEdBQW1CckYsWUFBbkI7QUFDQSxNQUFJOVYsTUFBSjtBQUNBLFFBQU1pYixjQUFjLEdBQUdsRixHQUFHLENBQUNrRixjQUEzQjs7QUFFQSxNQUFJO0FBQ0ZqYixJQUFBQSxNQUFNLEdBQUdtZ0IsU0FBUyxDQUFDcEssR0FBRCxFQUFNOVksS0FBTixFQUFhNlksWUFBYixFQUEyQjdVLElBQTNCLEVBQWlDbWYsTUFBakMsQ0FBbEI7O0FBRUEsU0FBS2hnQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdhLElBQUksQ0FBQ2YsTUFBckIsRUFBNkJFLENBQUMsRUFBOUIsRUFBa0M7QUFDaENKLE1BQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFZc2lCLGNBQWMsQ0FBQ2hNLEdBQUQsRUFBTTlZLEtBQU4sRUFBYTZZLFlBQWIsRUFBMkI3VSxJQUFJLENBQUNiLENBQUQsQ0FBL0IsRUFBb0NrZ0IsVUFBcEMsQ0FBMUI7QUFDRDtBQUNGLEdBTkQsQ0FNRSxPQUFPM2hCLEdBQVAsRUFBWTtBQUNaLFVBQU1takIsZUFBZSxHQUFHckQsV0FBVyxDQUFDeGhCLEtBQUQsRUFBUThHLFdBQVIsRUFBcUJxYSxHQUFyQixDQUFYLENBQXFDbFcsS0FBckMsQ0FBMkMsQ0FBM0MsRUFBOEMsQ0FBQyxDQUEvQyxDQUF4QjtBQUNBLFdBQU84WixzQkFBc0IsQ0FBQ2pNLEdBQUQsRUFBTXBYLEdBQU4sRUFBV21qQixlQUFYLEVBQTRCN0csY0FBNUIsQ0FBN0I7QUFDRDs7QUFFRCxNQUFJbEYsR0FBRyxDQUFDaUssUUFBSixLQUFpQmhoQixTQUFyQixFQUFnQztBQUM5QixVQUFNa00sS0FBSyxHQUFHNkssR0FBRyxDQUFDaUssUUFBSixDQUFhamUsR0FBYixDQUFpQjlFLEtBQWpCLENBQWQ7O0FBRUEsUUFBSWlPLEtBQUssS0FBS2xNLFNBQWQsRUFBeUI7QUFDdkIsWUFBTWlqQixTQUFTLEdBQUdsTSxHQUFHLENBQUM4RSxPQUFKLENBQWEsU0FBUTNQLEtBQU0sR0FBM0IsRUFBK0IsU0FBL0IsQ0FBbEIsQ0FEdUIsQ0FDc0M7O0FBRTdELFVBQUk2SyxHQUFHLENBQUNVLE9BQUosS0FBZ0IsSUFBcEIsRUFBMEI7QUFDeEJ5SixRQUFBQSxJQUFJLEdBQUdBLElBQUksS0FBSyxFQUFULEdBQWMrQixTQUFkLEdBQTJCLEdBQUVBLFNBQVUsSUFBRy9CLElBQUssRUFBdEQ7QUFDRCxPQUZELE1BRU87QUFDTEUsUUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFhLEdBQUU2QixTQUFVLElBQUc3QixNQUFNLENBQUMsQ0FBRCxDQUFJLEVBQXRDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEckssRUFBQUEsR0FBRyxDQUFDbUYsSUFBSixDQUFTZ0gsR0FBVDs7QUFFQSxNQUFJbk0sR0FBRyxDQUFDNEQsTUFBUixFQUFnQjtBQUNkLFVBQU13SSxVQUFVLEdBQUdwTSxHQUFHLENBQUM0RCxNQUFKLEtBQWUsSUFBZixHQUFzQjNhLFNBQXRCLEdBQWtDK1csR0FBRyxDQUFDNEQsTUFBekQ7O0FBRUEsUUFBSTJHLFVBQVUsS0FBS3pHLFdBQW5CLEVBQWdDO0FBQzlCN1osTUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNvaUIsSUFBUCxDQUFZRCxVQUFaLENBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSWxoQixJQUFJLENBQUNmLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUMxQixZQUFNeVosTUFBTSxHQUFHM1osTUFBTSxDQUFDa0ksS0FBUCxDQUFhbEksTUFBTSxDQUFDRSxNQUFQLEdBQWdCZSxJQUFJLENBQUNmLE1BQWxDLEVBQTBDa2lCLElBQTFDLENBQStDRCxVQUEvQyxDQUFmO0FBQ0FuaUIsTUFBQUEsTUFBTSxDQUFDcWlCLE1BQVAsQ0FBY3JpQixNQUFNLENBQUNFLE1BQVAsR0FBZ0JlLElBQUksQ0FBQ2YsTUFBbkMsRUFBMkNlLElBQUksQ0FBQ2YsTUFBaEQsRUFBd0QsR0FBR3laLE1BQTNEO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNMkksR0FBRyxHQUFHQyxvQkFBb0IsQ0FBQ3hNLEdBQUQsRUFBTS9WLE1BQU4sRUFBY2tnQixJQUFkLEVBQW9CRSxNQUFwQixFQUE0QkUsVUFBNUIsRUFBd0N4SyxZQUF4QyxFQUFzRDdZLEtBQXRELENBQWhDO0FBQ0EsUUFBTStkLE1BQU0sR0FBR2pGLEdBQUcsQ0FBQ2lGLE1BQUosQ0FBV2pGLEdBQUcsQ0FBQ2tGLGNBQWYsS0FBa0MsQ0FBakQ7QUFDQSxRQUFNdUgsU0FBUyxHQUFHeEgsTUFBTSxHQUFHc0gsR0FBRyxDQUFDcGlCLE1BQS9CO0FBQ0E2VixFQUFBQSxHQUFHLENBQUNpRixNQUFKLENBQVdqRixHQUFHLENBQUNrRixjQUFmLElBQWlDdUgsU0FBakMsQ0FuUXVELENBbVFYO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJQSxTQUFTLEdBQUcsS0FBSyxFQUFyQixFQUF5QjtBQUN2QnpNLElBQUFBLEdBQUcsQ0FBQ3VELEtBQUosR0FBWSxDQUFDLENBQWI7QUFDRDs7QUFFRCxTQUFPZ0osR0FBUDtBQUNEOztBQUVELFNBQVMxQixpQkFBVCxDQUEyQnBaLElBQTNCLEVBQWlDNFcsR0FBakMsRUFBc0M7QUFDcEMsTUFBSUEsR0FBRyxLQUFNLEdBQUU1VyxJQUFLLFdBQXBCLEVBQWdDO0FBQzlCLFFBQUk0VyxHQUFHLEtBQUssRUFBWixFQUFnQjtBQUNkQSxNQUFBQSxHQUFHLElBQUksS0FBUDtBQUNEOztBQUVEQSxJQUFBQSxHQUFHLElBQUssR0FBRTVXLElBQUssV0FBZjtBQUNEOztBQUVELFNBQU8sQ0FBRSxJQUFHNFcsR0FBSSxLQUFULEVBQWUsR0FBZixDQUFQO0FBQ0Q7O0FBRUQsU0FBU3dELFlBQVQsQ0FBc0Iza0IsS0FBdEIsRUFBNkI4WSxHQUE3QixFQUFrQzlVLElBQWxDLEVBQXdDOEMsV0FBeEMsRUFBcURxYSxHQUFyRCxFQUEwRDtBQUN4RCxNQUFJcUUsRUFBSjtBQUNBLE1BQUlqYixJQUFKOztBQUVBLE1BQUl2RSxjQUFjLENBQUNoRyxLQUFELENBQWxCLEVBQTJCO0FBQ3pCd2xCLElBQUFBLEVBQUUsR0FBR2xLLGVBQUw7QUFDQS9RLElBQUFBLElBQUksR0FBRyxRQUFQO0FBQ0QsR0FIRCxNQUdPLElBQUl0RSxjQUFjLENBQUNqRyxLQUFELENBQWxCLEVBQTJCO0FBQ2hDd2xCLElBQUFBLEVBQUUsR0FBRzlKLGVBQUw7QUFDQW5SLElBQUFBLElBQUksR0FBRyxRQUFQLENBRmdDLENBRWY7QUFDakI7QUFDQTs7QUFFQXZHLElBQUFBLElBQUksQ0FBQ29oQixNQUFMLENBQVksQ0FBWixFQUFlcGxCLEtBQUssQ0FBQ2lELE1BQXJCO0FBQ0QsR0FQTSxNQU9BLElBQUk2QyxlQUFlLENBQUM5RixLQUFELENBQW5CLEVBQTRCO0FBQ2pDd2xCLElBQUFBLEVBQUUsR0FBR3ZLLGdCQUFMO0FBQ0ExUSxJQUFBQSxJQUFJLEdBQUcsU0FBUDtBQUNELEdBSE0sTUFHQTtBQUNMaWIsSUFBQUEsRUFBRSxHQUFHM0osZUFBTDtBQUNBdFIsSUFBQUEsSUFBSSxHQUFHLFFBQVA7QUFDRDs7QUFFRCxNQUFJMFksSUFBSSxHQUFJLElBQUcxWSxJQUFLLEVBQXBCOztBQUVBLE1BQUlBLElBQUksS0FBS3pELFdBQWIsRUFBMEI7QUFDeEIsUUFBSUEsV0FBVyxLQUFLLElBQXBCLEVBQTBCO0FBQ3hCbWMsTUFBQUEsSUFBSSxJQUFJLG1CQUFSO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBLE1BQUFBLElBQUksSUFBSyxLQUFJbmMsV0FBWSxHQUF6QjtBQUNEO0FBQ0Y7O0FBRURtYyxFQUFBQSxJQUFJLElBQUssS0FBSVAsZUFBZSxDQUFDdkUsY0FBRCxFQUFpQnFILEVBQUUsQ0FBQ0MsT0FBSCxDQUFXemxCLEtBQVgsQ0FBakIsRUFBb0M4WSxHQUFwQyxDQUF5QyxHQUFyRTs7QUFFQSxNQUFJcUksR0FBRyxLQUFLLEVBQVIsSUFBY0EsR0FBRyxLQUFLcmEsV0FBMUIsRUFBdUM7QUFDckNtYyxJQUFBQSxJQUFJLElBQUssS0FBSTlCLEdBQUksR0FBakI7QUFDRDs7QUFFRCxNQUFJbmQsSUFBSSxDQUFDZixNQUFMLEtBQWdCLENBQWhCLElBQXFCNlYsR0FBRyxDQUFDOEUsT0FBSixLQUFnQk8sY0FBekMsRUFBeUQ7QUFDdkQsV0FBTzhFLElBQVA7QUFDRDs7QUFFRCxTQUFPbkssR0FBRyxDQUFDOEUsT0FBSixDQUFZcUYsSUFBWixFQUFrQjFZLElBQUksQ0FBQytCLFdBQUwsRUFBbEIsQ0FBUDtBQUNEOztBQUVELFNBQVN1WCxlQUFULENBQXlCN2pCLEtBQXpCLEVBQWdDOEcsV0FBaEMsRUFBNkNxYSxHQUE3QyxFQUFrRDtBQUNoRCxNQUFJNVcsSUFBSSxHQUFHLFVBQVg7O0FBRUEsTUFBSWhFLG1CQUFtQixDQUFDdkcsS0FBRCxDQUF2QixFQUFnQztBQUM5QnVLLElBQUFBLElBQUksR0FBSSxZQUFXQSxJQUFLLEVBQXhCO0FBQ0Q7O0FBRUQsTUFBSTVFLGVBQWUsQ0FBQzNGLEtBQUQsQ0FBbkIsRUFBNEI7QUFDMUJ1SyxJQUFBQSxJQUFJLEdBQUksUUFBT0EsSUFBSyxFQUFwQjtBQUNEOztBQUVELE1BQUkwWSxJQUFJLEdBQUksSUFBRzFZLElBQUssRUFBcEI7O0FBRUEsTUFBSXpELFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUN4Qm1jLElBQUFBLElBQUksSUFBSSxtQkFBUjtBQUNEOztBQUVELE1BQUlqakIsS0FBSyxDQUFDa0YsSUFBTixLQUFlLEVBQW5CLEVBQXVCO0FBQ3JCK2QsSUFBQUEsSUFBSSxJQUFJLGNBQVI7QUFDRCxHQUZELE1BRU87QUFDTEEsSUFBQUEsSUFBSSxJQUFLLEtBQUlqakIsS0FBSyxDQUFDa0YsSUFBSyxFQUF4QjtBQUNEOztBQUVEK2QsRUFBQUEsSUFBSSxJQUFJLEdBQVI7O0FBRUEsTUFBSW5jLFdBQVcsS0FBS3lELElBQWhCLElBQXdCekQsV0FBVyxLQUFLLElBQTVDLEVBQWtEO0FBQ2hEbWMsSUFBQUEsSUFBSSxJQUFLLElBQUduYyxXQUFZLEVBQXhCO0FBQ0Q7O0FBRUQsTUFBSXFhLEdBQUcsS0FBSyxFQUFSLElBQWNyYSxXQUFXLEtBQUtxYSxHQUFsQyxFQUF1QztBQUNyQzhCLElBQUFBLElBQUksSUFBSyxLQUFJOUIsR0FBSSxHQUFqQjtBQUNEOztBQUVELFNBQU84QixJQUFQO0FBQ0Q7O0FBRUQsU0FBU2dCLFdBQVQsQ0FBcUJ2aUIsR0FBckIsRUFBMEJvRixXQUExQixFQUF1Q3FhLEdBQXZDLEVBQTRDckksR0FBNUMsRUFBaUQ7QUFDL0MsTUFBSTlXLEtBQUssR0FBR04sR0FBRyxDQUFDTSxLQUFKLElBQWFxWixjQUFjLENBQUNsVyxRQUFmLENBQXdCN0IsSUFBeEIsQ0FBNkI1QixHQUE3QixDQUF6QixDQUQrQyxDQUNhOztBQUU1RCxNQUFJb2EsS0FBSixFQUFXO0FBQ1QsVUFBTTVaLEtBQUssR0FBR0YsS0FBSyxDQUFDRyxLQUFOLENBQVksSUFBWixDQUFkO0FBQ0FILElBQUFBLEtBQUssR0FBSSxHQUFFTixHQUFHLENBQUN3RCxJQUFLLEtBQUl4RCxHQUFHLENBQUMyRyxPQUFRLEVBQXBDOztBQUVBLFFBQUluRyxLQUFLLENBQUNlLE1BQU4sR0FBZSxDQUFuQixFQUFzQjtBQUNwQmpCLE1BQUFBLEtBQUssSUFBSUUsS0FBSyxDQUFDNkksR0FBTixDQUFVMmEsU0FBUyxJQUFJO0FBQzlCLGNBQU1DLGFBQWEsR0FBR0QsU0FBUyxDQUFDN1MsT0FBVixDQUFrQixHQUFsQixDQUF0QjtBQUNBLGNBQU1oRyxNQUFNLEdBQUc2WSxTQUFTLENBQUN6YSxLQUFWLENBQWdCMGEsYUFBYSxHQUFHLENBQWhDLENBQWY7QUFDQSxjQUFNQyxhQUFhLEdBQUcsa0JBQXRCO0FBQ0EsWUFBSUMsVUFBVSxHQUFHLFNBQWpCOztBQUVBLFlBQUlGLGFBQWEsS0FBSyxDQUFDLENBQXZCLEVBQTBCO0FBQ3hCRSxVQUFBQSxVQUFVLEdBQUdILFNBQVMsQ0FBQ3phLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUIwYSxhQUFuQixDQUFiO0FBQ0Q7O0FBRUQsY0FBTUcsV0FBVyxHQUFHalosTUFBTSxDQUFDdkssS0FBUCxDQUFhc2pCLGFBQWIsQ0FBcEI7O0FBRUEsWUFBSUUsV0FBSixFQUFpQjtBQUNmLGNBQUlDLFFBQVEsR0FBR0QsV0FBVyxDQUFDLENBQUQsQ0FBMUI7QUFDQSxnQkFBTUUsVUFBVSxHQUFHRixXQUFXLENBQUMsQ0FBRCxDQUE5QjtBQUNBLGdCQUFNRyxNQUFNLEdBQUdILFdBQVcsQ0FBQyxDQUFELENBQTFCOztBQUVBLGNBQUlDLFFBQVEsQ0FBQzNiLFVBQVQsQ0FBb0IsT0FBcEIsQ0FBSixFQUFrQztBQUNoQzJiLFlBQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDN2tCLE9BQVQsQ0FBa0IsVUFBU2YsRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY0Msa0JBQW1CLEVBQTVELEVBQStELEVBQS9ELENBQVg7QUFDRDs7QUFFRCxpQkFBUSxZQUFXTixVQUFXLEtBQUlFLFFBQVMsSUFBR0MsVUFBVyxJQUFHQyxNQUFPLEdBQW5FO0FBQ0QsU0FWRCxNQVVPO0FBQ0wsaUJBQVEsWUFBV0osVUFBVyxLQUFJaFosTUFBTyxHQUF6QztBQUNEO0FBQ0YsT0F6QlEsRUF5Qk4vSixJQXpCTSxDQXlCRCxFQXpCQyxDQUFUO0FBMEJEO0FBQ0YsR0FuQzhDLENBbUM3QztBQUNGOzs7QUFHQSxRQUFNb0MsSUFBSSxHQUFHeEQsR0FBRyxDQUFDd0QsSUFBSixJQUFZLE9BQXpCO0FBQ0EsTUFBSTRGLEdBQUcsR0FBRzVGLElBQUksQ0FBQ2pDLE1BQWY7O0FBRUEsTUFBSTZELFdBQVcsS0FBSyxJQUFoQixJQUF3QjVCLElBQUksQ0FBQ21GLFFBQUwsQ0FBYyxPQUFkLEtBQTBCckksS0FBSyxDQUFDb0ksVUFBTixDQUFpQmxGLElBQWpCLENBQTFCLEtBQXFEbEQsS0FBSyxDQUFDaUIsTUFBTixLQUFpQjZILEdBQWpCLElBQXdCOUksS0FBSyxDQUFDOEksR0FBRCxDQUFMLEtBQWUsR0FBdkMsSUFBOEM5SSxLQUFLLENBQUM4SSxHQUFELENBQUwsS0FBZSxJQUFsSCxDQUE1QixFQUFxSjtBQUNuSixRQUFJc1csUUFBUSxHQUFHLE9BQWY7O0FBRUEsUUFBSXRhLFdBQVcsS0FBSyxJQUFwQixFQUEwQjtBQUN4QixZQUFNOEUsS0FBSyxHQUFHNUosS0FBSyxDQUFDTSxLQUFOLENBQVksNENBQVosS0FBNkROLEtBQUssQ0FBQ00sS0FBTixDQUFZLHlCQUFaLENBQTNFO0FBQ0E4ZSxNQUFBQSxRQUFRLEdBQUd4VixLQUFLLElBQUlBLEtBQUssQ0FBQyxDQUFELENBQWQsSUFBcUIsRUFBaEM7QUFDQWQsTUFBQUEsR0FBRyxHQUFHc1csUUFBUSxDQUFDbmUsTUFBZjtBQUNBbWUsTUFBQUEsUUFBUSxHQUFHQSxRQUFRLElBQUksT0FBdkI7QUFDRDs7QUFFRCxVQUFNa0MsTUFBTSxHQUFHcEMsU0FBUyxDQUFDcGEsV0FBRCxFQUFjcWEsR0FBZCxFQUFtQkMsUUFBbkIsQ0FBVCxDQUFzQ25XLEtBQXRDLENBQTRDLENBQTVDLEVBQStDLENBQUMsQ0FBaEQsQ0FBZjs7QUFFQSxRQUFJL0YsSUFBSSxLQUFLb2UsTUFBYixFQUFxQjtBQUNuQixVQUFJQSxNQUFNLENBQUN2YyxRQUFQLENBQWdCN0IsSUFBaEIsQ0FBSixFQUEyQjtBQUN6QixZQUFJNEYsR0FBRyxLQUFLLENBQVosRUFBZTtBQUNiOUksVUFBQUEsS0FBSyxHQUFJLEdBQUVzaEIsTUFBTyxLQUFJdGhCLEtBQU0sRUFBNUI7QUFDRCxTQUZELE1BRU87QUFDTEEsVUFBQUEsS0FBSyxHQUFJLEdBQUVzaEIsTUFBTyxHQUFFdGhCLEtBQUssQ0FBQ2lKLEtBQU4sQ0FBWUgsR0FBWixDQUFpQixFQUFyQztBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0w5SSxRQUFBQSxLQUFLLEdBQUksR0FBRXNoQixNQUFPLEtBQUlwZSxJQUFLLElBQUdsRCxLQUFLLENBQUNpSixLQUFOLENBQVlILEdBQVosQ0FBaUIsRUFBL0M7QUFDRDtBQUNGO0FBQ0YsR0FqRThDLENBaUU3Qzs7O0FBR0YsTUFBSXNiLEdBQUcsR0FBRzFrQixHQUFHLENBQUMyRyxPQUFKLElBQWVyRyxLQUFLLENBQUM2USxPQUFOLENBQWNuUixHQUFHLENBQUMyRyxPQUFsQixDQUFmLElBQTZDLENBQUMsQ0FBeEQ7O0FBRUEsTUFBSStkLEdBQUcsS0FBSyxDQUFDLENBQWIsRUFBZ0I7QUFDZEEsSUFBQUEsR0FBRyxJQUFJMWtCLEdBQUcsQ0FBQzJHLE9BQUosQ0FBWXBGLE1BQW5CO0FBQ0QsR0F4RThDLENBd0U3Qzs7O0FBR0YsTUFBSW9qQixVQUFVLEdBQUdya0IsS0FBSyxDQUFDNlEsT0FBTixDQUFjLFVBQWQsRUFBMEJ1VCxHQUExQixDQUFqQjs7QUFFQSxNQUFJQyxVQUFVLEtBQUssQ0FBQyxDQUFwQixFQUF1QjtBQUNyQnJrQixJQUFBQSxLQUFLLEdBQUksSUFBR0EsS0FBTSxHQUFsQjtBQUNELEdBRkQsTUFFTyxJQUFJOFcsR0FBRyxDQUFDd0QsTUFBUixFQUFnQjtBQUNyQjtBQUNBLFFBQUlnSyxRQUFRLEdBQUd0a0IsS0FBSyxDQUFDaUosS0FBTixDQUFZLENBQVosRUFBZW9iLFVBQWYsQ0FBZjtBQUNBLFVBQU1ua0IsS0FBSyxHQUFHRixLQUFLLENBQUNpSixLQUFOLENBQVlvYixVQUFVLEdBQUcsQ0FBekIsRUFBNEJsa0IsS0FBNUIsQ0FBa0MsSUFBbEMsQ0FBZDs7QUFFQSxTQUFLLE1BQU1DLElBQVgsSUFBbUJGLEtBQW5CLEVBQTBCO0FBQ3hCO0FBQ0EsVUFBSXFrQixVQUFKO0FBQ0FELE1BQUFBLFFBQVEsSUFBSSxJQUFaO0FBQ0EsVUFBSUYsR0FBRyxHQUFHLENBQVY7O0FBRUEsYUFBT0csVUFBVSxHQUFHbEosaUJBQWlCLENBQUNtSixJQUFsQixDQUF1QnBrQixJQUF2QixDQUFwQixFQUFrRDtBQUNoRDtBQUNBa2tCLFFBQUFBLFFBQVEsSUFBSWxrQixJQUFJLENBQUM2SSxLQUFMLENBQVdtYixHQUFYLEVBQWdCRyxVQUFVLENBQUN0WSxLQUFYLEdBQW1CLEVBQW5DLENBQVo7QUFDQXFZLFFBQUFBLFFBQVEsSUFBSXhOLEdBQUcsQ0FBQzhFLE9BQUosQ0FBWTJJLFVBQVUsQ0FBQyxDQUFELENBQXRCLEVBQTJCLFFBQTNCLENBQVo7QUFDQUgsUUFBQUEsR0FBRyxHQUFHRyxVQUFVLENBQUN0WSxLQUFYLEdBQW1Cc1ksVUFBVSxDQUFDLENBQUQsQ0FBVixDQUFjdGpCLE1BQXZDO0FBQ0Q7O0FBRURxakIsTUFBQUEsUUFBUSxJQUFJRixHQUFHLEtBQUssQ0FBUixHQUFZaGtCLElBQVosR0FBbUJBLElBQUksQ0FBQzZJLEtBQUwsQ0FBV21iLEdBQVgsQ0FBL0I7QUFDRDs7QUFFRHBrQixJQUFBQSxLQUFLLEdBQUdza0IsUUFBUjtBQUNELEdBckc4QyxDQXFHN0M7OztBQUdGLE1BQUl4TixHQUFHLENBQUNrRixjQUFKLEtBQXVCLENBQTNCLEVBQThCO0FBQzVCLFVBQU15SSxXQUFXLEdBQUcsSUFBSTNELE1BQUosQ0FBV2hLLEdBQUcsQ0FBQ2tGLGNBQWYsQ0FBcEI7QUFDQWhjLElBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDZCxPQUFOLENBQWMsS0FBZCxFQUFzQixLQUFJdWxCLFdBQVksRUFBdEMsQ0FBUjtBQUNEOztBQUVELFNBQU96a0IsS0FBUDtBQUNEOztBQUVELFNBQVN1aUIsYUFBVCxDQUF1QnpMLEdBQXZCLEVBQTRCNE4sTUFBNUIsRUFBb0NDLGFBQXBDLEVBQW1EO0FBQ2pEO0FBQ0EsU0FBTyxDQUFDN04sR0FBRyxDQUFDOEUsT0FBSixDQUFZLFdBQVosRUFBeUIsU0FBekIsQ0FBRCxDQUFQO0FBQ0Q7O0FBRUQsU0FBU2tILGNBQVQsQ0FBd0JoTSxHQUF4QixFQUE2QjlZLEtBQTdCLEVBQW9DNlksWUFBcEMsRUFBa0QzVSxHQUFsRCxFQUF1RHFHLElBQXZELEVBQTZEO0FBQzNELE1BQUlyRixJQUFKLEVBQVVqRSxHQUFWO0FBQ0EsTUFBSTJsQixLQUFLLEdBQUcsR0FBWjtBQUNBLFFBQU1DLElBQUksR0FBRy9tQixNQUFNLENBQUM4RSx3QkFBUCxDQUFnQzVFLEtBQWhDLEVBQXVDa0UsR0FBdkMsS0FBK0M7QUFDMURsRSxJQUFBQSxLQUFLLEVBQUVBLEtBQUssQ0FBQ2tFLEdBQUQsQ0FEOEM7QUFFMURzRixJQUFBQSxVQUFVLEVBQUUsSUFGOEMsRUFBNUQ7OztBQUtBLE1BQUlxZCxJQUFJLENBQUM3bUIsS0FBTCxLQUFlK0IsU0FBbkIsRUFBOEI7QUFDNUIsVUFBTStrQixJQUFJLEdBQUd2YyxJQUFJLEtBQUtxUyxXQUFULElBQXdCOUQsR0FBRyxDQUFDVSxPQUFKLEtBQWdCLElBQXhDLEdBQStDLENBQS9DLEdBQW1ELENBQWhFO0FBQ0FWLElBQUFBLEdBQUcsQ0FBQ2tGLGNBQUosSUFBc0I4SSxJQUF0QjtBQUNBN2xCLElBQUFBLEdBQUcsR0FBR3FkLFdBQVcsQ0FBQ3hGLEdBQUQsRUFBTStOLElBQUksQ0FBQzdtQixLQUFYLEVBQWtCNlksWUFBbEIsQ0FBakI7O0FBRUEsUUFBSWlPLElBQUksS0FBSyxDQUFiLEVBQWdCO0FBQ2QsWUFBTWhjLEdBQUcsR0FBR2dPLEdBQUcsQ0FBQ3dELE1BQUosR0FBYXRiLFlBQVksQ0FBQ0MsR0FBRCxDQUFaLENBQWtCZ0MsTUFBL0IsR0FBd0NoQyxHQUFHLENBQUNnQyxNQUF4RDs7QUFFQSxVQUFJNlYsR0FBRyxDQUFDUyxXQUFKLEdBQWtCek8sR0FBdEIsRUFBMkI7QUFDekI4YixRQUFBQSxLQUFLLEdBQUksS0FBSSxJQUFJOUQsTUFBSixDQUFXaEssR0FBRyxDQUFDa0YsY0FBZixDQUErQixFQUE1QztBQUNEO0FBQ0Y7O0FBRURsRixJQUFBQSxHQUFHLENBQUNrRixjQUFKLElBQXNCOEksSUFBdEI7QUFDRCxHQWRELE1BY08sSUFBSUQsSUFBSSxDQUFDL2hCLEdBQUwsS0FBYS9DLFNBQWpCLEVBQTRCO0FBQ2pDLFVBQU1nbEIsS0FBSyxHQUFHRixJQUFJLENBQUM5ZCxHQUFMLEtBQWFoSCxTQUFiLEdBQXlCLGVBQXpCLEdBQTJDLFFBQXpEO0FBQ0EsVUFBTXFDLENBQUMsR0FBRzBVLEdBQUcsQ0FBQzhFLE9BQWQ7QUFDQSxVQUFNb0osRUFBRSxHQUFHLFNBQVg7O0FBRUEsUUFBSWxPLEdBQUcsQ0FBQzZELE9BQUosS0FBZ0I3RCxHQUFHLENBQUM2RCxPQUFKLEtBQWdCLElBQWhCLElBQXdCN0QsR0FBRyxDQUFDNkQsT0FBSixLQUFnQixLQUFoQixJQUF5QmtLLElBQUksQ0FBQzlkLEdBQUwsS0FBYWhILFNBQTlELElBQTJFK1csR0FBRyxDQUFDNkQsT0FBSixLQUFnQixLQUFoQixJQUF5QmtLLElBQUksQ0FBQzlkLEdBQUwsS0FBYWhILFNBQWpJLENBQUosRUFBaUo7QUFDL0ksVUFBSTtBQUNGLGNBQU1rbEIsR0FBRyxHQUFHam5CLEtBQUssQ0FBQ2tFLEdBQUQsQ0FBakI7QUFDQTRVLFFBQUFBLEdBQUcsQ0FBQ2tGLGNBQUosSUFBc0IsQ0FBdEI7O0FBRUEsWUFBSWlKLEdBQUcsS0FBSyxJQUFaLEVBQWtCO0FBQ2hCaG1CLFVBQUFBLEdBQUcsR0FBSSxHQUFFbUQsQ0FBQyxDQUFFLElBQUcyaUIsS0FBTSxHQUFYLEVBQWVDLEVBQWYsQ0FBbUIsSUFBRzVpQixDQUFDLENBQUMsTUFBRCxFQUFTLE1BQVQsQ0FBaUIsR0FBRUEsQ0FBQyxDQUFDLEdBQUQsRUFBTTRpQixFQUFOLENBQVUsRUFBL0Q7QUFDRCxTQUZELE1BRU8sSUFBSSxPQUFPQyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENobUIsVUFBQUEsR0FBRyxHQUFJLEdBQUVtRCxDQUFDLENBQUUsSUFBRzJpQixLQUFNLEdBQVgsRUFBZUMsRUFBZixDQUFtQixJQUFHMUksV0FBVyxDQUFDeEYsR0FBRCxFQUFNbU8sR0FBTixFQUFXcE8sWUFBWCxDQUF5QixFQUFwRTtBQUNELFNBRk0sTUFFQTtBQUNMLGdCQUFNcU8sU0FBUyxHQUFHeEUsZUFBZSxDQUFDdGUsQ0FBRCxFQUFJNmlCLEdBQUosRUFBU25PLEdBQVQsQ0FBakM7QUFDQTdYLFVBQUFBLEdBQUcsR0FBSSxHQUFFbUQsQ0FBQyxDQUFFLElBQUcyaUIsS0FBTSxHQUFYLEVBQWVDLEVBQWYsQ0FBbUIsSUFBR0UsU0FBVSxHQUFFOWlCLENBQUMsQ0FBQyxHQUFELEVBQU00aUIsRUFBTixDQUFVLEVBQXZEO0FBQ0Q7O0FBRURsTyxRQUFBQSxHQUFHLENBQUNrRixjQUFKLElBQXNCLENBQXRCO0FBQ0QsT0FkRCxDQWNFLE9BQU90YyxHQUFQLEVBQVk7QUFDWixjQUFNMkcsT0FBTyxHQUFJLHNCQUFxQjNHLEdBQUcsQ0FBQzJHLE9BQVEsSUFBbEQ7QUFDQXBILFFBQUFBLEdBQUcsR0FBSSxHQUFFbUQsQ0FBQyxDQUFFLElBQUcyaUIsS0FBTSxHQUFYLEVBQWVDLEVBQWYsQ0FBbUIsSUFBRzNlLE9BQVEsR0FBRWpFLENBQUMsQ0FBQyxHQUFELEVBQU00aUIsRUFBTixDQUFVLEVBQXJEO0FBQ0Q7QUFDRixLQW5CRCxNQW1CTztBQUNML2xCLE1BQUFBLEdBQUcsR0FBRzZYLEdBQUcsQ0FBQzhFLE9BQUosQ0FBYSxJQUFHbUosS0FBTSxHQUF0QixFQUEwQkMsRUFBMUIsQ0FBTjtBQUNEO0FBQ0YsR0EzQk0sTUEyQkEsSUFBSUgsSUFBSSxDQUFDOWQsR0FBTCxLQUFhaEgsU0FBakIsRUFBNEI7QUFDakNkLElBQUFBLEdBQUcsR0FBRzZYLEdBQUcsQ0FBQzhFLE9BQUosQ0FBWSxVQUFaLEVBQXdCLFNBQXhCLENBQU47QUFDRCxHQUZNLE1BRUE7QUFDTDNjLElBQUFBLEdBQUcsR0FBRzZYLEdBQUcsQ0FBQzhFLE9BQUosQ0FBWSxXQUFaLEVBQXlCLFdBQXpCLENBQU47QUFDRDs7QUFFRCxNQUFJclQsSUFBSSxLQUFLc1MsVUFBYixFQUF5QjtBQUN2QixXQUFPNWIsR0FBUDtBQUNEOztBQUVELE1BQUksT0FBT2lELEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixVQUFNK2lCLEdBQUcsR0FBRy9pQixHQUFHLENBQUNpQixRQUFKLEdBQWVqRSxPQUFmLENBQXVCOGIsMEJBQXZCLEVBQW1EbUQsUUFBbkQsQ0FBWjtBQUNBamIsSUFBQUEsSUFBSSxHQUFJLElBQUc0VCxHQUFHLENBQUM4RSxPQUFKLENBQVlxSixHQUFaLEVBQWlCLFFBQWpCLENBQTJCLEdBQXRDO0FBQ0QsR0FIRCxNQUdPLElBQUlKLElBQUksQ0FBQ3JkLFVBQUwsS0FBb0IsS0FBeEIsRUFBK0I7QUFDcEN0RSxJQUFBQSxJQUFJLEdBQUksSUFBR2hCLEdBQUcsQ0FBQ2hELE9BQUosQ0FBWThiLDBCQUFaLEVBQXdDbUQsUUFBeEMsQ0FBa0QsR0FBN0Q7QUFDRCxHQUZNLE1BRUEsSUFBSWhELFlBQVksQ0FBQ3RhLElBQWIsQ0FBa0JxQixHQUFsQixDQUFKLEVBQTRCO0FBQ2pDZ0IsSUFBQUEsSUFBSSxHQUFHNFQsR0FBRyxDQUFDOEUsT0FBSixDQUFZMVosR0FBWixFQUFpQixNQUFqQixDQUFQO0FBQ0QsR0FGTSxNQUVBO0FBQ0xnQixJQUFBQSxJQUFJLEdBQUc0VCxHQUFHLENBQUM4RSxPQUFKLENBQVl3QyxTQUFTLENBQUNsYyxHQUFELENBQXJCLEVBQTRCLFFBQTVCLENBQVA7QUFDRDs7QUFFRCxTQUFRLEdBQUVnQixJQUFLLElBQUcwaEIsS0FBTSxHQUFFM2xCLEdBQUksRUFBOUI7QUFDRDs7QUFFRCxTQUFTa21CLGtCQUFULENBQTRCck8sR0FBNUIsRUFBaUMvVixNQUFqQyxFQUF5Qy9DLEtBQXpDLEVBQWdEO0FBQzlDLE1BQUkwWSxXQUFXLEdBQUcsQ0FBbEI7QUFDQSxNQUFJbEksU0FBUyxHQUFHLENBQWhCO0FBQ0EsTUFBSXJOLENBQUMsR0FBRyxDQUFSO0FBQ0EsTUFBSWlrQixZQUFZLEdBQUdya0IsTUFBTSxDQUFDRSxNQUExQjs7QUFFQSxNQUFJNlYsR0FBRyxDQUFDMkQsY0FBSixHQUFxQjFaLE1BQU0sQ0FBQ0UsTUFBaEMsRUFBd0M7QUFDdEM7QUFDQW1rQixJQUFBQSxZQUFZO0FBQ2I7O0FBRUQsUUFBTUMsY0FBYyxHQUFHLENBQXZCLENBWDhDLENBV3BCOztBQUUxQixRQUFNQyxPQUFPLEdBQUcsSUFBSTVrQixLQUFKLENBQVUwa0IsWUFBVixDQUFoQixDQWI4QyxDQWFMO0FBQ3pDO0FBQ0E7O0FBRUEsU0FBT2prQixDQUFDLEdBQUdpa0IsWUFBWCxFQUF5QmprQixDQUFDLEVBQTFCLEVBQThCO0FBQzVCLFVBQU0ySCxHQUFHLEdBQUdnTyxHQUFHLENBQUN3RCxNQUFKLEdBQWF0YixZQUFZLENBQUMrQixNQUFNLENBQUNJLENBQUQsQ0FBUCxDQUFaLENBQXdCRixNQUFyQyxHQUE4Q0YsTUFBTSxDQUFDSSxDQUFELENBQU4sQ0FBVUYsTUFBcEU7QUFDQXFrQixJQUFBQSxPQUFPLENBQUNua0IsQ0FBRCxDQUFQLEdBQWEySCxHQUFiO0FBQ0E0TixJQUFBQSxXQUFXLElBQUk1TixHQUFHLEdBQUd1YyxjQUFyQjs7QUFFQSxRQUFJN1csU0FBUyxHQUFHMUYsR0FBaEIsRUFBcUI7QUFDbkIwRixNQUFBQSxTQUFTLEdBQUcxRixHQUFaO0FBQ0Q7QUFDRixHQXpCNkMsQ0F5QjVDO0FBQ0Y7OztBQUdBLFFBQU1rTyxTQUFTLEdBQUd4SSxTQUFTLEdBQUc2VyxjQUE5QixDQTdCOEMsQ0E2QkE7QUFDOUM7QUFDQTtBQUNBOztBQUVBLE1BQUlyTyxTQUFTLEdBQUcsQ0FBWixHQUFnQkYsR0FBRyxDQUFDa0YsY0FBcEIsR0FBcUNsRixHQUFHLENBQUNTLFdBQXpDLEtBQXlEYixXQUFXLEdBQUdNLFNBQWQsR0FBMEIsQ0FBMUIsSUFBK0J4SSxTQUFTLElBQUksQ0FBckcsQ0FBSixFQUE2RztBQUMzRyxVQUFNK1csaUJBQWlCLEdBQUcsR0FBMUI7QUFDQSxVQUFNQyxXQUFXLEdBQUdoVyxJQUFJLENBQUNpVyxJQUFMLENBQVV6TyxTQUFTLEdBQUdOLFdBQVcsR0FBRzNWLE1BQU0sQ0FBQ0UsTUFBM0MsQ0FBcEI7QUFDQSxVQUFNeWtCLFNBQVMsR0FBR2xXLElBQUksQ0FBQ3VILEdBQUwsQ0FBU0MsU0FBUyxHQUFHLENBQVosR0FBZ0J3TyxXQUF6QixFQUFzQyxDQUF0QyxDQUFsQixDQUgyRyxDQUcvQzs7QUFFNUQsVUFBTUcsT0FBTyxHQUFHblcsSUFBSSxDQUFDQyxHQUFMLEVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQUQsSUFBQUEsSUFBSSxDQUFDb1csS0FBTCxDQUFXcFcsSUFBSSxDQUFDaVcsSUFBTCxDQUFVRixpQkFBaUIsR0FBR0csU0FBcEIsR0FBZ0NOLFlBQTFDLElBQTBETSxTQUFyRSxDQUxnQixFQUtpRTtBQUNqRmxXLElBQUFBLElBQUksQ0FBQzhHLEtBQUwsQ0FBVyxDQUFDUSxHQUFHLENBQUNTLFdBQUosR0FBa0JULEdBQUcsQ0FBQ2tGLGNBQXZCLElBQXlDaEYsU0FBcEQsQ0FOZ0IsRUFNZ0Q7QUFDaEU7QUFDQUYsSUFBQUEsR0FBRyxDQUFDVSxPQUFKLEdBQWMsQ0FSRSxFQVFDO0FBQ2pCLE1BVGdCLENBQWhCLENBTDJHLENBY3RHOztBQUVMLFFBQUltTyxPQUFPLElBQUksQ0FBZixFQUFrQjtBQUNoQixhQUFPNWtCLE1BQVA7QUFDRDs7QUFFRCxVQUFNa2tCLEdBQUcsR0FBRyxFQUFaO0FBQ0EsVUFBTVksYUFBYSxHQUFHLEVBQXRCOztBQUVBLFNBQUssSUFBSTFrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHd2tCLE9BQXBCLEVBQTZCeGtCLENBQUMsRUFBOUIsRUFBa0M7QUFDaEMsVUFBSTJrQixhQUFhLEdBQUcsQ0FBcEI7O0FBRUEsV0FBSyxJQUFJQyxDQUFDLEdBQUc1a0IsQ0FBYixFQUFnQjRrQixDQUFDLEdBQUdobEIsTUFBTSxDQUFDRSxNQUEzQixFQUFtQzhrQixDQUFDLElBQUlKLE9BQXhDLEVBQWlEO0FBQy9DLFlBQUlMLE9BQU8sQ0FBQ1MsQ0FBRCxDQUFQLEdBQWFELGFBQWpCLEVBQWdDO0FBQzlCQSxVQUFBQSxhQUFhLEdBQUdSLE9BQU8sQ0FBQ1MsQ0FBRCxDQUF2QjtBQUNEO0FBQ0Y7O0FBRURELE1BQUFBLGFBQWEsSUFBSVQsY0FBakI7QUFDQVEsTUFBQUEsYUFBYSxDQUFDMWtCLENBQUQsQ0FBYixHQUFtQjJrQixhQUFuQjtBQUNEOztBQUVELFFBQUlFLEtBQUssR0FBRyxVQUFaOztBQUVBLFFBQUlob0IsS0FBSyxLQUFLK0IsU0FBZCxFQUF5QjtBQUN2QixXQUFLLElBQUlvQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHSixNQUFNLENBQUNFLE1BQTNCLEVBQW1DRSxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLFlBQUksT0FBT25ELEtBQUssQ0FBQ21ELENBQUQsQ0FBWixLQUFvQixRQUF4QixFQUFrQztBQUNoQzZrQixVQUFBQSxLQUFLLEdBQUcsUUFBUjtBQUNBO0FBQ0Q7QUFDRjtBQUNGLEtBN0MwRyxDQTZDekc7OztBQUdGLFNBQUssSUFBSTdrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaWtCLFlBQXBCLEVBQWtDamtCLENBQUMsSUFBSXdrQixPQUF2QyxFQUFnRDtBQUM5QztBQUNBLFlBQU01TyxHQUFHLEdBQUd2SCxJQUFJLENBQUNDLEdBQUwsQ0FBU3RPLENBQUMsR0FBR3drQixPQUFiLEVBQXNCUCxZQUF0QixDQUFaO0FBQ0EsVUFBSW5tQixHQUFHLEdBQUcsRUFBVjtBQUNBLFVBQUk4bUIsQ0FBQyxHQUFHNWtCLENBQVI7O0FBRUEsYUFBTzRrQixDQUFDLEdBQUdoUCxHQUFHLEdBQUcsQ0FBakIsRUFBb0JnUCxDQUFDLEVBQXJCLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGNBQU1FLE9BQU8sR0FBR0osYUFBYSxDQUFDRSxDQUFDLEdBQUc1a0IsQ0FBTCxDQUFiLEdBQXVCSixNQUFNLENBQUNnbEIsQ0FBRCxDQUFOLENBQVU5a0IsTUFBakMsR0FBMENxa0IsT0FBTyxDQUFDUyxDQUFELENBQWpFO0FBQ0E5bUIsUUFBQUEsR0FBRyxJQUFLLEdBQUU4QixNQUFNLENBQUNnbEIsQ0FBRCxDQUFJLElBQWIsQ0FBaUJDLEtBQWpCLEVBQXdCQyxPQUF4QixFQUFpQyxHQUFqQyxDQUFQO0FBQ0Q7O0FBRUQsVUFBSUQsS0FBSyxLQUFLLFVBQWQsRUFBMEI7QUFDeEIsY0FBTUMsT0FBTyxHQUFHSixhQUFhLENBQUNFLENBQUMsR0FBRzVrQixDQUFMLENBQWIsR0FBdUJKLE1BQU0sQ0FBQ2dsQixDQUFELENBQU4sQ0FBVTlrQixNQUFqQyxHQUEwQ3FrQixPQUFPLENBQUNTLENBQUQsQ0FBakQsR0FBdURWLGNBQXZFO0FBQ0FwbUIsUUFBQUEsR0FBRyxJQUFJOEIsTUFBTSxDQUFDZ2xCLENBQUQsQ0FBTixDQUFVRyxRQUFWLENBQW1CRCxPQUFuQixFQUE0QixHQUE1QixDQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0xobkIsUUFBQUEsR0FBRyxJQUFJOEIsTUFBTSxDQUFDZ2xCLENBQUQsQ0FBYjtBQUNEOztBQUVEZCxNQUFBQSxHQUFHLENBQUN6a0IsSUFBSixDQUFTdkIsR0FBVDtBQUNEOztBQUVELFFBQUk2WCxHQUFHLENBQUMyRCxjQUFKLEdBQXFCMVosTUFBTSxDQUFDRSxNQUFoQyxFQUF3QztBQUN0Q2drQixNQUFBQSxHQUFHLENBQUN6a0IsSUFBSixDQUFTTyxNQUFNLENBQUNxa0IsWUFBRCxDQUFmO0FBQ0Q7O0FBRURya0IsSUFBQUEsTUFBTSxHQUFHa2tCLEdBQVQ7QUFDRDs7QUFFRCxTQUFPbGtCLE1BQVA7QUFDRDs7QUFFRCxTQUFTZ2lCLHNCQUFULENBQWdDak0sR0FBaEMsRUFBcUNwWCxHQUFyQyxFQUEwQ21qQixlQUExQyxFQUEyRDdHLGNBQTNELEVBQTJFO0FBQ3pFLE1BQUlyVCxvQkFBb0IsQ0FBQ2pKLEdBQUQsQ0FBeEIsRUFBK0I7QUFDN0JvWCxJQUFBQSxHQUFHLENBQUNtRixJQUFKLENBQVNnSCxHQUFUO0FBQ0FuTSxJQUFBQSxHQUFHLENBQUNrRixjQUFKLEdBQXFCQSxjQUFyQjtBQUNBLFdBQU9sRixHQUFHLENBQUM4RSxPQUFKLENBQWEsSUFBR2lILGVBQWdCLDJFQUFoQyxFQUE0RyxTQUE1RyxDQUFQO0FBQ0Q7O0FBRUQsUUFBTW5qQixHQUFOO0FBQ0Q7O0FBRUQsU0FBUzRpQixZQUFULENBQXNCa0IsRUFBdEIsRUFBMEJ4bEIsS0FBMUIsRUFBaUM7QUFDL0I7QUFDQSxTQUFPd2xCLEVBQUUsQ0FBQzFsQixNQUFNLENBQUNxb0IsRUFBUCxDQUFVbm9CLEtBQVYsRUFBaUIsQ0FBQyxDQUFsQixJQUF1QixJQUF2QixHQUErQixHQUFFQSxLQUFNLEVBQXhDLEVBQTJDLFFBQTNDLENBQVQ7QUFDRDs7QUFFRCxTQUFTb29CLFlBQVQsQ0FBc0I1QyxFQUF0QixFQUEwQnhsQixLQUExQixFQUFpQztBQUMvQixTQUFPd2xCLEVBQUUsQ0FBRSxHQUFFeGxCLEtBQU0sR0FBVixFQUFjLFFBQWQsQ0FBVDtBQUNEOztBQUVELFNBQVMwaUIsZUFBVCxDQUF5QjhDLEVBQXpCLEVBQTZCeGxCLEtBQTdCLEVBQW9DOFksR0FBcEMsRUFBeUM7QUFDdkMsTUFBSSxPQUFPOVksS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixRQUFJOFksR0FBRyxDQUFDVSxPQUFKLEtBQWdCLElBQWhCLElBQXdCeFosS0FBSyxDQUFDaUQsTUFBTixHQUFlcWEsY0FBdkMsSUFBeUR0ZCxLQUFLLENBQUNpRCxNQUFOLEdBQWU2VixHQUFHLENBQUNTLFdBQUosR0FBa0JULEdBQUcsQ0FBQ2tGLGNBQXRCLEdBQXVDLENBQW5ILEVBQXNIO0FBQ3BILGFBQU9oZSxLQUFLLENBQUNtQyxLQUFOLENBQVksSUFBWixFQUFrQjRJLEdBQWxCLENBQXNCM0ksSUFBSSxJQUFJb2pCLEVBQUUsQ0FBQ3BGLFNBQVMsQ0FBQ2hlLElBQUQsQ0FBVixFQUFrQixRQUFsQixDQUFoQyxFQUE2RFUsSUFBN0QsQ0FBbUUsT0FBTSxJQUFJZ2dCLE1BQUosQ0FBV2hLLEdBQUcsQ0FBQ2tGLGNBQUosR0FBcUIsQ0FBaEMsQ0FBbUMsRUFBNUcsQ0FBUDtBQUNEOztBQUVELFdBQU93SCxFQUFFLENBQUNwRixTQUFTLENBQUNwZ0IsS0FBRCxDQUFWLEVBQW1CLFFBQW5CLENBQVQ7QUFDRDs7QUFFRCxNQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsV0FBT3NrQixZQUFZLENBQUNrQixFQUFELEVBQUt4bEIsS0FBTCxDQUFuQjtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQSxNQUFJLE9BQU9BLEtBQVAsS0FBaUIsU0FBckIsRUFBZ0M7QUFDOUIsV0FBT3dsQixFQUFFLENBQUUsR0FBRXhsQixLQUFNLEVBQVYsRUFBYSxTQUFiLENBQVQ7QUFDRDs7QUFFRCxNQUFJLE9BQU9BLEtBQVAsS0FBaUIsV0FBckIsRUFBa0M7QUFDaEMsV0FBT3dsQixFQUFFLENBQUMsV0FBRCxFQUFjLFdBQWQsQ0FBVDtBQUNELEdBekJzQyxDQXlCckM7OztBQUdGLFNBQU9BLEVBQUUsQ0FBQzNKLGVBQWUsQ0FBQzFXLFFBQWhCLENBQXlCN0IsSUFBekIsQ0FBOEJ0RCxLQUE5QixDQUFELEVBQXVDLFFBQXZDLENBQVQ7QUFDRCxDLENBQUM7OztBQUdGLFNBQVNxb0Isa0JBQVQsQ0FBNEJ2UCxHQUE1QixFQUFpQzlZLEtBQWpDLEVBQXdDNlksWUFBeEMsRUFBc0RySSxTQUF0RCxFQUFpRXpOLE1BQWpFLEVBQXlFSSxDQUF6RSxFQUE0RTtBQUMxRSxRQUFNYSxJQUFJLEdBQUdsRSxNQUFNLENBQUNrRSxJQUFQLENBQVloRSxLQUFaLENBQWI7QUFDQSxNQUFJaU8sS0FBSyxHQUFHOUssQ0FBWjs7QUFFQSxTQUFPQSxDQUFDLEdBQUdhLElBQUksQ0FBQ2YsTUFBVCxJQUFtQkYsTUFBTSxDQUFDRSxNQUFQLEdBQWdCdU4sU0FBMUMsRUFBcURyTixDQUFDLEVBQXRELEVBQTBEO0FBQ3hELFVBQU1lLEdBQUcsR0FBR0YsSUFBSSxDQUFDYixDQUFELENBQWhCO0FBQ0EsVUFBTThqQixHQUFHLEdBQUcsQ0FBQy9pQixHQUFiLENBRndELENBRXRDOztBQUVsQixRQUFJK2lCLEdBQUcsR0FBRyxLQUFLLEVBQUwsR0FBVSxDQUFwQixFQUF1QjtBQUNyQjtBQUNEOztBQUVELFFBQUssR0FBRWhaLEtBQU0sRUFBVCxLQUFlL0osR0FBbkIsRUFBd0I7QUFDdEIsVUFBSSxDQUFDa1osWUFBWSxDQUFDdmEsSUFBYixDQUFrQnFCLEdBQWxCLENBQUwsRUFBNkI7QUFDM0I7QUFDRDs7QUFFRCxZQUFNb2tCLFVBQVUsR0FBR3JCLEdBQUcsR0FBR2haLEtBQXpCO0FBQ0EsWUFBTXNhLE1BQU0sR0FBR0QsVUFBVSxHQUFHLENBQWIsR0FBaUIsR0FBakIsR0FBdUIsRUFBdEM7QUFDQSxZQUFNamdCLE9BQU8sR0FBSSxJQUFHaWdCLFVBQVcsY0FBYUMsTUFBTyxHQUFuRDtBQUNBeGxCLE1BQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFZc1csR0FBRyxDQUFDOEUsT0FBSixDQUFZdlYsT0FBWixFQUFxQixXQUFyQixDQUFaO0FBQ0E0RixNQUFBQSxLQUFLLEdBQUdnWixHQUFSOztBQUVBLFVBQUlsa0IsTUFBTSxDQUFDRSxNQUFQLEtBQWtCdU4sU0FBdEIsRUFBaUM7QUFDL0I7QUFDRDtBQUNGOztBQUVEek4sSUFBQUEsTUFBTSxDQUFDUCxJQUFQLENBQVlzaUIsY0FBYyxDQUFDaE0sR0FBRCxFQUFNOVksS0FBTixFQUFhNlksWUFBYixFQUEyQjNVLEdBQTNCLEVBQWdDMlksVUFBaEMsQ0FBMUI7QUFDQTVPLElBQUFBLEtBQUs7QUFDTjs7QUFFRCxRQUFNMkQsU0FBUyxHQUFHNVIsS0FBSyxDQUFDaUQsTUFBTixHQUFlZ0wsS0FBakM7O0FBRUEsTUFBSWxMLE1BQU0sQ0FBQ0UsTUFBUCxLQUFrQnVOLFNBQXRCLEVBQWlDO0FBQy9CLFFBQUlvQixTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDakIsWUFBTTJXLE1BQU0sR0FBRzNXLFNBQVMsR0FBRyxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLEVBQXJDO0FBQ0EsWUFBTXZKLE9BQU8sR0FBSSxJQUFHdUosU0FBVSxjQUFhMlcsTUFBTyxHQUFsRDtBQUNBeGxCLE1BQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFZc1csR0FBRyxDQUFDOEUsT0FBSixDQUFZdlYsT0FBWixFQUFxQixXQUFyQixDQUFaO0FBQ0Q7QUFDRixHQU5ELE1BTU8sSUFBSXVKLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtBQUN4QjdPLElBQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFhLE9BQU1vUCxTQUFVLGFBQVlBLFNBQVMsR0FBRyxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLEVBQUcsRUFBbEU7QUFDRDs7QUFFRCxTQUFPN08sTUFBUDtBQUNEOztBQUVELFNBQVNzaEIsaUJBQVQsQ0FBMkJ2TCxHQUEzQixFQUFnQzlZLEtBQWhDLEVBQXVDO0FBQ3JDLFFBQU1nTixNQUFNLEdBQUcsSUFBSXZJLFVBQUosQ0FBZXpFLEtBQWYsQ0FBZjtBQUNBOzs7Ozs7O0FBT0EsTUFBSWlCLEdBQUcsR0FBRzBVLFFBQVEsQ0FBQzNJLE1BQUQsRUFBUyxDQUFULEVBQVl3RSxJQUFJLENBQUNDLEdBQUwsQ0FBU3FILEdBQUcsQ0FBQzJELGNBQWIsRUFBNkJ6UCxNQUFNLENBQUMvSixNQUFwQyxDQUFaLENBQVIsQ0FBaUUvQixPQUFqRSxDQUF5RSxTQUF6RSxFQUFvRixLQUFwRixFQUEyRitYLElBQTNGLEVBQVY7QUFDQSxRQUFNckgsU0FBUyxHQUFHNUUsTUFBTSxDQUFDL0osTUFBUCxHQUFnQjZWLEdBQUcsQ0FBQzJELGNBQXRDOztBQUVBLE1BQUk3SyxTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDakIzUSxJQUFBQSxHQUFHLElBQUssUUFBTzJRLFNBQVUsYUFBWUEsU0FBUyxHQUFHLENBQVosR0FBZ0IsR0FBaEIsR0FBc0IsRUFBRyxFQUE5RDtBQUNEOztBQUVELFNBQU8sQ0FBRSxHQUFFa0gsR0FBRyxDQUFDOEUsT0FBSixDQUFZLGlCQUFaLEVBQStCLFNBQS9CLENBQTBDLE1BQUszYyxHQUFJLEdBQXZELENBQVA7QUFDRDs7QUFFRCxTQUFTc2lCLFdBQVQsQ0FBcUJ6SyxHQUFyQixFQUEwQjlZLEtBQTFCLEVBQWlDNlksWUFBakMsRUFBK0M7QUFDN0MsUUFBTTJQLE1BQU0sR0FBR3hvQixLQUFLLENBQUNpRCxNQUFyQjtBQUNBLFFBQU02SCxHQUFHLEdBQUcwRyxJQUFJLENBQUNDLEdBQUwsQ0FBU0QsSUFBSSxDQUFDdUgsR0FBTCxDQUFTLENBQVQsRUFBWUQsR0FBRyxDQUFDMkQsY0FBaEIsQ0FBVCxFQUEwQytMLE1BQTFDLENBQVo7QUFDQSxRQUFNNVcsU0FBUyxHQUFHNFcsTUFBTSxHQUFHMWQsR0FBM0I7QUFDQSxRQUFNL0gsTUFBTSxHQUFHLEVBQWY7O0FBRUEsT0FBSyxJQUFJSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMkgsR0FBcEIsRUFBeUIzSCxDQUFDLEVBQTFCLEVBQThCO0FBQzVCO0FBQ0EsUUFBSSxDQUFDNlksY0FBYyxDQUFDaGMsS0FBRCxFQUFRbUQsQ0FBUixDQUFuQixFQUErQjtBQUM3QixhQUFPa2xCLGtCQUFrQixDQUFDdlAsR0FBRCxFQUFNOVksS0FBTixFQUFhNlksWUFBYixFQUEyQi9OLEdBQTNCLEVBQWdDL0gsTUFBaEMsRUFBd0NJLENBQXhDLENBQXpCO0FBQ0Q7O0FBRURKLElBQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFZc2lCLGNBQWMsQ0FBQ2hNLEdBQUQsRUFBTTlZLEtBQU4sRUFBYTZZLFlBQWIsRUFBMkIxVixDQUEzQixFQUE4QjBaLFVBQTlCLENBQTFCO0FBQ0Q7O0FBRUQsTUFBSWpMLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtBQUNqQjdPLElBQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFhLE9BQU1vUCxTQUFVLGFBQVlBLFNBQVMsR0FBRyxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLEVBQUcsRUFBbEU7QUFDRDs7QUFFRCxTQUFPN08sTUFBUDtBQUNEOztBQUVELFNBQVMyZ0IsZ0JBQVQsQ0FBMEI1SyxHQUExQixFQUErQjlZLEtBQS9CLEVBQXNDNlksWUFBdEMsRUFBb0Q7QUFDbEQsUUFBTXJJLFNBQVMsR0FBR2dCLElBQUksQ0FBQ0MsR0FBTCxDQUFTRCxJQUFJLENBQUN1SCxHQUFMLENBQVMsQ0FBVCxFQUFZRCxHQUFHLENBQUMyRCxjQUFoQixDQUFULEVBQTBDemMsS0FBSyxDQUFDaUQsTUFBaEQsQ0FBbEI7QUFDQSxRQUFNMk8sU0FBUyxHQUFHNVIsS0FBSyxDQUFDaUQsTUFBTixHQUFldU4sU0FBakM7QUFDQSxRQUFNek4sTUFBTSxHQUFHLElBQUlMLEtBQUosQ0FBVThOLFNBQVYsQ0FBZjtBQUNBLFFBQU1pWSxnQkFBZ0IsR0FBR3pvQixLQUFLLENBQUNpRCxNQUFOLEdBQWUsQ0FBZixJQUFvQixPQUFPakQsS0FBSyxDQUFDLENBQUQsQ0FBWixLQUFvQixRQUF4QyxHQUFtRHNrQixZQUFuRCxHQUFrRThELFlBQTNGOztBQUVBLE9BQUssSUFBSWpsQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcU4sU0FBcEIsRUFBK0IsRUFBRXJOLENBQWpDLEVBQW9DO0FBQ2xDSixJQUFBQSxNQUFNLENBQUNJLENBQUQsQ0FBTixHQUFZc2xCLGdCQUFnQixDQUFDM1AsR0FBRyxDQUFDOEUsT0FBTCxFQUFjNWQsS0FBSyxDQUFDbUQsQ0FBRCxDQUFuQixDQUE1QjtBQUNEOztBQUVELE1BQUl5TyxTQUFTLEdBQUcsQ0FBaEIsRUFBbUI7QUFDakI3TyxJQUFBQSxNQUFNLENBQUN5TixTQUFELENBQU4sR0FBcUIsT0FBTW9CLFNBQVUsYUFBWUEsU0FBUyxHQUFHLENBQVosR0FBZ0IsR0FBaEIsR0FBc0IsRUFBRyxFQUExRTtBQUNEOztBQUVELE1BQUlrSCxHQUFHLENBQUNLLFVBQVIsRUFBb0I7QUFDbEI7QUFDQUwsSUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxTQUFLLE1BQU05WixHQUFYLElBQWtCLENBQUMsbUJBQUQsRUFBc0IsUUFBdEIsRUFBZ0MsWUFBaEMsRUFBOEMsWUFBOUMsRUFBNEQsUUFBNUQsQ0FBbEIsRUFBeUY7QUFDdkYsWUFBTWpELEdBQUcsR0FBR3FkLFdBQVcsQ0FBQ3hGLEdBQUQsRUFBTTlZLEtBQUssQ0FBQ2tFLEdBQUQsQ0FBWCxFQUFrQjJVLFlBQWxCLEVBQWdDLElBQWhDLENBQXZCO0FBQ0E5VixNQUFBQSxNQUFNLENBQUNQLElBQVAsQ0FBYSxJQUFHMEIsR0FBSSxNQUFLakQsR0FBSSxFQUE3QjtBQUNEOztBQUVENlgsSUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0QjtBQUNEOztBQUVELFNBQU9qYixNQUFQO0FBQ0Q7O0FBRUQsU0FBU3lnQixTQUFULENBQW1CMUssR0FBbkIsRUFBd0I5WSxLQUF4QixFQUErQjZZLFlBQS9CLEVBQTZDO0FBQzNDLFFBQU05VixNQUFNLEdBQUcsRUFBZjtBQUNBK1YsRUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxPQUFLLE1BQU0wSyxDQUFYLElBQWdCMW9CLEtBQWhCLEVBQXVCO0FBQ3JCK0MsSUFBQUEsTUFBTSxDQUFDUCxJQUFQLENBQVk4YixXQUFXLENBQUN4RixHQUFELEVBQU00UCxDQUFOLEVBQVM3UCxZQUFULENBQXZCO0FBQ0Q7O0FBRURDLEVBQUFBLEdBQUcsQ0FBQ2tGLGNBQUosSUFBc0IsQ0FBdEIsQ0FSMkMsQ0FRbEI7QUFDekI7QUFDQTs7QUFFQSxNQUFJbEYsR0FBRyxDQUFDSyxVQUFSLEVBQW9CO0FBQ2xCcFcsSUFBQUEsTUFBTSxDQUFDUCxJQUFQLENBQWEsV0FBVXNXLEdBQUcsQ0FBQzhFLE9BQUosQ0FBYSxHQUFFNWQsS0FBSyxDQUFDZ2pCLElBQUssRUFBMUIsRUFBNkIsUUFBN0IsQ0FBdUMsRUFBOUQ7QUFDRDs7QUFFRCxTQUFPamdCLE1BQVA7QUFDRDs7QUFFRCxTQUFTMGdCLFNBQVQsQ0FBbUIzSyxHQUFuQixFQUF3QjlZLEtBQXhCLEVBQStCNlksWUFBL0IsRUFBNkM7QUFDM0MsUUFBTTlWLE1BQU0sR0FBRyxFQUFmO0FBQ0ErVixFQUFBQSxHQUFHLENBQUNrRixjQUFKLElBQXNCLENBQXRCOztBQUVBLE9BQUssTUFBTSxDQUFDMkssQ0FBRCxFQUFJRCxDQUFKLENBQVgsSUFBcUIxb0IsS0FBckIsRUFBNEI7QUFDMUIrQyxJQUFBQSxNQUFNLENBQUNQLElBQVAsQ0FBYSxHQUFFOGIsV0FBVyxDQUFDeEYsR0FBRCxFQUFNNlAsQ0FBTixFQUFTOVAsWUFBVCxDQUF1QixPQUFNeUYsV0FBVyxDQUFDeEYsR0FBRCxFQUFNNFAsQ0FBTixFQUFTN1AsWUFBVCxDQUF1QixFQUF6RjtBQUNEOztBQUVEQyxFQUFBQSxHQUFHLENBQUNrRixjQUFKLElBQXNCLENBQXRCLENBUjJDLENBUWxCOztBQUV6QixNQUFJbEYsR0FBRyxDQUFDSyxVQUFSLEVBQW9CO0FBQ2xCcFcsSUFBQUEsTUFBTSxDQUFDUCxJQUFQLENBQWEsV0FBVXNXLEdBQUcsQ0FBQzhFLE9BQUosQ0FBYSxHQUFFNWQsS0FBSyxDQUFDZ2pCLElBQUssRUFBMUIsRUFBNkIsUUFBN0IsQ0FBdUMsRUFBOUQ7QUFDRDs7QUFFRCxTQUFPamdCLE1BQVA7QUFDRDs7QUFFRCxTQUFTNmxCLGtCQUFULENBQTRCOVAsR0FBNUIsRUFBaUNELFlBQWpDLEVBQStDL0csT0FBL0MsRUFBd0QrVyxLQUF4RCxFQUErRDtBQUM3RCxRQUFNcE0sY0FBYyxHQUFHakwsSUFBSSxDQUFDdUgsR0FBTCxDQUFTRCxHQUFHLENBQUMyRCxjQUFiLEVBQTZCLENBQTdCLENBQXZCO0FBQ0EsUUFBTWpNLFNBQVMsR0FBR2dCLElBQUksQ0FBQ0MsR0FBTCxDQUFTZ0wsY0FBVCxFQUF5QjNLLE9BQU8sQ0FBQzdPLE1BQWpDLENBQWxCO0FBQ0EsTUFBSUYsTUFBTSxHQUFHLElBQUlMLEtBQUosQ0FBVThOLFNBQVYsQ0FBYjtBQUNBc0ksRUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxPQUFLLElBQUk3YSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcU4sU0FBcEIsRUFBK0JyTixDQUFDLEVBQWhDLEVBQW9DO0FBQ2xDSixJQUFBQSxNQUFNLENBQUNJLENBQUQsQ0FBTixHQUFZbWIsV0FBVyxDQUFDeEYsR0FBRCxFQUFNaEgsT0FBTyxDQUFDM08sQ0FBRCxDQUFiLEVBQWtCMFYsWUFBbEIsQ0FBdkI7QUFDRDs7QUFFREMsRUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxNQUFJNkssS0FBSyxLQUFLdEwsS0FBVixJQUFtQixDQUFDekUsR0FBRyxDQUFDNEQsTUFBNUIsRUFBb0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EzWixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQ29pQixJQUFQLEVBQVQ7QUFDRDs7QUFFRCxRQUFNdlQsU0FBUyxHQUFHRSxPQUFPLENBQUM3TyxNQUFSLEdBQWlCdU4sU0FBbkM7O0FBRUEsTUFBSW9CLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtBQUNqQjdPLElBQUFBLE1BQU0sQ0FBQ1AsSUFBUCxDQUFhLE9BQU1vUCxTQUFVLGFBQVlBLFNBQVMsR0FBRyxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLEVBQUcsRUFBbEU7QUFDRDs7QUFFRCxTQUFPN08sTUFBUDtBQUNEOztBQUVELFNBQVMrbEIsa0JBQVQsQ0FBNEJoUSxHQUE1QixFQUFpQ0QsWUFBakMsRUFBK0MvRyxPQUEvQyxFQUF3RCtXLEtBQXhELEVBQStEO0FBQzdELFFBQU1wTSxjQUFjLEdBQUdqTCxJQUFJLENBQUN1SCxHQUFMLENBQVNELEdBQUcsQ0FBQzJELGNBQWIsRUFBNkIsQ0FBN0IsQ0FBdkIsQ0FENkQsQ0FDTDs7QUFFeEQsUUFBTTNSLEdBQUcsR0FBR2dILE9BQU8sQ0FBQzdPLE1BQVIsR0FBaUIsQ0FBN0I7QUFDQSxRQUFNMk8sU0FBUyxHQUFHOUcsR0FBRyxHQUFHMlIsY0FBeEI7QUFDQSxRQUFNak0sU0FBUyxHQUFHZ0IsSUFBSSxDQUFDQyxHQUFMLENBQVNnTCxjQUFULEVBQXlCM1IsR0FBekIsQ0FBbEI7QUFDQSxNQUFJL0gsTUFBTSxHQUFHLElBQUlMLEtBQUosQ0FBVThOLFNBQVYsQ0FBYjtBQUNBLE1BQUlyTixDQUFDLEdBQUcsQ0FBUjtBQUNBMlYsRUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxNQUFJNkssS0FBSyxLQUFLdEwsS0FBZCxFQUFxQjtBQUNuQixXQUFPcGEsQ0FBQyxHQUFHcU4sU0FBWCxFQUFzQnJOLENBQUMsRUFBdkIsRUFBMkI7QUFDekIsWUFBTWlqQixHQUFHLEdBQUdqakIsQ0FBQyxHQUFHLENBQWhCO0FBQ0FKLE1BQUFBLE1BQU0sQ0FBQ0ksQ0FBRCxDQUFOLEdBQWEsR0FBRW1iLFdBQVcsQ0FBQ3hGLEdBQUQsRUFBTWhILE9BQU8sQ0FBQ3NVLEdBQUQsQ0FBYixFQUFvQnZOLFlBQXBCLENBQWtDLEVBQWhELEdBQXFELE9BQU15RixXQUFXLENBQUN4RixHQUFELEVBQU1oSCxPQUFPLENBQUNzVSxHQUFHLEdBQUcsQ0FBUCxDQUFiLEVBQXdCdk4sWUFBeEIsQ0FBc0MsRUFBeEg7QUFDRCxLQUprQixDQUlqQjtBQUNGO0FBQ0E7OztBQUdBLFFBQUksQ0FBQ0MsR0FBRyxDQUFDNEQsTUFBVCxFQUFpQjtBQUNmM1osTUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNvaUIsSUFBUCxFQUFUO0FBQ0Q7QUFDRixHQVpELE1BWU87QUFDTCxXQUFPaGlCLENBQUMsR0FBR3FOLFNBQVgsRUFBc0JyTixDQUFDLEVBQXZCLEVBQTJCO0FBQ3pCLFlBQU1pakIsR0FBRyxHQUFHampCLENBQUMsR0FBRyxDQUFoQjtBQUNBLFlBQU1raUIsR0FBRyxHQUFHLENBQUMvRyxXQUFXLENBQUN4RixHQUFELEVBQU1oSCxPQUFPLENBQUNzVSxHQUFELENBQWIsRUFBb0J2TixZQUFwQixDQUFaLEVBQStDeUYsV0FBVyxDQUFDeEYsR0FBRCxFQUFNaEgsT0FBTyxDQUFDc1UsR0FBRyxHQUFHLENBQVAsQ0FBYixFQUF3QnZOLFlBQXhCLENBQTFELENBQVo7QUFDQTlWLE1BQUFBLE1BQU0sQ0FBQ0ksQ0FBRCxDQUFOLEdBQVltaUIsb0JBQW9CLENBQUN4TSxHQUFELEVBQU11TSxHQUFOLEVBQVcsRUFBWCxFQUFlLENBQUMsR0FBRCxFQUFNLEdBQU4sQ0FBZixFQUEyQnZJLGdCQUEzQixFQUE2Q2pFLFlBQTdDLENBQWhDO0FBQ0Q7QUFDRjs7QUFFREMsRUFBQUEsR0FBRyxDQUFDa0YsY0FBSixJQUFzQixDQUF0Qjs7QUFFQSxNQUFJcE0sU0FBUyxHQUFHLENBQWhCLEVBQW1CO0FBQ2pCN08sSUFBQUEsTUFBTSxDQUFDUCxJQUFQLENBQWEsT0FBTW9QLFNBQVUsYUFBWUEsU0FBUyxHQUFHLENBQVosR0FBZ0IsR0FBaEIsR0FBc0IsRUFBRyxFQUFsRTtBQUNEOztBQUVELFNBQU83TyxNQUFQO0FBQ0Q7O0FBRUQsU0FBUzBoQixvQkFBVCxDQUE4QjNMLEdBQTlCLEVBQW1DO0FBQ2pDLFNBQU8sQ0FBQ0EsR0FBRyxDQUFDOEUsT0FBSixDQUFZLGlCQUFaLEVBQStCLFNBQS9CLENBQUQsQ0FBUDtBQUNEOztBQUVELFNBQVM0RyxhQUFULENBQXVCMUwsR0FBdkIsRUFBNEI0TixNQUE1QixFQUFvQ0MsYUFBcEMsRUFBbUQ7QUFDakQ7QUFDQSxTQUFPbEMsb0JBQW9CLENBQUMzTCxHQUFELENBQTNCO0FBQ0Q7O0FBRUQsU0FBUzRMLGFBQVQsQ0FBdUI1TCxHQUF2QixFQUE0QjROLE1BQTVCLEVBQW9DQyxhQUFwQyxFQUFtRDtBQUNqRDtBQUNBLFNBQU9sQyxvQkFBb0IsQ0FBQzNMLEdBQUQsQ0FBM0I7QUFDRDs7QUFFRCxTQUFTOEssY0FBVCxDQUF3QjlLLEdBQXhCLEVBQTZCOVksS0FBN0IsRUFBb0M2WSxZQUFwQyxFQUFrRGtRLEtBQWxELEVBQXlENUYsTUFBekQsRUFBaUU7QUFDL0QsUUFBTXJSLE9BQU8sR0FBRyxFQUFoQjtBQUNBLE1BQUlrWCxVQUFVLEdBQUcsS0FBakI7QUFDQSxNQUFJOVcsTUFBTSxHQUFHbFMsS0FBSyxDQUFDaVMsSUFBTixFQUFiOztBQUVBLFNBQU8sQ0FBQ0MsTUFBTSxDQUFDQyxJQUFmLEVBQXFCO0FBQ25CLFVBQU04VyxZQUFZLEdBQUcvVyxNQUFNLENBQUNsUyxLQUE1QjtBQUNBOFIsSUFBQUEsT0FBTyxDQUFDdFAsSUFBUixDQUFheW1CLFlBQWI7O0FBRUEsUUFBSUEsWUFBWSxDQUFDLENBQUQsQ0FBWixLQUFvQkEsWUFBWSxDQUFDLENBQUQsQ0FBcEMsRUFBeUM7QUFDdkNELE1BQUFBLFVBQVUsR0FBRyxJQUFiO0FBQ0Q7O0FBRUQ5VyxJQUFBQSxNQUFNLEdBQUdsUyxLQUFLLENBQUNpUyxJQUFOLEVBQVQ7QUFDRDs7QUFFRCxNQUFJK1csVUFBSixFQUFnQjtBQUNkO0FBQ0E3RixJQUFBQSxNQUFNLENBQUMsQ0FBRCxDQUFOLEdBQVlBLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVWppQixPQUFWLENBQWtCLGVBQWxCLEVBQW1DLGFBQW5DLENBQVo7QUFDQSxXQUFPNG5CLGtCQUFrQixDQUFDaFEsR0FBRCxFQUFNRCxZQUFOLEVBQW9CL0csT0FBcEIsRUFBNkIyTCxXQUE3QixDQUF6QjtBQUNEOztBQUVELFNBQU9tTCxrQkFBa0IsQ0FBQzlQLEdBQUQsRUFBTUQsWUFBTixFQUFvQi9HLE9BQXBCLEVBQTZCMEwsU0FBN0IsQ0FBekI7QUFDRDs7QUFFRCxTQUFTMEwsa0JBQVQsQ0FBNEJwUSxHQUE1QixFQUFpQy9WLE1BQWpDLEVBQXlDNkksS0FBekMsRUFBZ0RxWCxJQUFoRCxFQUFzRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxNQUFJdkssV0FBVyxHQUFHM1YsTUFBTSxDQUFDRSxNQUFQLEdBQWdCMkksS0FBbEM7O0FBRUEsTUFBSThNLFdBQVcsR0FBRzNWLE1BQU0sQ0FBQ0UsTUFBckIsR0FBOEI2VixHQUFHLENBQUNTLFdBQXRDLEVBQW1EO0FBQ2pELFdBQU8sS0FBUDtBQUNEOztBQUVELE9BQUssSUFBSXBXLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdKLE1BQU0sQ0FBQ0UsTUFBM0IsRUFBbUNFLENBQUMsRUFBcEMsRUFBd0M7QUFDdEMsUUFBSTJWLEdBQUcsQ0FBQ3dELE1BQVIsRUFBZ0I7QUFDZDVELE1BQUFBLFdBQVcsSUFBSTFYLFlBQVksQ0FBQytCLE1BQU0sQ0FBQ0ksQ0FBRCxDQUFQLENBQVosQ0FBd0JGLE1BQXZDO0FBQ0QsS0FGRCxNQUVPO0FBQ0x5VixNQUFBQSxXQUFXLElBQUkzVixNQUFNLENBQUNJLENBQUQsQ0FBTixDQUFVRixNQUF6QjtBQUNEOztBQUVELFFBQUl5VixXQUFXLEdBQUdJLEdBQUcsQ0FBQ1MsV0FBdEIsRUFBbUM7QUFDakMsYUFBTyxLQUFQO0FBQ0Q7QUFDRixHQXBCbUQsQ0FvQmxEOzs7QUFHRixTQUFPMEosSUFBSSxLQUFLLEVBQVQsSUFBZSxDQUFDQSxJQUFJLENBQUNsYyxRQUFMLENBQWMsSUFBZCxDQUF2QjtBQUNEOztBQUVELFNBQVN1ZSxvQkFBVCxDQUE4QnhNLEdBQTlCLEVBQW1DL1YsTUFBbkMsRUFBMkNrZ0IsSUFBM0MsRUFBaURFLE1BQWpELEVBQXlERSxVQUF6RCxFQUFxRXhLLFlBQXJFLEVBQW1GN1ksS0FBbkYsRUFBMEY7QUFDeEYsTUFBSThZLEdBQUcsQ0FBQ1UsT0FBSixLQUFnQixJQUFwQixFQUEwQjtBQUN4QixRQUFJLE9BQU9WLEdBQUcsQ0FBQ1UsT0FBWCxLQUF1QixRQUF2QixJQUFtQ1YsR0FBRyxDQUFDVSxPQUFKLElBQWUsQ0FBdEQsRUFBeUQ7QUFDdkQ7QUFDQTtBQUNBLFlBQU0xSCxPQUFPLEdBQUcvTyxNQUFNLENBQUNFLE1BQXZCLENBSHVELENBR3hCO0FBQy9COztBQUVBLFVBQUlvZ0IsVUFBVSxLQUFLdkcsZ0JBQWYsSUFBbUNoTCxPQUFPLEdBQUcsQ0FBakQsRUFBb0Q7QUFDbEQvTyxRQUFBQSxNQUFNLEdBQUdva0Isa0JBQWtCLENBQUNyTyxHQUFELEVBQU0vVixNQUFOLEVBQWMvQyxLQUFkLENBQTNCO0FBQ0QsT0FSc0QsQ0FRckQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsVUFBSThZLEdBQUcsQ0FBQ29GLFlBQUosR0FBbUJyRixZQUFuQixHQUFrQ0MsR0FBRyxDQUFDVSxPQUF0QyxJQUFpRDFILE9BQU8sS0FBSy9PLE1BQU0sQ0FBQ0UsTUFBeEUsRUFBZ0Y7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsY0FBTTJJLEtBQUssR0FBRzdJLE1BQU0sQ0FBQ0UsTUFBUCxHQUFnQjZWLEdBQUcsQ0FBQ2tGLGNBQXBCLEdBQXFDbUYsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVbGdCLE1BQS9DLEdBQXdEZ2dCLElBQUksQ0FBQ2hnQixNQUE3RCxHQUFzRSxFQUFwRjs7QUFFQSxZQUFJaW1CLGtCQUFrQixDQUFDcFEsR0FBRCxFQUFNL1YsTUFBTixFQUFjNkksS0FBZCxFQUFxQnFYLElBQXJCLENBQXRCLEVBQWtEO0FBQ2hELGlCQUFRLEdBQUVBLElBQUksR0FBSSxHQUFFQSxJQUFLLEdBQVgsR0FBZ0IsRUFBRyxHQUFFRSxNQUFNLENBQUMsQ0FBRCxDQUFJLElBQUdyZ0IsSUFBSSxDQUFDQyxNQUFELEVBQVMsSUFBVCxDQUFlLElBQUdvZ0IsTUFBTSxDQUFDLENBQUQsQ0FBSSxFQUFoRjtBQUNEO0FBQ0Y7QUFDRixLQW5DdUIsQ0FtQ3RCOzs7QUFHRixVQUFNc0QsV0FBVyxHQUFJLEtBQUksSUFBSTNELE1BQUosQ0FBV2hLLEdBQUcsQ0FBQ2tGLGNBQWYsQ0FBK0IsRUFBeEQ7QUFDQSxXQUFRLEdBQUVpRixJQUFJLEdBQUksR0FBRUEsSUFBSyxHQUFYLEdBQWdCLEVBQUcsR0FBRUUsTUFBTSxDQUFDLENBQUQsQ0FBSSxHQUFFc0QsV0FBWSxJQUFwRCxHQUEyRCxHQUFFM2pCLElBQUksQ0FBQ0MsTUFBRCxFQUFVLElBQUcwakIsV0FBWSxJQUF6QixDQUE4QixHQUFFQSxXQUFZLEdBQUV0RCxNQUFNLENBQUMsQ0FBRCxDQUFJLEVBQWhJO0FBQ0QsR0F6Q3VGLENBeUN0RjtBQUNGOzs7QUFHQSxNQUFJK0Ysa0JBQWtCLENBQUNwUSxHQUFELEVBQU0vVixNQUFOLEVBQWMsQ0FBZCxFQUFpQmtnQixJQUFqQixDQUF0QixFQUE4QztBQUM1QyxXQUFRLEdBQUVFLE1BQU0sQ0FBQyxDQUFELENBQUksR0FBRUYsSUFBSSxHQUFJLElBQUdBLElBQUssRUFBWixHQUFnQixFQUFHLElBQUduZ0IsSUFBSSxDQUFDQyxNQUFELEVBQVMsSUFBVCxDQUFlLEdBQTVELEdBQWlFb2dCLE1BQU0sQ0FBQyxDQUFELENBQTlFO0FBQ0Q7O0FBRUQsUUFBTXNELFdBQVcsR0FBRyxJQUFJM0QsTUFBSixDQUFXaEssR0FBRyxDQUFDa0YsY0FBZixDQUFwQixDQWpEd0YsQ0FpRHBDO0FBQ3BEO0FBQ0E7O0FBRUEsUUFBTW1MLEVBQUUsR0FBR2xHLElBQUksS0FBSyxFQUFULElBQWVFLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVWxnQixNQUFWLEtBQXFCLENBQXBDLEdBQXdDLEdBQXhDLEdBQStDLEdBQUVnZ0IsSUFBSSxHQUFJLElBQUdBLElBQUssRUFBWixHQUFnQixFQUFHLEtBQUl3RCxXQUFZLElBQW5HLENBckR3RixDQXFEZ0I7O0FBRXhHLFNBQVEsR0FBRXRELE1BQU0sQ0FBQyxDQUFELENBQUksR0FBRWdHLEVBQUcsR0FBRXJtQixJQUFJLENBQUNDLE1BQUQsRUFBVSxNQUFLMGpCLFdBQVksSUFBM0IsQ0FBZ0MsSUFBR3RELE1BQU0sQ0FBQyxDQUFELENBQUksRUFBNUU7QUFDRDs7QUFFRCxTQUFTclosTUFBVCxDQUFnQixHQUFHVCxJQUFuQixFQUF5QjtBQUN2QixTQUFPK2YsaUJBQWlCLENBQUNybkIsU0FBRCxFQUFZLEdBQUdzSCxJQUFmLENBQXhCO0FBQ0Q7O0FBRUQsTUFBTWdnQixjQUFjLEdBQUdyaEIsS0FBSyxJQUFJQSxLQUFLLENBQUNLLE9BQU4sQ0FBY2xHLEtBQWQsQ0FBb0IsSUFBcEIsRUFBMEIsQ0FBMUIsQ0FBaEM7O0FBRUEsSUFBSW1uQixzQkFBSjs7QUFFQSxTQUFTQyxZQUFULENBQXNCdlosR0FBdEIsRUFBMkI7QUFDekIsTUFBSTtBQUNGLFdBQU93WixJQUFJLENBQUNDLFNBQUwsQ0FBZXpaLEdBQWYsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPdE8sR0FBUCxFQUFZO0FBQ1o7QUFDQSxRQUFJLENBQUM0bkIsc0JBQUwsRUFBNkI7QUFDM0IsVUFBSTtBQUNGLGNBQU1JLENBQUMsR0FBRyxFQUFWO0FBQ0FBLFFBQUFBLENBQUMsQ0FBQ0EsQ0FBRixHQUFNQSxDQUFOO0FBQ0FGLFFBQUFBLElBQUksQ0FBQ0MsU0FBTCxDQUFlQyxDQUFmO0FBQ0QsT0FKRCxDQUlFLE9BQU90b0IsQ0FBUCxFQUFVO0FBQ1Zrb0IsUUFBQUEsc0JBQXNCLEdBQUdELGNBQWMsQ0FBQ2pvQixDQUFELENBQXZDO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJTSxHQUFHLENBQUN3RCxJQUFKLEtBQWEsV0FBYixJQUE0Qm1rQixjQUFjLENBQUMzbkIsR0FBRCxDQUFkLEtBQXdCNG5CLHNCQUF4RCxFQUFnRjtBQUM5RSxhQUFPLFlBQVA7QUFDRDs7QUFFRCxVQUFNNW5CLEdBQU47QUFDRDtBQUNGO0FBQ0Q7OztBQUdBLFNBQVMwbkIsaUJBQVQsQ0FBMkJPLGNBQTNCLEVBQTJDLEdBQUd0Z0IsSUFBOUMsRUFBb0Q7QUFDbEQsUUFBTXdMLEtBQUssR0FBR3hMLElBQUksQ0FBQyxDQUFELENBQWxCO0FBQ0EsTUFBSXFnQixDQUFDLEdBQUcsQ0FBUjtBQUNBLE1BQUl6b0IsR0FBRyxHQUFHLEVBQVY7QUFDQSxNQUFJNkIsSUFBSSxHQUFHLEVBQVg7O0FBRUEsTUFBSSxPQUFPK1IsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixRQUFJeEwsSUFBSSxDQUFDcEcsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQixhQUFPNFIsS0FBUDtBQUNEOztBQUVELFFBQUkrVSxPQUFKO0FBQ0EsUUFBSUMsT0FBTyxHQUFHLENBQWQ7O0FBRUEsU0FBSyxJQUFJMW1CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwUixLQUFLLENBQUM1UixNQUFOLEdBQWUsQ0FBbkMsRUFBc0NFLENBQUMsRUFBdkMsRUFBMkM7QUFDekMsVUFBSTBSLEtBQUssQ0FBQ3ZRLFVBQU4sQ0FBaUJuQixDQUFqQixNQUF3QixFQUE1QixFQUFnQztBQUM5QjtBQUNBLGNBQU0ybUIsUUFBUSxHQUFHalYsS0FBSyxDQUFDdlEsVUFBTixDQUFpQixFQUFFbkIsQ0FBbkIsQ0FBakI7O0FBRUEsWUFBSXVtQixDQUFDLEdBQUcsQ0FBSixLQUFVcmdCLElBQUksQ0FBQ3BHLE1BQW5CLEVBQTJCO0FBQ3pCLGtCQUFRNm1CLFFBQVI7QUFDRSxpQkFBSyxHQUFMO0FBQ0U7QUFDQSxvQkFBTUMsT0FBTyxHQUFHMWdCLElBQUksQ0FBQyxFQUFFcWdCLENBQUgsQ0FBcEI7O0FBRUEsa0JBQUksT0FBT0ssT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQkgsZ0JBQUFBLE9BQU8sR0FBR3RGLFlBQVksQ0FBQ25HLGNBQUQsRUFBaUI0TCxPQUFqQixDQUF0QjtBQUNBOzs7O0FBSUQsZUFORCxNQU1PO0FBQ0wsb0JBQUlDLE1BQUo7O0FBRUEsb0JBQUksT0FBT0QsT0FBUCxLQUFtQixRQUFuQixJQUErQkEsT0FBTyxLQUFLLElBQTNDLElBQW1ELE9BQU9BLE9BQU8sQ0FBQzVrQixRQUFmLEtBQTRCLFVBQTVCLEtBQTJDNlcsY0FBYyxDQUFDK04sT0FBRCxFQUFVLFVBQVYsQ0FBZCxDQUFvQztBQUN0STtBQURrRyxtQkFFL0YsQ0FBQ0MsTUFBTSxHQUFHRCxPQUFPLENBQUNqakIsV0FBbEIsS0FBa0MsQ0FBQ29WLGNBQWMsQ0FBQ3JOLEdBQWYsQ0FBbUJtYixNQUFNLENBQUM5a0IsSUFBMUIsQ0FBbkMsSUFBc0U4a0IsTUFBTSxDQUFDdGxCLFNBQTdFLElBQTBGc1gsY0FBYyxDQUFDZ08sTUFBTSxDQUFDdGxCLFNBQVIsRUFBbUIsVUFBbkIsQ0FGcEQsQ0FBdkQsRUFFNEk7QUFDMUlrbEIsa0JBQUFBLE9BQU8sR0FBRzVlLE1BQU0sQ0FBQytlLE9BQUQsQ0FBaEI7QUFDRCxpQkFKRCxNQUlPO0FBQ0xILGtCQUFBQSxPQUFPLEdBQUd0USxPQUFPLENBQUN5USxPQUFELEVBQVUsRUFBRSxHQUFHSixjQUFMO0FBQ3pCblEsb0JBQUFBLE9BQU8sRUFBRSxDQURnQjtBQUV6QjhDLG9CQUFBQSxNQUFNLEVBQUUsS0FGaUI7QUFHekJELG9CQUFBQSxLQUFLLEVBQUUsQ0FIa0IsRUFBVixDQUFqQjs7QUFLRDtBQUNGOztBQUVEOztBQUVGLGlCQUFLLEdBQUw7QUFDRTtBQUNBdU4sY0FBQUEsT0FBTyxHQUFHTCxZQUFZLENBQUNsZ0IsSUFBSSxDQUFDLEVBQUVxZ0IsQ0FBSCxDQUFMLENBQXRCO0FBQ0E7O0FBRUYsaUJBQUssR0FBTDtBQUNFO0FBQ0Esb0JBQU1PLE9BQU8sR0FBRzVnQixJQUFJLENBQUMsRUFBRXFnQixDQUFILENBQXBCO0FBQ0E7Ozs7OztBQU1BLGtCQUFJLE9BQU9PLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0JMLGdCQUFBQSxPQUFPLEdBQUcsS0FBVjtBQUNELGVBRkQsTUFFTztBQUNMQSxnQkFBQUEsT0FBTyxHQUFHdEYsWUFBWSxDQUFDbkcsY0FBRCxFQUFpQjNTLE1BQU0sQ0FBQ3llLE9BQUQsQ0FBdkIsQ0FBdEI7QUFDRDs7QUFFRDs7QUFFRixpQkFBSyxFQUFMO0FBQ0U7QUFDQUwsY0FBQUEsT0FBTyxHQUFHdFEsT0FBTyxDQUFDalEsSUFBSSxDQUFDLEVBQUVxZ0IsQ0FBSCxDQUFMLEVBQVlDLGNBQVosQ0FBakI7QUFDQTs7QUFFRixpQkFBSyxHQUFMO0FBQ0U7QUFDQTtBQUNFQyxnQkFBQUEsT0FBTyxHQUFHdFEsT0FBTyxDQUFDalEsSUFBSSxDQUFDLEVBQUVxZ0IsQ0FBSCxDQUFMLEVBQVksRUFBRSxHQUFHQyxjQUFMO0FBQzNCeFEsa0JBQUFBLFVBQVUsRUFBRSxJQURlO0FBRTNCcUQsa0JBQUFBLFNBQVMsRUFBRSxJQUZnQjtBQUczQkgsa0JBQUFBLEtBQUssRUFBRSxDQUhvQixFQUFaLENBQWpCOztBQUtBO0FBQ0Q7O0FBRUgsaUJBQUssR0FBTDtBQUNFO0FBQ0Esb0JBQU02TixXQUFXLEdBQUc3Z0IsSUFBSSxDQUFDLEVBQUVxZ0IsQ0FBSCxDQUF4QjtBQUNBOzs7OztBQUtBLGtCQUFJLE9BQU9RLFdBQVAsS0FBdUIsUUFBM0IsRUFBcUM7QUFDbkNOLGdCQUFBQSxPQUFPLEdBQUcsS0FBVjtBQUNELGVBRkQsTUFFTztBQUNMQSxnQkFBQUEsT0FBTyxHQUFHdEYsWUFBWSxDQUFDbkcsY0FBRCxFQUFpQjdTLFFBQVEsQ0FBQzRlLFdBQUQsQ0FBekIsQ0FBdEI7QUFDRDs7QUFFRDs7QUFFRixpQkFBSyxHQUFMO0FBQ0U7QUFDQSxvQkFBTUMsU0FBUyxHQUFHOWdCLElBQUksQ0FBQyxFQUFFcWdCLENBQUgsQ0FBdEI7O0FBRUEsa0JBQUksT0FBT1MsU0FBUCxLQUFxQixRQUF6QixFQUFtQztBQUNqQ1AsZ0JBQUFBLE9BQU8sR0FBRyxLQUFWO0FBQ0QsZUFGRCxNQUVPO0FBQ0xBLGdCQUFBQSxPQUFPLEdBQUd0RixZQUFZLENBQUNuRyxjQUFELEVBQWlCaU0sVUFBVSxDQUFDRCxTQUFELENBQTNCLENBQXRCO0FBQ0Q7O0FBRUQ7O0FBRUYsaUJBQUssRUFBTDtBQUNFO0FBQ0FscEIsY0FBQUEsR0FBRyxJQUFJNFQsS0FBSyxDQUFDNUosS0FBTixDQUFZNGUsT0FBWixFQUFxQjFtQixDQUFyQixDQUFQO0FBQ0EwbUIsY0FBQUEsT0FBTyxHQUFHMW1CLENBQUMsR0FBRyxDQUFkO0FBQ0E7O0FBRUY7QUFDRTtBQUNBLHVCQXZHSjs7O0FBMEdBLGNBQUkwbUIsT0FBTyxLQUFLMW1CLENBQUMsR0FBRyxDQUFwQixFQUF1QjtBQUNyQmxDLFlBQUFBLEdBQUcsSUFBSTRULEtBQUssQ0FBQzVKLEtBQU4sQ0FBWTRlLE9BQVosRUFBcUIxbUIsQ0FBQyxHQUFHLENBQXpCLENBQVA7QUFDRDs7QUFFRGxDLFVBQUFBLEdBQUcsSUFBSTJvQixPQUFQO0FBQ0FDLFVBQUFBLE9BQU8sR0FBRzFtQixDQUFDLEdBQUcsQ0FBZDtBQUNELFNBakhELE1BaUhPLElBQUkybUIsUUFBUSxLQUFLLEVBQWpCLEVBQXFCO0FBQzFCN29CLFVBQUFBLEdBQUcsSUFBSTRULEtBQUssQ0FBQzVKLEtBQU4sQ0FBWTRlLE9BQVosRUFBcUIxbUIsQ0FBckIsQ0FBUDtBQUNBMG1CLFVBQUFBLE9BQU8sR0FBRzFtQixDQUFDLEdBQUcsQ0FBZDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJMG1CLE9BQU8sS0FBSyxDQUFoQixFQUFtQjtBQUNqQkgsTUFBQUEsQ0FBQztBQUNENW1CLE1BQUFBLElBQUksR0FBRyxHQUFQOztBQUVBLFVBQUkrbUIsT0FBTyxHQUFHaFYsS0FBSyxDQUFDNVIsTUFBcEIsRUFBNEI7QUFDMUJoQyxRQUFBQSxHQUFHLElBQUk0VCxLQUFLLENBQUM1SixLQUFOLENBQVk0ZSxPQUFaLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBT0gsQ0FBQyxHQUFHcmdCLElBQUksQ0FBQ3BHLE1BQWhCLEVBQXdCO0FBQ3RCLFVBQU1qRCxLQUFLLEdBQUdxSixJQUFJLENBQUNxZ0IsQ0FBRCxDQUFsQjtBQUNBem9CLElBQUFBLEdBQUcsSUFBSTZCLElBQVA7QUFDQTdCLElBQUFBLEdBQUcsSUFBSSxPQUFPakIsS0FBUCxLQUFpQixRQUFqQixHQUE0QnNaLE9BQU8sQ0FBQ3RaLEtBQUQsRUFBUTJwQixjQUFSLENBQW5DLEdBQTZEM3BCLEtBQXBFO0FBQ0E4QyxJQUFBQSxJQUFJLEdBQUcsR0FBUDtBQUNBNG1CLElBQUFBLENBQUM7QUFDRjs7QUFFRCxTQUFPem9CLEdBQVA7QUFDRDtBQUNEOztBQUVBLFNBQVNvcEIsSUFBVCxHQUFnQixDQUFFOztBQUVsQixTQUFTQyxPQUFULENBQWlCenFCLElBQWpCLEVBQXVCa25CLEtBQXZCLEVBQThCd0QsT0FBOUIsRUFBdUM7QUFDckN4RCxFQUFBQSxLQUFLLEdBQUksR0FBRUEsS0FBTSxFQUFqQjs7QUFFQSxRQUFNeUQsU0FBUyxHQUFHM3FCLElBQUksQ0FBQzRxQixNQUFMLENBQVkzbEIsR0FBWixDQUFnQmlpQixLQUFoQixDQUFsQjs7QUFFQSxNQUFJLENBQUN5RCxTQUFMLEVBQWdCO0FBQ2QzUCxJQUFBQSxPQUFPLENBQUNDLFdBQVIsQ0FBcUIsVUFBU2lNLEtBQU0sa0JBQXBDO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBTTJELFFBQVEsR0FBR3RQLElBQUksQ0FBQ3VQLEdBQUwsS0FBYUgsU0FBOUI7O0FBRUEsTUFBSUQsT0FBSixFQUFhO0FBQ1gxcUIsSUFBQUEsSUFBSSxDQUFDK3FCLEdBQUwsQ0FBVSxHQUFFN0QsS0FBTSxLQUFJMkQsUUFBUyxJQUEvQixFQUFvQyxHQUFHSCxPQUF2QztBQUNELEdBRkQsTUFFTztBQUNMMXFCLElBQUFBLElBQUksQ0FBQytxQixHQUFMLENBQVUsR0FBRTdELEtBQU0sS0FBSTJELFFBQVMsSUFBL0I7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFNRyxvQkFBb0IsR0FBRztBQUMzQnZPLEVBQUFBLE1BQU0sRUFBRSxJQURtQixFQUE3Qjs7QUFHQSxNQUFNd08sc0JBQXNCLEdBQUcsRUFBL0I7QUFDQSxJQUFJQyxXQUFKLEMsQ0FBaUI7QUFDakI7O0FBRUEsU0FBU0MsdUJBQVQsQ0FBaUNDLE1BQWpDLEVBQXlDO0FBQ3ZDLFNBQU92cEIsR0FBRyxJQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBSUEsR0FBRyxLQUFLLElBQVIsSUFBZ0IsQ0FBQ3VwQixNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLFlBQTNDLEVBQXlEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJRixNQUFNLENBQUNHLGFBQVAsQ0FBcUIsT0FBckIsTUFBa0MsQ0FBdEMsRUFBeUM7QUFDdkNILFFBQUFBLE1BQU0sQ0FBQ0ksSUFBUCxDQUFZLE9BQVosRUFBcUJoQixJQUFyQjtBQUNEO0FBQ0Y7QUFDRixHQWREO0FBZUQ7O0FBRUQsTUFBTWlCLE9BQU4sQ0FBYztBQUNaeGtCLEVBQUFBLFdBQVcsQ0FBQzBYLE9BQUQsRUFBVStNLE1BQVYsRUFBa0JDLFlBQWxCLEVBQWdDO0FBQ3pDLFFBQUloTixPQUFPLElBQUlBLE9BQU8sQ0FBQ3RPLE9BQVIsS0FBb0IsUUFBbkMsRUFBNkM7QUFDM0M7QUFDQSxXQUFLdWIsVUFBTCxHQUFrQmpOLE9BQWxCO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxVQUFJLENBQUNBLE9BQUQsSUFBWSxPQUFPQSxPQUFPLENBQUM3SCxLQUFmLEtBQXlCLFVBQXpDLEVBQXFEO0FBQ25EO0FBQ0E2SCxRQUFBQSxPQUFPLEdBQUc7QUFDUmtOLFVBQUFBLE1BQU0sRUFBRWxOLE9BREE7QUFFUitNLFVBQUFBLE1BRlE7QUFHUkMsVUFBQUEsWUFIUSxFQUFWOztBQUtEOztBQUVELFdBQUtHLE9BQUwsR0FBZW5OLE9BQU8sQ0FBQ2tOLE1BQXZCLENBWEssQ0FXMEI7O0FBRS9CLFdBQUtFLE9BQUwsR0FBZXBOLE9BQU8sQ0FBQytNLE1BQVIsSUFBa0IsS0FBS0ksT0FBdEM7QUFDQSxXQUFLRSxhQUFMLEdBQXFCck4sT0FBTyxDQUFDZ04sWUFBUixLQUF5QixLQUE5Qzs7QUFFQSxVQUFJLEtBQUtLLGFBQVQsRUFBd0I7QUFDdEIsYUFBS0MsbUJBQUwsR0FBMkJkLHVCQUF1QixDQUFDLEtBQUtXLE9BQU4sQ0FBbEQ7QUFDQSxhQUFLSSxtQkFBTCxHQUEyQmYsdUJBQXVCLENBQUMsS0FBS1ksT0FBTixDQUFsRDtBQUNEOztBQUVELFdBQUtJLFVBQUwsR0FBa0J4TixPQUFPLENBQUN5TixTQUFSLElBQXFCLE1BQXZDLENBckJLLENBcUIwQzs7QUFFL0MsV0FBS0MsZUFBTCxHQUF1QjFOLE9BQU8sQ0FBQ21MLGNBQS9CLENBdkJLLENBdUIwQztBQUNoRDs7QUFFRCxTQUFLYyxNQUFMLEdBQWMsSUFBSWppQixHQUFKLEVBQWQ7QUFDQSxTQUFLMmpCLE9BQUwsR0FBZSxJQUFJM2pCLEdBQUosRUFBZjtBQUNBLFNBQUs0akIsWUFBTCxHQUFvQixFQUFwQjtBQUNEOztBQUVEQyxFQUFBQSxlQUFlLENBQUNDLEtBQUQsRUFBUTFWLE1BQVIsRUFBZ0I7QUFDN0IsUUFBSSxLQUFLd1YsWUFBTCxDQUFrQm5wQixNQUFsQixLQUE2QixDQUFqQyxFQUFvQztBQUNsQyxVQUFJMlQsTUFBTSxDQUFDN1AsUUFBUCxDQUFnQixJQUFoQixDQUFKLEVBQTJCO0FBQ3pCNlAsUUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUMxVixPQUFQLENBQWUsS0FBZixFQUF1QixLQUFJLEtBQUtrckIsWUFBYSxFQUE3QyxDQUFUO0FBQ0Q7O0FBRUR4VixNQUFBQSxNQUFNLEdBQUcsS0FBS3dWLFlBQUwsR0FBb0J4VixNQUE3QjtBQUNELEtBUDRCLENBTzNCOzs7QUFHRixRQUFJLEtBQUs2VSxVQUFULEVBQXFCO0FBQ25CLFdBQUtBLFVBQUwsQ0FBZ0JhLEtBQWhCLEVBQXVCMVYsTUFBdkI7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBLFlBQU0yVixTQUFTLEdBQUdELEtBQUssS0FBSyxNQUFWLElBQW9CQSxLQUFLLEtBQUssT0FBOUIsSUFBeUNBLEtBQUssS0FBSyxPQUFyRTtBQUNBLFlBQU1yQixNQUFNLEdBQUdzQixTQUFTLEdBQUcsS0FBS1gsT0FBUixHQUFrQixLQUFLRCxPQUEvQzs7QUFFQSxVQUFJLEtBQUtFLGFBQUwsS0FBdUIsS0FBM0IsRUFBa0M7QUFDaEMsZUFBT1osTUFBTSxDQUFDdFUsS0FBUCxDQUFhQyxNQUFiLENBQVA7QUFDRCxPQVBJLENBT0g7QUFDRjtBQUNBOzs7QUFHQSxVQUFJO0FBQ0Y7QUFDQSxZQUFJcVUsTUFBTSxDQUFDRyxhQUFQLENBQXFCLE9BQXJCLE1BQWtDLENBQXRDLEVBQXlDO0FBQ3ZDSCxVQUFBQSxNQUFNLENBQUNJLElBQVAsQ0FBWSxPQUFaLEVBQXFCaEIsSUFBckI7QUFDRDs7QUFFRCxjQUFNbUMsWUFBWSxHQUFHRCxTQUFTLEdBQUcsS0FBS1IsbUJBQVIsR0FBOEIsS0FBS0QsbUJBQWpFO0FBQ0FiLFFBQUFBLE1BQU0sQ0FBQ3RVLEtBQVAsQ0FBYUMsTUFBYixFQUFxQjRWLFlBQXJCO0FBQ0QsT0FSRCxDQVFFLE9BQU9wckIsQ0FBUCxFQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQUl1SixvQkFBb0IsQ0FBQ3ZKLENBQUQsQ0FBeEIsRUFBNkI7QUFDM0IsZ0JBQU1BLENBQU47QUFDRCxTQUxTLENBS1I7O0FBRUgsT0FmRCxTQWVVO0FBQ1I2cEIsUUFBQUEsTUFBTSxDQUFDd0IsY0FBUCxJQUF5QnhCLE1BQU0sQ0FBQ3dCLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0JwQyxJQUEvQixDQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRHFDLEVBQUFBLElBQUksQ0FBQyxHQUFHcmpCLElBQUosRUFBVTtBQUNaLFNBQUtnakIsZUFBTCxDQUFxQixNQUFyQixFQUE2QmpELGlCQUFpQixDQUFDeUIsb0JBQUQsRUFBdUIsR0FBR3hoQixJQUExQixDQUE5QztBQUNEOztBQUVEc2pCLEVBQUFBLElBQUksQ0FBQyxHQUFHdGpCLElBQUosRUFBVTtBQUNaLFNBQUtnakIsZUFBTCxDQUFxQixNQUFyQixFQUE2QmpELGlCQUFpQixDQUFDMEIsc0JBQUQsRUFBeUIsR0FBR3poQixJQUE1QixDQUE5QztBQUNEOztBQUVEckIsRUFBQUEsS0FBSyxDQUFDLEdBQUdxQixJQUFKLEVBQVU7QUFDYixTQUFLZ2pCLGVBQUwsQ0FBcUIsT0FBckIsRUFBOEJqRCxpQkFBaUIsQ0FBQzBCLHNCQUFELEVBQXlCLEdBQUd6aEIsSUFBNUIsQ0FBL0M7QUFDRDs7QUFFRHVqQixFQUFBQSxLQUFLLENBQUMsR0FBR3ZqQixJQUFKLEVBQVU7QUFDYixTQUFLZ2pCLGVBQUwsQ0FBcUIsT0FBckIsRUFBOEJqRCxpQkFBaUIsQ0FBQ3lCLG9CQUFELEVBQXVCLEdBQUd4aEIsSUFBMUIsQ0FBL0M7QUFDRDs7QUFFRDFILEVBQUFBLEtBQUssQ0FBQyxHQUFHMEgsSUFBSixFQUFVO0FBQ2IsU0FBS2dqQixlQUFMLENBQXFCLE9BQXJCLEVBQThCakQsaUJBQWlCLENBQUN5QixvQkFBRCxFQUF1QixHQUFHeGhCLElBQTFCLENBQS9DO0FBQ0Q7O0FBRUR3akIsRUFBQUEsS0FBSyxHQUFHLENBQUUsQ0FyR0UsQ0FxR0Q7OztBQUdYQyxFQUFBQSxLQUFLLENBQUMsR0FBR3RYLElBQUosRUFBVTtBQUNiLFFBQUlBLElBQUksQ0FBQ3ZTLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQixXQUFLMm5CLEdBQUwsQ0FBUyxHQUFHcFYsSUFBWjtBQUNEOztBQUVELFNBQUs0VyxZQUFMLElBQXFCLElBQXJCO0FBQ0Q7O0FBRURXLEVBQUFBLFFBQVEsR0FBRztBQUNULFNBQUtYLFlBQUwsR0FBb0IsS0FBS0EsWUFBTCxDQUFrQm5oQixLQUFsQixDQUF3QixDQUF4QixFQUEyQixLQUFLbWhCLFlBQUwsQ0FBa0JucEIsTUFBbEIsR0FBMkIsQ0FBdEQsQ0FBcEI7QUFDRDs7QUFFRCtwQixFQUFBQSxHQUFHLENBQUNucEIsR0FBRCxFQUFNMmEsT0FBTixFQUFlO0FBQ2hCLFNBQUs2TixlQUFMLENBQXFCLE1BQXJCLEVBQTZCL1MsT0FBTyxDQUFDelYsR0FBRCxFQUFNO0FBQ3hDMFksTUFBQUEsYUFBYSxFQUFFLEtBRHlCO0FBRXhDLFNBQUdpQyxPQUZxQyxFQUFOLENBQXBDOztBQUlEOztBQUVEcFcsRUFBQUEsTUFBTSxDQUFDcEksS0FBRCxFQUFRLEdBQUdxSixJQUFYLEVBQWlCO0FBQ3JCLFFBQUksQ0FBQ3JKLEtBQUwsRUFBWTtBQUNWcUosTUFBQUEsSUFBSSxDQUFDLENBQUQsQ0FBSixHQUFXLG1CQUFrQkEsSUFBSSxDQUFDcEcsTUFBTCxLQUFnQixDQUFoQixHQUFvQixFQUFwQixHQUEwQixLQUFJb0csSUFBSSxDQUFDLENBQUQsQ0FBSSxFQUFFLEVBQXJFO0FBQ0EsV0FBS3NqQixJQUFMLENBQVUsR0FBR3RqQixJQUFiLEVBRlUsQ0FFVTtBQUNyQjtBQUNGOztBQUVENGpCLEVBQUFBLEtBQUssQ0FBQ2xHLEtBQUssR0FBRyxTQUFULEVBQW9CO0FBQ3ZCO0FBQ0E7QUFDQUEsSUFBQUEsS0FBSyxHQUFJLEdBQUVBLEtBQU0sRUFBakI7O0FBRUEsUUFBSWtHLEtBQUssR0FBRyxLQUFLZCxPQUFMLENBQWFybkIsR0FBYixDQUFpQmlpQixLQUFqQixDQUFaOztBQUVBLFFBQUlrRyxLQUFLLEtBQUtsckIsU0FBZCxFQUF5QjtBQUN2QmtyQixNQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNELEtBRkQsTUFFTztBQUNMQSxNQUFBQSxLQUFLO0FBQ047O0FBRUQsU0FBS2QsT0FBTCxDQUFhcGpCLEdBQWIsQ0FBaUJnZSxLQUFqQixFQUF3QmtHLEtBQXhCOztBQUVBLFNBQUtyQyxHQUFMLENBQVUsR0FBRTdELEtBQU0sS0FBSWtHLEtBQU0sRUFBNUI7QUFDRDs7QUFFREMsRUFBQUEsVUFBVSxDQUFDbkcsS0FBSyxHQUFHLFNBQVQsRUFBb0I7QUFDNUIsUUFBSSxDQUFDLEtBQUtvRixPQUFMLENBQWF0ZCxHQUFiLENBQWlCa1ksS0FBakIsQ0FBTCxFQUE4QjtBQUM1QmxNLE1BQUFBLE9BQU8sQ0FBQ0MsV0FBUixDQUFxQixjQUFhaU0sS0FBTSxrQkFBeEM7QUFDQTtBQUNEOztBQUVELFNBQUtvRixPQUFMLENBQWFnQixNQUFiLENBQXFCLEdBQUVwRyxLQUFNLEVBQTdCO0FBQ0Q7O0FBRURxRyxFQUFBQSxJQUFJLENBQUNyRyxLQUFLLEdBQUcsU0FBVCxFQUFvQjtBQUN0QkEsSUFBQUEsS0FBSyxHQUFJLEdBQUVBLEtBQU0sRUFBakI7O0FBRUEsUUFBSSxLQUFLMEQsTUFBTCxDQUFZNWIsR0FBWixDQUFnQmtZLEtBQWhCLENBQUosRUFBNEI7QUFDMUJsTSxNQUFBQSxPQUFPLENBQUNDLFdBQVIsQ0FBcUIsU0FBUWlNLEtBQU0sa0JBQW5DO0FBQ0E7QUFDRDs7QUFFRCxTQUFLMEQsTUFBTCxDQUFZMWhCLEdBQVosQ0FBZ0JnZSxLQUFoQixFQUF1QjNMLElBQUksQ0FBQ3VQLEdBQUwsRUFBdkI7QUFDRDs7QUFFRDBDLEVBQUFBLE9BQU8sQ0FBQ3RHLEtBQUssR0FBRyxTQUFULEVBQW9CO0FBQ3pCLFVBQU11RyxNQUFNLEdBQUdoRCxPQUFPLENBQUMsSUFBRCxFQUFPdkQsS0FBUCxDQUF0Qjs7QUFFQSxRQUFJLENBQUN1RyxNQUFMLEVBQWE7QUFDWCxXQUFLN0MsTUFBTCxDQUFZMEMsTUFBWixDQUFtQnBHLEtBQW5CO0FBQ0Q7QUFDRjs7QUFFRHdHLEVBQUFBLE9BQU8sQ0FBQ3hHLEtBQUssR0FBRyxTQUFULEVBQW9CLEdBQUd3RCxPQUF2QixFQUFnQztBQUNyQ0QsSUFBQUEsT0FBTyxDQUFDLElBQUQsRUFBT3ZELEtBQVAsRUFBY3dELE9BQWQsQ0FBUDtBQUNELEdBbExXLENBa0xWOzs7QUFHRmlELEVBQUFBLEtBQUssR0FBRztBQUNOLFFBQUksQ0FBQ3pDLFdBQUwsRUFBa0I7QUFDaEJBLE1BQUFBLFdBQVcsR0FBRyxJQUFkO0FBQ0FsUSxNQUFBQSxPQUFPLENBQUNDLFdBQVIsQ0FBb0IscURBQXBCO0FBQ0Q7QUFDRixHQTFMVzs7OztBQThMZHdRLE9BQU8sQ0FBQzVtQixTQUFSLENBQWtCa21CLEdBQWxCLEdBQXdCVSxPQUFPLENBQUM1bUIsU0FBUixDQUFrQmdvQixJQUExQyxDLENBQWdEOztBQUVoRHBCLE9BQU8sQ0FBQzVtQixTQUFSLENBQWtCK29CLE1BQWxCLEdBQTJCbkMsT0FBTyxDQUFDNW1CLFNBQVIsQ0FBa0JrbUIsR0FBN0MsQyxDQUFrRDs7QUFFbERVLE9BQU8sQ0FBQzVtQixTQUFSLENBQWtCZ3BCLGNBQWxCLEdBQW1DcEMsT0FBTyxDQUFDNW1CLFNBQVIsQ0FBa0Jvb0IsS0FBckQ7QUFDQSxNQUFNYSxhQUFhLEdBQUcsSUFBSXJDLE9BQUosQ0FBWW5yQixFQUFFLENBQUN5dEIsR0FBZixDQUF0QjtBQUNBRCxhQUFhLENBQUNyQyxPQUFkLEdBQXdCQSxPQUF4QjtBQUNBMXJCLE1BQU0sQ0FBQ2l1QixPQUFQLEdBQWlCRixhQUFqQjs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDRXZTLEVBQUFBLElBQUksQ0FBQzFXLFNBQUwsQ0FBZW9wQixrQkFBZixHQUFvQyxZQUFZO0FBQzlDLFVBQU1DLFVBQVUsR0FBR0MsSUFBSSxDQUFDQyxjQUFMLENBQW9CQyw2QkFBcEIsQ0FBa0QxcUIsU0FBbEQsQ0FBbkI7O0FBRUEsVUFBTTJxQixhQUFhLEdBQUdydUIsTUFBTSxDQUFDMmUsTUFBUCxDQUFjO0FBQ2xDMlAsTUFBQUEsU0FBUyxFQUFFLE9BRHVCLEVBQWQ7QUFFbkJMLElBQUFBLFVBQVUsQ0FBQ3ZQLE9BRlEsQ0FBdEI7QUFHQSxVQUFNMEUsU0FBUyxHQUFHLElBQUk4SyxJQUFJLENBQUNDLGNBQVQsQ0FBd0JGLFVBQVUsQ0FBQ00sTUFBbkMsRUFBMkNGLGFBQTNDLENBQWxCO0FBQ0EsV0FBT2pMLFNBQVMsQ0FBQ3BaLE1BQVYsQ0FBaUIsSUFBakIsQ0FBUDtBQUNELEdBUkQ7O0FBVUFzUixFQUFBQSxJQUFJLENBQUMxVyxTQUFMLENBQWU0cEIsa0JBQWYsR0FBb0MsWUFBWTtBQUM5QyxVQUFNUCxVQUFVLEdBQUdDLElBQUksQ0FBQ0MsY0FBTCxDQUFvQkMsNkJBQXBCLENBQWtEMXFCLFNBQWxELENBQW5COztBQUVBLFVBQU0ycUIsYUFBYSxHQUFHcnVCLE1BQU0sQ0FBQzJlLE1BQVAsQ0FBYztBQUNsQzhQLE1BQUFBLFNBQVMsRUFBRSxPQUR1QixFQUFkO0FBRW5CUixJQUFBQSxVQUFVLENBQUN2UCxPQUZRLENBQXRCO0FBR0EsVUFBTTBFLFNBQVMsR0FBRyxJQUFJOEssSUFBSSxDQUFDQyxjQUFULENBQXdCRixVQUFVLENBQUNNLE1BQW5DLEVBQTJDRixhQUEzQyxDQUFsQjtBQUNBLFdBQU9qTCxTQUFTLENBQUNwWixNQUFWLENBQWlCLElBQWpCLENBQVA7QUFDRCxHQVJEOztBQVVBc1IsRUFBQUEsSUFBSSxDQUFDMVcsU0FBTCxDQUFlOHBCLGNBQWYsR0FBZ0NwVCxJQUFJLENBQUMxVyxTQUFMLENBQWVvcEIsa0JBQS9DO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLE9BQU94c0IsS0FBSyxDQUFDb0QsU0FBTixDQUFnQjZRLE1BQXZCLEtBQWtDLFVBQXRDLEVBQWtEO0FBQ2hEalUsRUFBQUEsS0FBSyxDQUFDb0QsU0FBTixDQUFnQjZRLE1BQWhCLEdBQXlCLFlBQVk7QUFDbkMsUUFBSXdZLFVBQVUsR0FBRyxFQUFqQjtBQUNBanVCLElBQUFBLE1BQU0sQ0FBQ21FLG1CQUFQLENBQTJCLElBQTNCLEVBQWlDZ0YsT0FBakMsQ0FBeUMsVUFBVS9ELElBQVYsRUFBZ0I7QUFDdkQ2b0IsTUFBQUEsVUFBVSxDQUFDN29CLElBQUQsQ0FBVixHQUFtQixLQUFLQSxJQUFMLENBQW5CO0FBQ0QsS0FGRCxFQUVHLElBRkg7QUFHQSxXQUFPNm9CLFVBQVA7QUFDRCxHQU5EO0FBT0Q7O0FBRUQ7Ozs7Ozs7QUFPQTs7QUFFQTs7Ozs7Ozs7O0FBU0EsU0FBU1Usa0NBQVQsQ0FBNENwbEIsSUFBNUMsRUFBa0RxbEIsOEJBQWxELEVBQWtGO0FBQ2hGLFFBQU1YLFVBQVUsR0FBRyxFQUFuQjs7QUFFQSxNQUFJMWtCLElBQUksQ0FBQ3BHLE1BQUwsSUFBZSxDQUFuQixFQUFzQjtBQUNwQixRQUFJLE9BQU9vRyxJQUFJLENBQUMsQ0FBRCxDQUFYLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CMGtCLE1BQUFBLFVBQVUsQ0FBQ00sTUFBWCxHQUFvQmhsQixJQUFJLENBQUMsQ0FBRCxDQUF4QjtBQUNELEtBRkQsTUFFTyxJQUFJM0csS0FBSyxDQUFDQyxPQUFOLENBQWMwRyxJQUFJLENBQUMsQ0FBRCxDQUFsQixDQUFKLEVBQTRCO0FBQ2pDLFlBQU1zbEIsZ0JBQWdCLEdBQUdELDhCQUE4QixDQUFDcmxCLElBQUksQ0FBQyxDQUFELENBQUwsQ0FBdkQ7O0FBRUEsVUFBSXNsQixnQkFBZ0IsQ0FBQzFyQixNQUFqQixHQUEwQixDQUE5QixFQUFpQztBQUMvQjhxQixRQUFBQSxVQUFVLENBQUNNLE1BQVgsR0FBb0JNLGdCQUFnQixDQUFDLENBQUQsQ0FBcEM7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSXRsQixJQUFJLENBQUNwRyxNQUFMLElBQWUsQ0FBZixJQUFvQixPQUFPb0csSUFBSSxDQUFDLENBQUQsQ0FBWCxLQUFtQixRQUEzQyxFQUFxRDtBQUNuRDBrQixJQUFBQSxVQUFVLENBQUN2UCxPQUFYLEdBQXFCblYsSUFBSSxDQUFDLENBQUQsQ0FBekI7QUFDRDs7QUFFRCxTQUFPMGtCLFVBQVA7QUFDRCxDLENBQUM7OztBQUdGO0FBQ0U7QUFDQSxXQUFTYSxVQUFULEdBQXNCO0FBQ3BCLFVBQU1iLFVBQVUsR0FBR1Usa0NBQWtDLENBQUNqckIsU0FBRCxFQUFZckQsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVUMsMkJBQXRCLENBQXJEO0FBQ0EsVUFBTUMsUUFBUSxHQUFHLElBQUk1dUIsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVUcsUUFBZCxDQUF1QmpCLFVBQXZCLENBQWpCO0FBQ0FnQixJQUFBQSxRQUFRLENBQUNoZSxPQUFULEdBQW1CZ2UsUUFBUSxDQUFDaGUsT0FBVCxDQUFpQmtlLElBQWpCLENBQXNCRixRQUF0QixDQUFuQjtBQUNBLFdBQU9BLFFBQVA7QUFDRDs7QUFFREgsRUFBQUEsVUFBVSxDQUFDTSxrQkFBWCxHQUFnQy91QixFQUFFLENBQUMwdUIsTUFBSCxDQUFVQywyQkFBMUMsQ0FURixDQVN5RTs7QUFFdkUsV0FBU0ssZ0JBQVQsR0FBNEI7QUFDMUIsVUFBTXBCLFVBQVUsR0FBR1Usa0NBQWtDLENBQUNqckIsU0FBRCxFQUFZckQsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVU8saUNBQXRCLENBQXJEO0FBQ0EsV0FBTyxJQUFJanZCLEVBQUUsQ0FBQzB1QixNQUFILENBQVVaLGNBQWQsQ0FBNkJGLFVBQTdCLENBQVA7QUFDRDs7QUFFRG9CLEVBQUFBLGdCQUFnQixDQUFDakIsNkJBQWpCLEdBQWlEN2tCLElBQUksSUFBSTtBQUN2RCxXQUFPb2xCLGtDQUFrQyxDQUFDcGxCLElBQUQsRUFBT2xKLEVBQUUsQ0FBQzB1QixNQUFILENBQVVPLGlDQUFqQixDQUF6QztBQUNELEdBRkQ7O0FBSUFELEVBQUFBLGdCQUFnQixDQUFDRCxrQkFBakIsR0FBc0MvdUIsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVU8saUNBQWhELENBcEJGLENBb0JxRjs7QUFFbkYsV0FBU0MsY0FBVCxHQUEwQjtBQUN4QixVQUFNdEIsVUFBVSxHQUFHVSxrQ0FBa0MsQ0FBQ2pyQixTQUFELEVBQVlyRCxFQUFFLENBQUMwdUIsTUFBSCxDQUFVUywrQkFBdEIsQ0FBckQ7QUFDQSxXQUFPLElBQUludkIsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVVUsWUFBZCxDQUEyQnhCLFVBQTNCLENBQVA7QUFDRDs7QUFFRHNCLEVBQUFBLGNBQWMsQ0FBQ0gsa0JBQWYsR0FBb0MvdUIsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVVMsK0JBQTlDLENBM0JGLENBMkJpRjs7QUFFL0U3dkIsRUFBQUEsY0FBYyxDQUFDdXVCLElBQWYsR0FBc0I7QUFDcEJnQixJQUFBQSxRQUFRLEVBQUVKLFVBRFU7QUFFcEJYLElBQUFBLGNBQWMsRUFBRWtCLGdCQUZJO0FBR3BCSSxJQUFBQSxZQUFZLEVBQUVGLGNBSE07QUFJcEJHLElBQUFBLG1CQUFtQixFQUFFcnZCLEVBQUUsQ0FBQzB1QixNQUFILENBQVVXLG1CQUpYLEVBQXRCOztBQU1EOztBQUVEOzs7Ozs7O0FBT0E7QUFDQTtBQUNFaGtCLEVBQUFBLE1BQU0sQ0FBQzlHLFNBQVAsQ0FBaUI4cEIsY0FBakIsR0FBa0MsWUFBWTtBQUM1QyxVQUFNdEwsU0FBUyxHQUFHLElBQUk4SyxJQUFJLENBQUN1QixZQUFULENBQXNCLEdBQUcvckIsU0FBekIsQ0FBbEI7QUFDQSxXQUFPMGYsU0FBUyxDQUFDcFosTUFBVixDQUFpQixLQUFLMmIsT0FBTCxFQUFqQixDQUFQO0FBQ0QsR0FIRDtBQUlEOztBQUVEOzs7Ozs7O0FBT0E7QUFDQTtBQUNFemEsRUFBQUEsTUFBTSxDQUFDdEcsU0FBUCxDQUFpQitxQixhQUFqQixHQUFpQyxVQUFVQyxhQUFWLEVBQXlCQyxPQUF6QixFQUFrQ25SLE9BQWxDLEVBQTJDO0FBQzFFLFVBQU11USxRQUFRLEdBQUcsSUFBSWYsSUFBSSxDQUFDZ0IsUUFBVCxDQUFrQlcsT0FBbEIsRUFBMkJuUixPQUEzQixDQUFqQjtBQUNBLFdBQU91USxRQUFRLENBQUNoZSxPQUFULENBQWlCLElBQWpCLEVBQXVCMmUsYUFBdkIsQ0FBUDtBQUNELEdBSEQ7O0FBS0Exa0IsRUFBQUEsTUFBTSxDQUFDdEcsU0FBUCxDQUFpQmtyQixpQkFBakIsR0FBcUMsVUFBVXZCLE1BQVYsRUFBa0I7QUFDckQsV0FBT2x1QixFQUFFLENBQUMwdUIsTUFBSCxDQUFVZ0IsYUFBVixDQUF3QixJQUF4QixFQUE4QnhCLE1BQTlCLENBQVA7QUFDRCxHQUZEOztBQUlBcmpCLEVBQUFBLE1BQU0sQ0FBQ3RHLFNBQVAsQ0FBaUJvckIsaUJBQWpCLEdBQXFDLFVBQVV6QixNQUFWLEVBQWtCO0FBQ3JELFdBQU9sdUIsRUFBRSxDQUFDMHVCLE1BQUgsQ0FBVWtCLGFBQVYsQ0FBd0IsSUFBeEIsRUFBOEIxQixNQUE5QixDQUFQO0FBQ0QsR0FGRDtBQUdEOztBQUVEOzs7Ozs7Ozs7QUFTQTs7OztBQUlBLE1BQU0yQixRQUFRLEdBQUcsSUFBSXhuQixHQUFKLEVBQWpCO0FBQ0E7Ozs7O0FBS0EsTUFBTXluQixTQUFTLEdBQUcsSUFBSXpuQixHQUFKLEVBQWxCO0FBQ0E7Ozs7OztBQU1BLFNBQVMwbkIsb0JBQVQsQ0FBOEJDLElBQTlCLEVBQW9DO0FBQ2xDLE1BQUksQ0FBQ0EsSUFBRCxJQUFTQSxJQUFJLENBQUNsdEIsTUFBTCxHQUFjLENBQTNCLEVBQThCO0FBQzVCLFdBQU8sS0FBUDtBQUNEOztBQUVELFFBQU1tdEIsU0FBUyxHQUFHRCxJQUFJLENBQUM5WCxNQUFMLENBQVksQ0FBWixDQUFsQjtBQUNBLFNBQU8rWCxTQUFTLEtBQUssR0FBZCxJQUFxQkEsU0FBUyxLQUFLLEdBQTFDO0FBQ0QsQyxDQUFDOzs7QUFHRixNQUFNQyxlQUFlLEdBQUd6d0IsTUFBTSxDQUFDMHdCLE9BQS9CLEMsQ0FBd0M7O0FBRXhDMXdCLE1BQU0sQ0FBQzB3QixPQUFQLEdBQWlCLFVBQVVDLFFBQVYsRUFBb0I7QUFDbkMsTUFBSVAsUUFBUSxDQUFDbmhCLEdBQVQsQ0FBYTBoQixRQUFiLENBQUosRUFBNEI7QUFDMUIsV0FBT1AsUUFBUSxDQUFDbHJCLEdBQVQsQ0FBYXlyQixRQUFiLENBQVA7QUFDRDs7QUFFRCxNQUFJTixTQUFTLENBQUNwaEIsR0FBVixDQUFjMGhCLFFBQWQsQ0FBSixFQUE2QjtBQUMzQkEsSUFBQUEsUUFBUSxHQUFHTixTQUFTLENBQUNuckIsR0FBVixDQUFjeXJCLFFBQWQsQ0FBWDtBQUNEOztBQUVELFNBQU9GLGVBQWUsQ0FBQ0UsUUFBRCxDQUF0QjtBQUNELENBVkQ7O0FBWUE7QUFDRTtBQUNBLFFBQU1DLHFCQUFxQixHQUFHNXdCLE1BQU0sQ0FBQzZ3QixNQUFQLENBQWMvckIsU0FBZCxDQUF3QjRyQixPQUF0RDs7QUFFQTF3QixFQUFBQSxNQUFNLENBQUM2d0IsTUFBUCxDQUFjL3JCLFNBQWQsQ0FBd0I0ckIsT0FBeEIsR0FBa0MsVUFBVUgsSUFBVixFQUFnQnhOLE9BQWhCLEVBQXlCO0FBQ3pELFFBQUlxTixRQUFRLENBQUNuaEIsR0FBVCxDQUFhc2hCLElBQWIsQ0FBSixFQUF3QjtBQUN0QixhQUFPSCxRQUFRLENBQUNsckIsR0FBVCxDQUFhcXJCLElBQWIsQ0FBUDtBQUNEOztBQUVELFFBQUlGLFNBQVMsQ0FBQ3BoQixHQUFWLENBQWNzaEIsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCQSxNQUFBQSxJQUFJLEdBQUdGLFNBQVMsQ0FBQ25yQixHQUFWLENBQWNxckIsSUFBZCxDQUFQO0FBQ0Q7O0FBRUQsV0FBT0sscUJBQXFCLENBQUNsdEIsSUFBdEIsQ0FBMkIsSUFBM0IsRUFBaUM2c0IsSUFBakMsRUFBdUN4TixPQUF2QyxDQUFQO0FBQ0QsR0FWRDtBQVdEO0FBQ0Q7Ozs7Ozs7O0FBUUEsU0FBUytOLFFBQVQsQ0FBa0JILFFBQWxCLEVBQTRCSSxPQUE1QixFQUFxQztBQUNuQyxNQUFJLENBQUNULG9CQUFvQixDQUFDSyxRQUFELENBQXpCLEVBQXFDO0FBQ25DLFVBQU0sSUFBSWp2QixLQUFKLENBQVcsOEZBQTZGaXZCLFFBQVMsR0FBakgsQ0FBTjtBQUNEOztBQUVELE1BQUlOLFNBQVMsQ0FBQ3BoQixHQUFWLENBQWMwaEIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCcHdCLElBQUFBLEVBQUUsQ0FBQ3l0QixHQUFILENBQU9qQixJQUFQLENBQWEsMERBQXlENEQsUUFBUyw4QkFBL0U7QUFDQU4sSUFBQUEsU0FBUyxDQUFDOUMsTUFBVixDQUFpQm9ELFFBQWpCO0FBQ0QsR0FIRCxNQUdPLElBQUlQLFFBQVEsQ0FBQ25oQixHQUFULENBQWEwaEIsUUFBYixDQUFKLEVBQTRCO0FBQ2pDcHdCLElBQUFBLEVBQUUsQ0FBQ3l0QixHQUFILENBQU9qQixJQUFQLENBQWEsMERBQXlENEQsUUFBUyw4QkFBL0U7QUFDRDs7QUFFRFAsRUFBQUEsUUFBUSxDQUFDam5CLEdBQVQsQ0FBYXduQixRQUFiLEVBQXVCSSxPQUF2QjtBQUNEO0FBQ0Q7Ozs7Ozs7Ozs7QUFVQSxTQUFTQyxRQUFULENBQWtCTCxRQUFsQixFQUE0Qk0sUUFBNUIsRUFBc0M7QUFDcEMsTUFBSSxDQUFDWCxvQkFBb0IsQ0FBQ0ssUUFBRCxDQUF6QixFQUFxQztBQUNuQyxVQUFNLElBQUlqdkIsS0FBSixDQUFXLDhGQUE2Rml2QixRQUFTLEdBQWpILENBQU47QUFDRDs7QUFFRCxNQUFJUCxRQUFRLENBQUNuaEIsR0FBVCxDQUFhMGhCLFFBQWIsQ0FBSixFQUE0QjtBQUMxQnB3QixJQUFBQSxFQUFFLENBQUN5dEIsR0FBSCxDQUFPakIsSUFBUCxDQUFhLDBEQUF5RDRELFFBQVMsOEJBQS9FO0FBQ0FQLElBQUFBLFFBQVEsQ0FBQzdDLE1BQVQsQ0FBZ0JvRCxRQUFoQjtBQUNELEdBSEQsTUFHTyxJQUFJTixTQUFTLENBQUNwaEIsR0FBVixDQUFjMGhCLFFBQWQsQ0FBSixFQUE2QjtBQUNsQ3B3QixJQUFBQSxFQUFFLENBQUN5dEIsR0FBSCxDQUFPakIsSUFBUCxDQUFhLDBEQUF5RDRELFFBQVMsOEJBQS9FO0FBQ0Q7O0FBRUROLEVBQUFBLFNBQVMsQ0FBQ2xuQixHQUFWLENBQWN3bkIsUUFBZCxFQUF3Qk0sUUFBeEI7QUFDRDtBQUNELE1BQU1GLE9BQU8sR0FBRztBQUNkRCxFQUFBQSxRQURjO0FBRWRFLEVBQUFBLFFBRmMsRUFBaEI7O0FBSUFoeEIsTUFBTSxDQUFDK3dCLE9BQVAsR0FBaUJBLE9BQWpCOztBQUVBO0FBQ0FELFFBQVEsQ0FBQyxTQUFELEVBQVkvQyxhQUFaLENBQVI7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNBLE1BQU0zZ0IsTUFBTSxHQUFHN00sRUFBRSxDQUFDaU4sWUFBSCxDQUFnQjtBQUM3QnBOLEVBQUFBLEtBQUssRUFBRSxFQURzQixFQUFoQixDQUFmOztBQUdBLE1BQU11TSxJQUFJLEdBQUdTLE1BQU0sQ0FBQzBJLE1BQVAsRUFBYjtBQUNBOzs7QUFHQW5KLElBQUksQ0FBQ3pGLFdBQUwsQ0FBaUJwQyxTQUFqQixDQUEyQm9zQixXQUEzQixHQUF5QyxZQUFZO0FBQ25ELFNBQU8sSUFBSUMsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0QyxRQUFJbmlCLEdBQUo7O0FBRUEsUUFBSTtBQUNGQSxNQUFBQSxHQUFHLEdBQUcsS0FBSzZCLGFBQUwsRUFBTjtBQUNELEtBRkQsQ0FFRSxPQUFPalAsR0FBUCxFQUFZO0FBQ1osYUFBT3V2QixNQUFNLENBQUN2dkIsR0FBRCxDQUFiO0FBQ0Q7O0FBRURzdkIsSUFBQUEsT0FBTyxDQUFDbGlCLEdBQUQsQ0FBUDtBQUNELEdBVk0sQ0FBUDtBQVdELENBWkQ7O0FBY0E7Ozs7O0FBS0EsTUFBTW9pQixXQUFXLEdBQUcsa0NBQXBCLEMsQ0FBd0Q7O0FBRXhELE1BQU1DLFdBQVcsR0FBRywyQ0FBcEIsQyxDQUFpRTs7QUFFakUsTUFBTUMsV0FBVyxHQUFHLG1CQUFwQixDLENBQXlDOztBQUV6QyxNQUFNQyxXQUFXLEdBQUcsbUJBQXBCLEMsQ0FBeUM7O0FBRXpDOzs7OztBQUtBLFNBQVNDLFNBQVQsQ0FBbUJDLE9BQW5CLEVBQTRCO0FBQzFCLFFBQU10d0IsR0FBRyxHQUFHc3dCLE9BQU8sQ0FBQ3BzQixRQUFSLENBQWlCLEVBQWpCLENBQVo7O0FBRUEsTUFBSWxFLEdBQUcsQ0FBQ2dDLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixXQUFRLElBQUdoQyxHQUFJLEVBQWY7QUFDRDs7QUFFRCxTQUFPQSxHQUFQO0FBQ0Q7O0FBRUQsTUFBTXV3QixLQUFOLENBQVk7QUFDVjs7Ozs7O0FBTUExcUIsRUFBQUEsV0FBVyxDQUFDMnFCLENBQUQsRUFBSUMsQ0FBSixFQUFPQyxDQUFQLEVBQVVqSSxDQUFDLEdBQUcsR0FBZCxFQUFtQjtBQUM1QixTQUFLK0gsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsU0FBS0MsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsU0FBS0MsQ0FBTCxHQUFTQSxDQUFUO0FBQ0EsU0FBS0MsS0FBTCxHQUFhbEksQ0FBYjtBQUNEO0FBQ0Q7Ozs7OztBQU1BbUksRUFBQUEsUUFBUSxHQUFHO0FBQ1QsV0FBTyxLQUFLRCxLQUFMLEtBQWUsR0FBdEI7QUFDRDtBQUNEOzs7Ozs7QUFNQUUsRUFBQUEsUUFBUSxHQUFHO0FBQ1Q7QUFDQSxXQUFPUixTQUFTLENBQUM5ZixJQUFJLENBQUNvVyxLQUFMLENBQVcsS0FBS2dLLEtBQUwsR0FBYSxLQUF4QixDQUFELENBQWhCO0FBQ0Q7QUFDRDs7Ozs7O0FBTUFHLEVBQUFBLGVBQWUsR0FBRztBQUNoQixXQUFRLEdBQUVULFNBQVMsQ0FBQyxLQUFLRyxDQUFOLENBQVMsR0FBRUgsU0FBUyxDQUFDLEtBQUtJLENBQU4sQ0FBUyxHQUFFSixTQUFTLENBQUMsS0FBS0ssQ0FBTixDQUFTLEVBQXBFO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFRQUssRUFBQUEsZUFBZSxHQUFHO0FBQ2hCLFFBQUksS0FBS0gsUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGFBQVEsSUFBRyxLQUFLRSxlQUFMLEVBQXVCLEVBQWxDO0FBQ0Q7O0FBRUQsV0FBUSxJQUFHLEtBQUtBLGVBQUwsRUFBdUIsR0FBRSxLQUFLRCxRQUFMLEVBQWdCLEVBQXBEO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFRQUcsRUFBQUEsZUFBZSxHQUFHO0FBQ2hCLFFBQUksS0FBS0osUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGFBQVEsSUFBRyxLQUFLRSxlQUFMLEVBQXVCLEVBQWxDO0FBQ0Q7O0FBRUQsV0FBUSxJQUFHLEtBQUtELFFBQUwsRUFBZ0IsR0FBRSxLQUFLQyxlQUFMLEVBQXVCLEVBQXBEO0FBQ0Q7QUFDRDs7Ozs7O0FBTUFHLEVBQUFBLEtBQUssR0FBRztBQUNOLFdBQU8sS0FBS0QsZUFBTCxFQUFQO0FBQ0Q7QUFDRDs7Ozs7OztBQU9BRSxFQUFBQSxZQUFZLEdBQUc7QUFDYixXQUFRLFFBQU8sS0FBS1YsQ0FBRSxLQUFJLEtBQUtDLENBQUUsS0FBSSxLQUFLQyxDQUFFLEtBQUksS0FBS0MsS0FBTCxDQUFXUSxPQUFYLENBQW1CLENBQW5CLENBQXNCLEdBQXRFO0FBQ0Q7QUFDRDs7Ozs7QUFLQSxTQUFPaFIsUUFBUCxHQUFrQjtBQUNoQixXQUFPLElBQUlvUSxLQUFKLENBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsQ0FBUCxDQURnQixDQUNXO0FBQzVCO0FBQ0Q7Ozs7Ozs7O0FBUUEsU0FBT2EsY0FBUCxDQUFzQnBjLEdBQXRCLEVBQTJCMmIsS0FBM0IsRUFBa0M7QUFDaEMsVUFBTVUsVUFBVSxHQUFHcmMsR0FBRyxDQUFDN0wsVUFBSixDQUFlLEdBQWYsSUFBc0IsQ0FBdEIsR0FBMEIsQ0FBN0M7QUFDQSxVQUFNcW5CLENBQUMsR0FBR25tQixRQUFRLENBQUMySyxHQUFHLENBQUMxSyxNQUFKLENBQVcrbUIsVUFBWCxFQUF1QixDQUF2QixDQUFELEVBQTRCLEVBQTVCLENBQWxCO0FBQ0EsVUFBTVosQ0FBQyxHQUFHcG1CLFFBQVEsQ0FBQzJLLEdBQUcsQ0FBQzFLLE1BQUosQ0FBVyttQixVQUFVLEdBQUcsQ0FBeEIsRUFBMkIsQ0FBM0IsQ0FBRCxFQUFnQyxFQUFoQyxDQUFsQjtBQUNBLFVBQU1YLENBQUMsR0FBR3JtQixRQUFRLENBQUMySyxHQUFHLENBQUMxSyxNQUFKLENBQVcrbUIsVUFBVSxHQUFHLENBQXhCLEVBQTJCLENBQTNCLENBQUQsRUFBZ0MsRUFBaEMsQ0FBbEI7QUFDQSxXQUFPLElBQUlkLEtBQUosQ0FBVUMsQ0FBVixFQUFhQyxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQkMsS0FBbkIsQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQSxTQUFPVyxjQUFQLENBQXNCdGMsR0FBdEIsRUFBMkI7QUFDekIsVUFBTXFjLFVBQVUsR0FBR3JjLEdBQUcsQ0FBQzdMLFVBQUosQ0FBZSxHQUFmLElBQXNCLENBQXRCLEdBQTBCLENBQTdDO0FBQ0EsVUFBTXduQixLQUFLLEdBQUd0bUIsUUFBUSxDQUFDMkssR0FBRyxDQUFDMUssTUFBSixDQUFXK21CLFVBQVgsRUFBdUIsQ0FBdkIsQ0FBRCxFQUE0QixFQUE1QixDQUF0QixDQUZ5QixDQUU4Qjs7QUFFdkQsVUFBTWIsQ0FBQyxHQUFHbm1CLFFBQVEsQ0FBQzJLLEdBQUcsQ0FBQzFLLE1BQUosQ0FBVyttQixVQUFVLEdBQUcsQ0FBeEIsRUFBMkIsQ0FBM0IsQ0FBRCxFQUFnQyxFQUFoQyxDQUFsQjtBQUNBLFVBQU1aLENBQUMsR0FBR3BtQixRQUFRLENBQUMySyxHQUFHLENBQUMxSyxNQUFKLENBQVcrbUIsVUFBVSxHQUFHLENBQXhCLEVBQTJCLENBQTNCLENBQUQsRUFBZ0MsRUFBaEMsQ0FBbEI7QUFDQSxVQUFNWCxDQUFDLEdBQUdybUIsUUFBUSxDQUFDMkssR0FBRyxDQUFDMUssTUFBSixDQUFXK21CLFVBQVUsR0FBRyxDQUF4QixFQUEyQixDQUEzQixDQUFELEVBQWdDLEVBQWhDLENBQWxCO0FBQ0EsV0FBTyxJQUFJZCxLQUFKLENBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQkMsQ0FBaEIsRUFBbUJDLEtBQUssR0FBRyxLQUEzQixDQUFQLENBUHlCLENBT2lCO0FBQzNDO0FBQ0Q7Ozs7Ozs7Ozs7QUFVQSxTQUFPWSx1QkFBUCxDQUErQkMsS0FBL0IsRUFBc0M7QUFDcEMsUUFBSTdSLEtBQUssR0FBRzZSLEtBQVo7QUFDQSxRQUFJYixLQUFLLEdBQUcsR0FBWjtBQUNBLFFBQUljLFFBQVEsR0FBRyxLQUFmOztBQUVBLFFBQUk1eUIsTUFBTSxDQUFDNEUsU0FBUCxDQUFpQnNYLGNBQWpCLENBQWdDMVksSUFBaEMsQ0FBcUNtdkIsS0FBckMsRUFBNEMsT0FBNUMsQ0FBSixFQUEwRDtBQUN4RGIsTUFBQUEsS0FBSyxHQUFHeEgsVUFBVSxDQUFDcUksS0FBSyxDQUFDYixLQUFQLENBQVYsR0FBMEIsS0FBbEMsQ0FEd0QsQ0FDZjs7QUFFekNjLE1BQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0E5UixNQUFBQSxLQUFLLEdBQUc2UixLQUFLLENBQUM3UixLQUFkLENBSndELENBSW5DO0FBQ3RCLEtBVm1DLENBVWxDOzs7QUFHRixRQUFJQSxLQUFLLENBQUMzZCxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCO0FBQ0EyZCxNQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQzFmLE9BQU4sQ0FBY2d3QixXQUFkLEVBQTJCLENBQUN5QixDQUFELEVBQUlsQixDQUFKLEVBQU9DLENBQVAsRUFBVUMsQ0FBVixLQUFnQkYsQ0FBQyxHQUFHQSxDQUFKLEdBQVFDLENBQVIsR0FBWUEsQ0FBWixHQUFnQkMsQ0FBaEIsR0FBb0JBLENBQS9ELENBQVI7QUFDRCxLQUhELE1BR08sSUFBSS9RLEtBQUssQ0FBQzNkLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7QUFDN0I7QUFDQTJkLE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDMWYsT0FBTixDQUFjaXdCLFdBQWQsRUFBMkIsQ0FBQ3dCLENBQUQsRUFBSWpKLENBQUosRUFBTytILENBQVAsRUFBVUMsQ0FBVixFQUFhQyxDQUFiLEtBQW1CakksQ0FBQyxHQUFHQSxDQUFKLEdBQVErSCxDQUFSLEdBQVlBLENBQVosR0FBZ0JDLENBQWhCLEdBQW9CQSxDQUFwQixHQUF3QkMsQ0FBeEIsR0FBNEJBLENBQTFFLENBQVI7QUFDRDs7QUFFRCxRQUFJUCxXQUFXLENBQUM1SyxJQUFaLENBQWlCNUYsS0FBakIsQ0FBSixFQUE2QjtBQUMzQixhQUFPNFEsS0FBSyxDQUFDYSxjQUFOLENBQXFCelIsS0FBckIsRUFBNEJnUixLQUE1QixDQUFQO0FBQ0Q7O0FBRUQsUUFBSVAsV0FBVyxDQUFDN0ssSUFBWixDQUFpQjVGLEtBQWpCLENBQUosRUFBNkI7QUFDM0IsVUFBSThSLFFBQUosRUFBYztBQUNaLGNBQU0sSUFBSXB4QixLQUFKLENBQVcsU0FBUW14QixLQUFNLHNGQUF6QixDQUFOO0FBQ0Q7O0FBRUQsYUFBT2pCLEtBQUssQ0FBQ2UsY0FBTixDQUFxQjNSLEtBQXJCLENBQVA7QUFDRCxLQS9CbUMsQ0ErQmxDOzs7QUFHRixXQUFPNFEsS0FBSyxDQUFDcFEsUUFBTixFQUFQO0FBQ0QsR0E5S1M7Ozs7QUFrTFosSUFBSVIsS0FBSyxHQUFHNFEsS0FBWjs7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBOztBQUVBLE1BQU1vQixFQUFFLEdBQUlDLEtBQUssQ0FBQ2xDLE9BQU4sQ0FBYyxVQUFkLEVBQTBCbUMsUUFBMUIsQ0FBbUNGLEVBQS9DLEMsQ0FBb0Q7QUFDcEQ7O0FBRUE5eUIsTUFBTSxDQUFDeUosY0FBUCxDQUFzQnFwQixFQUF0QixFQUEwQiwyQkFBMUIsRUFBdUQ7QUFDckQ1eUIsRUFBQUEsS0FBSyxFQUFFLE9BRDhDO0FBRXJEQyxFQUFBQSxRQUFRLEVBQUUsS0FGMkMsRUFBdkQ7O0FBSUFILE1BQU0sQ0FBQ3lKLGNBQVAsQ0FBc0JxcEIsRUFBdEIsRUFBMEIsMEJBQTFCLEVBQXNEO0FBQ3BENXlCLEVBQUFBLEtBQUssRUFBRSxNQUQ2QztBQUVwREMsRUFBQUEsUUFBUSxFQUFFLEtBRjBDLEVBQXREOztBQUlBSCxNQUFNLENBQUN5SixjQUFQLENBQXNCcXBCLEVBQXRCLEVBQTBCLG1CQUExQixFQUErQztBQUM3Qzl0QixFQUFBQSxHQUFHLEVBQUUsTUFBTTtBQUNUO0FBQ0E7QUFDQSxRQUFJM0UsRUFBRSxDQUFDeXlCLEVBQUgsQ0FBTUcsa0JBQU4sS0FBNkI1eUIsRUFBRSxDQUFDeXlCLEVBQUgsQ0FBTUkseUJBQXZDLEVBQWtFO0FBQ2hFLGFBQU9KLEVBQUUsQ0FBQ0ssd0JBQVY7QUFDRDs7QUFFRCxXQUFPTCxFQUFFLENBQUNNLHlCQUFWO0FBQ0QsR0FUNEMsRUFBL0M7QUFVSTtBQUNKOztBQUVBOztBQUVFLE1BQUlDLFFBQUo7O0FBRUFQLEVBQUFBLEVBQUUsQ0FBQ1Esa0JBQUgsR0FBd0IsU0FBU0Esa0JBQVQsQ0FBNEJDLFNBQTVCLEVBQXVDO0FBQzdELFFBQUksQ0FBQ0YsUUFBTCxFQUFlO0FBQ2IsVUFBSTtBQUNGLGNBQU1HLFlBQVksR0FBR256QixFQUFFLENBQUMrbEIsVUFBSCxDQUFjcU4sT0FBZCxDQUFzQnB6QixFQUFFLENBQUMrbEIsVUFBSCxDQUFjQyxrQkFBcEMsRUFBd0Qsc0JBQXhELENBQXJCOztBQUVBLFlBQUltTixZQUFZLENBQUNFLE1BQWIsRUFBSixFQUEyQjtBQUN6QkwsVUFBQUEsUUFBUSxHQUFHM0osSUFBSSxDQUFDaUssS0FBTCxDQUFXSCxZQUFZLENBQUNJLElBQWIsR0FBb0JDLElBQS9CLENBQVg7QUFDRDtBQUNGLE9BTkQsQ0FNRSxPQUFPM3JCLEtBQVAsRUFBYztBQUNkO0FBQ0E2bEIsUUFBQUEsT0FBTyxDQUFDN2xCLEtBQVIsQ0FBYyxxREFBZDtBQUNBLGVBQU80WSxLQUFLLENBQUNRLFFBQU4sR0FBaUI4USxLQUFqQixFQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJO0FBQ0YsVUFBSSxDQUFDaUIsUUFBUSxDQUFDRSxTQUFELENBQWIsRUFBMEI7QUFDeEIsWUFBSSxJQUFKLEVBQVU7QUFDUjtBQUNBLGdCQUFNTyxhQUFhLEdBQUd6ekIsRUFBRSxDQUFDMHpCLE9BQUgsQ0FBV0MsQ0FBWCxDQUFhbFQsS0FBYixDQUFtQnlTLFNBQW5CLENBQXRCOztBQUVBLGNBQUlPLGFBQUosRUFBbUI7QUFDakIsa0JBQU1HLGFBQWEsR0FBRzV6QixFQUFFLENBQUN5eUIsRUFBSCxDQUFNaUIsT0FBTixDQUFjRyxnQkFBZCxDQUErQkosYUFBL0IsQ0FBdEI7O0FBRUEsZ0JBQUlHLGFBQUosRUFBbUI7QUFDakIscUJBQU9BLGFBQWEsQ0FBQzdCLEtBQWQsRUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxlQUFPdFIsS0FBSyxDQUFDUSxRQUFOLEdBQWlCOFEsS0FBakIsRUFBUDtBQUNEOztBQUVELFlBQU1PLEtBQUssR0FBR1UsUUFBUSxDQUFDRSxTQUFELENBQVIsQ0FBb0JULEVBQUUsQ0FBQ3FCLGlCQUF2QixDQUFkO0FBQ0EsWUFBTUMsUUFBUSxHQUFHdFQsS0FBSyxDQUFDNFIsdUJBQU4sQ0FBOEJDLEtBQTlCLENBQWpCLENBbkJFLENBbUJxRDtBQUN2RDtBQUNBOztBQUVBLGFBQU95QixRQUFRLENBQUMvQixZQUFULEVBQVAsQ0F2QkUsQ0F1QjhCO0FBQ2pDLEtBeEJELENBd0JFLE9BQU9ucUIsS0FBUCxFQUFjO0FBQ2Q2bEIsTUFBQUEsT0FBTyxDQUFDN2xCLEtBQVIsQ0FBZSw4QkFBNkJxckIsU0FBVSxFQUF0RDtBQUNEOztBQUVELFdBQU96UyxLQUFLLENBQUNRLFFBQU4sR0FBaUI4USxLQUFqQixFQUFQO0FBQ0QsR0E1Q0Q7QUE2Q0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTaUMsWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0JDLFNBQS9CLEVBQTBDQyxRQUExQyxFQUFvREMsT0FBcEQsRUFBNkQ7QUFDM0QsTUFBSSxDQUFDSCxPQUFPLENBQUNJLGtCQUFiLEVBQWlDO0FBQy9CO0FBQ0FKLElBQUFBLE9BQU8sQ0FBQ0ksa0JBQVIsR0FBNkIsRUFBN0IsQ0FGK0IsQ0FFRTtBQUNsQyxHQUowRCxDQUl6RDs7O0FBR0YsTUFBSUosT0FBTyxDQUFDSSxrQkFBUixDQUEyQkMsV0FBL0IsRUFBNEM7QUFDMUNMLElBQUFBLE9BQU8sQ0FBQ00sSUFBUixDQUFhLGFBQWIsRUFBNEJMLFNBQTVCLEVBQXVDQyxRQUF2QztBQUNEOztBQUVELFFBQU1LLGNBQWMsR0FBR1AsT0FBTyxDQUFDSSxrQkFBUixDQUEyQkgsU0FBM0IsS0FBeUMsRUFBaEU7O0FBRUEsTUFBSUUsT0FBSixFQUFhO0FBQ1hJLElBQUFBLGNBQWMsQ0FBQzlxQixPQUFmLENBQXVCeXFCLFFBQXZCO0FBQ0QsR0FGRCxNQUVPO0FBQ0xLLElBQUFBLGNBQWMsQ0FBQ255QixJQUFmLENBQW9COHhCLFFBQXBCO0FBQ0Q7O0FBRURGLEVBQUFBLE9BQU8sQ0FBQ0ksa0JBQVIsQ0FBMkJILFNBQTNCLElBQXdDTSxjQUF4QyxDQW5CMkQsQ0FtQkg7O0FBRXhELFFBQU01YixHQUFHLEdBQUdxYixPQUFPLENBQUNRLGVBQVIsRUFBWjtBQUNBLFFBQU0zeEIsTUFBTSxHQUFHMHhCLGNBQWMsQ0FBQzF4QixNQUE5Qjs7QUFFQSxNQUFJOFYsR0FBRyxHQUFHLENBQU4sSUFBVzlWLE1BQU0sR0FBRzhWLEdBQXhCLEVBQTZCO0FBQzNCLFVBQU04YixDQUFDLEdBQUcsSUFBSXZ6QixLQUFKLENBQVcsK0NBQThDMkIsTUFBTyxJQUFHb3hCLFNBQVUsbUVBQTdFLENBQVY7QUFDQVEsSUFBQUEsQ0FBQyxDQUFDM3ZCLElBQUYsR0FBUyw2QkFBVDtBQUNBMnZCLElBQUFBLENBQUMsQ0FBQ1QsT0FBRixHQUFZQSxPQUFaO0FBQ0FTLElBQUFBLENBQUMsQ0FBQ3RxQixJQUFGLEdBQVM4cEIsU0FBVDtBQUNBUSxJQUFBQSxDQUFDLENBQUM1SCxLQUFGLEdBQVVocUIsTUFBVjtBQUNBNFgsSUFBQUEsT0FBTyxDQUFDQyxXQUFSLENBQW9CK1osQ0FBcEI7QUFDRDs7QUFFRCxTQUFPVCxPQUFQO0FBQ0Q7O0FBRUQsU0FBU1UsUUFBVCxDQUFrQlYsT0FBbEIsRUFBMkJDLFNBQTNCLEVBQXNDQyxRQUF0QyxFQUFnRDtBQUM5QyxXQUFTUyxPQUFULENBQWlCLEdBQUcxckIsSUFBcEIsRUFBMEI7QUFDeEIsU0FBSytxQixPQUFMLENBQWEzSCxjQUFiLENBQTRCLEtBQUs0SCxTQUFqQyxFQUE0QyxLQUFLVyxXQUFqRCxFQUR3QixDQUN1Qzs7QUFFL0QsU0FBS1YsUUFBTCxDQUFjL3dCLEtBQWQsQ0FBb0IsS0FBSzZ3QixPQUF6QixFQUFrQy9xQixJQUFsQyxFQUh3QixDQUdpQjtBQUMxQyxHQUw2QyxDQUs1Qzs7O0FBR0YsUUFBTTRyQixXQUFXLEdBQUc7QUFDbEJiLElBQUFBLE9BRGtCO0FBRWxCQyxJQUFBQSxTQUZrQjtBQUdsQkMsSUFBQUEsUUFIa0IsRUFBcEI7O0FBS0EsUUFBTVksS0FBSyxHQUFHSCxPQUFPLENBQUM5RixJQUFSLENBQWFnRyxXQUFiLENBQWQsQ0FiOEMsQ0FhTDs7QUFFekNDLEVBQUFBLEtBQUssQ0FBQ1osUUFBTixHQUFpQkEsUUFBakIsQ0FmOEMsQ0FlbkI7O0FBRTNCVyxFQUFBQSxXQUFXLENBQUNELFdBQVosR0FBMEJFLEtBQTFCO0FBQ0EsU0FBT0EsS0FBUDtBQUNELEMsQ0FBQztBQUNGOzs7QUFHQSxNQUFNQyxZQUFOLENBQW1CO0FBQ2pCcnVCLEVBQUFBLFdBQVcsR0FBRztBQUNaLFNBQUswdEIsa0JBQUwsR0FBMEIsRUFBMUI7QUFDQSxTQUFLWSxhQUFMLEdBQXFCcnpCLFNBQXJCO0FBQ0Q7O0FBRURzekIsRUFBQUEsV0FBVyxDQUFDaEIsU0FBRCxFQUFZQyxRQUFaLEVBQXNCO0FBQy9CLFdBQU9ILFlBQVksQ0FBQyxJQUFELEVBQU9FLFNBQVAsRUFBa0JDLFFBQWxCLEVBQTRCLEtBQTVCLENBQW5CO0FBQ0Q7O0FBRURnQixFQUFBQSxFQUFFLENBQUNqQixTQUFELEVBQVlDLFFBQVosRUFBc0I7QUFDdEIsV0FBTyxLQUFLZSxXQUFMLENBQWlCaEIsU0FBakIsRUFBNEJDLFFBQTVCLENBQVA7QUFDRDs7QUFFRGlCLEVBQUFBLGVBQWUsQ0FBQ2xCLFNBQUQsRUFBWUMsUUFBWixFQUFzQjtBQUNuQyxXQUFPSCxZQUFZLENBQUMsSUFBRCxFQUFPRSxTQUFQLEVBQWtCQyxRQUFsQixFQUE0QixJQUE1QixDQUFuQjtBQUNEOztBQUVEakosRUFBQUEsSUFBSSxDQUFDZ0osU0FBRCxFQUFZQyxRQUFaLEVBQXNCO0FBQ3hCLFNBQUtnQixFQUFMLENBQVFqQixTQUFSLEVBQW1CUyxRQUFRLENBQUMsSUFBRCxFQUFPVCxTQUFQLEVBQWtCQyxRQUFsQixDQUEzQjtBQUNEOztBQUVEa0IsRUFBQUEsbUJBQW1CLENBQUNuQixTQUFELEVBQVlDLFFBQVosRUFBc0I7QUFDdkMsU0FBS2lCLGVBQUwsQ0FBcUJsQixTQUFyQixFQUFnQ1MsUUFBUSxDQUFDLElBQUQsRUFBT1QsU0FBUCxFQUFrQkMsUUFBbEIsQ0FBeEM7QUFDRDs7QUFFRDdILEVBQUFBLGNBQWMsQ0FBQzRILFNBQUQsRUFBWUMsUUFBWixFQUFzQjtBQUNsQyxRQUFJLENBQUMsS0FBS0Usa0JBQVYsRUFBOEI7QUFDNUI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxVQUFNRyxjQUFjLEdBQUcsS0FBS0gsa0JBQUwsQ0FBd0JILFNBQXhCLEtBQXNDLEVBQTdEO0FBQ0EsVUFBTXB4QixNQUFNLEdBQUcweEIsY0FBYyxDQUFDMXhCLE1BQTlCO0FBQ0EsUUFBSXd5QixVQUFVLEdBQUcsQ0FBQyxDQUFsQjtBQUNBLFFBQUlDLGlCQUFKLENBVGtDLENBU1g7O0FBRXZCLFNBQUssSUFBSXZ5QixDQUFDLEdBQUdGLE1BQU0sR0FBRyxDQUF0QixFQUF5QkUsQ0FBQyxJQUFJLENBQTlCLEVBQWlDQSxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFVBQUl3eEIsY0FBYyxDQUFDeHhCLENBQUQsQ0FBZCxLQUFzQm14QixRQUF0QixJQUFrQ0ssY0FBYyxDQUFDeHhCLENBQUQsQ0FBZCxDQUFrQm14QixRQUFsQixLQUErQkEsUUFBckUsRUFBK0U7QUFDN0VtQixRQUFBQSxVQUFVLEdBQUd0eUIsQ0FBYjtBQUNBdXlCLFFBQUFBLGlCQUFpQixHQUFHZixjQUFjLENBQUN4eEIsQ0FBRCxDQUFkLENBQWtCbXhCLFFBQXRDO0FBQ0E7QUFDRDtBQUNGOztBQUVELFFBQUltQixVQUFVLEtBQUssQ0FBQyxDQUFwQixFQUF1QjtBQUNyQixVQUFJeHlCLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCO0FBQ0EsZUFBTyxLQUFLdXhCLGtCQUFMLENBQXdCSCxTQUF4QixDQUFQO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQU0sUUFBQUEsY0FBYyxDQUFDdlAsTUFBZixDQUFzQnFRLFVBQXRCLEVBQWtDLENBQWxDLEVBRkssQ0FFaUM7QUFDdkMsT0FQb0IsQ0FPbkI7OztBQUdGLFVBQUksS0FBS2pCLGtCQUFMLENBQXdCL0gsY0FBNUIsRUFBNEM7QUFDMUMsYUFBS2lJLElBQUwsQ0FBVSxnQkFBVixFQUE0QkwsU0FBNUIsRUFBdUNxQixpQkFBaUIsSUFBSXBCLFFBQTVEO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRDs7QUFFRHFCLEVBQUFBLEdBQUcsQ0FBQ3RCLFNBQUQsRUFBWUMsUUFBWixFQUFzQjtBQUN2QixXQUFPLEtBQUs3SCxjQUFMLENBQW9CNEgsU0FBcEIsRUFBK0JDLFFBQS9CLENBQVA7QUFDRDs7QUFFREksRUFBQUEsSUFBSSxDQUFDTCxTQUFELEVBQVksR0FBR2hyQixJQUFmLEVBQXFCO0FBQ3ZCLFFBQUksQ0FBQyxLQUFLbXJCLGtCQUFWLEVBQThCO0FBQzVCO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQsVUFBTUcsY0FBYyxHQUFHLEtBQUtILGtCQUFMLENBQXdCSCxTQUF4QixLQUFzQyxFQUE3RDs7QUFFQSxTQUFLLE1BQU1DLFFBQVgsSUFBdUJLLGNBQWMsQ0FBQzFwQixLQUFmLEVBQXZCLEVBQStDO0FBQzdDO0FBQ0FxcEIsTUFBQUEsUUFBUSxDQUFDaHhCLElBQVQsQ0FBYyxJQUFkLEVBQW9CLEdBQUcrRixJQUF2QjtBQUNEOztBQUVELFdBQU9zckIsY0FBYyxDQUFDMXhCLE1BQWYsS0FBMEIsQ0FBakM7QUFDRDs7QUFFRG1vQixFQUFBQSxhQUFhLENBQUNpSixTQUFELEVBQVk7QUFDdkIsUUFBSSxDQUFDLEtBQUtHLGtCQUFWLEVBQThCO0FBQzVCO0FBQ0EsYUFBTyxDQUFQO0FBQ0Q7O0FBRUQsVUFBTUcsY0FBYyxHQUFHLEtBQUtILGtCQUFMLENBQXdCSCxTQUF4QixLQUFzQyxFQUE3RDtBQUNBLFdBQU9NLGNBQWMsQ0FBQzF4QixNQUF0QjtBQUNEOztBQUVEMnlCLEVBQUFBLFVBQVUsR0FBRztBQUNYLFdBQU85MUIsTUFBTSxDQUFDbUUsbUJBQVAsQ0FBMkIsS0FBS3V3QixrQkFBTCxJQUEyQixFQUF0RCxDQUFQO0FBQ0Q7O0FBRURxQixFQUFBQSxTQUFTLENBQUN4QixTQUFELEVBQVk7QUFDbkIsUUFBSSxDQUFDLEtBQUtHLGtCQUFWLEVBQThCO0FBQzVCO0FBQ0EsYUFBTyxFQUFQO0FBQ0QsS0FKa0IsQ0FJakI7OztBQUdGLFVBQU1zQixHQUFHLEdBQUcsS0FBS3RCLGtCQUFMLENBQXdCSCxTQUF4QixLQUFzQyxFQUFsRDtBQUNBLFdBQU95QixHQUFHLENBQUMvcUIsR0FBSixDQUFRZ3JCLENBQUMsSUFBSUEsQ0FBQyxDQUFDekIsUUFBRixJQUFjeUIsQ0FBM0IsQ0FBUCxDQVJtQixDQVFtQjtBQUN2Qzs7QUFFREMsRUFBQUEsWUFBWSxDQUFDM0IsU0FBRCxFQUFZO0FBQ3RCLFFBQUksQ0FBQyxLQUFLRyxrQkFBVixFQUE4QjtBQUM1QjtBQUNBLGFBQU8sRUFBUDtBQUNEOztBQUVELFdBQU8sQ0FBQyxLQUFLQSxrQkFBTCxDQUF3QkgsU0FBeEIsS0FBc0MsRUFBdkMsRUFBMkNwcEIsS0FBM0MsQ0FBaUQsQ0FBakQsQ0FBUCxDQU5zQixDQU1zQztBQUM3RDs7QUFFRDJwQixFQUFBQSxlQUFlLEdBQUc7QUFDaEIsV0FBTyxLQUFLUSxhQUFMLElBQXNCRCxZQUFZLENBQUNjLG1CQUExQztBQUNEOztBQUVEQyxFQUFBQSxlQUFlLENBQUNDLENBQUQsRUFBSTtBQUNqQixTQUFLZixhQUFMLEdBQXFCZSxDQUFyQixDQURpQixDQUNPOztBQUV4QixXQUFPLElBQVA7QUFDRDs7QUFFREMsRUFBQUEsa0JBQWtCLENBQUMvQixTQUFELEVBQVk7QUFDNUIsUUFBSSxDQUFDLEtBQUtHLGtCQUFWLEVBQThCO0FBQzVCO0FBQ0EsV0FBS0Esa0JBQUwsR0FBMEIsRUFBMUIsQ0FGNEIsQ0FFRTtBQUMvQjs7QUFFRCxRQUFJLENBQUMsS0FBS0Esa0JBQUwsQ0FBd0IvSCxjQUE3QixFQUE2QztBQUMzQztBQUNBLFVBQUk0SCxTQUFTLEtBQUt0eUIsU0FBbEIsRUFBNkI7QUFDM0I7QUFDQSxhQUFLeXlCLGtCQUFMLEdBQTBCLEVBQTFCO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQSxlQUFPLEtBQUtBLGtCQUFMLENBQXdCSCxTQUF4QixDQUFQO0FBQ0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0QsS0FqQjJCLENBaUIxQjs7O0FBR0YsUUFBSUEsU0FBUyxLQUFLdHlCLFNBQWxCLEVBQTZCO0FBQzNCO0FBQ0EsWUFBTXMwQixLQUFLLEdBQUd2MkIsTUFBTSxDQUFDa0UsSUFBUCxDQUFZLEtBQUt3d0Isa0JBQWpCLEVBQXFDMXdCLE1BQXJDLENBQTRDb0IsSUFBSSxJQUFJQSxJQUFJLEtBQUssZ0JBQTdELENBQWQ7QUFDQW14QixNQUFBQSxLQUFLLENBQUNwdEIsT0FBTixDQUFjL0QsSUFBSSxJQUFJLEtBQUtreEIsa0JBQUwsQ0FBd0JseEIsSUFBeEIsQ0FBdEI7QUFDQSxXQUFLa3hCLGtCQUFMLENBQXdCLGdCQUF4QjtBQUNBLFdBQUs1QixrQkFBTCxHQUEwQixFQUExQjtBQUNELEtBTkQsTUFNTztBQUNMO0FBQ0EsWUFBTXFCLFNBQVMsR0FBRyxLQUFLckIsa0JBQUwsQ0FBd0JILFNBQXhCLEtBQXNDLEVBQXhEOztBQUVBLFdBQUssSUFBSWx4QixDQUFDLEdBQUcweUIsU0FBUyxDQUFDNXlCLE1BQVYsR0FBbUIsQ0FBaEMsRUFBbUNFLENBQUMsSUFBSSxDQUF4QyxFQUEyQ0EsQ0FBQyxFQUE1QyxFQUFnRDtBQUM5QyxhQUFLc3BCLGNBQUwsQ0FBb0I0SCxTQUFwQixFQUErQndCLFNBQVMsQ0FBQzF5QixDQUFELENBQXhDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQW5LZ0I7OztBQXNLbkJneUIsWUFBWSxDQUFDYyxtQkFBYixHQUFtQyxFQUFuQzs7QUFFQWQsWUFBWSxDQUFDL0osYUFBYixHQUE2QixVQUFVZ0osT0FBVixFQUFtQkMsU0FBbkIsRUFBOEI7QUFDekQsU0FBT0QsT0FBTyxDQUFDaEosYUFBUixDQUFzQmlKLFNBQXRCLENBQVA7QUFDRCxDQUZEOztBQUlBYyxZQUFZLENBQUNBLFlBQWIsR0FBNEJBLFlBQTVCOztBQUVBOzs7Ozs7O0FBT0EsU0FBU21CLGtCQUFULENBQTRCdG1CLEdBQTVCLEVBQWlDOUssSUFBakMsRUFBdUNxeEIsUUFBdkMsRUFBaUQ7QUFDL0MsUUFBTWhzQixJQUFJLEdBQUcsT0FBT3lGLEdBQXBCOztBQUVBLE1BQUl6RixJQUFJLEtBQUtnc0IsUUFBUSxDQUFDanFCLFdBQVQsRUFBYixFQUFxQztBQUNuQyxVQUFNLElBQUk5QixTQUFKLENBQWUsUUFBT3RGLElBQUssOEJBQTZCcXhCLFFBQVMsbUJBQWtCaHNCLElBQUssRUFBeEYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsTUFBTWlnQixTQUFTLEdBQUdwUCxJQUFJLENBQUN1UCxHQUFMLEVBQWxCO0FBQ0E7Ozs7Ozs7Ozs7QUFVQSxTQUFTNkwsZUFBVCxDQUF5QkMsUUFBekIsRUFBbUM7QUFDakMsVUFBUUEsUUFBUjtBQUNFO0FBQ0E7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLGFBQUw7QUFDQSxTQUFLLEtBQUw7QUFDRSxhQUFPLEtBQVA7QUFDRjs7QUFFQSxTQUFLLFdBQUw7QUFDRSxhQUFPLE9BQVA7QUFDRjs7QUFFQSxTQUFLLE1BQUw7QUFDQSxTQUFLLEtBQUw7QUFDRSxhQUFPLE1BQVA7QUFDRjs7QUFFQSxTQUFLLFFBQUw7QUFDQSxTQUFLLE1BQUw7QUFDRSxhQUFPLEtBQVA7QUFDRjs7QUFFQSxTQUFLLFFBQUw7QUFDRSxhQUFPLE1BQVA7QUFDRjs7QUFFQSxTQUFLLFNBQUw7QUFDRSxhQUFPLFNBQVA7O0FBRUY7QUFDRSxhQUFPQSxRQUFQLENBaENKOztBQWtDRDs7QUFFRCxNQUFNQyxTQUFTLEdBQUcsSUFBSXZCLFlBQUosRUFBbEI7O0FBRUF1QixTQUFTLENBQUNDLEtBQVYsR0FBa0IsTUFBTSxDQUFFLENBQTFCLEMsQ0FBNEI7OztBQUc1QkQsU0FBUyxDQUFDRSxJQUFWLEdBQWlCSixlQUFlLENBQUNyMkIsRUFBRSxDQUFDQyxRQUFILENBQVl5MkIsWUFBYixDQUFoQztBQUNBSCxTQUFTLENBQUNJLElBQVYsR0FBaUIsRUFBakIsQyxDQUFxQjs7QUFFckJoM0IsTUFBTSxDQUFDeUosY0FBUCxDQUFzQm10QixTQUF0QixFQUFpQyxPQUFqQyxFQUEwQztBQUN4QzEyQixFQUFBQSxLQUFLLEVBQUUsRUFEaUM7QUFFeEM7QUFDQUMsRUFBQUEsUUFBUSxFQUFFLEtBSDhCO0FBSXhDdUosRUFBQUEsVUFBVSxFQUFFLElBSjRCO0FBS3hDQyxFQUFBQSxZQUFZLEVBQUUsS0FMMEIsRUFBMUM7OztBQVFBaXRCLFNBQVMsQ0FBQy9GLE9BQVYsR0FBb0IsTUFBTTtBQUN4QixRQUFNLElBQUlydkIsS0FBSixDQUFVLHdEQUFWLENBQU47QUFDRCxDQUZEOztBQUlBbzFCLFNBQVMsQ0FBQ0ssT0FBVixHQUFvQmgxQixTQUFwQjs7QUFFQTIwQixTQUFTLENBQUNNLEtBQVYsR0FBa0IsTUFBTTtBQUN0QixRQUFNLElBQUkxMUIsS0FBSixDQUFVLDhCQUFWLENBQU47QUFDRCxDQUZEOztBQUlBbzFCLFNBQVMsQ0FBQ08sTUFBVixHQUFtQixFQUFuQjtBQUNBUCxTQUFTLENBQUNRLFNBQVYsR0FBc0IsS0FBdEI7O0FBRUFSLFNBQVMsQ0FBQ1MsUUFBVixHQUFxQixNQUFNO0FBQ3pCO0FBQ0EsU0FBTztBQUNMQyxJQUFBQSxJQUFJLEVBQUUsQ0FERDtBQUVMQyxJQUFBQSxNQUFNLEVBQUUsQ0FGSCxFQUFQOztBQUlELENBTkQ7O0FBUUFYLFNBQVMsQ0FBQ1ksR0FBVixHQUFnQixNQUFNQyxTQUF0Qjs7QUFFQXozQixNQUFNLENBQUN5SixjQUFQLENBQXNCbXRCLFNBQXRCLEVBQWlDLFdBQWpDLEVBQThDO0FBQzVDNXhCLEVBQUFBLEdBQUcsRUFBRSxZQUFZO0FBQ2YsUUFBSTlFLEtBQUssR0FBRyxDQUFaLENBRGUsQ0FDQTs7QUFFZixRQUFJO0FBQ0YsVUFBSSxjQUFjLFNBQWxCLEVBQTZCO0FBQzNCLGNBQU13M0IsTUFBTSxHQUFHM0UsS0FBSyxDQUFDbEMsT0FBTixDQUFjLFFBQWQsQ0FBZjtBQUNBLGNBQU04RyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0UsU0FBUCxDQUFpQixhQUFqQixDQUFiOztBQUVBLFlBQUlELElBQUosRUFBVTtBQUNSLGdCQUFNRSxVQUFVLEdBQUduTyxJQUFJLENBQUNpSyxLQUFMLENBQVdnRSxJQUFYLENBQW5COztBQUVBLGNBQUlFLFVBQVUsQ0FBQ0MsWUFBWCxLQUE0QixDQUFDLENBQWpDLEVBQW9DO0FBQ2xDO0FBQ0E1M0IsWUFBQUEsS0FBSyxHQUFHMjNCLFVBQVUsQ0FBQ0MsWUFBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixLQWRELENBY0UsT0FBTzV2QixLQUFQLEVBQWMsQ0FBRSxDQWpCSCxDQWlCSTtBQUNuQjs7O0FBR0FsSSxJQUFBQSxNQUFNLENBQUN5SixjQUFQLENBQXNCLElBQXRCLEVBQTRCLFdBQTVCLEVBQXlDO0FBQ3ZDdkosTUFBQUEsS0FBSyxFQUFFQSxLQURnQztBQUV2Q0MsTUFBQUEsUUFBUSxFQUFFLElBRjZCO0FBR3ZDdUosTUFBQUEsVUFBVSxFQUFFLElBSDJCO0FBSXZDQyxNQUFBQSxZQUFZLEVBQUUsSUFKeUIsRUFBekM7O0FBTUEsV0FBT3pKLEtBQVA7QUFDRCxHQTdCMkM7QUE4QjVDd0osRUFBQUEsVUFBVSxFQUFFLElBOUJnQztBQStCNUNDLEVBQUFBLFlBQVksRUFBRSxJQS9COEIsRUFBOUM7OztBQWtDQWl0QixTQUFTLENBQUNtQixVQUFWLEdBQXVCLE1BQU0sQ0FBRSxDQUEvQixDLENBQWlDOzs7QUFHakNuQixTQUFTLENBQUNvQixNQUFWLEdBQW1CLE1BQU07QUFDdkIsUUFBTSxJQUFJeDJCLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0QsQ0FGRDs7QUFJQW8xQixTQUFTLENBQUM1YixXQUFWLEdBQXdCLFVBQVVpZCxPQUFWLEVBQW1CdlosT0FBbkIsRUFBNEJuYSxJQUE1QixFQUFrQzJ6QixJQUFsQyxFQUF3QztBQUM5RDtBQUNBLE1BQUl6dEIsSUFBSjtBQUNBLE1BQUkwdEIsTUFBSjs7QUFFQSxNQUFJLE9BQU96WixPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CalUsSUFBQUEsSUFBSSxHQUFHaVUsT0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDdENqVSxJQUFBQSxJQUFJLEdBQUdpVSxPQUFPLENBQUNqVSxJQUFmO0FBQ0FsRyxJQUFBQSxJQUFJLEdBQUdtYSxPQUFPLENBQUNuYSxJQUFmO0FBQ0E0ekIsSUFBQUEsTUFBTSxHQUFHelosT0FBTyxDQUFDeVosTUFBakI7QUFDRDs7QUFFRCxNQUFJLE9BQU9GLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBQSxJQUFBQSxPQUFPLEdBQUcsSUFBSXoyQixLQUFKLENBQVV5MkIsT0FBVixDQUFWO0FBQ0FBLElBQUFBLE9BQU8sQ0FBQzd5QixJQUFSLEdBQWVxRixJQUFJLElBQUksU0FBdkI7O0FBRUEsUUFBSWxHLElBQUksS0FBS3RDLFNBQWIsRUFBd0I7QUFDdEJnMkIsTUFBQUEsT0FBTyxDQUFDMXpCLElBQVIsR0FBZUEsSUFBZjtBQUNEOztBQUVELFFBQUk0ekIsTUFBTSxLQUFLbDJCLFNBQWYsRUFBMEI7QUFDeEJnMkIsTUFBQUEsT0FBTyxDQUFDRSxNQUFSLEdBQWlCQSxNQUFqQjtBQUNEO0FBQ0YsR0ExQjZELENBMEI1RDs7O0FBR0YsUUFBTUMsYUFBYSxHQUFHSCxPQUFPLENBQUM3eUIsSUFBUixLQUFpQixvQkFBdkM7O0FBRUEsTUFBSWd6QixhQUFhLElBQUl4QixTQUFTLENBQUN5QixhQUEvQixFQUE4QztBQUM1QyxXQUQ0QyxDQUNwQztBQUNUOztBQUVELE1BQUlELGFBQWEsSUFBSXhCLFNBQVMsQ0FBQzBCLGdCQUEvQixFQUFpRDtBQUMvQyxVQUFNTCxPQUFOO0FBQ0Q7O0FBRUQsT0FBS3JELElBQUwsQ0FBVSxTQUFWLEVBQXFCcUQsT0FBckI7QUFDRCxDQXhDRDs7QUEwQ0EsU0FBU00sV0FBVCxHQUF1QjtBQUNyQixNQUFJO0FBQ0YsVUFBTUMsUUFBUSxHQUFHbjRCLEVBQUUsQ0FBQytsQixVQUFILENBQWNxTixPQUFkLENBQXNCcHpCLEVBQUUsQ0FBQytsQixVQUFILENBQWNDLGtCQUFwQyxFQUF3RCxZQUF4RCxDQUFqQjs7QUFFQSxRQUFJbVMsUUFBUSxDQUFDOUUsTUFBVCxFQUFKLEVBQXVCO0FBQ3JCLGFBQU9oSyxJQUFJLENBQUNpSyxLQUFMLENBQVc2RSxRQUFRLENBQUM1RSxJQUFULEdBQWdCQyxJQUEzQixDQUFQO0FBQ0Q7QUFDRixHQU5ELENBTUUsT0FBTzNyQixLQUFQLEVBQWM7QUFDZDdILElBQUFBLEVBQUUsQ0FBQ3l0QixHQUFILENBQU81bEIsS0FBUCxDQUFjLHdDQUF1Q0EsS0FBSyxDQUFDSyxPQUFRLEVBQW5FO0FBQ0Q7O0FBRUQsU0FBTyxFQUFQO0FBQ0Q7O0FBRUR2SSxNQUFNLENBQUN5SixjQUFQLENBQXNCbXRCLFNBQXRCLEVBQWlDLEtBQWpDLEVBQXdDO0FBQ3RDNXhCLEVBQUFBLEdBQUcsRUFBRSxZQUFZO0FBQ2YsV0FBTyxLQUFLeXpCLEdBQVo7QUFDQSxXQUFPLEtBQUtBLEdBQUwsR0FBV0YsV0FBVyxFQUE3QjtBQUNELEdBSnFDO0FBS3RDN3VCLEVBQUFBLFVBQVUsRUFBRSxJQUwwQjtBQU10Q0MsRUFBQUEsWUFBWSxFQUFFLElBTndCLEVBQXhDOztBQVFBaXRCLFNBQVMsQ0FBQzhCLFFBQVYsR0FBcUIsRUFBckI7QUFDQTlCLFNBQVMsQ0FBQytCLFFBQVYsR0FBcUIsRUFBckIsQyxDQUF5Qjs7QUFFekIvQixTQUFTLENBQUNnQyxJQUFWLEdBQWlCLE1BQU07QUFDckIsUUFBTSxJQUFJcDNCLEtBQUosQ0FBVSwrQkFBVixDQUFOO0FBQ0QsQ0FGRDs7QUFJQW8xQixTQUFTLENBQUNpQyxRQUFWLEdBQXFCNTJCLFNBQXJCO0FBQ0EyMEIsU0FBUyxDQUFDeUIsYUFBVixHQUEwQixLQUExQjtBQUNBekIsU0FBUyxDQUFDa0MsR0FBVixHQUFnQixDQUFoQixDLENBQW1COztBQUVuQmxDLFNBQVMsQ0FBQ21DLFFBQVYsR0FBcUIsU0FBckI7QUFDQW5DLFNBQVMsQ0FBQ29DLElBQVYsR0FBaUIsQ0FBakIsQyxDQUFvQjtBQUNwQjtBQUNBOztBQUVBcEMsU0FBUyxDQUFDbkwsTUFBVixHQUFtQjtBQUNqQndOLEVBQUFBLEtBQUssRUFBRSxLQURVO0FBRWpCOTRCLEVBQUFBLFFBQVEsRUFBRSxJQUZPO0FBR2pCMFcsRUFBQUEsS0FBSyxFQUFFLENBQUNxaUIsS0FBRCxFQUFRN3NCLFFBQVIsRUFBa0I4c0IsUUFBbEIsS0FBK0I7QUFDcEM5NEIsSUFBQUEsRUFBRSxDQUFDeXRCLEdBQUgsQ0FBTzVsQixLQUFQLENBQWFneEIsS0FBYjs7QUFFQSxRQUFJQyxRQUFKLEVBQWM7QUFDWkEsTUFBQUEsUUFBUTtBQUNUOztBQUVELFdBQU8sSUFBUDtBQUNELEdBWGdCLEVBQW5COztBQWFBdkMsU0FBUyxDQUFDaEwsTUFBVixHQUFtQjtBQUNqQnFOLEVBQUFBLEtBQUssRUFBRSxLQURVO0FBRWpCOTRCLEVBQUFBLFFBQVEsRUFBRSxJQUZPO0FBR2pCMFcsRUFBQUEsS0FBSyxFQUFFLENBQUNxaUIsS0FBRCxFQUFRN3NCLFFBQVIsRUFBa0I4c0IsUUFBbEIsS0FBK0I7QUFDcEM5NEIsSUFBQUEsRUFBRSxDQUFDeXRCLEdBQUgsQ0FBT2xCLElBQVAsQ0FBWXNNLEtBQVo7O0FBRUEsUUFBSUMsUUFBSixFQUFjO0FBQ1pBLE1BQUFBLFFBQVE7QUFDVDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQVhnQixFQUFuQjs7QUFhQXZDLFNBQVMsQ0FBQ3dDLEtBQVYsR0FBa0IvNEIsRUFBRSxDQUFDZzVCLEdBQUgsQ0FBT2owQixJQUF6QjtBQUNBd3hCLFNBQVMsQ0FBQzBCLGdCQUFWLEdBQTZCLEtBQTdCO0FBQ0ExQixTQUFTLENBQUMwQyxnQkFBVixHQUE2QixLQUE3Qjs7QUFFQTFDLFNBQVMsQ0FBQzJDLEtBQVYsR0FBa0IsTUFBTSxDQUF4QixDLENBQTJCOzs7QUFHM0IzQyxTQUFTLENBQUM0QyxNQUFWLEdBQW1CLE1BQU07QUFDdkIsUUFBTUMsTUFBTSxHQUFHbmUsSUFBSSxDQUFDdVAsR0FBTCxLQUFhSCxTQUE1QjtBQUNBLFNBQU8rTyxNQUFNLEdBQUcsTUFBaEIsQ0FGdUIsQ0FFQztBQUN6QixDQUhEOztBQUtBN0MsU0FBUyxDQUFDOEMsT0FBVixHQUFvQixPQUFwQjtBQUNBOUMsU0FBUyxDQUFDK0MsUUFBVixHQUFxQjtBQUNuQkMsRUFBQUEsT0FBTyxFQUFFLEVBRFU7QUFFbkI7QUFDQUMsRUFBQUEsRUFBRSxFQUFFLEVBSGU7QUFJbkI7QUFDQUMsRUFBQUEsR0FBRyxFQUFFLEVBTGMsQ0FLWDtBQUNSO0FBTm1CLENBQXJCOztBQVNBbEQsU0FBUyxDQUFDOTFCLE1BQU0sQ0FBQ2lFLFdBQVIsQ0FBVCxHQUFnQyxTQUFoQztBQUNBakYsTUFBTSxDQUFDaWIsT0FBUCxHQUFpQjZiLFNBQWpCLEMsQ0FBNEI7O0FBRTVCLE1BQU1tRCxjQUFjLEdBQUksYUFBWW5ELFNBQVMsQ0FBQ2tDLEdBQUksSUFBbEQ7QUFDQWxDLFNBQVMsQ0FBQ3BCLEVBQVYsQ0FBYSxTQUFiLEVBQXdCeUMsT0FBTyxJQUFJO0FBQ2pDLFFBQU1HLGFBQWEsR0FBR0gsT0FBTyxDQUFDN3lCLElBQVIsS0FBaUIsb0JBQXZDLENBRGlDLENBQzRCOztBQUU3RCxNQUFJZ3pCLGFBQWEsSUFBSXhCLFNBQVMsQ0FBQ3lCLGFBQS9CLEVBQThDO0FBQzVDO0FBQ0QsR0FMZ0MsQ0FLL0I7OztBQUdGLE1BQUl4dUIsR0FBRyxHQUFHa3dCLGNBQVY7O0FBRUEsTUFBSTlCLE9BQU8sQ0FBQzF6QixJQUFSLEtBQWlCdEMsU0FBckIsRUFBZ0M7QUFDOUI0SCxJQUFBQSxHQUFHLElBQUssSUFBR291QixPQUFPLENBQUMxekIsSUFBSyxJQUF4QjtBQUNEOztBQUVELE1BQUkwekIsT0FBTyxDQUFDNXlCLFFBQVosRUFBc0I7QUFDcEJ3RSxJQUFBQSxHQUFHLElBQUlvdUIsT0FBTyxDQUFDNXlCLFFBQVIsRUFBUDtBQUNEOztBQUVELE1BQUk0eUIsT0FBTyxDQUFDRSxNQUFaLEVBQW9CO0FBQ2xCdHVCLElBQUFBLEdBQUcsSUFBSyxLQUFJb3VCLE9BQU8sQ0FBQ0UsTUFBTyxFQUEzQjtBQUNEOztBQUVEcEssRUFBQUEsT0FBTyxDQUFDN2xCLEtBQVIsQ0FBYzJCLEdBQWQ7QUFDRCxDQXZCRDtBQXdCQSxJQUFJbXdCLHlCQUF5QixHQUFHLElBQWhDOztBQUVBcEQsU0FBUyxDQUFDcUQsbUNBQVYsR0FBZ0QsTUFBTUQseUJBQXlCLEtBQUssSUFBcEY7O0FBRUFwRCxTQUFTLENBQUNzRCxtQ0FBVixHQUFnRHhVLEVBQUUsSUFBSTtBQUNwRCxNQUFJQSxFQUFFLEtBQUssSUFBWCxFQUFpQjtBQUNmc1UsSUFBQUEseUJBQXlCLEdBQUcsSUFBNUI7QUFDQTtBQUNEOztBQUVEeEQsRUFBQUEsa0JBQWtCLENBQUM5USxFQUFELEVBQUssSUFBTCxFQUFXLFVBQVgsQ0FBbEI7O0FBRUEsTUFBSXNVLHlCQUF5QixLQUFLLElBQWxDLEVBQXdDO0FBQ3RDLFVBQU0sSUFBSXg0QixLQUFKLENBQVUsd0dBQVYsQ0FBTjtBQUNEOztBQUVEdzRCLEVBQUFBLHlCQUF5QixHQUFHdFUsRUFBNUI7QUFDRCxDQWJEOztBQWVBcmxCLEVBQUUsQ0FBQ2c1QixHQUFILENBQU9jLGdCQUFQLENBQXdCLG1CQUF4QixFQUE2QyxVQUFVQyxLQUFWLEVBQWlCO0FBQzVEO0FBQ0E7QUFDQSxRQUFNbHlCLEtBQUssR0FBRyxJQUFJMUcsS0FBSixDQUFVNDRCLEtBQUssQ0FBQzd4QixPQUFoQixDQUFkO0FBQ0FMLEVBQUFBLEtBQUssQ0FBQ2hHLEtBQU4sR0FBY2s0QixLQUFLLENBQUNDLFNBQXBCO0FBQ0FueUIsRUFBQUEsS0FBSyxDQUFDb3lCLFFBQU4sR0FBaUJGLEtBQUssQ0FBQ0csVUFBdkI7QUFDQXJ5QixFQUFBQSxLQUFLLENBQUNnZSxVQUFOLEdBQW1Ca1UsS0FBSyxDQUFDOTNCLElBQXpCO0FBQ0E0RixFQUFBQSxLQUFLLENBQUNzeUIsWUFBTixHQUFxQkosS0FBSyxDQUFDSyxVQUEzQjs7QUFFQSxNQUFJN0QsU0FBUyxDQUFDcUQsbUNBQVYsRUFBSixFQUFxRDtBQUNuRCxXQUFPRCx5QkFBeUIsQ0FBQzl4QixLQUFELENBQWhDO0FBQ0QsR0FYMkQsQ0FXMUQ7OztBQUdGMHVCLEVBQUFBLFNBQVMsQ0FBQ2hDLElBQVYsQ0FBZSxtQkFBZixFQUFvQzFzQixLQUFwQztBQUNELENBZkQ7QUFnQkE7O0FBRUEsTUFBTXd5QixnQkFBTixDQUF1QjtBQUNyQjF6QixFQUFBQSxXQUFXLENBQUMyekIsSUFBRCxFQUFPcHhCLElBQVAsRUFBYTtBQUN0QixTQUFLb3hCLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtweEIsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7O0FBRURxeEIsRUFBQUEsR0FBRyxHQUFHO0FBQ0osUUFBSSxLQUFLcnhCLElBQVQsRUFBZTtBQUNiLFdBQUtveEIsSUFBTCxDQUFVbDNCLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0IsS0FBSzhGLElBQTNCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsV0FBS3N4QixHQUFMO0FBQ0Q7QUFDRixHQVpvQjs7QUFjckI7QUFDRjtBQUNBO0FBQ0E7OztBQUdBLE1BQU1DLFNBQVMsR0FBRyxFQUFsQjtBQUNBLE1BQU1DLGNBQWMsR0FBRyxFQUF2QjtBQUNBLElBQUlDLGlCQUFpQixHQUFHLEtBQXhCO0FBQ0EsSUFBSUMsa0JBQWtCLEdBQUcsSUFBekI7QUFDQTs7Ozs7QUFLQSxTQUFTQyxjQUFULEdBQTBCO0FBQ3hCLE1BQUlGLGlCQUFKLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBRURBLEVBQUFBLGlCQUFpQixHQUFHLElBQXBCOztBQUVBLFNBQU9GLFNBQVMsQ0FBQzMzQixNQUFqQixFQUF5QjtBQUN2QixVQUFNZzRCLElBQUksR0FBR0wsU0FBUyxDQUFDTSxLQUFWLEVBQWI7QUFDQUQsSUFBQUEsSUFBSSxDQUFDUCxHQUFMO0FBQ0Q7O0FBRURJLEVBQUFBLGlCQUFpQixHQUFHLEtBQXBCO0FBQ0Q7O0FBRUQsU0FBU0ssV0FBVCxHQUF1QjtBQUNyQjtBQUNBSCxFQUFBQSxjQUFjLEdBRk8sQ0FFSDs7QUFFbEIsUUFBTUksbUJBQW1CLEdBQUdDLHFCQUFxQixFQUFqRDs7QUFFQSxNQUFJRCxtQkFBbUIsS0FBSyxDQUE1QixFQUErQjtBQUM3QjtBQUNBTCxJQUFBQSxrQkFBa0IsR0FBR08sVUFBVSxDQUFDSCxXQUFELEVBQWMsQ0FBZCxDQUEvQjtBQUNELEdBSEQsTUFHTztBQUNMSixJQUFBQSxrQkFBa0IsR0FBRyxJQUFyQjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7O0FBU0EsU0FBU00scUJBQVQsR0FBaUM7QUFDL0IsUUFBTUUsaUJBQWlCLEdBQUduZ0IsSUFBSSxDQUFDdVAsR0FBTCxLQUFhLEdBQXZDLENBRCtCLENBQ2E7O0FBRTVDLFNBQU9rUSxjQUFjLENBQUM1M0IsTUFBZixJQUF5Qm1ZLElBQUksQ0FBQ3VQLEdBQUwsS0FBYTRRLGlCQUE3QyxFQUFnRTtBQUM5RCxVQUFNQyxTQUFTLEdBQUdYLGNBQWMsQ0FBQ0ssS0FBZixFQUFsQjtBQUNBTSxJQUFBQSxTQUFTLENBQUNkLEdBQVY7O0FBRUEsUUFBSUUsU0FBUyxDQUFDMzNCLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEI7QUFDQSszQixNQUFBQSxjQUFjO0FBQ2Y7QUFDRjs7QUFFRCxTQUFPSCxjQUFjLENBQUM1M0IsTUFBdEI7QUFDRDs7QUFFRHl6QixTQUFTLENBQUMrRSxRQUFWLEdBQXFCLFVBQVV4QyxRQUFWLEVBQW9CLEdBQUc1dkIsSUFBdkIsRUFBNkI7QUFDaERpdEIsRUFBQUEsa0JBQWtCLENBQUMyQyxRQUFELEVBQVcsVUFBWCxFQUF1QixVQUF2QixDQUFsQjtBQUNBMkIsRUFBQUEsU0FBUyxDQUFDcDRCLElBQVYsQ0FBZSxJQUFJZzRCLGdCQUFKLENBQXFCdkIsUUFBckIsRUFBK0I1dkIsSUFBL0IsQ0FBZjs7QUFFQSxNQUFJLENBQUMweEIsa0JBQUwsRUFBeUI7QUFDdkJBLElBQUFBLGtCQUFrQixHQUFHTyxVQUFVLENBQUNILFdBQUQsRUFBYyxDQUFkLENBQS9CO0FBQ0Q7QUFDRixDQVBEOztBQVNBdjdCLE1BQU0sQ0FBQzg3QixZQUFQLEdBQXNCLFVBQVV6QyxRQUFWLEVBQW9CLEdBQUc1dkIsSUFBdkIsRUFBNkI7QUFDakRpdEIsRUFBQUEsa0JBQWtCLENBQUMyQyxRQUFELEVBQVcsVUFBWCxFQUF1QixVQUF2QixDQUFsQjtBQUNBLFFBQU11QyxTQUFTLEdBQUcsSUFBSWhCLGdCQUFKLENBQXFCdkIsUUFBckIsRUFBK0I1dkIsSUFBL0IsQ0FBbEI7QUFDQXd4QixFQUFBQSxjQUFjLENBQUNyNEIsSUFBZixDQUFvQmc1QixTQUFwQjs7QUFFQSxNQUFJLENBQUNULGtCQUFMLEVBQXlCO0FBQ3ZCQSxJQUFBQSxrQkFBa0IsR0FBR08sVUFBVSxDQUFDSCxXQUFELEVBQWMsQ0FBZCxDQUEvQjtBQUNEOztBQUVELFNBQU9LLFNBQVA7QUFDRCxDQVZEOztBQVlBNTdCLE1BQU0sQ0FBQys3QixjQUFQLEdBQXdCLFVBQVVILFNBQVYsRUFBcUI7QUFDM0MsUUFBTXZ0QixLQUFLLEdBQUc0c0IsY0FBYyxDQUFDaG9CLE9BQWYsQ0FBdUIyb0IsU0FBdkIsQ0FBZDs7QUFFQSxNQUFJdnRCLEtBQUssS0FBSyxDQUFDLENBQWYsRUFBa0I7QUFDaEI0c0IsSUFBQUEsY0FBYyxDQUFDelYsTUFBZixDQUFzQm5YLEtBQXRCLEVBQTZCLENBQTdCO0FBQ0Q7QUFDRixDQU5EOztBQVFBLE1BQU0ydEIsYUFBYSxHQUFHLEVBQXRCLEMsQ0FBMEI7O0FBRTFCLE1BQU1DLGNBQWMsR0FBRyxFQUF2QixDLENBQTJCOztBQUUzQjs7Ozs7O0FBTUEsU0FBU0MsbUJBQVQsQ0FBNkJDLFFBQTdCLEVBQXVDO0FBQ3JDLFNBQU9BLFFBQVEsSUFBSSxFQUFaLElBQWtCQSxRQUFRLElBQUksRUFBOUIsSUFBb0NBLFFBQVEsSUFBSSxFQUFaLElBQWtCQSxRQUFRLElBQUksR0FBekU7QUFDRDtBQUNEOzs7Ozs7OztBQVFBLFNBQVNDLFVBQVQsQ0FBb0JDLE9BQXBCLEVBQTZCcEwsUUFBN0IsRUFBdUM7QUFDckN5RixFQUFBQSxrQkFBa0IsQ0FBQ3pGLFFBQUQsRUFBVyxNQUFYLEVBQW1CLFFBQW5CLENBQWxCO0FBQ0EsUUFBTTV0QixNQUFNLEdBQUc0dEIsUUFBUSxDQUFDNXRCLE1BQXhCLENBRnFDLENBRUw7O0FBRWhDLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCLFdBQU8sS0FBUDtBQUNEOztBQUVELFFBQU1tdEIsU0FBUyxHQUFHUyxRQUFRLENBQUN2c0IsVUFBVCxDQUFvQixDQUFwQixDQUFsQjs7QUFFQSxNQUFJOHJCLFNBQVMsS0FBS3dMLGFBQWxCLEVBQWlDO0FBQy9CLFdBQU8sSUFBUDtBQUNELEdBWm9DLENBWW5DOzs7QUFHRixNQUFJSyxPQUFKLEVBQWE7QUFDWCxXQUFPLEtBQVA7QUFDRCxHQWpCb0MsQ0FpQm5DOzs7QUFHRixNQUFJN0wsU0FBUyxLQUFLeUwsY0FBbEIsRUFBa0M7QUFDaEMsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSTU0QixNQUFNLEdBQUcsQ0FBVCxJQUFjNjRCLG1CQUFtQixDQUFDMUwsU0FBRCxDQUFqQyxJQUFnRFMsUUFBUSxDQUFDeFksTUFBVCxDQUFnQixDQUFoQixNQUF1QixHQUEzRSxFQUFnRjtBQUM5RSxVQUFNNmpCLFNBQVMsR0FBR3JMLFFBQVEsQ0FBQ3hZLE1BQVQsQ0FBZ0IsQ0FBaEIsQ0FBbEI7QUFDQSxXQUFPNmpCLFNBQVMsS0FBSyxHQUFkLElBQXFCQSxTQUFTLEtBQUssSUFBMUM7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDtBQUNEOzs7Ozs7OztBQVFBLFNBQVNDLE9BQVQsQ0FBaUJuNUIsU0FBakIsRUFBNEI2dEIsUUFBNUIsRUFBc0M7QUFDcEN5RixFQUFBQSxrQkFBa0IsQ0FBQ3pGLFFBQUQsRUFBVyxNQUFYLEVBQW1CLFFBQW5CLENBQWxCO0FBQ0EsUUFBTTV0QixNQUFNLEdBQUc0dEIsUUFBUSxDQUFDNXRCLE1BQXhCOztBQUVBLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCLFdBQU8sR0FBUDtBQUNELEdBTm1DLENBTWxDOzs7QUFHRixNQUFJbTVCLFNBQVMsR0FBR241QixNQUFNLEdBQUcsQ0FBekI7QUFDQSxRQUFNbzVCLFdBQVcsR0FBR3hMLFFBQVEsQ0FBQ3htQixRQUFULENBQWtCckgsU0FBbEIsQ0FBcEI7O0FBRUEsTUFBSXE1QixXQUFKLEVBQWlCO0FBQ2ZELElBQUFBLFNBQVM7QUFDVjs7QUFFRCxRQUFNM0csVUFBVSxHQUFHNUUsUUFBUSxDQUFDeUwsV0FBVCxDQUFxQnQ1QixTQUFyQixFQUFnQ281QixTQUFoQyxDQUFuQixDQWhCb0MsQ0FnQjJCOztBQUUvRCxNQUFJM0csVUFBVSxLQUFLLENBQUMsQ0FBcEIsRUFBdUI7QUFDckI7QUFDQSxRQUFJeHlCLE1BQU0sSUFBSSxDQUFWLElBQWVELFNBQVMsS0FBSyxJQUE3QixJQUFxQzZ0QixRQUFRLENBQUN4WSxNQUFULENBQWdCLENBQWhCLE1BQXVCLEdBQWhFLEVBQXFFO0FBQ25FLFlBQU0rWCxTQUFTLEdBQUdTLFFBQVEsQ0FBQ3ZzQixVQUFULENBQW9CLENBQXBCLENBQWxCOztBQUVBLFVBQUl3M0IsbUJBQW1CLENBQUMxTCxTQUFELENBQXZCLEVBQW9DO0FBQ2xDLGVBQU9TLFFBQVAsQ0FEa0MsQ0FDakI7QUFDbEI7QUFDRjs7QUFFRCxXQUFPLEdBQVA7QUFDRCxHQTdCbUMsQ0E2QmxDOzs7QUFHRixNQUFJNEUsVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQ3BCLFdBQU96eUIsU0FBUCxDQURvQixDQUNGO0FBQ25CLEdBbENtQyxDQWtDbEM7OztBQUdGLE1BQUl5eUIsVUFBVSxLQUFLLENBQWYsSUFBb0J6eUIsU0FBUyxLQUFLLEdBQWxDLElBQXlDNnRCLFFBQVEsQ0FBQ3hZLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBcEUsRUFBeUU7QUFDdkUsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBT3dZLFFBQVEsQ0FBQzVsQixLQUFULENBQWUsQ0FBZixFQUFrQndxQixVQUFsQixDQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7QUFRQSxTQUFTOEcsT0FBVCxDQUFpQnY1QixTQUFqQixFQUE0QjZ0QixRQUE1QixFQUFzQztBQUNwQ3lGLEVBQUFBLGtCQUFrQixDQUFDekYsUUFBRCxFQUFXLE1BQVgsRUFBbUIsUUFBbkIsQ0FBbEI7QUFDQSxRQUFNNWlCLEtBQUssR0FBRzRpQixRQUFRLENBQUN5TCxXQUFULENBQXFCLEdBQXJCLENBQWQ7O0FBRUEsTUFBSXJ1QixLQUFLLEtBQUssQ0FBQyxDQUFYLElBQWdCQSxLQUFLLEtBQUssQ0FBOUIsRUFBaUM7QUFDL0IsV0FBTyxFQUFQO0FBQ0QsR0FObUMsQ0FNbEM7OztBQUdGLE1BQUl1dUIsUUFBUSxHQUFHM0wsUUFBUSxDQUFDNXRCLE1BQXhCOztBQUVBLE1BQUk0dEIsUUFBUSxDQUFDeG1CLFFBQVQsQ0FBa0JySCxTQUFsQixDQUFKLEVBQWtDO0FBQ2hDdzVCLElBQUFBLFFBQVE7QUFDVDs7QUFFRCxTQUFPM0wsUUFBUSxDQUFDNWxCLEtBQVQsQ0FBZWdELEtBQWYsRUFBc0J1dUIsUUFBdEIsQ0FBUDtBQUNEOztBQUVELFNBQVNDLHVCQUFULENBQWlDNUwsUUFBakMsRUFBMkM1aUIsS0FBM0MsRUFBa0Q7QUFDaEQsT0FBSyxJQUFJOUssQ0FBQyxHQUFHOEssS0FBYixFQUFvQjlLLENBQUMsSUFBSSxDQUF6QixFQUE0QkEsQ0FBQyxFQUE3QixFQUFpQztBQUMvQixVQUFNdTVCLElBQUksR0FBRzdMLFFBQVEsQ0FBQ3ZzQixVQUFULENBQW9CbkIsQ0FBcEIsQ0FBYjs7QUFFQSxRQUFJdTVCLElBQUksS0FBS2IsY0FBVCxJQUEyQmEsSUFBSSxLQUFLZCxhQUF4QyxFQUF1RDtBQUNyRCxhQUFPejRCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBU0EsU0FBU3c1QixRQUFULENBQWtCMzVCLFNBQWxCLEVBQTZCNnRCLFFBQTdCLEVBQXVDK0wsR0FBdkMsRUFBNEM7QUFDMUN0RyxFQUFBQSxrQkFBa0IsQ0FBQ3pGLFFBQUQsRUFBVyxNQUFYLEVBQW1CLFFBQW5CLENBQWxCOztBQUVBLE1BQUkrTCxHQUFHLEtBQUs3NkIsU0FBWixFQUF1QjtBQUNyQnUwQixJQUFBQSxrQkFBa0IsQ0FBQ3NHLEdBQUQsRUFBTSxLQUFOLEVBQWEsUUFBYixDQUFsQjtBQUNEOztBQUVELFFBQU0zNUIsTUFBTSxHQUFHNHRCLFFBQVEsQ0FBQzV0QixNQUF4Qjs7QUFFQSxNQUFJQSxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNoQixXQUFPLEVBQVA7QUFDRDs7QUFFRCxRQUFNZzVCLE9BQU8sR0FBR2o1QixTQUFTLEtBQUssR0FBOUI7QUFDQSxNQUFJdzVCLFFBQVEsR0FBR3Y1QixNQUFmLENBZDBDLENBY25COztBQUV2QixRQUFNNDVCLFlBQVksR0FBR2hNLFFBQVEsQ0FBQ3ZzQixVQUFULENBQW9CckIsTUFBTSxHQUFHLENBQTdCLENBQXJCOztBQUVBLE1BQUk0NUIsWUFBWSxLQUFLakIsYUFBakIsSUFBa0MsQ0FBQ0ssT0FBRCxJQUFZWSxZQUFZLEtBQUtoQixjQUFuRSxFQUFtRjtBQUNqRlcsSUFBQUEsUUFBUTtBQUNULEdBcEJ5QyxDQW9CeEM7OztBQUdGLE1BQUl0NUIsU0FBUyxHQUFHLENBQUMsQ0FBakI7O0FBRUEsTUFBSSs0QixPQUFKLEVBQWE7QUFDWC80QixJQUFBQSxTQUFTLEdBQUcydEIsUUFBUSxDQUFDeUwsV0FBVCxDQUFxQnQ1QixTQUFyQixFQUFnQ3c1QixRQUFRLEdBQUcsQ0FBM0MsQ0FBWjtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0F0NUIsSUFBQUEsU0FBUyxHQUFHdTVCLHVCQUF1QixDQUFDNUwsUUFBRCxFQUFXMkwsUUFBUSxHQUFHLENBQXRCLENBQW5DLENBRkssQ0FFd0Q7O0FBRTdELFFBQUksQ0FBQ3Q1QixTQUFTLEtBQUssQ0FBZCxJQUFtQkEsU0FBUyxLQUFLLENBQUMsQ0FBbkMsS0FBeUMydEIsUUFBUSxDQUFDeFksTUFBVCxDQUFnQixDQUFoQixNQUF1QixHQUFoRSxJQUF1RXlqQixtQkFBbUIsQ0FBQ2pMLFFBQVEsQ0FBQ3ZzQixVQUFULENBQW9CLENBQXBCLENBQUQsQ0FBOUYsRUFBd0g7QUFDdEgsYUFBTyxFQUFQO0FBQ0Q7QUFDRixHQWxDeUMsQ0FrQ3hDOzs7QUFHRixRQUFNMmUsSUFBSSxHQUFHNE4sUUFBUSxDQUFDNWxCLEtBQVQsQ0FBZS9ILFNBQVMsR0FBRyxDQUEzQixFQUE4QnM1QixRQUE5QixDQUFiLENBckMwQyxDQXFDWTs7QUFFdEQsTUFBSUksR0FBRyxLQUFLNzZCLFNBQVosRUFBdUI7QUFDckIsV0FBT2toQixJQUFQO0FBQ0Q7O0FBRUQsU0FBT0EsSUFBSSxDQUFDNVksUUFBTCxDQUFjdXlCLEdBQWQsSUFBcUIzWixJQUFJLENBQUNoWSxLQUFMLENBQVcsQ0FBWCxFQUFjZ1ksSUFBSSxDQUFDaGdCLE1BQUwsR0FBYzI1QixHQUFHLENBQUMzNUIsTUFBaEMsQ0FBckIsR0FBK0RnZ0IsSUFBdEU7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxTQUFTNlosU0FBVCxDQUFtQjk1QixTQUFuQixFQUE4QjZ0QixRQUE5QixFQUF3QztBQUN0Q3lGLEVBQUFBLGtCQUFrQixDQUFDekYsUUFBRCxFQUFXLE1BQVgsRUFBbUIsUUFBbkIsQ0FBbEI7O0FBRUEsTUFBSUEsUUFBUSxDQUFDNXRCLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIsV0FBTyxHQUFQO0FBQ0QsR0FMcUMsQ0FLcEM7OztBQUdGLFFBQU04NUIsU0FBUyxHQUFHLzVCLFNBQVMsS0FBSyxJQUFoQzs7QUFFQSxNQUFJKzVCLFNBQUosRUFBZTtBQUNibE0sSUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUMzdkIsT0FBVCxDQUFpQixLQUFqQixFQUF3QjhCLFNBQXhCLENBQVg7QUFDRDs7QUFFRCxRQUFNZzZCLFVBQVUsR0FBR25NLFFBQVEsQ0FBQ3ptQixVQUFULENBQW9CcEgsU0FBcEIsQ0FBbkIsQ0Fkc0MsQ0FjYTs7QUFFbkQsUUFBTWk2QixLQUFLLEdBQUdELFVBQVUsSUFBSUQsU0FBZCxJQUEyQmxNLFFBQVEsQ0FBQzV0QixNQUFULEdBQWtCLENBQTdDLElBQWtENHRCLFFBQVEsQ0FBQ3hZLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsSUFBdkY7QUFDQSxRQUFNZ2tCLFdBQVcsR0FBR3hMLFFBQVEsQ0FBQ3htQixRQUFULENBQWtCckgsU0FBbEIsQ0FBcEI7QUFDQSxRQUFNazZCLEtBQUssR0FBR3JNLFFBQVEsQ0FBQzF1QixLQUFULENBQWVhLFNBQWYsQ0FBZDtBQUNBLFFBQU1rUCxNQUFNLEdBQUcsRUFBZjs7QUFFQSxPQUFLLE1BQU1pckIsT0FBWCxJQUFzQkQsS0FBdEIsRUFBNkI7QUFDM0IsUUFBSUMsT0FBTyxDQUFDbDZCLE1BQVIsS0FBbUIsQ0FBbkIsSUFBd0JrNkIsT0FBTyxLQUFLLEdBQXhDLEVBQTZDO0FBQzNDLFVBQUlBLE9BQU8sS0FBSyxJQUFoQixFQUFzQjtBQUNwQmpyQixRQUFBQSxNQUFNLENBQUMrUyxHQUFQLEdBRG9CLENBQ047QUFDZixPQUZELE1BRU87QUFDTC9TLFFBQUFBLE1BQU0sQ0FBQzFQLElBQVAsQ0FBWTI2QixPQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELE1BQUlDLFVBQVUsR0FBR0osVUFBVSxHQUFHaDZCLFNBQUgsR0FBZSxFQUExQztBQUNBbzZCLEVBQUFBLFVBQVUsSUFBSWxyQixNQUFNLENBQUNwUCxJQUFQLENBQVlFLFNBQVosQ0FBZDs7QUFFQSxNQUFJcTVCLFdBQUosRUFBaUI7QUFDZmUsSUFBQUEsVUFBVSxJQUFJcDZCLFNBQWQ7QUFDRDs7QUFFRCxNQUFJaTZCLEtBQUosRUFBVztBQUNURyxJQUFBQSxVQUFVLEdBQUcsT0FBT0EsVUFBcEI7QUFDRDs7QUFFRCxTQUFPQSxVQUFQO0FBQ0Q7QUFDRDs7Ozs7OztBQU9BLFNBQVNDLGFBQVQsQ0FBdUJGLE9BQXZCLEVBQWdDO0FBQzlCLE1BQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixVQUFNLElBQUkzeUIsU0FBSixDQUFlLG1DQUFrQzJ5QixPQUFRLEVBQXpELENBQU47QUFDRDtBQUNGO0FBQ0Q7Ozs7Ozs7Ozs7O0FBV0EsU0FBU0csTUFBVCxDQUFnQnQ2QixTQUFoQixFQUEyQnU2QixLQUEzQixFQUFrQztBQUNoQyxRQUFNcnJCLE1BQU0sR0FBRyxFQUFmLENBRGdDLENBQ2I7O0FBRW5CLE9BQUssTUFBTWlyQixPQUFYLElBQXNCSSxLQUF0QixFQUE2QjtBQUMzQkYsSUFBQUEsYUFBYSxDQUFDRixPQUFELENBQWI7O0FBRUEsUUFBSUEsT0FBTyxDQUFDbDZCLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEJpUCxNQUFBQSxNQUFNLENBQUMxUCxJQUFQLENBQVkyNkIsT0FBWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT0wsU0FBUyxDQUFDOTVCLFNBQUQsRUFBWWtQLE1BQU0sQ0FBQ3BQLElBQVAsQ0FBWUUsU0FBWixDQUFaLENBQWhCO0FBQ0Q7QUFDRDs7Ozs7Ozs7O0FBU0EsU0FBU2d1QixPQUFULENBQWlCaHVCLFNBQWpCLEVBQTRCdTZCLEtBQTVCLEVBQW1DO0FBQ2pDLE1BQUlDLFFBQVEsR0FBRyxFQUFmO0FBQ0EsTUFBSUMsT0FBTyxHQUFHLEtBQWQ7QUFDQSxRQUFNeEIsT0FBTyxHQUFHajVCLFNBQVMsS0FBSyxHQUE5QixDQUhpQyxDQUdFOztBQUVuQyxPQUFLLElBQUlHLENBQUMsR0FBR282QixLQUFLLENBQUN0NkIsTUFBTixHQUFlLENBQTVCLEVBQStCRSxDQUFDLElBQUksQ0FBcEMsRUFBdUNBLENBQUMsRUFBeEMsRUFBNEM7QUFDMUMsVUFBTWc2QixPQUFPLEdBQUdJLEtBQUssQ0FBQ3A2QixDQUFELENBQXJCO0FBQ0FrNkIsSUFBQUEsYUFBYSxDQUFDRixPQUFELENBQWI7O0FBRUEsUUFBSUEsT0FBTyxDQUFDbDZCLE1BQVIsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEIsZUFEd0IsQ0FDZDtBQUNYOztBQUVEdTZCLElBQUFBLFFBQVEsR0FBR0wsT0FBTyxHQUFHbjZCLFNBQVYsR0FBc0J3NkIsUUFBakMsQ0FSMEMsQ0FRQzs7QUFFM0MsUUFBSXhCLFVBQVUsQ0FBQ0MsT0FBRCxFQUFVa0IsT0FBVixDQUFkLEVBQWtDO0FBQ2hDO0FBQ0FNLE1BQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0E7QUFDRDtBQUNGLEdBcEJnQyxDQW9CL0I7OztBQUdGLE1BQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1pELElBQUFBLFFBQVEsR0FBRzNpQixPQUFPLENBQUN5YyxHQUFSLEtBQWdCdDBCLFNBQWhCLEdBQTRCdzZCLFFBQXZDO0FBQ0Q7O0FBRUQsUUFBTUosVUFBVSxHQUFHTixTQUFTLENBQUM5NUIsU0FBRCxFQUFZdzZCLFFBQVosQ0FBNUI7O0FBRUEsTUFBSUosVUFBVSxDQUFDL2tCLE1BQVgsQ0FBa0Ira0IsVUFBVSxDQUFDbjZCLE1BQVgsR0FBb0IsQ0FBdEMsTUFBNkNELFNBQWpELEVBQTREO0FBQzFEO0FBQ0E7QUFDQSxRQUFJLENBQUNpNUIsT0FBRCxJQUFZbUIsVUFBVSxDQUFDbjZCLE1BQVgsS0FBc0IsQ0FBbEMsSUFBdUNtNkIsVUFBVSxDQUFDL2tCLE1BQVgsQ0FBa0IsQ0FBbEIsTUFBeUIsR0FBaEUsSUFBdUV5akIsbUJBQW1CLENBQUNzQixVQUFVLENBQUM5NEIsVUFBWCxDQUFzQixDQUF0QixDQUFELENBQTlGLEVBQTBIO0FBQ3hILGFBQU84NEIsVUFBUDtBQUNELEtBTHlELENBS3hEOzs7QUFHRixXQUFPQSxVQUFVLENBQUNueUIsS0FBWCxDQUFpQixDQUFqQixFQUFvQm15QixVQUFVLENBQUNuNkIsTUFBWCxHQUFvQixDQUF4QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBT202QixVQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsU0FBU00sUUFBVCxDQUFrQjE2QixTQUFsQixFQUE2QnNLLElBQTdCLEVBQW1DcXdCLEVBQW5DLEVBQXVDO0FBQ3JDckgsRUFBQUEsa0JBQWtCLENBQUNocEIsSUFBRCxFQUFPLE1BQVAsRUFBZSxRQUFmLENBQWxCO0FBQ0FncEIsRUFBQUEsa0JBQWtCLENBQUNxSCxFQUFELEVBQUssSUFBTCxFQUFXLFFBQVgsQ0FBbEI7O0FBRUEsTUFBSXJ3QixJQUFJLEtBQUtxd0IsRUFBYixFQUFpQjtBQUNmLFdBQU8sRUFBUDtBQUNEOztBQUVEcndCLEVBQUFBLElBQUksR0FBRzBqQixPQUFPLENBQUNodUIsU0FBRCxFQUFZLENBQUNzSyxJQUFELENBQVosQ0FBZDtBQUNBcXdCLEVBQUFBLEVBQUUsR0FBRzNNLE9BQU8sQ0FBQ2h1QixTQUFELEVBQVksQ0FBQzI2QixFQUFELENBQVosQ0FBWjs7QUFFQSxNQUFJcndCLElBQUksS0FBS3F3QixFQUFiLEVBQWlCO0FBQ2YsV0FBTyxFQUFQO0FBQ0QsR0Fib0MsQ0FhbkM7QUFDRjtBQUNBOzs7QUFHQSxNQUFJQyxPQUFPLEdBQUcsQ0FBZDtBQUNBLE1BQUlDLGFBQWEsR0FBRyxFQUFwQjs7QUFFQSxTQUFPLElBQVAsRUFBYTtBQUNYLFFBQUlGLEVBQUUsQ0FBQ3Z6QixVQUFILENBQWNrRCxJQUFkLENBQUosRUFBeUI7QUFDdkI7QUFDQXV3QixNQUFBQSxhQUFhLEdBQUdGLEVBQUUsQ0FBQzF5QixLQUFILENBQVNxQyxJQUFJLENBQUNySyxNQUFkLENBQWhCO0FBQ0E7QUFDRCxLQUxVLENBS1Q7OztBQUdGcUssSUFBQUEsSUFBSSxHQUFHNnVCLE9BQU8sQ0FBQ241QixTQUFELEVBQVlzSyxJQUFaLENBQWQ7QUFDQXN3QixJQUFBQSxPQUFPO0FBQ1IsR0EvQm9DLENBK0JuQzs7O0FBR0YsTUFBSUMsYUFBYSxDQUFDNTZCLE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUI0NkIsSUFBQUEsYUFBYSxHQUFHQSxhQUFhLENBQUM1eUIsS0FBZCxDQUFvQixDQUFwQixDQUFoQjtBQUNEOztBQUVELFNBQU8sQ0FBQyxPQUFPakksU0FBUixFQUFtQjhmLE1BQW5CLENBQTBCOGEsT0FBMUIsSUFBcUNDLGFBQTVDO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLFNBQVNwSyxLQUFULENBQWV6d0IsU0FBZixFQUEwQjZ0QixRQUExQixFQUFvQztBQUNsQ3lGLEVBQUFBLGtCQUFrQixDQUFDekYsUUFBRCxFQUFXLE1BQVgsRUFBbUIsUUFBbkIsQ0FBbEI7QUFDQSxRQUFNM2UsTUFBTSxHQUFHO0FBQ2I0ckIsSUFBQUEsSUFBSSxFQUFFLEVBRE87QUFFYjlRLElBQUFBLEdBQUcsRUFBRSxFQUZRO0FBR2IvSixJQUFBQSxJQUFJLEVBQUUsRUFITztBQUliMlosSUFBQUEsR0FBRyxFQUFFLEVBSlE7QUFLYjEzQixJQUFBQSxJQUFJLEVBQUUsRUFMTyxFQUFmOztBQU9BLFFBQU1qQyxNQUFNLEdBQUc0dEIsUUFBUSxDQUFDNXRCLE1BQXhCOztBQUVBLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCO0FBQ2hCLFdBQU9pUCxNQUFQO0FBQ0QsR0FiaUMsQ0FhaEM7OztBQUdGQSxFQUFBQSxNQUFNLENBQUMrUSxJQUFQLEdBQWMwWixRQUFRLENBQUMzNUIsU0FBRCxFQUFZNnRCLFFBQVosQ0FBdEI7QUFDQTNlLEVBQUFBLE1BQU0sQ0FBQzBxQixHQUFQLEdBQWFMLE9BQU8sQ0FBQ3Y1QixTQUFELEVBQVlrUCxNQUFNLENBQUMrUSxJQUFuQixDQUFwQjtBQUNBLFFBQU04YSxVQUFVLEdBQUc3ckIsTUFBTSxDQUFDK1EsSUFBUCxDQUFZaGdCLE1BQS9CO0FBQ0FpUCxFQUFBQSxNQUFNLENBQUNoTixJQUFQLEdBQWNnTixNQUFNLENBQUMrUSxJQUFQLENBQVloWSxLQUFaLENBQWtCLENBQWxCLEVBQXFCOHlCLFVBQVUsR0FBRzdyQixNQUFNLENBQUMwcUIsR0FBUCxDQUFXMzVCLE1BQTdDLENBQWQ7QUFDQSxRQUFNKzZCLFVBQVUsR0FBR0QsVUFBVSxLQUFLLENBQWYsR0FBbUIsQ0FBbkIsR0FBdUJBLFVBQVUsR0FBRyxDQUF2RDtBQUNBN3JCLEVBQUFBLE1BQU0sQ0FBQzhhLEdBQVAsR0FBYTZELFFBQVEsQ0FBQzVsQixLQUFULENBQWUsQ0FBZixFQUFrQjRsQixRQUFRLENBQUM1dEIsTUFBVCxHQUFrQis2QixVQUFwQyxDQUFiLENBckJrQyxDQXFCNEI7O0FBRTlELFFBQU1DLGFBQWEsR0FBR3BOLFFBQVEsQ0FBQ3ZzQixVQUFULENBQW9CLENBQXBCLENBQXRCLENBdkJrQyxDQXVCWTs7QUFFOUMsTUFBSTI1QixhQUFhLEtBQUtyQyxhQUF0QixFQUFxQztBQUNuQzFwQixJQUFBQSxNQUFNLENBQUM0ckIsSUFBUCxHQUFjLEdBQWQ7QUFDQSxXQUFPNXJCLE1BQVA7QUFDRCxHQTVCaUMsQ0E0QmhDOzs7QUFHRixNQUFJbFAsU0FBUyxLQUFLLEdBQWxCLEVBQXVCO0FBQ3JCLFdBQU9rUCxNQUFQO0FBQ0QsR0FqQ2lDLENBaUNoQzs7O0FBR0YsTUFBSStyQixhQUFhLEtBQUtwQyxjQUF0QixFQUFzQztBQUNwQztBQUNBO0FBQ0EzcEIsSUFBQUEsTUFBTSxDQUFDNHJCLElBQVAsR0FBYyxJQUFkO0FBQ0EsV0FBTzVyQixNQUFQO0FBQ0QsR0F6Q2lDLENBeUNoQzs7O0FBR0YsTUFBSWpQLE1BQU0sR0FBRyxDQUFULElBQWM2NEIsbUJBQW1CLENBQUNtQyxhQUFELENBQWpDLElBQW9EcE4sUUFBUSxDQUFDeFksTUFBVCxDQUFnQixDQUFoQixNQUF1QixHQUEvRSxFQUFvRjtBQUNsRixRQUFJcFYsTUFBTSxHQUFHLENBQWIsRUFBZ0I7QUFDZDtBQUNBLFlBQU1pN0IsYUFBYSxHQUFHck4sUUFBUSxDQUFDdnNCLFVBQVQsQ0FBb0IsQ0FBcEIsQ0FBdEI7O0FBRUEsVUFBSTQ1QixhQUFhLEtBQUt0QyxhQUFsQixJQUFtQ3NDLGFBQWEsS0FBS3JDLGNBQXpELEVBQXlFO0FBQ3ZFM3BCLFFBQUFBLE1BQU0sQ0FBQzRyQixJQUFQLEdBQWNqTixRQUFRLENBQUM1bEIsS0FBVCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZDtBQUNBLGVBQU9pSCxNQUFQO0FBQ0Q7QUFDRixLQVRpRixDQVNoRjs7O0FBR0ZBLElBQUFBLE1BQU0sQ0FBQzRyQixJQUFQLEdBQWNqTixRQUFRLENBQUM1bEIsS0FBVCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZDtBQUNEOztBQUVELFNBQU9pSCxNQUFQO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsU0FBU2lzQixRQUFULENBQWtCbjdCLFNBQWxCLEVBQTZCbzdCLFVBQTdCLEVBQXlDO0FBQ3ZDOUgsRUFBQUEsa0JBQWtCLENBQUM4SCxVQUFELEVBQWEsWUFBYixFQUEyQixRQUEzQixDQUFsQjtBQUNBLFFBQU1uYixJQUFJLEdBQUdtYixVQUFVLENBQUNuYixJQUFYLElBQW9CLEdBQUVtYixVQUFVLENBQUNsNUIsSUFBWCxJQUFtQixFQUFHLEdBQUVrNUIsVUFBVSxDQUFDeEIsR0FBWCxJQUFrQixFQUFHLEVBQWhGLENBRnVDLENBRTRDO0FBQ25GOztBQUVBLE1BQUksQ0FBQ3dCLFVBQVUsQ0FBQ3BSLEdBQVosSUFBbUJvUixVQUFVLENBQUNwUixHQUFYLEtBQW1Cb1IsVUFBVSxDQUFDTixJQUFyRCxFQUEyRDtBQUN6RCxXQUFRLEdBQUVNLFVBQVUsQ0FBQ04sSUFBWCxJQUFtQixFQUFHLEdBQUU3YSxJQUFLLEVBQXZDO0FBQ0QsR0FQc0MsQ0FPckM7OztBQUdGLFNBQVEsR0FBRW1iLFVBQVUsQ0FBQ3BSLEdBQUksR0FBRWhxQixTQUFVLEdBQUVpZ0IsSUFBSyxFQUE1QztBQUNEO0FBQ0Q7Ozs7Ozs7OztBQVNBLFNBQVNvYixnQkFBVCxDQUEwQnhOLFFBQTFCLEVBQW9DO0FBQ2xDLE1BQUksT0FBT0EsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQyxXQUFPQSxRQUFQO0FBQ0Q7O0FBRUQsTUFBSUEsUUFBUSxDQUFDNXRCLE1BQVQsS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekIsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQsUUFBTXE3QixZQUFZLEdBQUd0TixPQUFPLENBQUMsSUFBRCxFQUFPLENBQUNILFFBQUQsQ0FBUCxDQUE1QjtBQUNBLFFBQU01dEIsTUFBTSxHQUFHcTdCLFlBQVksQ0FBQ3I3QixNQUE1Qjs7QUFFQSxNQUFJQSxNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUNkO0FBQ0EsV0FBTzR0QixRQUFQO0FBQ0Q7O0FBRUQsUUFBTW9OLGFBQWEsR0FBR0ssWUFBWSxDQUFDaDZCLFVBQWIsQ0FBd0IsQ0FBeEIsQ0FBdEIsQ0FqQmtDLENBaUJnQjs7QUFFbEQsTUFBSTI1QixhQUFhLEtBQUtwQyxjQUFsQixJQUFvQ3lDLFlBQVksQ0FBQ2ptQixNQUFiLENBQW9CLENBQXBCLE1BQTJCLElBQW5FLEVBQXlFO0FBQ3ZFO0FBQ0EsUUFBSXBWLE1BQU0sSUFBSSxDQUFkLEVBQWlCO0FBQ2YsWUFBTWk1QixTQUFTLEdBQUdvQyxZQUFZLENBQUNqbUIsTUFBYixDQUFvQixDQUFwQixDQUFsQjs7QUFFQSxVQUFJNmpCLFNBQVMsS0FBSyxHQUFkLElBQXFCQSxTQUFTLEtBQUssR0FBdkMsRUFBNEM7QUFDMUMsZUFBT3JMLFFBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8saUJBQWlCeU4sWUFBWSxDQUFDcnpCLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBeEI7QUFDRCxHQVhELE1BV08sSUFBSTZ3QixtQkFBbUIsQ0FBQ21DLGFBQUQsQ0FBbkIsSUFBc0NLLFlBQVksQ0FBQ2ptQixNQUFiLENBQW9CLENBQXBCLE1BQTJCLEdBQXJFLEVBQTBFO0FBQy9FLFdBQU8sWUFBWWltQixZQUFuQjtBQUNEOztBQUVELFNBQU96TixRQUFQO0FBQ0Q7O0FBRUQsTUFBTTBOLFNBQVMsR0FBRztBQUNoQkMsRUFBQUEsR0FBRyxFQUFFLElBRFc7QUFFaEJDLEVBQUFBLFNBQVMsRUFBRSxHQUZLO0FBR2hCOUIsRUFBQUEsUUFBUSxFQUFFLFVBQVU5TCxRQUFWLEVBQW9CK0wsR0FBcEIsRUFBeUI7QUFDakMsV0FBT0QsUUFBUSxDQUFDLEtBQUs2QixHQUFOLEVBQVczTixRQUFYLEVBQXFCK0wsR0FBckIsQ0FBZjtBQUNELEdBTGU7QUFNaEJFLEVBQUFBLFNBQVMsRUFBRSxVQUFVak0sUUFBVixFQUFvQjtBQUM3QixXQUFPaU0sU0FBUyxDQUFDLEtBQUswQixHQUFOLEVBQVczTixRQUFYLENBQWhCO0FBQ0QsR0FSZTtBQVNoQi90QixFQUFBQSxJQUFJLEVBQUUsVUFBVSxHQUFHeTZCLEtBQWIsRUFBb0I7QUFDeEIsV0FBT0QsTUFBTSxDQUFDLEtBQUtrQixHQUFOLEVBQVdqQixLQUFYLENBQWI7QUFDRCxHQVhlO0FBWWhCaEIsRUFBQUEsT0FBTyxFQUFFLFVBQVUxTCxRQUFWLEVBQW9CO0FBQzNCLFdBQU8wTCxPQUFPLENBQUMsS0FBS2lDLEdBQU4sRUFBVzNOLFFBQVgsQ0FBZDtBQUNELEdBZGU7QUFlaEJzTCxFQUFBQSxPQUFPLEVBQUUsVUFBVXRMLFFBQVYsRUFBb0I7QUFDM0IsV0FBT3NMLE9BQU8sQ0FBQyxLQUFLcUMsR0FBTixFQUFXM04sUUFBWCxDQUFkO0FBQ0QsR0FqQmU7QUFrQmhCbUwsRUFBQUEsVUFBVSxFQUFFLFVBQVVuTCxRQUFWLEVBQW9CO0FBQzlCLFdBQU9tTCxVQUFVLENBQUMsS0FBRCxFQUFRbkwsUUFBUixDQUFqQjtBQUNELEdBcEJlO0FBcUJoQjZNLEVBQUFBLFFBQVEsRUFBRSxVQUFVcHdCLElBQVYsRUFBZ0Jxd0IsRUFBaEIsRUFBb0I7QUFDNUIsV0FBT0QsUUFBUSxDQUFDLEtBQUtjLEdBQU4sRUFBV2x4QixJQUFYLEVBQWlCcXdCLEVBQWpCLENBQWY7QUFDRCxHQXZCZTtBQXdCaEIzTSxFQUFBQSxPQUFPLEVBQUUsVUFBVSxHQUFHdU0sS0FBYixFQUFvQjtBQUMzQixXQUFPdk0sT0FBTyxDQUFDLEtBQUt3TixHQUFOLEVBQVdqQixLQUFYLENBQWQ7QUFDRCxHQTFCZTtBQTJCaEI5SixFQUFBQSxLQUFLLEVBQUUsVUFBVTVDLFFBQVYsRUFBb0I7QUFDekIsV0FBTzRDLEtBQUssQ0FBQyxLQUFLK0ssR0FBTixFQUFXM04sUUFBWCxDQUFaO0FBQ0QsR0E3QmU7QUE4QmhCL21CLEVBQUFBLE1BQU0sRUFBRSxVQUFVczBCLFVBQVYsRUFBc0I7QUFDNUIsV0FBT0QsUUFBUSxDQUFDLEtBQUtLLEdBQU4sRUFBV0osVUFBWCxDQUFmO0FBQ0QsR0FoQ2U7QUFpQ2hCQyxFQUFBQSxnQkFBZ0IsRUFBRUEsZ0JBakNGLEVBQWxCOztBQW1DQSxNQUFNSyxTQUFTLEdBQUc7QUFDaEJGLEVBQUFBLEdBQUcsRUFBRSxHQURXO0FBRWhCQyxFQUFBQSxTQUFTLEVBQUUsR0FGSztBQUdoQjlCLEVBQUFBLFFBQVEsRUFBRSxVQUFVOUwsUUFBVixFQUFvQitMLEdBQXBCLEVBQXlCO0FBQ2pDLFdBQU9ELFFBQVEsQ0FBQyxLQUFLNkIsR0FBTixFQUFXM04sUUFBWCxFQUFxQitMLEdBQXJCLENBQWY7QUFDRCxHQUxlO0FBTWhCRSxFQUFBQSxTQUFTLEVBQUUsVUFBVWpNLFFBQVYsRUFBb0I7QUFDN0IsV0FBT2lNLFNBQVMsQ0FBQyxLQUFLMEIsR0FBTixFQUFXM04sUUFBWCxDQUFoQjtBQUNELEdBUmU7QUFTaEIvdEIsRUFBQUEsSUFBSSxFQUFFLFVBQVUsR0FBR3k2QixLQUFiLEVBQW9CO0FBQ3hCLFdBQU9ELE1BQU0sQ0FBQyxLQUFLa0IsR0FBTixFQUFXakIsS0FBWCxDQUFiO0FBQ0QsR0FYZTtBQVloQmhCLEVBQUFBLE9BQU8sRUFBRSxVQUFVMUwsUUFBVixFQUFvQjtBQUMzQixXQUFPMEwsT0FBTyxDQUFDLEtBQUtpQyxHQUFOLEVBQVczTixRQUFYLENBQWQ7QUFDRCxHQWRlO0FBZWhCc0wsRUFBQUEsT0FBTyxFQUFFLFVBQVV0TCxRQUFWLEVBQW9CO0FBQzNCLFdBQU9zTCxPQUFPLENBQUMsS0FBS3FDLEdBQU4sRUFBVzNOLFFBQVgsQ0FBZDtBQUNELEdBakJlO0FBa0JoQm1MLEVBQUFBLFVBQVUsRUFBRSxVQUFVbkwsUUFBVixFQUFvQjtBQUM5QixXQUFPbUwsVUFBVSxDQUFDLElBQUQsRUFBT25MLFFBQVAsQ0FBakI7QUFDRCxHQXBCZTtBQXFCaEI2TSxFQUFBQSxRQUFRLEVBQUUsVUFBVXB3QixJQUFWLEVBQWdCcXdCLEVBQWhCLEVBQW9CO0FBQzVCLFdBQU9ELFFBQVEsQ0FBQyxLQUFLYyxHQUFOLEVBQVdseEIsSUFBWCxFQUFpQnF3QixFQUFqQixDQUFmO0FBQ0QsR0F2QmU7QUF3QmhCM00sRUFBQUEsT0FBTyxFQUFFLFVBQVUsR0FBR3VNLEtBQWIsRUFBb0I7QUFDM0IsV0FBT3ZNLE9BQU8sQ0FBQyxLQUFLd04sR0FBTixFQUFXakIsS0FBWCxDQUFkO0FBQ0QsR0ExQmU7QUEyQmhCOUosRUFBQUEsS0FBSyxFQUFFLFVBQVU1QyxRQUFWLEVBQW9CO0FBQ3pCLFdBQU80QyxLQUFLLENBQUMsS0FBSytLLEdBQU4sRUFBVzNOLFFBQVgsQ0FBWjtBQUNELEdBN0JlO0FBOEJoQi9tQixFQUFBQSxNQUFNLEVBQUUsVUFBVXMwQixVQUFWLEVBQXNCO0FBQzVCLFdBQU9ELFFBQVEsQ0FBQyxLQUFLSyxHQUFOLEVBQVdKLFVBQVgsQ0FBZjtBQUNELEdBaENlO0FBaUNoQkMsRUFBQUEsZ0JBQWdCLEVBQUUsVUFBVXhOLFFBQVYsRUFBb0I7QUFDcEMsV0FBT0EsUUFBUCxDQURvQyxDQUNuQjtBQUNsQixHQW5DZSxFQUFsQjs7QUFxQ0EsTUFBTVYsSUFBSSxHQUFHdU8sU0FBYjtBQUNBdk8sSUFBSSxDQUFDd08sS0FBTCxHQUFhSixTQUFiO0FBQ0FwTyxJQUFJLENBQUN5TyxLQUFMLEdBQWFGLFNBQWI7O0FBRUEsTUFBTUcsY0FBYyxHQUFHO0FBQ3JCQyxFQUFBQSxnQkFBZ0IsRUFBRSxDQURHO0FBRXJCaEgsRUFBQUEsTUFBTSxFQUFFLEVBRmE7QUFHckJpSCxFQUFBQSxLQUFLLEVBQUU7QUFDTEMsSUFBQUEsS0FBSyxFQUFFLENBREY7QUFFTEMsSUFBQUEsTUFBTSxFQUFFLEVBRkg7QUFHTEMsSUFBQUEsVUFBVSxFQUFFLEVBSFA7QUFJTEMsSUFBQUEsYUFBYSxFQUFFLEVBSlY7QUFLTEMsSUFBQUEsWUFBWSxFQUFFLEVBTFQ7QUFNTEMsSUFBQUEsTUFBTSxFQUFFLEVBTkg7QUFPTEMsSUFBQUEsUUFBUSxFQUFFLEVBUEw7QUFRTEMsSUFBQUEsS0FBSyxFQUFFLENBUkY7QUFTTEMsSUFBQUEsT0FBTyxFQUFFLEVBVEo7QUFVTEMsSUFBQUEsS0FBSyxFQUFFLEVBVkY7QUFXTEMsSUFBQUEsU0FBUyxFQUFFLEVBWE47QUFZTEMsSUFBQUEsTUFBTSxFQUFFLEVBWkg7QUFhTEMsSUFBQUEsWUFBWSxFQUFFLEVBYlQ7QUFjTEMsSUFBQUEsWUFBWSxFQUFFLEVBZFQ7QUFlTEMsSUFBQUEsVUFBVSxFQUFFLEVBZlA7QUFnQkxDLElBQUFBLE9BQU8sRUFBRSxFQWhCSjtBQWlCTEMsSUFBQUEsWUFBWSxFQUFFLEVBakJUO0FBa0JMQyxJQUFBQSxJQUFJLEVBQUUsRUFsQkQ7QUFtQkxDLElBQUFBLE1BQU0sRUFBRSxFQW5CSDtBQW9CTEMsSUFBQUEsTUFBTSxFQUFFLEVBcEJIO0FBcUJMQyxJQUFBQSxNQUFNLEVBQUUsRUFyQkg7QUFzQkxDLElBQUFBLEtBQUssRUFBRSxFQXRCRjtBQXVCTEMsSUFBQUEsWUFBWSxFQUFFLEVBdkJUO0FBd0JMQyxJQUFBQSxLQUFLLEVBQUUsRUF4QkY7QUF5QkxDLElBQUFBLE1BQU0sRUFBRSxFQXpCSDtBQTBCTEMsSUFBQUEsV0FBVyxFQUFFLEVBMUJSO0FBMkJMQyxJQUFBQSxLQUFLLEVBQUUsQ0EzQkY7QUE0QkxDLElBQUFBLE1BQU0sRUFBRSxFQTVCSDtBQTZCTEMsSUFBQUEsR0FBRyxFQUFFLENBN0JBO0FBOEJMQyxJQUFBQSxPQUFPLEVBQUUsRUE5Qko7QUErQkxDLElBQUFBLE1BQU0sRUFBRSxFQS9CSDtBQWdDTEMsSUFBQUEsS0FBSyxFQUFFLEVBaENGO0FBaUNMQyxJQUFBQSxNQUFNLEVBQUUsRUFqQ0g7QUFrQ0xDLElBQUFBLE1BQU0sRUFBRSxFQWxDSDtBQW1DTEMsSUFBQUEsUUFBUSxFQUFFLEVBbkNMO0FBb0NMQyxJQUFBQSxTQUFTLEVBQUUsRUFwQ047QUFxQ0xDLElBQUFBLFlBQVksRUFBRSxFQXJDVDtBQXNDTEMsSUFBQUEsUUFBUSxFQUFFLEVBdENMO0FBdUNMQyxJQUFBQSxTQUFTLEVBQUUsRUF2Q047QUF3Q0xDLElBQUFBLFdBQVcsRUFBRSxFQXhDUjtBQXlDTEMsSUFBQUEsTUFBTSxFQUFFLEVBekNIO0FBMENMQyxJQUFBQSxPQUFPLEVBQUUsRUExQ0o7QUEyQ0xDLElBQUFBLE9BQU8sRUFBRSxFQTNDSjtBQTRDTEMsSUFBQUEsTUFBTSxFQUFFLEVBNUNIO0FBNkNMQyxJQUFBQSxNQUFNLEVBQUUsQ0E3Q0g7QUE4Q0xDLElBQUFBLE9BQU8sRUFBRSxDQTlDSjtBQStDTEMsSUFBQUEsTUFBTSxFQUFFLEVBL0NIO0FBZ0RMQyxJQUFBQSxPQUFPLEVBQUUsRUFoREo7QUFpRExDLElBQUFBLE1BQU0sRUFBRSxFQWpESDtBQWtETEMsSUFBQUEsTUFBTSxFQUFFLEVBbERIO0FBbURMQyxJQUFBQSxXQUFXLEVBQUUsRUFuRFI7QUFvRExDLElBQUFBLE1BQU0sRUFBRSxFQXBESDtBQXFETEMsSUFBQUEsS0FBSyxFQUFFLEVBckRGO0FBc0RMQyxJQUFBQSxNQUFNLEVBQUUsRUF0REg7QUF1RExDLElBQUFBLE1BQU0sRUFBRSxFQXZESDtBQXdETEMsSUFBQUEsUUFBUSxFQUFFLEVBeERMO0FBeURMQyxJQUFBQSxPQUFPLEVBQUUsRUF6REo7QUEwRExDLElBQUFBLFNBQVMsRUFBRSxFQTFETjtBQTJETEMsSUFBQUEsUUFBUSxFQUFFLEVBM0RMO0FBNERMQyxJQUFBQSxPQUFPLEVBQUUsRUE1REo7QUE2RExDLElBQUFBLE1BQU0sRUFBRSxFQTdESDtBQThETEMsSUFBQUEsS0FBSyxFQUFFLENBOURGO0FBK0RMQyxJQUFBQSxVQUFVLEVBQUUsR0EvRFA7QUFnRUxDLElBQUFBLFNBQVMsRUFBRSxFQWhFTjtBQWlFTEMsSUFBQUEsS0FBSyxFQUFFLENBakVGO0FBa0VMQyxJQUFBQSxLQUFLLEVBQUUsRUFsRUY7QUFtRUxDLElBQUFBLE1BQU0sRUFBRSxHQW5FSDtBQW9FTEMsSUFBQUEsZUFBZSxFQUFFLEVBcEVaO0FBcUVMQyxJQUFBQSxVQUFVLEVBQUUsRUFyRVA7QUFzRUxDLElBQUFBLE1BQU0sRUFBRSxFQXRFSDtBQXVFTEMsSUFBQUEsS0FBSyxFQUFFLEVBdkVGO0FBd0VMQyxJQUFBQSxNQUFNLEVBQUUsRUF4RUg7QUF5RUxDLElBQUFBLEtBQUssRUFBRSxDQXpFRjtBQTBFTEMsSUFBQUEsTUFBTSxFQUFFLEVBMUVIO0FBMkVMQyxJQUFBQSxLQUFLLEVBQUUsR0EzRUY7QUE0RUxDLElBQUFBLFNBQVMsRUFBRSxFQTVFTjtBQTZFTEMsSUFBQUEsT0FBTyxFQUFFLEVBN0VKO0FBOEVMQyxJQUFBQSxXQUFXLEVBQUUsRUE5RVI7QUErRUxDLElBQUFBLEtBQUssRUFBRSxFQS9FRixFQUhjOztBQW9GckJDLEVBQUFBLE9BQU8sRUFBRTtBQUNQQyxJQUFBQSxNQUFNLEVBQUUsQ0FERDtBQUVQQyxJQUFBQSxNQUFNLEVBQUUsQ0FGRDtBQUdQQyxJQUFBQSxPQUFPLEVBQUUsQ0FIRjtBQUlQQyxJQUFBQSxNQUFNLEVBQUUsQ0FKRDtBQUtQQyxJQUFBQSxPQUFPLEVBQUUsQ0FMRjtBQU1QQyxJQUFBQSxPQUFPLEVBQUUsQ0FORjtBQU9QQyxJQUFBQSxNQUFNLEVBQUUsQ0FQRDtBQVFQQyxJQUFBQSxNQUFNLEVBQUUsRUFSRDtBQVNQQyxJQUFBQSxNQUFNLEVBQUUsQ0FURDtBQVVQQyxJQUFBQSxPQUFPLEVBQUUsQ0FWRjtBQVdQQyxJQUFBQSxPQUFPLEVBQUUsRUFYRjtBQVlQQyxJQUFBQSxPQUFPLEVBQUUsRUFaRjtBQWFQQyxJQUFBQSxPQUFPLEVBQUUsRUFiRjtBQWNQQyxJQUFBQSxPQUFPLEVBQUUsRUFkRjtBQWVQQyxJQUFBQSxPQUFPLEVBQUUsRUFmRjtBQWdCUEMsSUFBQUEsT0FBTyxFQUFFLEVBaEJGO0FBaUJQQyxJQUFBQSxPQUFPLEVBQUUsRUFqQkY7QUFrQlBDLElBQUFBLE9BQU8sRUFBRSxFQWxCRjtBQW1CUEMsSUFBQUEsT0FBTyxFQUFFLEVBbkJGO0FBb0JQQyxJQUFBQSxPQUFPLEVBQUUsRUFwQkY7QUFxQlBDLElBQUFBLE9BQU8sRUFBRSxFQXJCRjtBQXNCUEMsSUFBQUEsT0FBTyxFQUFFLEVBdEJGO0FBdUJQQyxJQUFBQSxNQUFNLEVBQUUsRUF2QkQ7QUF3QlBDLElBQUFBLE9BQU8sRUFBRSxFQXhCRjtBQXlCUEMsSUFBQUEsT0FBTyxFQUFFLEVBekJGO0FBMEJQQyxJQUFBQSxTQUFTLEVBQUUsRUExQko7QUEyQlBDLElBQUFBLE9BQU8sRUFBRSxFQTNCRjtBQTRCUEMsSUFBQUEsUUFBUSxFQUFFLEVBNUJIO0FBNkJQQyxJQUFBQSxLQUFLLEVBQUUsRUE3QkE7QUE4QlBDLElBQUFBLE9BQU8sRUFBRSxFQTlCRjtBQStCUEMsSUFBQUEsTUFBTSxFQUFFLEVBL0JELEVBcEZZOztBQXFIckJDLEVBQUFBLFFBQVEsRUFBRTtBQUNSQyxJQUFBQSxZQUFZLEVBQUUsRUFETjtBQUVSQyxJQUFBQSxxQkFBcUIsRUFBRSxFQUZmO0FBR1JDLElBQUFBLGVBQWUsRUFBRSxDQUhUO0FBSVJDLElBQUFBLHFCQUFxQixFQUFFLENBQUMsQ0FKaEI7QUFLUkMsSUFBQUEsYUFBYSxFQUFFLENBQUMsRUFMUjtBQU1SQyxJQUFBQSxnQkFBZ0IsRUFBRSxDQUFDLEVBTlgsRUFySFcsRUFBdkI7O0FBNkhHOztBQUVILE1BQU1DLEVBQUUsR0FBRztBQUNUQyxFQUFBQSxHQUFHLEVBQUUsSUFESTtBQUVUM1AsRUFBQUEsSUFBSSxFQUFFLE1BQU0vYixPQUFPLENBQUMrYixJQUZYO0FBR1QzYyxFQUFBQSxTQUFTLEVBQUU0a0IsY0FIRjtBQUlUMkgsRUFBQUEsSUFBSSxFQUFFLE1BQU07QUFDVixVQUFNdlosS0FBSyxHQUFHOXNCLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZcW1DLGNBQTFCO0FBQ0EsVUFBTUMsS0FBSyxHQUFHLEVBQWQ7O0FBRUEsU0FBSyxJQUFJdmpDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4cEIsS0FBcEIsRUFBMkI5cEIsQ0FBQyxFQUE1QixFQUFnQztBQUM5QnVqQyxNQUFBQSxLQUFLLENBQUNsa0MsSUFBTixDQUFXO0FBQ1Rta0MsUUFBQUEsS0FBSyxFQUFFLFNBREU7QUFFVEMsUUFBQUEsS0FBSyxFQUFFLENBRkU7QUFHVEMsUUFBQUEsS0FBSyxFQUFFO0FBQ0x6UCxVQUFBQSxJQUFJLEVBQUUsQ0FERDtBQUVMMFAsVUFBQUEsSUFBSSxFQUFFLENBRkQ7QUFHTEMsVUFBQUEsR0FBRyxFQUFFLENBSEE7QUFJTEMsVUFBQUEsSUFBSSxFQUFFLENBSkQ7QUFLTEMsVUFBQUEsR0FBRyxFQUFFLENBTEEsRUFIRSxFQUFYOzs7QUFXRDs7QUFFRCxXQUFPUCxLQUFQO0FBQ0QsR0F2QlE7QUF3QlRRLEVBQUFBLFVBQVUsRUFBRSxNQUFNO0FBQ2hCO0FBQ0EsVUFBTWgxQixNQUFNLEdBQUcvUixFQUFFLENBQUM2TyxLQUFILENBQVNtNEIsa0JBQVQsRUFBZjs7QUFFQSxRQUFJajFCLE1BQU0sS0FBSy9SLEVBQUUsQ0FBQzZPLEtBQUgsQ0FBU280QixhQUF4QixFQUF1QztBQUNyQyxhQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQWpDUTtBQWtDVEMsRUFBQUEsT0FBTyxFQUFFLE1BQU1sbkMsRUFBRSxDQUFDQyxRQUFILENBQVlrbkMsZUFsQ2xCO0FBbUNUQyxFQUFBQSxXQUFXLEVBQUUsTUFBTSxDQW5DVjtBQW9DVDtBQUNBQyxFQUFBQSxPQUFPLEVBQUUsTUFBTXJuQyxFQUFFLENBQUMrbEIsVUFBSCxDQUFjdWhCLHdCQXJDcEI7QUFzQ1Q7QUFDQUMsRUFBQUEsUUFBUSxFQUFFLE1BQU12bkMsRUFBRSxDQUFDQyxRQUFILENBQVl1bkMsT0F2Q25CO0FBd0NUO0FBQ0FDLEVBQUFBLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBekNOO0FBMENUO0FBQ0FDLEVBQUFBLGlCQUFpQixFQUFFLE1BQU0sQ0FBRSxDQTNDbEI7QUE0Q1Q7QUFDQWhQLEVBQUFBLFFBQVEsRUFBRSxNQUFNaGUsT0FBTyxDQUFDZ2UsUUE3Q2Y7QUE4Q1RyZSxFQUFBQSxPQUFPLEVBQUUsTUFBTXJhLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZbzVCLE9BOUNsQjtBQStDVHNPLEVBQUFBLFdBQVcsRUFBRSxNQUFNLENBQUUsQ0EvQ1o7QUFnRFQ7O0FBRUE7Ozs7QUFJQUMsRUFBQUEsTUFBTSxFQUFFLE1BQU01bkMsRUFBRSxDQUFDK2xCLFVBQUgsQ0FBYzhoQixhQXREbkI7O0FBd0RUOzs7O0FBSUFDLEVBQUFBLFFBQVEsRUFBRSxNQUFNOW5DLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZOG5DLFdBNURuQjtBQTZEVDM5QixFQUFBQSxJQUFJLEVBQUUsTUFBTSxTQTdESDtBQThEVDs7QUFFQTs7OztBQUlBK3VCLEVBQUFBLE1BQU0sRUFBRSxNQUFNbjVCLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZazVCLE1BcEVqQjtBQXFFVDZPLEVBQUFBLFFBQVEsRUFBRSxNQUFNO0FBQ2Q7QUFDQSxXQUFPO0FBQ0xDLE1BQUFBLEdBQUcsRUFBRSxDQUFDLENBREQ7QUFFTEMsTUFBQUEsSUFBSSxFQUFFLENBQUMsQ0FGRjtBQUdMQyxNQUFBQSxRQUFRLEVBQUVub0MsRUFBRSxDQUFDQyxRQUFILENBQVlrb0MsUUFIakI7QUFJTGQsTUFBQUEsT0FBTyxFQUFFcm5DLEVBQUUsQ0FBQytsQixVQUFILENBQWN1aEIsd0JBSmxCO0FBS0xjLE1BQUFBLEtBQUssRUFBRSxJQUxGLEVBQVA7O0FBT0QsR0E5RVEsRUFBWDtBQStFRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNFakMsRUFBQUEsRUFBRSxDQUFDRSxJQUFILEdBQVUsTUFBTXJtQyxFQUFFLENBQUNDLFFBQUgsQ0FBWW9tQyxJQUFaLEVBQWhCOztBQUVBRixFQUFBQSxFQUFFLENBQUMvN0IsSUFBSCxHQUFVLE1BQU0sT0FBaEI7QUFDRDs7QUFFRCxNQUFNaStCLEdBQUcsR0FBRztBQUNWQyxFQUFBQSxNQUFNLEVBQUUsTUFBTSxLQURKO0FBRVZDLEVBQUFBLFVBQVUsRUFBRSxNQUFNO0FBQ2hCLFVBQU0sSUFBSXBuQyxLQUFKLENBQVUsbUNBQVYsQ0FBTjtBQUNELEdBSlM7QUFLVnFuQyxFQUFBQSxXQUFXLEVBQUUsTUFBTTtBQUNqQixVQUFNLElBQUlybkMsS0FBSixDQUFVLG9DQUFWLENBQU47QUFDRCxHQVBTLEVBQVo7OztBQVVBLE1BQU1zbkMsTUFBTSxHQUFHLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLEtBQTdCLEVBQW9DLEtBQXBDLEVBQTJDLEtBQTNDLEVBQWtELEtBQWxELEVBQXlELEtBQXpELEVBQWdFLEtBQWhFLEVBQXVFLEtBQXZFLEVBQThFLEtBQTlFLENBQWY7QUFDQSxNQUFNQyxJQUFJLEdBQUc7QUFDWC8rQixFQUFBQSxNQURXO0FBRVhzZixFQUFBQSxpQkFGVztBQUdYOVAsRUFBQUEsT0FIVztBQUlYM1csRUFBQUEsT0FBTyxFQUFFRCxLQUFLLENBQUNDLE9BSko7QUFLWG1tQyxFQUFBQSxTQUFTLEVBQUU5b0MsS0FBSyxJQUFJLE9BQU9BLEtBQVAsS0FBaUIsU0FMMUI7QUFNWGMsRUFBQUEsUUFBUSxFQUFFNFksWUFBWSxDQUFDdE4sTUFBYixDQUFvQnRMLFFBTm5CO0FBT1hrRSxFQUFBQSxVQUFVLEVBQUVoRixLQUFLLElBQUksT0FBT0EsS0FBUCxLQUFpQixVQVAzQjtBQVFYK29DLEVBQUFBLE1BQU0sRUFBRS9vQyxLQUFLLElBQUlBLEtBQUssS0FBSyxJQVJoQjtBQVNYZ3BDLEVBQUFBLGlCQUFpQixFQUFFaHBDLEtBQUssSUFBSUEsS0FBSyxLQUFLK0IsU0FBVixJQUF1Qi9CLEtBQUssS0FBSyxJQVRsRDtBQVVYaXBDLEVBQUFBLFFBQVEsRUFBRWpwQyxLQUFLLElBQUksT0FBT0EsS0FBUCxLQUFpQixRQVZ6QjtBQVdYK0UsRUFBQUEsUUFBUSxFQUFFL0UsS0FBSyxJQUFJQSxLQUFLLEtBQUssSUFBVixJQUFrQixPQUFPQSxLQUFQLEtBQWlCLFFBWDNDO0FBWVhrcEMsRUFBQUEsV0FBVyxFQUFFbHBDLEtBQUssSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQVAsS0FBaUIsVUFBOUMsSUFBNERBLEtBQUssS0FBSyxJQVpqRjtBQWFYbXBDLEVBQUFBLFFBQVEsRUFBRW5wQyxLQUFLLElBQUksT0FBT0EsS0FBUCxLQUFpQixRQWJ6QjtBQWNYb3BDLEVBQUFBLFFBQVEsRUFBRXBwQyxLQUFLLElBQUksT0FBT0EsS0FBUCxLQUFpQixRQWR6QjtBQWVYcXBDLEVBQUFBLFdBQVcsRUFBRXJwQyxLQUFLLElBQUlBLEtBQUssS0FBSytCLFNBZnJCO0FBZ0JYa0YsRUFBQUEsUUFBUSxFQUFFQSxRQWhCQztBQWlCWGIsRUFBQUEsTUFBTSxFQUFFQSxNQWpCRztBQWtCWGpGLEVBQUFBLE9BQU8sRUFBRUMsQ0FBQyxJQUFJdEIsTUFBTSxDQUFDNEUsU0FBUCxDQUFpQlMsUUFBakIsQ0FBMEI3QixJQUExQixDQUErQmxDLENBQS9CLE1BQXNDLGdCQUF0QyxJQUEwREEsQ0FBQyxZQUFZRSxLQWxCMUU7QUFtQlhzcEIsRUFBQUEsR0FBRyxFQUFFaFUsTUFBTSxJQUFJO0FBQ2IsVUFBTWtKLElBQUksR0FBRyxJQUFJMUUsSUFBSixFQUFiO0FBQ0EsVUFBTWdTLElBQUksR0FBSSxHQUFFdE4sSUFBSSxDQUFDd3BCLFFBQUwsR0FBZ0Jua0MsUUFBaEIsR0FBMkIraUIsUUFBM0IsQ0FBb0MsQ0FBcEMsRUFBdUMsR0FBdkMsQ0FBNEMsSUFBR3BJLElBQUksQ0FBQ3lwQixVQUFMLEdBQWtCcGtDLFFBQWxCLEdBQTZCK2lCLFFBQTdCLENBQXNDLENBQXRDLEVBQXlDLEdBQXpDLENBQThDLElBQUdwSSxJQUFJLENBQUMwcEIsVUFBTCxHQUFrQnJrQyxRQUFsQixHQUE2QitpQixRQUE3QixDQUFzQyxDQUF0QyxFQUF5QyxHQUF6QyxDQUE4QyxFQUE5SixDQUZhLENBRW9KOztBQUVqSzJGLElBQUFBLE9BQU8sQ0FBQ2pELEdBQVIsQ0FBYSxHQUFFOUssSUFBSSxDQUFDMnBCLE9BQUwsRUFBZSxJQUFHYixNQUFNLENBQUM5b0IsSUFBSSxDQUFDNHBCLFFBQUwsRUFBRCxDQUFrQixJQUFHdGMsSUFBSyxNQUFLeFcsTUFBTyxFQUE3RTtBQUNELEdBeEJVO0FBeUJYK3lCLEVBQUFBLEtBQUssRUFBRSxDQUFDLEdBQUd0Z0MsSUFBSixLQUFhd2tCLE9BQU8sQ0FBQ2pELEdBQVIsQ0FBWXZoQixJQUFJLENBQUN2RyxJQUFMLENBQVUsRUFBVixDQUFaLENBekJUO0FBMEJYO0FBQ0E4bUMsRUFBQUEsSUFBSSxFQUFFLENBQUMsR0FBR3ZnQyxJQUFKLEtBQWF3a0IsT0FBTyxDQUFDakQsR0FBUixDQUFZdmhCLElBQUksQ0FBQ3ZHLElBQUwsQ0FBVSxJQUFWLENBQVosQ0EzQlI7QUE0QlhrRixFQUFBQSxLQUFLLEVBQUUsQ0FBQyxHQUFHcUIsSUFBSixLQUFhd2tCLE9BQU8sQ0FBQzdsQixLQUFSLENBQWNxQixJQUFJLENBQUN2RyxJQUFMLENBQVUsSUFBVixDQUFkLENBNUJUO0FBNkJYOHBCLEVBQUFBLEtBQUssRUFBRWhXLE1BQU0sSUFBSWlYLE9BQU8sQ0FBQzdsQixLQUFSLENBQWUsVUFBUzRPLE1BQU8sRUFBL0IsQ0E3Qk47QUE4QlgvTyxFQUFBQSxLQTlCVyxFQUFiOztBQWdDQTs7Ozs7O0FBTUFnaEMsSUFBSSxDQUFDZ0IsUUFBTCxHQUFnQixVQUFVL2lDLFdBQVYsRUFBdUJnakMsZ0JBQXZCLEVBQXlDO0FBQ3ZEeFQsRUFBQUEsa0JBQWtCLENBQUN4dkIsV0FBRCxFQUFjLGFBQWQsRUFBNkIsVUFBN0IsQ0FBbEI7QUFDQXd2QixFQUFBQSxrQkFBa0IsQ0FBQ3dULGdCQUFELEVBQW1CLGtCQUFuQixFQUF1QyxVQUF2QyxDQUFsQjtBQUNBeFQsRUFBQUEsa0JBQWtCLENBQUN3VCxnQkFBZ0IsQ0FBQ3BsQyxTQUFsQixFQUE2Qiw0QkFBN0IsRUFBMkQsUUFBM0QsQ0FBbEI7QUFDQTVFLEVBQUFBLE1BQU0sQ0FBQ3lKLGNBQVAsQ0FBc0J6QyxXQUF0QixFQUFtQyxRQUFuQyxFQUE2QztBQUMzQzlHLElBQUFBLEtBQUssRUFBRThwQyxnQkFEb0MsRUFBN0M7O0FBR0FocUMsRUFBQUEsTUFBTSxDQUFDZ1IsY0FBUCxDQUFzQmhLLFdBQVcsQ0FBQ3BDLFNBQWxDLEVBQTZDb2xDLGdCQUFnQixDQUFDcGxDLFNBQTlEO0FBQ0QsQ0FSRDtBQVNBOzs7Ozs7QUFNQW1rQyxJQUFJLENBQUNrQixTQUFMLEdBQWlCLFVBQVV0VCxRQUFWLEVBQW9CO0FBQ25DSCxFQUFBQSxrQkFBa0IsQ0FBQ0csUUFBRCxFQUFXLFVBQVgsRUFBdUIsVUFBdkIsQ0FBbEI7O0FBRUEsV0FBU3VULE9BQVQsQ0FBaUIsR0FBRzNnQyxJQUFwQixFQUEwQjtBQUN4QixXQUFPLElBQUkwbkIsT0FBSixDQUFZLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUN0Q3dGLE1BQUFBLFFBQVEsQ0FBQ256QixJQUFULENBQWMsSUFBZCxFQUFvQixHQUFHK0YsSUFBdkIsRUFBNkIsQ0FBQzNILEdBQUQsRUFBTXdRLE1BQU4sS0FBaUI7QUFDNUMsWUFBSXhRLEdBQUosRUFBUztBQUNQLGlCQUFPdXZCLE1BQU0sQ0FBQ3Z2QixHQUFELENBQWI7QUFDRDs7QUFFRCxlQUFPc3ZCLE9BQU8sQ0FBQzllLE1BQUQsQ0FBZDtBQUNELE9BTkQ7QUFPRCxLQVJNLENBQVA7QUFTRCxHQWJrQyxDQWFqQztBQUNGO0FBQ0E7OztBQUdBLFNBQU84M0IsT0FBUDtBQUNELENBbkJEO0FBb0JBOzs7Ozs7QUFNQW5CLElBQUksQ0FBQ29CLFdBQUwsR0FBbUIsVUFBVXhULFFBQVYsRUFBb0I7QUFDckNILEVBQUFBLGtCQUFrQixDQUFDRyxRQUFELEVBQVcsVUFBWCxFQUF1QixVQUF2QixDQUFsQjs7QUFFQSxXQUFTdVQsT0FBVCxDQUFpQixHQUFHM2dDLElBQXBCLEVBQTBCO0FBQ3hCLFVBQU00dkIsUUFBUSxHQUFHNXZCLElBQUksQ0FBQzRiLEdBQUwsRUFBakI7QUFDQSxVQUFNaWxCLE9BQU8sR0FBR3pULFFBQVEsQ0FBQ2x6QixLQUFULENBQWUsSUFBZixFQUFxQjhGLElBQXJCLENBQWhCO0FBQ0E2Z0MsSUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWFqNEIsTUFBTSxJQUFJO0FBQ3JCO0FBQ0ErbUIsTUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBTy9tQixNQUFQLENBQVIsQ0FGcUIsQ0FFRztBQUN6QixLQUhELEVBR0drNEIsS0FISCxDQUdTMW9DLEdBQUcsSUFBSTtBQUNkLFVBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ1IsY0FBTTJvQyxZQUFZLEdBQUcsSUFBSS9vQyxLQUFKLENBQVUsdUNBQVYsQ0FBckI7QUFDQStvQyxRQUFBQSxZQUFZLENBQUNDLE1BQWIsR0FBc0I1b0MsR0FBdEI7QUFDQUEsUUFBQUEsR0FBRyxHQUFHMm9DLFlBQU47QUFDRDs7QUFFRHBSLE1BQUFBLFFBQVEsQ0FBQ3YzQixHQUFELENBQVIsQ0FQYyxDQU9DO0FBQ2hCLEtBWEQ7QUFZRDs7QUFFRCxTQUFPc29DLE9BQVA7QUFDRCxDQXJCRDtBQXNCQTs7Ozs7Ozs7QUFRQW5CLElBQUksQ0FBQzBCLFNBQUwsR0FBaUIsVUFBVTlQLElBQVYsRUFBZ0I3akIsTUFBaEIsRUFBd0J2UyxJQUF4QixFQUE4QjtBQUM3QztBQUNBLE1BQUl3VyxPQUFPLENBQUNzZCxhQUFaLEVBQTJCO0FBQ3pCLFdBQU9zQyxJQUFQLENBRHlCLENBQ1o7QUFDZCxHQUo0QyxDQUkzQzs7O0FBR0YsV0FBU3VQLE9BQVQsQ0FBaUIsR0FBRzNnQyxJQUFwQixFQUEwQjtBQUN4QixRQUFJaWtCLE1BQU0sR0FBRyxLQUFiOztBQUVBLFFBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1h6UyxNQUFBQSxPQUFPLENBQUNDLFdBQVIsQ0FBb0JsRSxNQUFwQixFQUE0QixvQkFBNUI7QUFDQTBXLE1BQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0Q7O0FBRUQsV0FBT21OLElBQUksQ0FBQ2wzQixLQUFMLENBQVcsSUFBWCxFQUFpQjhGLElBQWpCLENBQVA7QUFDRDs7QUFFRCxTQUFPMmdDLE9BQVA7QUFDRCxDQW5CRCxDLENBbUJHOzs7QUFHSCxNQUFNUSxNQUFNLEdBQUcsTUFBTSxDQUFFLENBQXZCOztBQUVBM0IsSUFBSSxDQUFDNEIsUUFBTCxHQUFnQixNQUFNO0FBQ3BCLFNBQU9ELE1BQVA7QUFDRCxDQUZEOztBQUlBLE1BQU1FLGdCQUFnQixHQUFHO0FBQ3ZCQyxFQUFBQSxlQUFlLEVBQUUsNENBRE07QUFFdkJDLEVBQUFBLFdBQVcsRUFBRSx1Q0FGVTtBQUd2QkMsRUFBQUEsU0FBUyxFQUFFLDJDQUhZO0FBSXZCQyxFQUFBQSxLQUFLLEVBQUUsc0NBSmdCO0FBS3ZCQyxFQUFBQSxrQkFBa0IsRUFBRSxxREFMRztBQU12QkMsRUFBQUEsY0FBYyxFQUFFLDhDQU5PO0FBT3ZCQyxFQUFBQSxZQUFZLEVBQUUsb0RBUFM7QUFRdkJDLEVBQUFBLFFBQVEsRUFBRSw2Q0FSYSxFQUF6QjtBQVNHOztBQUVILE1BQU1DLFlBQVksR0FBRztBQUNuQnJyQyxFQUFBQSxNQUFNLEVBQUUsQ0FEVztBQUVuQjBJLEVBQUFBLEdBQUcsRUFBRSxDQUZjO0FBR25Cb1QsRUFBQUEsR0FBRyxFQUFFLENBSGMsRUFBckI7O0FBS0EsTUFBTXd2QixVQUFVLEdBQUc7QUFDakJDLEVBQUFBLE1BQU0sRUFBRSxDQURTO0FBRWpCQyxFQUFBQSxLQUFLLEVBQUUsQ0FGVSxFQUFuQjs7O0FBS0EsTUFBTUMsY0FBTixTQUE2QmpxQyxLQUE3QixDQUFtQztBQUNqQ3dGLEVBQUFBLFdBQVcsQ0FBQzBYLE9BQUQsRUFBVTtBQUNuQixRQUFJO0FBQ0Z0VSxNQUFBQSxNQURFO0FBRUZELE1BQUFBLFFBRkU7QUFHRjVCLE1BQUFBLE9BSEU7QUFJRm1qQyxNQUFBQSxRQUpFO0FBS0FodEIsSUFBQUEsT0FMSjs7QUFPQSxRQUFJLENBQUNuVyxPQUFMLEVBQWM7QUFDWjtBQUNBQSxNQUFBQSxPQUFPLEdBQUksR0FBRXFpQyxnQkFBZ0IsQ0FBQ2MsUUFBRCxDQUFXLE1BQXhDO0FBQ0Q7O0FBRUQsVUFBTW5qQyxPQUFOO0FBQ0EsU0FBSzZCLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtELFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS3VoQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLENBQUNwakMsT0FBekI7QUFDQSxTQUFLbkQsSUFBTCxHQUFZLGdDQUFaO0FBQ0EsU0FBS2IsSUFBTCxHQUFZLGVBQVo7QUFDRCxHQXJCZ0M7O0FBdUJqQztBQUNGO0FBQ0E7OztBQUdBLE1BQU1xbkMsUUFBUSxHQUFHLENBQUMxckMsS0FBRCxFQUFRcUksT0FBUixLQUFvQnFqQyxRQUFRLENBQUNDLEVBQVQsQ0FBWTNyQyxLQUFaLEVBQW1CcUksT0FBbkIsQ0FBckM7O0FBRUFxakMsUUFBUSxDQUFDSCxjQUFULEdBQTBCQSxjQUExQjs7QUFFQUcsUUFBUSxDQUFDQyxFQUFULEdBQWMsQ0FBQyxHQUFHdGlDLElBQUosS0FBYTtBQUN6QixRQUFNckosS0FBSyxHQUFHcUosSUFBSSxDQUFDLENBQUQsQ0FBbEI7O0FBRUEsTUFBSXJKLEtBQUosRUFBVztBQUNUO0FBQ0Q7O0FBRUQsTUFBSXFJLE9BQU8sR0FBR2dCLElBQUksQ0FBQyxDQUFELENBQWxCO0FBQ0EsTUFBSW9pQyxnQkFBZ0IsR0FBRyxLQUF2QixDQVJ5QixDQVFLO0FBQzlCOztBQUVBLE1BQUlwaUMsSUFBSSxDQUFDcEcsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQm9GLElBQUFBLE9BQU8sR0FBRywyQ0FBVjtBQUNBb2pDLElBQUFBLGdCQUFnQixHQUFHLElBQW5CO0FBQ0QsR0FIRCxNQUdPLElBQUlwakMsT0FBTyxJQUFJLElBQWYsRUFBcUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0FBLElBQUFBLE9BQU8sR0FBRyxnREFBVjtBQUNBb2pDLElBQUFBLGdCQUFnQixHQUFHLElBQW5CO0FBQ0QsR0FOTSxNQU1BLElBQUlwakMsT0FBTyxZQUFZL0csS0FBdkIsRUFBOEI7QUFDbkMsVUFBTStHLE9BQU47QUFDRDs7QUFFRCxRQUFNM0csR0FBRyxHQUFHLElBQUk2cEMsY0FBSixDQUFtQjtBQUM3QnJoQyxJQUFBQSxNQUFNLEVBQUVsSyxLQURxQjtBQUU3QmlLLElBQUFBLFFBQVEsRUFBRSxJQUZtQjtBQUc3QjVCLElBQUFBLE9BSDZCO0FBSTdCbWpDLElBQUFBLFFBQVEsRUFBRSxJQUptQixFQUFuQixDQUFaOztBQU1BOXBDLEVBQUFBLEdBQUcsQ0FBQytwQyxnQkFBSixHQUF1QkEsZ0JBQXZCO0FBQ0EsUUFBTS9wQyxHQUFOO0FBQ0QsQ0FoQ0Q7O0FBa0NBLFNBQVNrcUMsVUFBVCxDQUFvQi9uQyxHQUFwQixFQUF5QjtBQUN2QjtBQUNBLE1BQUlBLEdBQUcsQ0FBQ3dFLE9BQUosWUFBdUIvRyxLQUEzQixFQUFrQztBQUNoQyxVQUFNdUMsR0FBRyxDQUFDd0UsT0FBVjtBQUNEOztBQUVELFFBQU0sSUFBSWtqQyxjQUFKLENBQW1CMW5DLEdBQW5CLENBQU47QUFDRDs7QUFFRDZuQyxRQUFRLENBQUNaLEtBQVQsR0FBaUIsQ0FBQzVnQyxNQUFELEVBQVNELFFBQVQsRUFBbUI1QixPQUFuQixLQUErQjtBQUM5QyxNQUFJNkIsTUFBTSxJQUFJRCxRQUFkLEVBQXdCO0FBQ3RCO0FBQ0E7QUFDRDs7QUFFRDJoQyxFQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxJQUFBQSxNQURTO0FBRVRELElBQUFBLFFBRlM7QUFHVDVCLElBQUFBLE9BSFM7QUFJVG1qQyxJQUFBQSxRQUFRLEVBQUUsT0FKRCxFQUFELENBQVY7O0FBTUQsQ0FaRDs7QUFjQUUsUUFBUSxDQUFDZCxXQUFULEdBQXVCLENBQUMxZ0MsTUFBRCxFQUFTRCxRQUFULEVBQW1CNUIsT0FBbkIsS0FBK0I7QUFDcEQsTUFBSXZJLE1BQU0sQ0FBQ3FvQixFQUFQLENBQVVqZSxNQUFWLEVBQWtCRCxRQUFsQixDQUFKLEVBQWlDO0FBQy9CO0FBQ0E7QUFDRDs7QUFFRDJoQyxFQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxJQUFBQSxNQURTO0FBRVRELElBQUFBLFFBRlM7QUFHVDVCLElBQUFBLE9BSFM7QUFJVG1qQyxJQUFBQSxRQUFRLEVBQUUsYUFKRCxFQUFELENBQVY7O0FBTUQsQ0FaRDs7QUFjQUUsUUFBUSxDQUFDUixRQUFULEdBQW9CLENBQUNoaEMsTUFBRCxFQUFTRCxRQUFULEVBQW1CNUIsT0FBbkIsS0FBK0I7QUFDakQsTUFBSTZCLE1BQU0sSUFBSUQsUUFBZCxFQUF3QjtBQUN0QjtBQUNBO0FBQ0Q7O0FBRUQyaEMsRUFBQUEsVUFBVSxDQUFDO0FBQ1QxaEMsSUFBQUEsTUFEUztBQUVURCxJQUFBQSxRQUZTO0FBR1Q1QixJQUFBQSxPQUhTO0FBSVRtakMsSUFBQUEsUUFBUSxFQUFFLFVBSkQsRUFBRCxDQUFWOztBQU1ELENBWkQ7O0FBY0FFLFFBQVEsQ0FBQ1YsY0FBVCxHQUEwQixDQUFDOWdDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQjVCLE9BQW5CLEtBQStCO0FBQ3ZELE1BQUksQ0FBQ3ZJLE1BQU0sQ0FBQ3FvQixFQUFQLENBQVVqZSxNQUFWLEVBQWtCRCxRQUFsQixDQUFMLEVBQWtDO0FBQ2hDO0FBQ0E7QUFDRDs7QUFFRDJoQyxFQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxJQUFBQSxNQURTO0FBRVRELElBQUFBLFFBRlM7QUFHVDVCLElBQUFBLE9BSFM7QUFJVG1qQyxJQUFBQSxRQUFRLEVBQUUsZ0JBSkQsRUFBRCxDQUFWOztBQU1ELENBWkQ7O0FBY0EsTUFBTXRDLFdBQVcsR0FBR2xwQyxLQUFLLElBQUk7QUFDM0IsU0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQVAsS0FBaUIsVUFBOUMsSUFBNERBLEtBQUssS0FBSyxJQUE3RTtBQUNELENBRkQ7QUFHQTs7Ozs7Ozs7O0FBU0EsU0FBUzZyQyxXQUFULENBQXFCM2hDLE1BQXJCLEVBQTZCRCxRQUE3QixFQUF1QzZoQyxVQUF2QyxFQUFtREMsVUFBbkQsRUFBK0Q7QUFDN0QsUUFBTUMsV0FBVyxHQUFHLElBQUlwd0IsR0FBSixFQUFwQixDQUQ2RCxDQUM5Qjs7QUFFL0IsT0FBSyxNQUFNLENBQUMxWCxHQUFELEVBQU1sRSxLQUFOLENBQVgsSUFBMkJrSyxNQUEzQixFQUFtQztBQUNqQyxRQUFJLE9BQU9oRyxHQUFQLEtBQWUsUUFBZixJQUEyQkEsR0FBRyxLQUFLLElBQXZDLEVBQTZDO0FBQzNDO0FBQ0E4bkMsTUFBQUEsV0FBVyxDQUFDQyxHQUFaLENBQWdCL25DLEdBQWhCO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxVQUFJK0YsUUFBUSxDQUFDNEUsR0FBVCxDQUFhM0ssR0FBYixLQUFxQjJtQyxTQUFTLENBQUM3cUMsS0FBRCxFQUFRaUssUUFBUSxDQUFDbkYsR0FBVCxDQUFhWixHQUFiLENBQVIsRUFBMkI0bkMsVUFBM0IsRUFBdUNDLFVBQXZDLENBQWxDLEVBQXNGO0FBQ3BGO0FBQ0E7QUFDRDs7QUFFRCxVQUFJRCxVQUFVLEtBQUtWLFVBQVUsQ0FBQ0MsTUFBOUIsRUFBc0M7QUFDcEM7QUFDQSxlQUFPLEtBQVA7QUFDRCxPQVZJLENBVUg7OztBQUdGVyxNQUFBQSxXQUFXLENBQUNDLEdBQVosQ0FBZ0IvbkMsR0FBaEI7QUFDRDtBQUNGOztBQUVELE1BQUk4bkMsV0FBVyxDQUFDaHBCLElBQVosS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxXQUFPLElBQVA7QUFDRCxHQTNCNEQsQ0EyQjNEOzs7QUFHRixPQUFLLE1BQU0sQ0FBQ2twQixXQUFELEVBQWNDLGFBQWQsQ0FBWCxJQUEyQ2xpQyxRQUEzQyxFQUFxRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxRQUFJNmhDLFVBQVUsS0FBS1YsVUFBVSxDQUFDQyxNQUExQixJQUFvQyxFQUFFLE9BQU9hLFdBQVAsS0FBdUIsUUFBdkIsSUFBbUNBLFdBQVcsS0FBSyxJQUFyRCxDQUF4QyxFQUFvRztBQUNsRyxhQUFPLEtBQVA7QUFDRCxLQU5rRCxDQU1qRDs7O0FBR0YsUUFBSUUsS0FBSyxHQUFHLEtBQVo7O0FBRUEsU0FBSyxNQUFNbG9DLEdBQVgsSUFBa0I4bkMsV0FBbEIsRUFBK0I7QUFDN0I7QUFDQSxVQUFJbkIsU0FBUyxDQUFDM21DLEdBQUQsRUFBTWdvQyxXQUFOLEVBQW1CSixVQUFuQixFQUErQkMsVUFBL0IsQ0FBVCxJQUF1RGxCLFNBQVMsQ0FBQzNnQyxNQUFNLENBQUNwRixHQUFQLENBQVdaLEdBQVgsQ0FBRCxFQUFrQmlvQyxhQUFsQixFQUFpQ0wsVUFBakMsRUFBNkNDLFVBQTdDLENBQXBFLEVBQThIO0FBQzVISyxRQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNBSixRQUFBQSxXQUFXLENBQUM3ZSxNQUFaLENBQW1CanBCLEdBQW5CLEVBRjRILENBRW5HOztBQUV6QjtBQUNEO0FBQ0YsS0FuQmtELENBbUJqRDs7O0FBR0YsUUFBSSxDQUFDa29DLEtBQUwsRUFBWTtBQUNWLGFBQU8sS0FBUDtBQUNEO0FBQ0YsR0F2RDRELENBdUQzRDs7O0FBR0YsU0FBT0osV0FBVyxDQUFDaHBCLElBQVosS0FBcUIsQ0FBNUI7QUFDRDtBQUNEOzs7Ozs7Ozs7QUFTQSxTQUFTcXBCLFdBQVQsQ0FBcUJuaUMsTUFBckIsRUFBNkJELFFBQTdCLEVBQXVDNmhDLFVBQXZDLEVBQW1EQyxVQUFuRCxFQUErRDtBQUM3RCxRQUFNQyxXQUFXLEdBQUcsSUFBSXB3QixHQUFKLEVBQXBCLENBRDZELENBQzlCOztBQUUvQixPQUFLLE1BQU01YixLQUFYLElBQW9Ca0ssTUFBcEIsRUFBNEI7QUFDMUIsUUFBSSxPQUFPbEssS0FBUCxLQUFpQixRQUFqQixJQUE2QkEsS0FBSyxLQUFLLElBQTNDLEVBQWlEO0FBQy9DO0FBQ0Fnc0MsTUFBQUEsV0FBVyxDQUFDQyxHQUFaLENBQWdCanNDLEtBQWhCO0FBQ0QsS0FIRCxNQUdPLElBQUksQ0FBQ2lLLFFBQVEsQ0FBQzRFLEdBQVQsQ0FBYTdPLEtBQWIsQ0FBTCxFQUEwQjtBQUMvQjtBQUNBO0FBQ0EsVUFBSThyQyxVQUFVLEtBQUtWLFVBQVUsQ0FBQ0MsTUFBOUIsRUFBc0M7QUFDcEM7QUFDQSxlQUFPLEtBQVA7QUFDRCxPQU44QixDQU03QjtBQUNGOzs7QUFHQVcsTUFBQUEsV0FBVyxDQUFDQyxHQUFaLENBQWdCanNDLEtBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJZ3NDLFdBQVcsQ0FBQ2hwQixJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0F4QjRELENBd0IzRDtBQUNGOzs7QUFHQSxPQUFLLE1BQU1tcEIsYUFBWCxJQUE0QmxpQyxRQUE1QixFQUFzQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFJNmhDLFVBQVUsS0FBS1YsVUFBVSxDQUFDQyxNQUExQixJQUFvQyxFQUFFLE9BQU9jLGFBQVAsS0FBeUIsUUFBekIsSUFBcUNBLGFBQWEsS0FBSyxJQUF6RCxDQUF4QyxFQUF3RztBQUN0RyxhQUFPLEtBQVA7QUFDRDs7QUFFRCxRQUFJQyxLQUFLLEdBQUcsS0FBWjs7QUFFQSxTQUFLLE1BQU1FLE1BQVgsSUFBcUJOLFdBQXJCLEVBQWtDO0FBQ2hDLFVBQUluQixTQUFTLENBQUN5QixNQUFELEVBQVNILGFBQVQsRUFBd0JMLFVBQXhCLEVBQW9DQyxVQUFwQyxDQUFiLEVBQThEO0FBQzVESyxRQUFBQSxLQUFLLEdBQUcsSUFBUixDQUQ0RCxDQUM5Qzs7QUFFZEosUUFBQUEsV0FBVyxDQUFDN2UsTUFBWixDQUFtQm1mLE1BQW5CLEVBSDRELENBR2hDOztBQUU1QjtBQUNEO0FBQ0YsS0FsQm1DLENBa0JsQzs7O0FBR0YsUUFBSSxDQUFDRixLQUFMLEVBQVk7QUFDVixhQUFPLEtBQVA7QUFDRDtBQUNGLEdBcEQ0RCxDQW9EM0Q7OztBQUdGLFNBQU9KLFdBQVcsQ0FBQ2hwQixJQUFaLEtBQXFCLENBQTVCO0FBQ0Q7QUFDRDs7Ozs7Ozs7Ozs7O0FBWUEsU0FBUzZuQixTQUFULENBQW1CM2dDLE1BQW5CLEVBQTJCRCxRQUEzQixFQUFxQzZoQyxVQUFyQyxFQUFpREMsVUFBakQsRUFBNkQ7QUFDM0Q7QUFDQTtBQUNBLE1BQUk3QyxXQUFXLENBQUNoL0IsTUFBRCxDQUFYLElBQXVCZy9CLFdBQVcsQ0FBQ2ovQixRQUFELENBQXRDLEVBQWtEO0FBQ2hELFFBQUk2aEMsVUFBVSxLQUFLVixVQUFVLENBQUNDLE1BQTlCLEVBQXNDO0FBQ3BDLGFBQU92ckMsTUFBTSxDQUFDcW9CLEVBQVAsQ0FBVWplLE1BQVYsRUFBa0JELFFBQWxCLENBQVA7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPQyxNQUFNLElBQUlELFFBQWpCLENBREssQ0FDc0I7QUFDNUI7QUFDRixHQVQwRCxDQVN6RDtBQUNGO0FBQ0E7QUFDQTs7O0FBR0EsUUFBTXNpQyxTQUFTLEdBQUd6c0MsTUFBTSxDQUFDNEUsU0FBUCxDQUFpQlMsUUFBakIsQ0FBMEI3QixJQUExQixDQUErQjRHLE1BQS9CLENBQWxCO0FBQ0EsUUFBTXNpQyxXQUFXLEdBQUcxc0MsTUFBTSxDQUFDNEUsU0FBUCxDQUFpQlMsUUFBakIsQ0FBMEI3QixJQUExQixDQUErQjJHLFFBQS9CLENBQXBCOztBQUVBLE1BQUlzaUMsU0FBUyxLQUFLQyxXQUFsQixFQUErQjtBQUM3QixXQUFPLEtBQVA7QUFDRCxHQXBCMEQsQ0FvQnpEOzs7QUFHRixNQUFJVixVQUFVLEtBQUtWLFVBQVUsQ0FBQ0MsTUFBOUIsRUFBc0M7QUFDcEM7QUFDQSxVQUFNb0IsZUFBZSxHQUFHM3NDLE1BQU0sQ0FBQzBFLGNBQVAsQ0FBc0IwRixNQUF0QixDQUF4QjtBQUNBLFVBQU13aUMsaUJBQWlCLEdBQUc1c0MsTUFBTSxDQUFDMEUsY0FBUCxDQUFzQnlGLFFBQXRCLENBQTFCOztBQUVBLFFBQUl3aUMsZUFBZSxLQUFLQyxpQkFBeEIsRUFBMkM7QUFDekMsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJQyxVQUFVLEdBQUd4QixZQUFZLENBQUNyckMsTUFBOUI7O0FBRUEsTUFBSStvQyxJQUFJLENBQUNoaEMsS0FBTCxDQUFXWixRQUFYLENBQW9CaUQsTUFBcEIsQ0FBSixFQUFpQztBQUMvQjtBQUNBLFFBQUksQ0FBQzIrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXWixRQUFYLENBQW9CZ0QsUUFBcEIsQ0FBRCxJQUFrQ0MsTUFBTSxDQUFDMGlDLEtBQVAsS0FBaUIzaUMsUUFBUSxDQUFDMmlDLEtBQTVELElBQXFFMWlDLE1BQU0sQ0FBQzJDLE1BQVAsS0FBa0I1QyxRQUFRLENBQUM0QyxNQUFwRyxFQUE0RztBQUMxRyxhQUFPLEtBQVA7QUFDRCxLQUo4QixDQUk3Qjs7QUFFSCxHQU5ELE1BTU8sSUFBSWc4QixJQUFJLENBQUNoaEMsS0FBTCxDQUFXekIsTUFBWCxDQUFrQjhELE1BQWxCLENBQUosRUFBK0I7QUFDcEM7QUFDQSxRQUFJLENBQUMyK0IsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBV3pCLE1BQVgsQ0FBa0I2RCxRQUFsQixDQUFELElBQWdDQyxNQUFNLENBQUM2WixPQUFQLE9BQXFCOVosUUFBUSxDQUFDOFosT0FBVCxFQUF6RCxFQUE2RTtBQUMzRSxhQUFPLEtBQVA7QUFDRCxLQUptQyxDQUlsQzs7QUFFSCxHQU5NLE1BTUEsSUFBSTdaLE1BQU0sWUFBWTVJLEtBQXRCLEVBQTZCO0FBQ2xDO0FBQ0EsUUFBSSxFQUFFMkksUUFBUSxZQUFZM0ksS0FBdEIsS0FBZ0M0SSxNQUFNLENBQUNoRixJQUFQLEtBQWdCK0UsUUFBUSxDQUFDL0UsSUFBekQsSUFBaUVnRixNQUFNLENBQUM3QixPQUFQLEtBQW1CNEIsUUFBUSxDQUFDNUIsT0FBakcsRUFBMEc7QUFDeEcsYUFBTyxLQUFQO0FBQ0QsS0FKaUMsQ0FJaEM7O0FBRUgsR0FOTSxNQU1BLElBQUkzRixLQUFLLENBQUNDLE9BQU4sQ0FBY3VILE1BQWQsQ0FBSixFQUEyQjtBQUNoQztBQUNBLFFBQUksQ0FBQ3hILEtBQUssQ0FBQ0MsT0FBTixDQUFjc0gsUUFBZCxDQUFELElBQTRCQyxNQUFNLENBQUNqSCxNQUFQLEtBQWtCZ0gsUUFBUSxDQUFDaEgsTUFBM0QsRUFBbUU7QUFDakUsYUFBTyxLQUFQO0FBQ0QsS0FKK0IsQ0FJOUI7O0FBRUgsR0FOTSxNQU1BLElBQUk0bEMsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBVzlCLGdCQUFYLENBQTRCbUUsTUFBNUIsQ0FBSixFQUF5QztBQUM5QyxRQUFJLENBQUMyK0IsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBVzlCLGdCQUFYLENBQTRCa0UsUUFBNUIsQ0FBTCxFQUE0QztBQUMxQyxhQUFPLEtBQVA7QUFDRCxLQUg2QyxDQUc1Qzs7O0FBR0YsUUFBSTQrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXN0IsY0FBWCxDQUEwQmtFLE1BQTFCLE1BQXNDLENBQUMyK0IsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBVzdCLGNBQVgsQ0FBMEJpRSxRQUExQixDQUFELElBQXdDLENBQUNuSyxNQUFNLENBQUNxb0IsRUFBUCxDQUFVM2MsTUFBTSxDQUFDOUcsU0FBUCxDQUFpQitnQixPQUFqQixDQUF5Qm5pQixJQUF6QixDQUE4QjRHLE1BQTlCLENBQVYsRUFBaURzQixNQUFNLENBQUM5RyxTQUFQLENBQWlCK2dCLE9BQWpCLENBQXlCbmlCLElBQXpCLENBQThCMkcsUUFBOUIsQ0FBakQsQ0FBL0UsQ0FBSixFQUErSztBQUM3SyxhQUFPLEtBQVA7QUFDRCxLQUZELE1BRU8sSUFBSTQrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXNUIsY0FBWCxDQUEwQmlFLE1BQTFCLE1BQXNDLENBQUMyK0IsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBVzVCLGNBQVgsQ0FBMEJnRSxRQUExQixDQUFELElBQXdDZSxNQUFNLENBQUN0RyxTQUFQLENBQWlCK2dCLE9BQWpCLENBQXlCbmlCLElBQXpCLENBQThCNEcsTUFBOUIsTUFBMENjLE1BQU0sQ0FBQ3RHLFNBQVAsQ0FBaUIrZ0IsT0FBakIsQ0FBeUJuaUIsSUFBekIsQ0FBOEIyRyxRQUE5QixDQUF4SCxDQUFKLEVBQXNLO0FBQzNLLGFBQU8sS0FBUDtBQUNELEtBRk0sTUFFQSxJQUFJNCtCLElBQUksQ0FBQ2hoQyxLQUFMLENBQVcvQixlQUFYLENBQTJCb0UsTUFBM0IsTUFBdUMsQ0FBQzIrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXL0IsZUFBWCxDQUEyQm1FLFFBQTNCLENBQUQsSUFBeUNpUixPQUFPLENBQUN4VyxTQUFSLENBQWtCK2dCLE9BQWxCLENBQTBCbmlCLElBQTFCLENBQStCNEcsTUFBL0IsTUFBMkNnUixPQUFPLENBQUN4VyxTQUFSLENBQWtCK2dCLE9BQWxCLENBQTBCbmlCLElBQTFCLENBQStCMkcsUUFBL0IsQ0FBM0gsQ0FBSixFQUEwSztBQUMvSyxhQUFPLEtBQVAsQ0FEK0ssQ0FDaks7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNELEtBTk0sTUFNQSxJQUFJNCtCLElBQUksQ0FBQ2hoQyxLQUFMLENBQVczQixjQUFYLENBQTBCZ0UsTUFBMUIsTUFBc0MsQ0FBQzIrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXM0IsY0FBWCxDQUEwQitELFFBQTFCLENBQUQsSUFBd0NySixNQUFNLENBQUM4RCxTQUFQLENBQWlCK2dCLE9BQWpCLENBQXlCbmlCLElBQXpCLENBQThCNEcsTUFBOUIsTUFBMEN0SixNQUFNLENBQUM4RCxTQUFQLENBQWlCK2dCLE9BQWpCLENBQXlCbmlCLElBQXpCLENBQThCMkcsUUFBOUIsQ0FBeEgsQ0FBSixFQUFzSztBQUMzSyxhQUFPLEtBQVA7QUFDRCxLQWxCNkMsQ0FrQjVDOztBQUVILEdBcEJNLE1Bb0JBLElBQUk0K0IsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBV1gsS0FBWCxDQUFpQmdELE1BQWpCLENBQUosRUFBOEI7QUFDbkMsUUFBSSxDQUFDMitCLElBQUksQ0FBQ2hoQyxLQUFMLENBQVdYLEtBQVgsQ0FBaUIrQyxRQUFqQixDQUFELElBQStCQyxNQUFNLENBQUM4WSxJQUFQLEtBQWdCL1ksUUFBUSxDQUFDK1ksSUFBNUQsRUFBa0U7QUFDaEUsYUFBTyxLQUFQO0FBQ0Q7O0FBRUQycEIsSUFBQUEsVUFBVSxHQUFHeEIsWUFBWSxDQUFDdnZCLEdBQTFCLENBTG1DLENBS0o7QUFDaEMsR0FOTSxNQU1BLElBQUlpdEIsSUFBSSxDQUFDaGhDLEtBQUwsQ0FBV2pCLEtBQVgsQ0FBaUJzRCxNQUFqQixDQUFKLEVBQThCO0FBQ25DLFFBQUksQ0FBQzIrQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXakIsS0FBWCxDQUFpQnFELFFBQWpCLENBQUQsSUFBK0JDLE1BQU0sQ0FBQzhZLElBQVAsS0FBZ0IvWSxRQUFRLENBQUMrWSxJQUE1RCxFQUFrRTtBQUNoRSxhQUFPLEtBQVA7QUFDRDs7QUFFRDJwQixJQUFBQSxVQUFVLEdBQUd4QixZQUFZLENBQUMzaUMsR0FBMUIsQ0FMbUMsQ0FLSjtBQUNoQyxHQTNGMEQsQ0EyRnpEOzs7QUFHRixRQUFNcWtDLFVBQVUsR0FBRy9zQyxNQUFNLENBQUNrRSxJQUFQLENBQVlrRyxNQUFaLENBQW5CLENBOUYyRCxDQThGbkI7O0FBRXhDLFFBQU00aUMsWUFBWSxHQUFHaHRDLE1BQU0sQ0FBQ2tFLElBQVAsQ0FBWWlHLFFBQVosQ0FBckIsQ0FoRzJELENBZ0dmO0FBQzVDOztBQUVBLE1BQUk0aUMsVUFBVSxDQUFDNXBDLE1BQVgsS0FBc0I2cEMsWUFBWSxDQUFDN3BDLE1BQXZDLEVBQStDO0FBQzdDLFdBQU8sS0FBUDtBQUNELEdBckcwRCxDQXFHekQ7OztBQUdGLE1BQUksQ0FBQzRwQyxVQUFVLENBQUMxb0IsS0FBWCxDQUFpQmpnQixHQUFHLElBQUlwRSxNQUFNLENBQUM0RSxTQUFQLENBQWlCc1gsY0FBakIsQ0FBZ0MxWSxJQUFoQyxDQUFxQzJHLFFBQXJDLEVBQStDL0YsR0FBL0MsQ0FBeEIsQ0FBTCxFQUFtRjtBQUNqRixXQUFPLEtBQVA7QUFDRCxHQTFHMEQsQ0EwR3pEOzs7QUFHRixNQUFJNG5DLFVBQVUsS0FBS1YsVUFBVSxDQUFDQyxNQUE5QixFQUFzQztBQUNwQyxVQUFNMEIsYUFBYSxHQUFHanRDLE1BQU0sQ0FBQ3loQixxQkFBUCxDQUE2QnJYLE1BQTdCLENBQXRCO0FBQ0EsVUFBTThpQyxlQUFlLEdBQUdsdEMsTUFBTSxDQUFDeWhCLHFCQUFQLENBQTZCdFgsUUFBN0IsQ0FBeEIsQ0FGb0MsQ0FFNEI7O0FBRWhFLFFBQUk4aUMsYUFBYSxDQUFDOXBDLE1BQWQsS0FBeUIrcEMsZUFBZSxDQUFDL3BDLE1BQTdDLEVBQXFEO0FBQ25ELGFBQU8sS0FBUDtBQUNEOztBQUVELFFBQUk4cEMsYUFBYSxDQUFDOXBDLE1BQWQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUI7QUFDQSxXQUFLLE1BQU1pQixHQUFYLElBQWtCNm9DLGFBQWxCLEVBQWlDO0FBQy9CLGNBQU1FLGtCQUFrQixHQUFHbnRDLE1BQU0sQ0FBQzRFLFNBQVAsQ0FBaUJ1WCxvQkFBakIsQ0FBc0MzWSxJQUF0QyxDQUEyQzRHLE1BQTNDLEVBQW1EaEcsR0FBbkQsQ0FBM0I7QUFDQSxjQUFNZ3BDLG9CQUFvQixHQUFHcHRDLE1BQU0sQ0FBQzRFLFNBQVAsQ0FBaUJ1WCxvQkFBakIsQ0FBc0MzWSxJQUF0QyxDQUEyQzJHLFFBQTNDLEVBQXFEL0YsR0FBckQsQ0FBN0I7O0FBRUEsWUFBSStvQyxrQkFBa0IsS0FBS0Msb0JBQTNCLEVBQWlEO0FBQy9DLGlCQUFPLEtBQVAsQ0FEK0MsQ0FDakM7QUFDZixTQUZELE1BRU8sSUFBSUQsa0JBQUosRUFBd0I7QUFDN0I7QUFDQUosVUFBQUEsVUFBVSxDQUFDcnFDLElBQVgsQ0FBZ0IwQixHQUFoQjtBQUNBNG9DLFVBQUFBLFlBQVksQ0FBQ3RxQyxJQUFiLENBQWtCMEIsR0FBbEI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHQXBJMEQsQ0FvSXpEO0FBQ0Y7OztBQUdBLE1BQUk2bkMsVUFBVSxLQUFLaHFDLFNBQW5CLEVBQThCO0FBQzVCZ3FDLElBQUFBLFVBQVUsR0FBRztBQUNYN2hDLE1BQUFBLE1BQU0sRUFBRSxJQUFJMUIsR0FBSixFQURHO0FBRVh5QixNQUFBQSxRQUFRLEVBQUUsSUFBSXpCLEdBQUosRUFGQztBQUdYNlQsTUFBQUEsS0FBSyxFQUFFLENBSEksRUFBYjs7QUFLRCxHQU5ELE1BTU87QUFDTDtBQUNBO0FBQ0EsVUFBTTh3QixjQUFjLEdBQUdwQixVQUFVLENBQUM3aEMsTUFBWCxDQUFrQnBGLEdBQWxCLENBQXNCb0YsTUFBdEIsQ0FBdkI7O0FBRUEsUUFBSWlqQyxjQUFjLEtBQUtwckMsU0FBdkIsRUFBa0M7QUFDaEMsWUFBTXFyQyxnQkFBZ0IsR0FBR3JCLFVBQVUsQ0FBQzloQyxRQUFYLENBQW9CbkYsR0FBcEIsQ0FBd0JtRixRQUF4QixDQUF6Qjs7QUFFQSxVQUFJbWpDLGdCQUFnQixLQUFLcnJDLFNBQXpCLEVBQW9DO0FBQ2xDLGVBQU9vckMsY0FBYyxLQUFLQyxnQkFBMUI7QUFDRDtBQUNGOztBQUVEckIsSUFBQUEsVUFBVSxDQUFDMXZCLEtBQVg7QUFDRCxHQTVKMEQsQ0E0SnpEOzs7QUFHRjB2QixFQUFBQSxVQUFVLENBQUM3aEMsTUFBWCxDQUFrQm5CLEdBQWxCLENBQXNCbUIsTUFBdEIsRUFBOEI2aEMsVUFBVSxDQUFDMXZCLEtBQXpDO0FBQ0EwdkIsRUFBQUEsVUFBVSxDQUFDOWhDLFFBQVgsQ0FBb0JsQixHQUFwQixDQUF3QmtCLFFBQXhCLEVBQWtDOGhDLFVBQVUsQ0FBQzF2QixLQUE3QyxFQWhLMkQsQ0FnS047O0FBRXJELE1BQUluSyxNQUFNLEdBQUcsSUFBYjs7QUFFQSxNQUFJeTZCLFVBQVUsS0FBS3hCLFlBQVksQ0FBQ3Z2QixHQUFoQyxFQUFxQztBQUNuQzFKLElBQUFBLE1BQU0sR0FBR202QixXQUFXLENBQUNuaUMsTUFBRCxFQUFTRCxRQUFULEVBQW1CNmhDLFVBQW5CLEVBQStCQyxVQUEvQixDQUFwQjtBQUNELEdBRkQsTUFFTyxJQUFJWSxVQUFVLEtBQUt4QixZQUFZLENBQUMzaUMsR0FBaEMsRUFBcUM7QUFDMUMwSixJQUFBQSxNQUFNLEdBQUcyNUIsV0FBVyxDQUFDM2hDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQjZoQyxVQUFuQixFQUErQkMsVUFBL0IsQ0FBcEI7QUFDRDs7QUFFRCxNQUFJNzVCLE1BQUosRUFBWTtBQUNWO0FBQ0EsU0FBSyxNQUFNaE8sR0FBWCxJQUFrQjJvQyxVQUFsQixFQUE4QjtBQUM1QixVQUFJLENBQUNoQyxTQUFTLENBQUMzZ0MsTUFBTSxDQUFDaEcsR0FBRCxDQUFQLEVBQWMrRixRQUFRLENBQUMvRixHQUFELENBQXRCLEVBQTZCNG5DLFVBQTdCLEVBQXlDQyxVQUF6QyxDQUFkLEVBQW9FO0FBQ2xFNzVCLFFBQUFBLE1BQU0sR0FBRyxLQUFUO0FBQ0E7QUFDRDtBQUNGO0FBQ0YsR0FsTDBELENBa0x6RDs7O0FBR0Y2NUIsRUFBQUEsVUFBVSxDQUFDN2hDLE1BQVgsQ0FBa0JpakIsTUFBbEIsQ0FBeUJqakIsTUFBekI7QUFDQTZoQyxFQUFBQSxVQUFVLENBQUM5aEMsUUFBWCxDQUFvQmtqQixNQUFwQixDQUEyQmxqQixRQUEzQjtBQUNBLFNBQU9pSSxNQUFQO0FBQ0Q7O0FBRUR3NUIsUUFBUSxDQUFDZixlQUFULEdBQTJCLENBQUN6Z0MsTUFBRCxFQUFTRCxRQUFULEVBQW1CNUIsT0FBbkIsS0FBK0I7QUFDeEQsTUFBSSxDQUFDd2lDLFNBQVMsQ0FBQzNnQyxNQUFELEVBQVNELFFBQVQsRUFBbUJtaEMsVUFBVSxDQUFDQyxNQUE5QixDQUFkLEVBQXFEO0FBQ25ETyxJQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxNQUFBQSxNQURTO0FBRVRELE1BQUFBLFFBRlM7QUFHVDVCLE1BQUFBLE9BSFM7QUFJVG1qQyxNQUFBQSxRQUFRLEVBQUUsaUJBSkQsRUFBRCxDQUFWOztBQU1EO0FBQ0YsQ0FURDs7QUFXQUUsUUFBUSxDQUFDWCxrQkFBVCxHQUE4QixDQUFDN2dDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQjVCLE9BQW5CLEtBQStCO0FBQzNELE1BQUl3aUMsU0FBUyxDQUFDM2dDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQm1oQyxVQUFVLENBQUNDLE1BQTlCLENBQWIsRUFBb0Q7QUFDbERPLElBQUFBLFVBQVUsQ0FBQztBQUNUMWhDLE1BQUFBLE1BRFM7QUFFVEQsTUFBQUEsUUFGUztBQUdUNUIsTUFBQUEsT0FIUztBQUlUbWpDLE1BQUFBLFFBQVEsRUFBRSxvQkFKRCxFQUFELENBQVY7O0FBTUQ7QUFDRixDQVREOztBQVdBRSxRQUFRLENBQUNiLFNBQVQsR0FBcUIsQ0FBQzNnQyxNQUFELEVBQVNELFFBQVQsRUFBbUI1QixPQUFuQixLQUErQjtBQUNsRCxNQUFJLENBQUN3aUMsU0FBUyxDQUFDM2dDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQm1oQyxVQUFVLENBQUNFLEtBQTlCLENBQWQsRUFBb0Q7QUFDbERNLElBQUFBLFVBQVUsQ0FBQztBQUNUMWhDLE1BQUFBLE1BRFM7QUFFVEQsTUFBQUEsUUFGUztBQUdUNUIsTUFBQUEsT0FIUztBQUlUbWpDLE1BQUFBLFFBQVEsRUFBRSxXQUpELEVBQUQsQ0FBVjs7QUFNRDtBQUNGLENBVEQ7O0FBV0FFLFFBQVEsQ0FBQ1QsWUFBVCxHQUF3QixDQUFDL2dDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQjVCLE9BQW5CLEtBQStCO0FBQ3JELE1BQUl3aUMsU0FBUyxDQUFDM2dDLE1BQUQsRUFBU0QsUUFBVCxFQUFtQm1oQyxVQUFVLENBQUNFLEtBQTlCLENBQWIsRUFBbUQ7QUFDakRNLElBQUFBLFVBQVUsQ0FBQztBQUNUMWhDLE1BQUFBLE1BRFM7QUFFVEQsTUFBQUEsUUFGUztBQUdUNUIsTUFBQUEsT0FIUztBQUlUbWpDLE1BQUFBLFFBQVEsRUFBRSxjQUpELEVBQUQsQ0FBVjs7QUFNRDtBQUNGLENBVEQ7O0FBV0FFLFFBQVEsQ0FBQ3BqQyxJQUFULEdBQWdCLENBQUNELE9BQU8sR0FBRyxRQUFYLEtBQXdCdWpDLFVBQVUsQ0FBQztBQUNqRHZqQyxFQUFBQSxPQURpRCxFQUFELENBQWxEOzs7QUFJQSxNQUFNZ2xDLFlBQVksR0FBRyxFQUFyQjs7QUFFQSxTQUFTQyxPQUFULENBQWlCOW5CLEVBQWpCLEVBQXFCO0FBQ25COFEsRUFBQUEsa0JBQWtCLENBQUM5USxFQUFELEVBQUssSUFBTCxFQUFXLFVBQVgsQ0FBbEI7O0FBRUEsTUFBSTtBQUNGQSxJQUFBQSxFQUFFO0FBQ0gsR0FGRCxDQUVFLE9BQU9wa0IsQ0FBUCxFQUFVO0FBQ1YsV0FBT0EsQ0FBUDtBQUNEOztBQUVELFNBQU9pc0MsWUFBUDtBQUNEOztBQUVELFNBQVNFLGFBQVQsQ0FBdUIvbkIsRUFBdkIsRUFBMkI7QUFDekIsU0FBT3FqQixJQUFJLENBQUNoaEMsS0FBTCxDQUFXYixTQUFYLENBQXFCd2UsRUFBckIsS0FBNEJBLEVBQUUsSUFBSSxPQUFPQSxFQUFQLEtBQWMsUUFBcEIsSUFBZ0MsT0FBT0EsRUFBRSxDQUFDMmtCLElBQVYsS0FBbUIsVUFBdEY7QUFDRDs7QUFFRCxlQUFlcUQsY0FBZixDQUE4QmhvQixFQUE5QixFQUFrQztBQUNoQyxNQUFJMGtCLE9BQUo7QUFDQSxRQUFNdUQsTUFBTSxHQUFHLE9BQU9qb0IsRUFBdEI7O0FBRUEsTUFBSWlvQixNQUFNLEtBQUssVUFBZixFQUEyQjtBQUN6QnZELElBQUFBLE9BQU8sR0FBRzFrQixFQUFFLEVBQVo7O0FBRUEsUUFBSSxDQUFDK25CLGFBQWEsQ0FBQ3JELE9BQUQsQ0FBbEIsRUFBNkI7QUFDM0IsWUFBTSxJQUFJMS9CLFNBQUosQ0FBZSw2RUFBNEUsT0FBTzAvQixPQUFRLEVBQTFHLENBQU47QUFDRDtBQUNGLEdBTkQsTUFNTztBQUNMLFFBQUksQ0FBQ3FELGFBQWEsQ0FBQy9uQixFQUFELENBQWxCLEVBQXdCO0FBQ3RCLFlBQU0sSUFBSWhiLFNBQUosQ0FBZSx3RUFBdUVpakMsTUFBTyxFQUE3RixDQUFOO0FBQ0Q7O0FBRUR2RCxJQUFBQSxPQUFPLEdBQUcxa0IsRUFBVjtBQUNEOztBQUVELE1BQUk7QUFDRixVQUFNMGtCLE9BQU47QUFDRCxHQUZELENBRUUsT0FBTzlvQyxDQUFQLEVBQVU7QUFDVixXQUFPQSxDQUFQO0FBQ0Q7O0FBRUQsU0FBT2lzQyxZQUFQO0FBQ0Q7O0FBRUQzQixRQUFRLENBQUNnQyxNQUFULEdBQWtCLENBQUNsb0IsRUFBRCxFQUFLeGQsS0FBTCxFQUFZSyxPQUFaLEtBQXdCO0FBQ3hDLFFBQU02QixNQUFNLEdBQUdvakMsT0FBTyxDQUFDOW5CLEVBQUQsQ0FBdEI7O0FBRUEsTUFBSXRiLE1BQU0sS0FBS21qQyxZQUFmLEVBQTZCO0FBQzNCO0FBQ0F6QixJQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxNQUFBQSxNQUFNLEVBQUVuSSxTQURDO0FBRVRrSSxNQUFBQSxRQUFRLEVBQUVqQyxLQUZEO0FBR1RLLE1BQUFBLE9BQU8sRUFBRSw2QkFIQTtBQUlUbWpDLE1BQUFBLFFBQVEsRUFBRSxRQUpELEVBQUQsQ0FBVjs7QUFNQTtBQUNELEdBWnVDLENBWXRDOzs7QUFHRixNQUFJLENBQUN4akMsS0FBTCxFQUFZO0FBQ1Y7QUFDRDs7QUFFRCxNQUFJLENBQUMybEMsVUFBVSxDQUFDempDLE1BQUQsRUFBU2xDLEtBQVQsRUFBZ0JLLE9BQWhCLENBQWYsRUFBeUM7QUFDdkMsVUFBTTZCLE1BQU4sQ0FEdUMsQ0FDekI7QUFDZjtBQUNGLENBdEJEOztBQXdCQXdoQyxRQUFRLENBQUNrQyxPQUFULEdBQW1CLGdCQUFnQkMsT0FBaEIsRUFBeUI3bEMsS0FBekIsRUFBZ0NLLE9BQWhDLEVBQXlDO0FBQzFELFFBQU02QixNQUFNLEdBQUcsTUFBTXNqQyxjQUFjLENBQUNLLE9BQUQsQ0FBbkM7O0FBRUEsTUFBSTNqQyxNQUFNLEtBQUttakMsWUFBZixFQUE2QjtBQUMzQjtBQUNBekIsSUFBQUEsVUFBVSxDQUFDO0FBQ1QxaEMsTUFBQUEsTUFBTSxFQUFFbkksU0FEQztBQUVUa0ksTUFBQUEsUUFBUSxFQUFFakMsS0FGRDtBQUdUSyxNQUFBQSxPQUFPLEVBQUUsNkJBSEE7QUFJVG1qQyxNQUFBQSxRQUFRLEVBQUUsU0FKRCxFQUFELENBQVY7O0FBTUE7QUFDRCxHQVp5RCxDQVl4RDs7O0FBR0YsTUFBSSxDQUFDeGpDLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDMmxDLFVBQVUsQ0FBQ3pqQyxNQUFELEVBQVNsQyxLQUFULEVBQWdCSyxPQUFoQixDQUFmLEVBQXlDO0FBQ3ZDLFVBQU02QixNQUFOLENBRHVDLENBQ3pCO0FBQ2Y7QUFDRixDQXRCRDs7QUF3QkF3aEMsUUFBUSxDQUFDb0MsWUFBVCxHQUF3QixDQUFDdG9CLEVBQUQsRUFBS3hkLEtBQUwsRUFBWUssT0FBWixLQUF3QjtBQUM5QyxRQUFNNkIsTUFBTSxHQUFHb2pDLE9BQU8sQ0FBQzluQixFQUFELENBQXRCLENBRDhDLENBQ2xCOztBQUU1QixNQUFJdGIsTUFBTSxLQUFLbWpDLFlBQWYsRUFBNkI7QUFDM0I7QUFDRCxHQUw2QyxDQUs1Qzs7O0FBR0YsTUFBSSxDQUFDcmxDLEtBQUwsRUFBWTtBQUNWLFVBQU1rQyxNQUFOO0FBQ0QsR0FWNkMsQ0FVNUM7OztBQUdGLE1BQUl5akMsVUFBVSxDQUFDempDLE1BQUQsRUFBU2xDLEtBQVQsQ0FBZCxFQUErQjtBQUM3QjRqQyxJQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxNQUFBQSxNQURTO0FBRVRELE1BQUFBLFFBQVEsRUFBRWpDLEtBRkQ7QUFHVHdqQyxNQUFBQSxRQUFRLEVBQUUsY0FIRDtBQUlUbmpDLE1BQUFBLE9BQU8sRUFBRyx5QkFBd0JBLE9BQU8sR0FBRyxPQUFPQSxPQUFWLEdBQW9CLEdBQUksRUFKeEQsRUFBRCxDQUFWOztBQU1BO0FBQ0QsR0FyQjZDLENBcUI1Qzs7O0FBR0YsUUFBTTZCLE1BQU47QUFDRCxDQXpCRDs7QUEyQkF3aEMsUUFBUSxDQUFDcUMsYUFBVCxHQUF5QixnQkFBZ0J2b0IsRUFBaEIsRUFBb0J4ZCxLQUFwQixFQUEyQkssT0FBM0IsRUFBb0M7QUFDM0QsUUFBTTZCLE1BQU0sR0FBRyxNQUFNc2pDLGNBQWMsQ0FBQ2hvQixFQUFELENBQW5DLENBRDJELENBQ2xCOztBQUV6QyxNQUFJdGIsTUFBTSxLQUFLbWpDLFlBQWYsRUFBNkI7QUFDM0I7QUFDRCxHQUwwRCxDQUt6RDs7O0FBR0YsTUFBSSxDQUFDcmxDLEtBQUwsRUFBWTtBQUNWLFVBQU1rQyxNQUFOO0FBQ0QsR0FWMEQsQ0FVekQ7OztBQUdGLE1BQUl5akMsVUFBVSxDQUFDempDLE1BQUQsRUFBU2xDLEtBQVQsQ0FBZCxFQUErQjtBQUM3QjRqQyxJQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxNQUFBQSxNQURTO0FBRVRELE1BQUFBLFFBQVEsRUFBRWpDLEtBRkQ7QUFHVHdqQyxNQUFBQSxRQUFRLEVBQUUsY0FIRDtBQUlUbmpDLE1BQUFBLE9BQU8sRUFBRyx5QkFBd0JBLE9BQU8sR0FBRyxPQUFPQSxPQUFWLEdBQW9CLEdBQUksRUFKeEQsRUFBRCxDQUFWOztBQU1BO0FBQ0QsR0FyQjBELENBcUJ6RDs7O0FBR0YsUUFBTTZCLE1BQU47QUFDRCxDQXpCRDtBQTBCQTs7Ozs7Ozs7QUFRQSxTQUFTeWpDLFVBQVQsQ0FBb0J6akMsTUFBcEIsRUFBNEJELFFBQTVCLEVBQXNDNUIsT0FBdEMsRUFBK0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSSxPQUFPNEIsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQyxRQUFJNCtCLElBQUksQ0FBQ2hoQyxLQUFMLENBQVdaLFFBQVgsQ0FBb0JnRCxRQUFwQixDQUFKLEVBQW1DO0FBQ2pDLGFBQU9BLFFBQVEsQ0FBQ3BILElBQVQsQ0FBY3FILE1BQWQsQ0FBUCxDQURpQyxDQUNIO0FBQy9CLEtBSCtCLENBRzlCOzs7QUFHRixVQUFNbEcsSUFBSSxHQUFHbEUsTUFBTSxDQUFDa0UsSUFBUCxDQUFZaUcsUUFBWixDQUFiLENBTmdDLENBTUk7O0FBRXBDLFFBQUlBLFFBQVEsWUFBWTNJLEtBQXhCLEVBQStCO0FBQzdCMEMsTUFBQUEsSUFBSSxDQUFDNkYsT0FBTCxDQUFhLE1BQWIsRUFBcUIsU0FBckIsRUFENkIsQ0FDSTtBQUNsQzs7QUFFRCxTQUFLLE1BQU0zRixHQUFYLElBQWtCRixJQUFsQixFQUF3QjtBQUN0QixVQUFJLENBQUM2bUMsU0FBUyxDQUFDM2dDLE1BQU0sQ0FBQ2hHLEdBQUQsQ0FBUCxFQUFjK0YsUUFBUSxDQUFDL0YsR0FBRCxDQUF0QixFQUE2QmtuQyxVQUFVLENBQUNDLE1BQXhDLENBQWQsRUFBK0Q7QUFDN0QsWUFBSSxDQUFDaGpDLE9BQUwsRUFBYztBQUNaO0FBQ0E7QUFDQSxjQUFJO0FBQ0Z1akMsWUFBQUEsVUFBVSxDQUFDO0FBQ1QxaEMsY0FBQUEsTUFBTSxFQUFFQSxNQUFNLENBQUNoRyxHQUFELENBREw7QUFFVCtGLGNBQUFBLFFBQVEsRUFBRUEsUUFBUSxDQUFDL0YsR0FBRCxDQUZUO0FBR1RzbkMsY0FBQUEsUUFBUSxFQUFFLGlCQUhELEVBQUQsQ0FBVjs7QUFLRCxXQU5ELENBTUUsT0FBTzlwQyxHQUFQLEVBQVk7QUFDWjJHLFlBQUFBLE9BQU8sR0FBRzNHLEdBQUcsQ0FBQzJHLE9BQWQ7QUFDRDtBQUNGOztBQUVEdWpDLFFBQUFBLFVBQVUsQ0FBQztBQUNUMWhDLFVBQUFBLE1BRFM7QUFFVEQsVUFBQUEsUUFGUztBQUdUNUIsVUFBQUEsT0FIUztBQUlUbWpDLFVBQUFBLFFBQVEsRUFBRSxRQUpELEVBQUQsQ0FBVjs7QUFNQSxlQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUCxDQXRDZ0MsQ0FzQ25CO0FBQ2QsR0F2Q0QsTUF1Q08sSUFBSSxPQUFPdmhDLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDekM7QUFDQSxRQUFJQSxRQUFRLENBQUN2RixTQUFULElBQXNCLElBQXRCLElBQThCd0YsTUFBTSxZQUFZRCxRQUFwRCxFQUE4RDtBQUM1RDtBQUNBLGFBQU8sSUFBUDtBQUNELEtBTHdDLENBS3ZDOzs7QUFHRixRQUFJbkssTUFBTSxDQUFDNEUsU0FBUCxDQUFpQnNwQyxhQUFqQixDQUErQjFxQyxJQUEvQixDQUFvQ2hDLEtBQXBDLEVBQTJDMkksUUFBM0MsQ0FBSixFQUEwRDtBQUN4RCxhQUFPLEtBQVA7QUFDRCxLQVZ3QyxDQVV2QztBQUNGOzs7QUFHQSxXQUFPQSxRQUFRLENBQUMzRyxJQUFULENBQWMsRUFBZCxFQUFrQjRHLE1BQWxCLENBQVA7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7QUFFRHdoQyxRQUFRLENBQUN1QyxPQUFULEdBQW1CanVDLEtBQUssSUFBSTtBQUMxQixNQUFJQSxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLK0IsU0FBaEMsRUFBMkM7QUFDekM7QUFDRDs7QUFFRDZwQyxFQUFBQSxVQUFVLENBQUM7QUFDVDFoQyxJQUFBQSxNQUFNLEVBQUVsSyxLQURDO0FBRVRpSyxJQUFBQSxRQUFRLEVBQUUsSUFGRDtBQUdUNUIsSUFBQUEsT0FBTyxFQUFHLG1DQUFrQ3JJLEtBQU0sRUFIekM7QUFJVHdyQyxJQUFBQSxRQUFRLEVBQUUsU0FKRCxFQUFELENBQVY7O0FBTUQsQ0FYRCxDLENBV0c7OztBQUdIRSxRQUFRLENBQUN3QyxNQUFULEdBQWtCLENBQUNsdUMsS0FBRCxFQUFRcUksT0FBUixLQUFvQnFqQyxRQUFRLENBQUNDLEVBQVQsQ0FBWTNyQyxLQUFaLEVBQW1CcUksT0FBbkIsQ0FBdEMsQyxDQUFtRTs7O0FBR25FdkksTUFBTSxDQUFDMmUsTUFBUCxDQUFjaXRCLFFBQVEsQ0FBQ3dDLE1BQXZCLEVBQStCeEMsUUFBL0IsRSxDQUEwQzs7QUFFMUNBLFFBQVEsQ0FBQ3dDLE1BQVQsQ0FBZ0JyRCxTQUFoQixHQUE0QmEsUUFBUSxDQUFDZixlQUFyQztBQUNBZSxRQUFRLENBQUN3QyxNQUFULENBQWdCakQsWUFBaEIsR0FBK0JTLFFBQVEsQ0FBQ1gsa0JBQXhDO0FBQ0FXLFFBQVEsQ0FBQ3dDLE1BQVQsQ0FBZ0JwRCxLQUFoQixHQUF3QlksUUFBUSxDQUFDZCxXQUFqQztBQUNBYyxRQUFRLENBQUN3QyxNQUFULENBQWdCaEQsUUFBaEIsR0FBMkJRLFFBQVEsQ0FBQ1YsY0FBcEMsQyxDQUFvRDs7QUFFcERVLFFBQVEsQ0FBQ3dDLE1BQVQsQ0FBZ0JBLE1BQWhCLEdBQXlCeEMsUUFBUSxDQUFDd0MsTUFBbEM7O0FBRUE7OztBQUdBLFNBQVNDLGFBQVQsQ0FBdUJoaUMsUUFBUSxHQUFHLE1BQWxDLEVBQTBDO0FBQ3hDLE9BQUtBLFFBQUwsR0FBZ0JBLFFBQVEsQ0FBQ0csV0FBVCxFQUFoQjs7QUFFQSxVQUFRLEtBQUtILFFBQWI7QUFDRSxTQUFLLE1BQUw7QUFDQSxTQUFLLE9BQUw7QUFDRSxXQUFLaWlDLEtBQUwsR0FBYSxJQUFJQyxpQkFBSixFQUFiO0FBQ0E7O0FBRUYsU0FBSyxNQUFMO0FBQ0EsU0FBSyxPQUFMO0FBQ0EsU0FBSyxVQUFMO0FBQ0EsU0FBSyxTQUFMO0FBQ0UsV0FBS0QsS0FBTCxHQUFhLElBQUlFLGtCQUFKLEVBQWI7QUFDQTs7QUFFRixTQUFLLFFBQUw7QUFDRSxXQUFLRixLQUFMLEdBQWEsSUFBSUcsbUJBQUosRUFBYjtBQUNBOztBQUVGO0FBQ0UsV0FBS0gsS0FBTCxHQUFhLElBQUlJLGlCQUFKLENBQXNCLEtBQUtyaUMsUUFBM0IsQ0FBYjtBQUNBLFlBbkJKOztBQXFCRDtBQUNEOzs7Ozs7Ozs7OztBQVdBZ2lDLGFBQWEsQ0FBQ3pwQyxTQUFkLENBQXdCZ0osR0FBeEIsR0FBOEIsU0FBU0EsR0FBVCxDQUFhVixNQUFiLEVBQXFCO0FBQ2pELFNBQU8sS0FBS29oQyxLQUFMLENBQVcxZ0MsR0FBWCxDQUFlVixNQUFmLENBQVA7QUFDRCxDQUZEO0FBR0E7Ozs7Ozs7OztBQVNBbWhDLGFBQWEsQ0FBQ3pwQyxTQUFkLENBQXdCaVMsS0FBeEIsR0FBZ0MsU0FBU0EsS0FBVCxDQUFlM0osTUFBZixFQUF1QjtBQUNyRCxNQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsV0FBT0EsTUFBUDtBQUNELEdBSG9ELENBR25EOzs7QUFHRixNQUFJQSxNQUFNLENBQUMvSixNQUFQLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLFdBQU8sRUFBUDtBQUNEOztBQUVELFNBQU8sS0FBS21yQyxLQUFMLENBQVd6M0IsS0FBWCxDQUFpQjNKLE1BQWpCLENBQVA7QUFDRCxDQVhEO0FBWUE7Ozs7O0FBS0EsTUFBTXdoQyxpQkFBTixDQUF3QjtBQUN0QjFuQyxFQUFBQSxXQUFXLENBQUNxRixRQUFRLEdBQUcsTUFBWixFQUFvQjtBQUM3QixTQUFLQSxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtzaUMsU0FBTCxHQUFpQixDQUFqQjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsQ0FBbEI7QUFDRCxHQUxxQixDQUtwQjs7O0FBR0ZoaEMsRUFBQUEsR0FBRyxDQUFDVixNQUFELEVBQVM7QUFDVixRQUFJQSxNQUFNLElBQUlBLE1BQU0sQ0FBQy9KLE1BQVAsS0FBa0IsQ0FBaEMsRUFBbUM7QUFDakMsYUFBTyxLQUFLMFQsS0FBTCxDQUFXM0osTUFBWCxDQUFQO0FBQ0Q7O0FBRUQsV0FBTyxFQUFQO0FBQ0Q7O0FBRUQySixFQUFBQSxLQUFLLENBQUMzSixNQUFELEVBQVM7QUFDWixRQUFJQSxNQUFNLElBQUlBLE1BQU0sQ0FBQy9KLE1BQVAsS0FBa0IsQ0FBaEMsRUFBbUM7QUFDakMsYUFBTytKLE1BQU0sQ0FBQzdILFFBQVAsQ0FBZ0IsS0FBS2dILFFBQXJCLENBQVAsQ0FEaUMsQ0FDTTtBQUN4Qzs7QUFFRCxXQUFPLEVBQVAsQ0FMWSxDQUtEO0FBQ1osR0F0QnFCOztBQXdCdEI7OztBQUdGLE1BQU13aUMsMEJBQU4sU0FBeUNILGlCQUF6QyxDQUEyRDtBQUN6RDFuQyxFQUFBQSxXQUFXLENBQUNxRixRQUFELEVBQVd5aUMsWUFBWCxFQUF5QjtBQUNsQyxVQUFNemlDLFFBQU47QUFDQSxTQUFLMGlDLFVBQUwsR0FBa0J6aUMsTUFBTSxDQUFDd0UsV0FBUCxDQUFtQmcrQixZQUFuQixDQUFsQixDQUZrQyxDQUVrQjtBQUNyRDtBQUNEOzs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7O0FBV0FFLEVBQUFBLHFCQUFxQixDQUFDQyxPQUFELEVBQVU7QUFDN0IsVUFBTSxJQUFJenRDLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0Q7O0FBRUQwdEMsRUFBQUEsY0FBYyxHQUFHO0FBQ2YsVUFBTSxJQUFJMXRDLEtBQUosQ0FBVSwyQkFBVixDQUFOO0FBQ0Q7O0FBRUQydEMsRUFBQUEsd0JBQXdCLEdBQUc7QUFDekI7QUFDQSxTQUFLUixTQUFMLEdBQWlCLENBQWpCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixDQUFsQjtBQUNEOztBQUVEaGhDLEVBQUFBLEdBQUcsQ0FBQ1YsTUFBRCxFQUFTO0FBQ1YsUUFBSWtGLE1BQU0sR0FBRyxNQUFNeEUsR0FBTixDQUFVVixNQUFWLENBQWI7O0FBRUEsUUFBSSxLQUFLeWhDLFNBQUwsS0FBbUIsQ0FBdkIsRUFBMEI7QUFDeEI7QUFDQXY4QixNQUFBQSxNQUFNLElBQUksS0FBSzg4QixjQUFMLEVBQVY7QUFDRDs7QUFFRCxTQUFLQyx3QkFBTCxHQVJVLENBUXVCOzs7QUFHakMsV0FBTy84QixNQUFQO0FBQ0Q7O0FBRUR5RSxFQUFBQSxLQUFLLENBQUMzSixNQUFELEVBQVM7QUFDWjtBQUNBLFFBQUkwdkIsSUFBSSxHQUFHLEVBQVg7O0FBRUEsUUFBSSxLQUFLK1IsU0FBTCxLQUFtQixDQUF2QixFQUEwQjtBQUN4QjtBQUNBO0FBQ0EsWUFBTVMsSUFBSSxHQUFHLEtBQUtSLFVBQUwsR0FBa0IsS0FBS0QsU0FBcEMsQ0FId0IsQ0FHdUI7O0FBRS9DLFlBQU1VLFdBQVcsR0FBRzM5QixJQUFJLENBQUNDLEdBQUwsQ0FBU3k5QixJQUFULEVBQWVsaUMsTUFBTSxDQUFDL0osTUFBdEIsQ0FBcEIsQ0FMd0IsQ0FLMkI7QUFDbkQ7O0FBRUErSixNQUFBQSxNQUFNLENBQUM2RCxJQUFQLENBQVksS0FBS2crQixVQUFqQixFQUE2QixLQUFLSixTQUFsQyxFQUE2QyxDQUE3QyxFQUFnRFUsV0FBaEQ7QUFDQSxXQUFLVixTQUFMLElBQWtCVSxXQUFsQixDQVR3QixDQVNPOztBQUUvQixVQUFJQSxXQUFXLEdBQUdELElBQWxCLEVBQXdCO0FBQ3RCO0FBQ0EsZUFBTyxFQUFQO0FBQ0QsT0FkdUIsQ0FjdEI7QUFDRjs7O0FBR0F4UyxNQUFBQSxJQUFJLEdBQUcsS0FBS21TLFVBQUwsQ0FBZ0I1akMsS0FBaEIsQ0FBc0IsQ0FBdEIsRUFBeUIsS0FBS3lqQyxVQUE5QixFQUEwQ3ZwQyxRQUExQyxDQUFtRCxLQUFLZ0gsUUFBeEQsQ0FBUCxDQWxCd0IsQ0FrQmtEOztBQUUxRSxXQUFLOGlDLHdCQUFMLEdBcEJ3QixDQW9CUzs7O0FBR2pDLFVBQUlFLFdBQVcsS0FBS25pQyxNQUFNLENBQUMvSixNQUEzQixFQUFtQztBQUNqQyxlQUFPeTVCLElBQVAsQ0FEaUMsQ0FDcEI7QUFDZCxPQXpCdUIsQ0F5QnRCOzs7QUFHRjF2QixNQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQy9CLEtBQVAsQ0FBYWtrQyxXQUFiLEVBQTBCbmlDLE1BQU0sQ0FBQy9KLE1BQWpDLENBQVQ7QUFDRCxLQWpDVyxDQWlDVjs7O0FBR0YsVUFBTW1zQyxrQkFBa0IsR0FBRyxLQUFLTixxQkFBTCxDQUEyQjloQyxNQUEzQixDQUEzQjs7QUFFQSxRQUFJb2lDLGtCQUFrQixDQUFDQyxXQUFuQixLQUFtQyxDQUF2QyxFQUEwQztBQUN4QyxhQUFPM1MsSUFBSSxHQUFHMXZCLE1BQU0sQ0FBQzdILFFBQVAsQ0FBZ0IsS0FBS2dILFFBQXJCLENBQWQsQ0FEd0MsQ0FDTTtBQUMvQyxLQXhDVyxDQXdDVjs7O0FBR0YsU0FBS3VpQyxVQUFMLEdBQWtCVSxrQkFBa0IsQ0FBQ1YsVUFBckMsQ0EzQ1ksQ0EyQ3FDOztBQUVqRCxVQUFNWSxtQkFBbUIsR0FBR0Ysa0JBQWtCLENBQUNuaEMsS0FBL0MsQ0E3Q1ksQ0E2QzBDO0FBQ3REOztBQUVBLFVBQU1zaEMsV0FBVyxHQUFHdmlDLE1BQU0sQ0FBQy9KLE1BQVAsR0FBZ0Jxc0MsbUJBQXBDO0FBQ0F0aUMsSUFBQUEsTUFBTSxDQUFDNkQsSUFBUCxDQUFZLEtBQUtnK0IsVUFBakIsRUFBNkIsQ0FBN0IsRUFBZ0NTLG1CQUFoQyxFQUFxRHRpQyxNQUFNLENBQUMvSixNQUE1RDtBQUNBLFNBQUt3ckMsU0FBTCxHQUFpQmMsV0FBakIsQ0FsRFksQ0FrRGtCOztBQUU5QixRQUFJQSxXQUFXLEdBQUd2aUMsTUFBTSxDQUFDL0osTUFBekIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBLGFBQU95NUIsSUFBSSxHQUFHMXZCLE1BQU0sQ0FBQzdILFFBQVAsQ0FBZ0IsS0FBS2dILFFBQXJCLEVBQStCLENBQS9CLEVBQWtDbWpDLG1CQUFsQyxDQUFkO0FBQ0Q7O0FBRUQsV0FBTzVTLElBQVAsQ0ExRFksQ0EwREM7QUFDZCxHQTlHd0Q7Ozs7QUFrSDNELE1BQU0yUixpQkFBTixTQUFnQ00sMEJBQWhDLENBQTJEO0FBQ3pEN25DLEVBQUFBLFdBQVcsR0FBRztBQUNaLFVBQU0sTUFBTixFQUFjLENBQWQ7QUFDRDs7QUFFRGdvQyxFQUFBQSxxQkFBcUIsQ0FBQzloQyxNQUFELEVBQVM7QUFDNUIsVUFBTS9KLE1BQU0sR0FBRytKLE1BQU0sQ0FBQy9KLE1BQXRCLENBRDRCLENBQ0U7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJQSxNQUFNLElBQUksQ0FBZCxFQUFpQjtBQUNmLFVBQUl5ckMsVUFBVSxHQUFHYyxzQkFBc0IsQ0FBQ3hpQyxNQUFNLENBQUMvSixNQUFNLEdBQUcsQ0FBVixDQUFQLENBQXZDOztBQUVBLFVBQUl5ckMsVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQ3BCLGVBQU87QUFDTFcsVUFBQUEsV0FBVyxFQUFFLENBRFI7QUFFTDtBQUNBcGhDLFVBQUFBLEtBQUssRUFBRWhMLE1BQU0sR0FBRyxDQUhYO0FBSUx5ckMsVUFBQUEsVUFBVSxFQUFFLENBSlAsRUFBUDs7QUFNRDtBQUNGLEtBekIyQixDQXlCMUI7OztBQUdGLFFBQUl6ckMsTUFBTSxJQUFJLENBQWQsRUFBaUI7QUFDZixVQUFJeXJDLFVBQVUsR0FBR2Msc0JBQXNCLENBQUN4aUMsTUFBTSxDQUFDL0osTUFBTSxHQUFHLENBQVYsQ0FBUCxDQUF2Qzs7QUFFQSxVQUFJeXJDLFVBQVUsSUFBSSxDQUFsQixFQUFxQjtBQUNuQixlQUFPO0FBQ0xXLFVBQUFBLFdBQVcsRUFBRVgsVUFBVSxHQUFHLENBRHJCO0FBRUw7QUFDQXpnQyxVQUFBQSxLQUFLLEVBQUVoTCxNQUFNLEdBQUcsQ0FIWDtBQUlMeXJDLFVBQUFBLFVBSkssRUFBUDs7QUFNRDtBQUNGLEtBdkMyQixDQXVDMUI7OztBQUdGLFFBQUl6ckMsTUFBTSxJQUFJLENBQWQsRUFBaUI7QUFDZixVQUFJeXJDLFVBQVUsR0FBR2Msc0JBQXNCLENBQUN4aUMsTUFBTSxDQUFDL0osTUFBTSxHQUFHLENBQVYsQ0FBUCxDQUF2Qzs7QUFFQSxVQUFJeXJDLFVBQVUsSUFBSSxDQUFsQixFQUFxQjtBQUNuQixlQUFPO0FBQ0xXLFVBQUFBLFdBQVcsRUFBRVgsVUFBVSxHQUFHLENBRHJCO0FBRUw7QUFDQXpnQyxVQUFBQSxLQUFLLEVBQUVoTCxNQUFNLEdBQUcsQ0FIWDtBQUlMeXJDLFVBQUFBLFVBSkssRUFBUDs7QUFNRDtBQUNGLEtBckQyQixDQXFEMUI7OztBQUdGLFdBQU87QUFDTFcsTUFBQUEsV0FBVyxFQUFFLENBRFI7QUFFTHBoQyxNQUFBQSxLQUFLLEVBQUVoTCxNQUFNLEdBQUcsQ0FGWDtBQUdMeXJDLE1BQUFBLFVBQVUsRUFBRSxDQUhQLEVBQVA7O0FBS0Q7O0FBRURNLEVBQUFBLGNBQWMsR0FBRztBQUNmLFdBQU8sUUFBUCxDQURlLENBQ0U7QUFDbEIsR0F0RXdEOzs7O0FBMEUzRCxNQUFNVixrQkFBTixTQUFpQ0ssMEJBQWpDLENBQTREO0FBQzFEN25DLEVBQUFBLFdBQVcsR0FBRztBQUNaLFVBQU0sU0FBTixFQUFpQixDQUFqQjtBQUNEOztBQUVEZ29DLEVBQUFBLHFCQUFxQixDQUFDOWhDLE1BQUQsRUFBUztBQUM1QixVQUFNL0osTUFBTSxHQUFHK0osTUFBTSxDQUFDL0osTUFBdEI7QUFDQSxVQUFNd3NDLE1BQU0sR0FBR3hzQyxNQUFNLEdBQUcsQ0FBeEIsQ0FGNEIsQ0FFRDs7QUFFM0IsUUFBSXdzQyxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNoQjtBQUNBLFlBQU1DLElBQUksR0FBRzFpQyxNQUFNLENBQUNBLE1BQU0sQ0FBQy9KLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBbkI7O0FBRUEsVUFBSXlzQyxJQUFJLElBQUksSUFBUixJQUFnQkEsSUFBSSxJQUFJLElBQTVCLEVBQWtDO0FBQ2hDLGVBQU87QUFDTEwsVUFBQUEsV0FBVyxFQUFFLENBRFI7QUFFTFgsVUFBQUEsVUFBVSxFQUFFLENBRlA7QUFHTHpnQyxVQUFBQSxLQUFLLEVBQUVoTCxNQUFNLEdBQUcsQ0FIWCxFQUFQOztBQUtELE9BVmUsQ0FVZDs7O0FBR0YsYUFBTztBQUNMb3NDLFFBQUFBLFdBQVcsRUFBRSxDQURSO0FBRUxYLFFBQUFBLFVBQVUsRUFBRSxDQUZQLEVBQVA7O0FBSUQsS0FyQjJCLENBcUIxQjs7O0FBR0YsV0FBTztBQUNMVyxNQUFBQSxXQUFXLEVBQUUsQ0FEUjtBQUVMcGhDLE1BQUFBLEtBQUssRUFBRWhMLE1BQU0sR0FBRyxDQUZYO0FBR0x5ckMsTUFBQUEsVUFBVSxFQUFFLENBSFAsRUFBUDs7QUFLRDs7QUFFRE0sRUFBQUEsY0FBYyxHQUFHO0FBQ2Y7QUFDQSxXQUFPLEtBQUtILFVBQUwsQ0FBZ0IxcEMsUUFBaEIsQ0FBeUIsU0FBekIsRUFBb0MsQ0FBcEMsRUFBdUMsS0FBS3NwQyxTQUE1QyxDQUFQO0FBQ0QsR0F2Q3lEOzs7O0FBMkM1RCxNQUFNRixtQkFBTixTQUFrQ0ksMEJBQWxDLENBQTZEO0FBQzNEN25DLEVBQUFBLFdBQVcsR0FBRztBQUNaLFVBQU0sUUFBTixFQUFnQixDQUFoQjtBQUNBLFNBQUs0bkMsVUFBTCxHQUFrQixDQUFsQixDQUZZLENBRVM7QUFDdEI7O0FBRURJLEVBQUFBLHFCQUFxQixDQUFDOWhDLE1BQUQsRUFBUztBQUM1QixVQUFNL0osTUFBTSxHQUFHK0osTUFBTSxDQUFDL0osTUFBdEI7QUFDQSxVQUFNd3NDLE1BQU0sR0FBR3hzQyxNQUFNLEdBQUcsQ0FBeEIsQ0FGNEIsQ0FFRDs7QUFFM0IsUUFBSXdzQyxNQUFNLEtBQUssQ0FBZixFQUFrQjtBQUNoQixhQUFPO0FBQ0xKLFFBQUFBLFdBQVcsRUFBRSxDQURSO0FBRUxYLFFBQUFBLFVBQVUsRUFBRSxDQUZQLEVBQVA7O0FBSUQsS0FUMkIsQ0FTMUI7OztBQUdGLFdBQU87QUFDTFcsTUFBQUEsV0FBVyxFQUFFLElBQUlJLE1BRFo7QUFFTDtBQUNBeGhDLE1BQUFBLEtBQUssRUFBRWhMLE1BQU0sR0FBR3dzQyxNQUhYO0FBSUxmLE1BQUFBLFVBQVUsRUFBRSxDQUpQLENBSVM7QUFKVCxLQUFQOztBQU9EOztBQUVETyxFQUFBQSx3QkFBd0IsR0FBRztBQUN6QixTQUFLUixTQUFMLEdBQWlCLENBQWpCO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixDQUFsQixDQUZ5QixDQUVKO0FBQ3RCOztBQUVETSxFQUFBQSxjQUFjLEdBQUc7QUFDZjtBQUNBO0FBQ0EsV0FBTyxLQUFLSCxVQUFMLENBQWdCMXBDLFFBQWhCLENBQXlCLFFBQXpCLEVBQW1DLENBQW5DLEVBQXNDLEtBQUtzcEMsU0FBM0MsQ0FBUDtBQUNELEdBcEMwRDs7OztBQXdDN0QsU0FBU2Usc0JBQVQsQ0FBZ0NFLElBQWhDLEVBQXNDO0FBQ3BDO0FBQ0EsTUFBSUEsSUFBSSxJQUFJLENBQVIsS0FBYyxJQUFsQixFQUF3QjtBQUN0QixXQUFPLENBQVA7QUFDRCxHQUptQyxDQUlsQzs7O0FBR0YsTUFBSUEsSUFBSSxJQUFJLENBQVIsS0FBYyxJQUFsQixFQUF3QjtBQUN0QixXQUFPLENBQVA7QUFDRCxHQVRtQyxDQVNsQzs7O0FBR0YsTUFBSUEsSUFBSSxJQUFJLENBQVIsS0FBYyxJQUFsQixFQUF3QjtBQUN0QixXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPLENBQVA7QUFDRDs7QUFFRCxJQUFJQyxlQUFlLEdBQUc7QUFDcEJ4QixFQUFBQSxhQURvQixFQUF0Qjs7O0FBSUEsTUFBTXlCLGVBQWUsR0FBRyxFQUF4Qjs7QUFFQSxTQUFTQyxjQUFULENBQXdCM3JDLEdBQXhCLEVBQTZCeUYsR0FBN0IsRUFBa0M7QUFDaEMsTUFBSSxDQUFDaW1DLGVBQWUsQ0FBQzFyQyxHQUFELENBQXBCLEVBQTJCO0FBQ3pCMnBCLElBQUFBLE9BQU8sQ0FBQ2xCLElBQVIsQ0FBYWhqQixHQUFiO0FBQ0FpbUMsSUFBQUEsZUFBZSxDQUFDMXJDLEdBQUQsQ0FBZixHQUF1QixJQUF2QjtBQUNEO0FBQ0Y7QUFDRDs7Ozs7Ozs7QUFRQSxTQUFTNHJDLGVBQVQsQ0FBeUJDLFVBQXpCLEVBQXFDN3FDLElBQXJDLEVBQTJDO0FBQ3pDLFNBQU8sTUFBTTtBQUNYLFVBQU04cUMsR0FBRyxHQUFJLEdBQUVELFVBQVcsSUFBRzdxQyxJQUFLLEVBQWxDO0FBQ0EycUMsSUFBQUEsY0FBYyxDQUFDRyxHQUFELEVBQU8sSUFBR0EsR0FBSSwrREFBZCxDQUFkO0FBQ0EsV0FBT2p1QyxTQUFQO0FBQ0QsR0FKRDtBQUtEO0FBQ0Q7Ozs7Ozs7QUFPQSxTQUFTa3VDLG9CQUFULENBQThCRixVQUE5QixFQUEwQzdxQyxJQUExQyxFQUFnRCt6QixRQUFoRCxFQUEwRDtBQUN4REEsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBRCxDQUF4QixDQUR3RCxDQUNwQjs7QUFFcEM2VyxFQUFBQSxlQUFlLENBQUNDLFVBQUQsRUFBYTdxQyxJQUFiLENBQWY7QUFDQW8yQixFQUFBQSxVQUFVLENBQUNyQyxRQUFELEVBQVcsQ0FBWCxDQUFWO0FBQ0QsQyxDQUFDOzs7QUFHRixNQUFNa1gsb0JBQW9CLEdBQUcsSUFBN0IsQyxDQUFtQztBQUNuQzs7QUFFQSxNQUFNQyxlQUFlLEdBQUcsSUFBSTVuQyxHQUFKLEVBQXhCO0FBQ0EsSUFBSTZuQyxtQkFBbUIsR0FBRyxDQUExQixDLENBQTZCO0FBQzdCOztBQUVBLE1BQU1DLGdCQUFnQixHQUFHLElBQUk5bkMsR0FBSixFQUF6QjtBQUNBOG5DLGdCQUFnQixDQUFDdm5DLEdBQWpCLENBQXFCLEdBQXJCLEVBQTBCNUksRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY3FxQixXQUF4QztBQUNBRCxnQkFBZ0IsQ0FBQ3ZuQyxHQUFqQixDQUFxQixJQUFyQixFQUEyQjVJLEVBQUUsQ0FBQytsQixVQUFILENBQWNxcUIsV0FBekM7QUFDQUQsZ0JBQWdCLENBQUN2bkMsR0FBakIsQ0FBcUIsSUFBckIsRUFBMkI1SSxFQUFFLENBQUMrbEIsVUFBSCxDQUFjcXFCLFdBQXpDO0FBQ0FELGdCQUFnQixDQUFDdm5DLEdBQWpCLENBQXFCLEtBQXJCLEVBQTRCNUksRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY3FxQixXQUExQztBQUNBRCxnQkFBZ0IsQ0FBQ3ZuQyxHQUFqQixDQUFxQixLQUFyQixFQUE0QjVJLEVBQUUsQ0FBQytsQixVQUFILENBQWNxcUIsV0FBMUM7QUFDQUQsZ0JBQWdCLENBQUN2bkMsR0FBakIsQ0FBcUIsR0FBckIsRUFBMEI1SSxFQUFFLENBQUMrbEIsVUFBSCxDQUFjblosU0FBeEM7QUFDQXVqQyxnQkFBZ0IsQ0FBQ3ZuQyxHQUFqQixDQUFxQixJQUFyQixFQUEyQjVJLEVBQUUsQ0FBQytsQixVQUFILENBQWNuWixTQUF6QztBQUNBdWpDLGdCQUFnQixDQUFDdm5DLEdBQWpCLENBQXFCLEtBQXJCLEVBQTRCNUksRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY25aLFNBQTFDO0FBQ0F1akMsZ0JBQWdCLENBQUN2bkMsR0FBakIsQ0FBcUIsR0FBckIsRUFBMEI1SSxFQUFFLENBQUMrbEIsVUFBSCxDQUFjc3FCLFVBQXhDO0FBQ0FGLGdCQUFnQixDQUFDdm5DLEdBQWpCLENBQXFCLElBQXJCLEVBQTJCNUksRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY3NxQixVQUF6QztBQUNBRixnQkFBZ0IsQ0FBQ3ZuQyxHQUFqQixDQUFxQixJQUFyQixFQUEyQjVJLEVBQUUsQ0FBQytsQixVQUFILENBQWNzcUIsVUFBekM7QUFDQUYsZ0JBQWdCLENBQUN2bkMsR0FBakIsQ0FBcUIsS0FBckIsRUFBNEI1SSxFQUFFLENBQUMrbEIsVUFBSCxDQUFjc3FCLFVBQTFDLEUsQ0FBdUQ7O0FBRXZELE1BQU1DLGdCQUFnQixHQUFHLENBQUNDLE9BQUQsRUFBVXZnQixJQUFWLEtBQW1Cd2dCLFNBQVMsQ0FBQyxRQUFELEVBQVcsbUJBQVgsRUFBZ0MsQ0FBQyxFQUFqQyxFQUFxQ0QsT0FBckMsRUFBOEN2Z0IsSUFBOUMsQ0FBckQ7O0FBRUEsTUFBTXlnQixVQUFVLEdBQUcsQ0FBQ0YsT0FBRCxFQUFVdmdCLElBQVYsS0FBbUJ3Z0IsU0FBUyxDQUFDLFFBQUQsRUFBVywyQkFBWCxFQUF3QyxDQUFDLENBQXpDLEVBQTRDRCxPQUE1QyxFQUFxRHZnQixJQUFyRCxDQUEvQzs7QUFFQSxNQUFNMGdCLGlCQUFpQixHQUFHLENBQUNILE9BQUQsRUFBVXZnQixJQUFWLEtBQW1Cd2dCLFNBQVMsQ0FBQyxRQUFELEVBQVcscUJBQVgsRUFBa0MsQ0FBQyxFQUFuQyxFQUF1Q0QsT0FBdkMsRUFBZ0R2Z0IsSUFBaEQsQ0FBdEQ7O0FBRUEsTUFBTTJnQixhQUFhLEdBQUcsQ0FBQ0osT0FBRCxFQUFVdmdCLElBQVYsS0FBbUJ3Z0IsU0FBUyxDQUFDLFNBQUQsRUFBWSxpQkFBWixFQUErQixDQUFDLEVBQWhDLEVBQW9DRCxPQUFwQyxFQUE2Q3ZnQixJQUE3QyxDQUFsRDs7QUFFQSxNQUFNNGdCLGlCQUFpQixHQUFHLENBQUNMLE9BQUQsRUFBVXZnQixJQUFWLEtBQW1Cd2dCLFNBQVMsQ0FBQyxXQUFELEVBQWMscUJBQWQsRUFBcUMsQ0FBQyxFQUF0QyxFQUEwQ0QsT0FBMUMsRUFBbUR2Z0IsSUFBbkQsQ0FBdEQ7O0FBRUEsTUFBTTZnQiw0QkFBNEIsR0FBRyxDQUFDTixPQUFELEVBQVV2Z0IsSUFBVixLQUFtQndnQixTQUFTLENBQUMsUUFBRCxFQUFXLGtDQUFYLEVBQStDLENBQUMsRUFBaEQsRUFBb0RELE9BQXBELEVBQTZEdmdCLElBQTdELENBQWpFOztBQUVBLE1BQU04Z0IsRUFBRSxHQUFHO0FBQ1RoM0IsRUFBQUEsU0FBUyxFQUFFO0FBQ1RpM0IsSUFBQUEsUUFBUSxFQUFFLENBREQ7QUFFVEMsSUFBQUEsUUFBUSxFQUFFLENBRkQ7QUFHVEMsSUFBQUEsTUFBTSxFQUFFLENBSEM7QUFJVEMsSUFBQUEsTUFBTSxFQUFFLEtBSkM7QUFLVEMsSUFBQUEsT0FBTyxFQUFFLEtBTEE7QUFNVEMsSUFBQUEsT0FBTyxFQUFFLEtBTkE7QUFPVEMsSUFBQUEsT0FBTyxFQUFFLElBUEE7QUFRVEMsSUFBQUEsT0FBTyxFQUFFLEtBUkE7QUFTVEMsSUFBQUEsT0FBTyxFQUFFLElBVEE7QUFVVEMsSUFBQUEsT0FBTyxFQUFFLEtBVkE7QUFXVEMsSUFBQUEsUUFBUSxFQUFFLEtBWEQ7QUFZVEMsSUFBQUEsT0FBTyxFQUFFLEdBWkE7QUFhVEMsSUFBQUEsTUFBTSxFQUFFLElBYkM7QUFjVEMsSUFBQUEsUUFBUSxFQUFFLE1BZEQ7QUFlVEMsSUFBQUEsT0FBTyxFQUFFLElBZkE7QUFnQlRDLElBQUFBLFFBQVEsRUFBRSxDQWhCRDtBQWlCVEMsSUFBQUEsV0FBVyxFQUFFLE9BakJKO0FBa0JUQyxJQUFBQSxVQUFVLEVBQUUsR0FsQkg7QUFtQlRDLElBQUFBLE1BQU0sRUFBRSxHQW5CQztBQW9CVEMsSUFBQUEsT0FBTyxFQUFFLE9BcEJBO0FBcUJUQyxJQUFBQSxTQUFTLEVBQUUsT0FyQkY7QUFzQlRDLElBQUFBLFVBQVUsRUFBRSxDQXRCSDtBQXVCVEMsSUFBQUEsT0FBTyxFQUFFLEdBdkJBO0FBd0JUQyxJQUFBQSxPQUFPLEVBQUUsR0F4QkE7QUF5QlRDLElBQUFBLE9BQU8sRUFBRSxHQXpCQTtBQTBCVEMsSUFBQUEsT0FBTyxFQUFFLEVBMUJBO0FBMkJUQyxJQUFBQSxPQUFPLEVBQUUsRUEzQkE7QUE0QlRDLElBQUFBLE9BQU8sRUFBRSxFQTVCQTtBQTZCVEMsSUFBQUEsT0FBTyxFQUFFLEVBN0JBO0FBOEJUQyxJQUFBQSxPQUFPLEVBQUUsQ0E5QkE7QUErQlRDLElBQUFBLE9BQU8sRUFBRSxDQS9CQTtBQWdDVEMsSUFBQUEsT0FBTyxFQUFFLENBaENBO0FBaUNUQyxJQUFBQSxPQUFPLEVBQUUsQ0FqQ0E7QUFrQ1RDLElBQUFBLE9BQU8sRUFBRSxDQWxDQTtBQW1DVEMsSUFBQUEsSUFBSSxFQUFFLENBbkNHO0FBb0NUQyxJQUFBQSxJQUFJLEVBQUUsQ0FwQ0c7QUFxQ1RDLElBQUFBLElBQUksRUFBRSxDQXJDRztBQXNDVEMsSUFBQUEsSUFBSSxFQUFFLENBdENHO0FBdUNUQyxJQUFBQSxtQkFBbUIsRUFBRSxDQXZDWjtBQXdDVEMsSUFBQUEsYUFBYSxFQUFFLENBeENOLEVBREYsRUFBWDs7OztBQTZDQSxNQUFNQyxLQUFOLENBQVk7QUFDVjVzQyxFQUFBQSxXQUFXLENBQUNxcEIsSUFBRCxFQUFPO0FBQ2hCLFNBQUt3akIsS0FBTCxHQUFhLElBQWI7QUFDQSxTQUFLQyxHQUFMLEdBQVcsQ0FBWDtBQUNBLFNBQUtDLEdBQUwsR0FBVyxDQUFYO0FBQ0EsU0FBSy9tQyxJQUFMLEdBQVksQ0FBWjtBQUNBLFNBQUtnbkMsS0FBTCxHQUFhLENBQWI7QUFDQSxTQUFLMUwsR0FBTCxHQUFXLENBQVg7QUFDQSxTQUFLMkwsR0FBTCxHQUFXLENBQVg7QUFDQSxTQUFLQyxJQUFMLEdBQVksQ0FBWjtBQUNBLFNBQUtoeEIsSUFBTCxHQUFZLENBQVo7QUFDQSxTQUFLaXhCLE9BQUwsR0FBZSxJQUFmLENBVmdCLENBVUs7O0FBRXJCLFNBQUtDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLEtBQUtDLE9BQUwsR0FBZSxLQUFLQyxPQUFMLEdBQWUsS0FBS0MsV0FBTCxHQUFtQixDQUFoRTtBQUNBLFNBQUtDLEtBQUwsR0FBYSxLQUFLQyxLQUFMLEdBQWEsS0FBS0MsS0FBTCxHQUFhLEtBQUtDLFNBQUwsR0FBaUIsSUFBSXQ1QixJQUFKLENBQVMsQ0FBVCxDQUF4RDs7QUFFQSxRQUFJK1UsSUFBSixFQUFVO0FBQ1IsV0FBS3dqQixLQUFMLEdBQWFnQiwwQkFBMEIsQ0FBQ3hrQixJQUFELENBQXZDLENBRFEsQ0FDdUM7O0FBRS9DLFdBQUtza0IsS0FBTCxHQUFhLEtBQUtDLFNBQUwsR0FBaUIsS0FBS2YsS0FBTCxDQUFXaUIsU0FBWCxFQUE5QjtBQUNBLFdBQUtMLEtBQUwsR0FBYSxLQUFLQyxLQUFMLEdBQWEsS0FBS2IsS0FBTCxDQUFXa0IsVUFBWCxFQUExQjtBQUNBLFdBQUtWLE9BQUwsR0FBZSxLQUFLSSxLQUFMLENBQVd4d0IsT0FBWCxFQUFmO0FBQ0EsV0FBS3V3QixXQUFMLEdBQW1CLEtBQUtJLFNBQUwsQ0FBZTN3QixPQUFmLEVBQW5CO0FBQ0EsV0FBS3N3QixPQUFMLEdBQWUsS0FBS0ksS0FBTCxDQUFXMXdCLE9BQVgsRUFBZjtBQUNBLFdBQUtxd0IsT0FBTCxHQUFlLEtBQUtJLEtBQUwsQ0FBV3p3QixPQUFYLEVBQWY7QUFDQSxXQUFLZixJQUFMLEdBQVksS0FBSzJ3QixLQUFMLENBQVczd0IsSUFBdkI7QUFDQSxXQUFLa3hCLE1BQUwsR0FBYzFpQyxJQUFJLENBQUNzakMsSUFBTCxDQUFVLEtBQUs5eEIsSUFBTCxHQUFZLEtBQUtpeEIsT0FBM0IsQ0FBZCxDQVZRLENBVTJDO0FBQ3BEO0FBQ0Y7O0FBRURjLEVBQUFBLE1BQU0sR0FBRztBQUNQLFdBQU8sS0FBS3BCLEtBQUwsQ0FBV29CLE1BQVgsRUFBUDtBQUNEOztBQUVEQyxFQUFBQSxXQUFXLEdBQUc7QUFDWixXQUFPLEtBQUtyQixLQUFMLENBQVdxQixXQUFYLEVBQVA7QUFDRDs7QUFFREMsRUFBQUEsYUFBYSxHQUFHO0FBQ2QsV0FBTyxLQUFQO0FBQ0Q7O0FBRURDLEVBQUFBLGlCQUFpQixHQUFHO0FBQ2xCLFdBQU8sS0FBUDtBQUNEOztBQUVEQyxFQUFBQSxjQUFjLEdBQUc7QUFDZixXQUFPLEtBQUt4QixLQUFMLENBQVd5QixZQUFsQjtBQUNEOztBQUVEQyxFQUFBQSxNQUFNLEdBQUc7QUFDUCxXQUFPLEtBQVA7QUFDRDs7QUFFREMsRUFBQUEsUUFBUSxHQUFHO0FBQ1QsV0FBTyxLQUFQO0FBQ0QsR0F6RFM7Ozs7QUE2RFpyRSxFQUFFLENBQUN5QyxLQUFILEdBQVdBLEtBQVg7O0FBRUEsTUFBTWhMLFVBQU4sQ0FBaUI7O0FBRWpCdUksRUFBRSxDQUFDdkksVUFBSCxHQUFnQkEsVUFBaEI7O0FBRUEsTUFBTUMsV0FBTixDQUFrQjs7QUFFbEJzSSxFQUFFLENBQUN0SSxXQUFILEdBQWlCQSxXQUFqQjtBQUNBOzs7Ozs7QUFNQTs7Ozs7O0FBTUFzSSxFQUFFLENBQUNzRSxNQUFILEdBQVksVUFBVXBsQixJQUFWLEVBQWdCcmpCLElBQWhCLEVBQXNCbXNCLFFBQXRCLEVBQWdDO0FBQzFDLE1BQUksT0FBT25zQixJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQzlCbXNCLElBQUFBLFFBQVEsR0FBR25zQixJQUFYO0FBQ0FBLElBQUFBLElBQUksR0FBR21rQyxFQUFFLENBQUNoM0IsU0FBSCxDQUFhbTVCLElBQXBCO0FBQ0Q7O0FBRURuYSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFELENBQXhCO0FBQ0FxQyxFQUFBQSxVQUFVLENBQUMsTUFBTTtBQUNmLFFBQUk7QUFDRjJWLE1BQUFBLEVBQUUsQ0FBQ3VFLFVBQUgsQ0FBY3JsQixJQUFkLEVBQW9CcmpCLElBQXBCO0FBQ0QsS0FGRCxDQUVFLE9BQU8xTCxDQUFQLEVBQVU7QUFDVjYzQixNQUFBQSxRQUFRLENBQUM3M0IsQ0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRDYzQixJQUFBQSxRQUFRO0FBQ1QsR0FUUyxFQVNQLENBVE8sQ0FBVjtBQVVELENBakJEO0FBa0JBOzs7Ozs7QUFNQWdZLEVBQUUsQ0FBQ3VFLFVBQUgsR0FBZ0IsVUFBVXJsQixJQUFWLEVBQWdCcmpCLElBQUksR0FBR21rQyxFQUFFLENBQUNoM0IsU0FBSCxDQUFhbTVCLElBQXBDLEVBQTBDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTXFDLFVBQVUsR0FBR2QsMEJBQTBCLENBQUN4a0IsSUFBRCxDQUE3Qzs7QUFFQSxNQUFJLENBQUNzbEIsVUFBVSxDQUFDamlCLE1BQVgsRUFBTCxFQUEwQjtBQUN4QixVQUFNb2QsVUFBVSxDQUFDLFFBQUQsRUFBV3pnQixJQUFYLENBQWhCO0FBQ0QsR0FUdUQsQ0FTdEQ7OztBQUdGLE1BQUlyakIsSUFBSSxHQUFHbWtDLEVBQUUsQ0FBQ2gzQixTQUFILENBQWFxNUIsSUFBcEIsSUFBNEIsQ0FBQ21DLFVBQVUsQ0FBQ3gxQyxRQUE1QyxFQUFzRDtBQUNwRCxVQUFNd3dDLGdCQUFnQixDQUFDLFFBQUQsRUFBV3RnQixJQUFYLENBQXRCO0FBQ0Q7O0FBRUQsTUFBSXJqQixJQUFJLEdBQUdta0MsRUFBRSxDQUFDaDNCLFNBQUgsQ0FBYXM1QixJQUFwQixJQUE0QixDQUFDa0MsVUFBVSxDQUFDQyxVQUF4QyxJQUFzREQsVUFBVSxDQUFDVixNQUFYLEVBQTFELEVBQStFO0FBQzdFLFVBQU10RSxnQkFBZ0IsQ0FBQyxRQUFELEVBQVd0Z0IsSUFBWCxDQUF0QjtBQUNEO0FBQ0YsQ0FuQkQ7QUFvQkE7Ozs7Ozs7Ozs7OztBQVlBOGdCLEVBQUUsQ0FBQzBFLFVBQUgsR0FBZ0IsQ0FBQ0MsSUFBRCxFQUFPcGdDLElBQVAsRUFBYWdKLE9BQWIsRUFBc0J5YSxRQUF0QixLQUFtQztBQUNqREEsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBUSxJQUFJemEsT0FBYixDQUF4QjtBQUNBQSxFQUFBQSxPQUFPLEdBQUdxM0IsbUJBQW1CLENBQUNyM0IsT0FBRCxFQUFVO0FBQ3JDclMsSUFBQUEsUUFBUSxFQUFFLE1BRDJCO0FBRXJDVyxJQUFBQSxJQUFJLEVBQUUsS0FGK0I7QUFHckNncEMsSUFBQUEsSUFBSSxFQUFFLEdBSCtCLEVBQVYsQ0FBN0I7O0FBS0E3RSxFQUFBQSxFQUFFLENBQUM4RSxTQUFILENBQWFILElBQWIsRUFBbUJwZ0MsSUFBbkIsRUFBeUJnSixPQUF6QixFQUFrQ3lhLFFBQWxDO0FBQ0QsQ0FSRDtBQVNBOzs7Ozs7Ozs7OztBQVdBZ1ksRUFBRSxDQUFDK0UsY0FBSCxHQUFvQixDQUFDSixJQUFELEVBQU9wZ0MsSUFBUCxFQUFhZ0osT0FBYixLQUF5QjtBQUMzQ0EsRUFBQUEsT0FBTyxHQUFHcTNCLG1CQUFtQixDQUFDcjNCLE9BQUQsRUFBVTtBQUNyQ3JTLElBQUFBLFFBQVEsRUFBRSxNQUQyQjtBQUVyQ1csSUFBQUEsSUFBSSxFQUFFLEtBRitCO0FBR3JDZ3BDLElBQUFBLElBQUksRUFBRSxHQUgrQixFQUFWLENBQTdCOztBQUtBN0UsRUFBQUEsRUFBRSxDQUFDZ0YsYUFBSCxDQUFpQkwsSUFBakIsRUFBdUJwZ0MsSUFBdkIsRUFBNkJnSixPQUE3QixFQU4yQyxDQU1KO0FBQ3hDLENBUEQ7O0FBU0F5eUIsRUFBRSxDQUFDaUYsS0FBSCxHQUFXLENBQUMvbEIsSUFBRCxFQUFPcmpCLElBQVAsRUFBYW1zQixRQUFiLEtBQTBCZ1gsb0JBQW9CLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0JoWCxRQUFoQixDQUF6RDs7QUFFQWdZLEVBQUUsQ0FBQ2tGLFNBQUgsR0FBZXJHLGVBQWUsQ0FBQyxJQUFELEVBQU8sV0FBUCxDQUE5Qjs7QUFFQW1CLEVBQUUsQ0FBQ21GLEtBQUgsR0FBVyxDQUFDam1CLElBQUQsRUFBT2lZLEdBQVAsRUFBWTJMLEdBQVosRUFBaUI5YSxRQUFqQixLQUE4QmdYLG9CQUFvQixDQUFDLElBQUQsRUFBTyxPQUFQLEVBQWdCaFgsUUFBaEIsQ0FBN0Q7O0FBRUFnWSxFQUFFLENBQUNvRixTQUFILEdBQWV2RyxlQUFlLENBQUMsSUFBRCxFQUFPLFdBQVAsQ0FBOUI7QUFDQTs7Ozs7OztBQU9BOzs7OztBQUtBbUIsRUFBRSxDQUFDL2pDLEtBQUgsR0FBVyxDQUFDb3BDLEVBQUQsRUFBS3JkLFFBQUwsS0FBa0I7QUFDM0JBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsUUFBSTtBQUNGMlYsTUFBQUEsRUFBRSxDQUFDc0YsU0FBSCxDQUFhRCxFQUFiO0FBQ0QsS0FGRCxDQUVFLE9BQU9sMUMsQ0FBUCxFQUFVO0FBQ1Y2M0IsTUFBQUEsUUFBUSxDQUFDNzNCLENBQUQsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUQ2M0IsSUFBQUEsUUFBUTtBQUNULEdBVFMsRUFTUCxDQVRPLENBQVY7QUFVRCxDQVpEO0FBYUE7Ozs7O0FBS0FnWSxFQUFFLENBQUNzRixTQUFILEdBQWVELEVBQUUsSUFBSTtBQUNuQixRQUFNcnJCLE1BQU0sR0FBR3VyQixtQkFBbUIsQ0FBQ0YsRUFBRCxDQUFsQztBQUNBcnJCLEVBQUFBLE1BQU0sQ0FBQy9kLEtBQVA7QUFDRCxDQUhELEMsQ0FHRzs7QUFFSDs7Ozs7Ozs7QUFRQStqQyxFQUFFLENBQUN3RixRQUFILEdBQWMsVUFBVXRvQyxHQUFWLEVBQWVtRCxJQUFmLEVBQXFCczdCLEtBQXJCLEVBQTRCM1QsUUFBNUIsRUFBc0M7QUFDbEQsTUFBSSxPQUFPMlQsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQjNULElBQUFBLFFBQVEsR0FBRzJULEtBQVg7QUFDQUEsSUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRDs7QUFFRDNULEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEIsQ0FOa0QsQ0FNZDs7QUFFcEMsUUFBTXlkLE9BQU8sR0FBR3YyQyxFQUFFLENBQUMrbEIsVUFBSCxDQUFjcU4sT0FBZCxDQUFzQnBsQixHQUF0QixDQUFoQjtBQUNBLFFBQU13b0MsU0FBUyxHQUFHRCxPQUFPLENBQUNFLElBQVIsQ0FBYXoyQyxFQUFFLENBQUMrbEIsVUFBSCxDQUFjblosU0FBM0IsQ0FBbEI7QUFDQSxRQUFNOHBDLFFBQVEsR0FBRzEyQyxFQUFFLENBQUMrbEIsVUFBSCxDQUFjcU4sT0FBZCxDQUFzQmppQixJQUF0QixDQUFqQjtBQUNBLFFBQU13bEMsVUFBVSxHQUFHRCxRQUFRLENBQUNELElBQVQsQ0FBY3oyQyxFQUFFLENBQUMrbEIsVUFBSCxDQUFjc3FCLFVBQTVCLENBQW5CO0FBQ0F1RyxFQUFBQSxJQUFJLENBQUNKLFNBQUQsRUFBWUcsVUFBWixFQUF3QjdkLFFBQXhCLENBQUo7QUFDRCxDQWJEO0FBY0E7Ozs7Ozs7QUFPQWdZLEVBQUUsQ0FBQytGLFlBQUgsR0FBa0IsVUFBVTdvQyxHQUFWLEVBQWVtRCxJQUFmLEVBQXFCczdCLEtBQUssR0FBRyxDQUE3QixFQUFnQztBQUNoRCxRQUFNOEosT0FBTyxHQUFHdjJDLEVBQUUsQ0FBQytsQixVQUFILENBQWNxTixPQUFkLENBQXNCcGxCLEdBQXRCLENBQWhCOztBQUVBLE1BQUl5K0IsS0FBSyxLQUFLcUUsRUFBRSxDQUFDaDNCLFNBQUgsQ0FBYXc1QixhQUF2QixJQUF3Q3hDLEVBQUUsQ0FBQ2dHLFVBQUgsQ0FBYzNsQyxJQUFkLENBQTVDLEVBQWlFO0FBQy9ELFVBQU11L0IsaUJBQWlCLENBQUMsVUFBRCxFQUFhdi9CLElBQWIsQ0FBdkI7QUFDRDs7QUFFRCxNQUFJLENBQUNvbEMsT0FBTyxDQUFDN2xDLElBQVIsQ0FBYVMsSUFBYixDQUFMLEVBQXlCO0FBQ3ZCLFVBQU0sSUFBSWhRLEtBQUosQ0FBVyxrQkFBaUI2TSxHQUFJLE9BQU1tRCxJQUFLLEVBQTNDLENBQU4sQ0FEdUIsQ0FDOEI7QUFDdEQ7QUFDRixDQVZELEMsQ0FVRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOzs7Ozs7O0FBT0EyL0IsRUFBRSxDQUFDemQsTUFBSCxHQUFZLFVBQVVyRCxJQUFWLEVBQWdCOEksUUFBaEIsRUFBMEI7QUFDcENBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2ZyQyxJQUFBQSxRQUFRLENBQUNnWSxFQUFFLENBQUNnRyxVQUFILENBQWM5bUIsSUFBZCxDQUFELENBQVI7QUFDRCxHQUZTLEVBRVAsQ0FGTyxDQUFWO0FBR0QsQ0FMRDtBQU1BOzs7Ozs7QUFNQThnQixFQUFFLENBQUNnRyxVQUFILEdBQWdCLFVBQVU5bUIsSUFBVixFQUFnQjtBQUM5QixNQUFJO0FBQ0Y4Z0IsSUFBQUEsRUFBRSxDQUFDdUUsVUFBSCxDQUFjcmxCLElBQWQ7QUFDQSxXQUFPLElBQVA7QUFDRCxHQUhELENBR0UsT0FBTy91QixDQUFQLEVBQVU7QUFDVixXQUFPLEtBQVA7QUFDRDtBQUNGLENBUEQ7O0FBU0E2dkMsRUFBRSxDQUFDaUcsTUFBSCxHQUFZLENBQUNaLEVBQUQsRUFBS3hwQyxJQUFMLEVBQVdtc0IsUUFBWCxLQUF3QmdYLG9CQUFvQixDQUFDLElBQUQsRUFBTyxRQUFQLEVBQWlCaFgsUUFBakIsQ0FBeEQ7O0FBRUFnWSxFQUFFLENBQUNrRyxVQUFILEdBQWdCckgsZUFBZSxDQUFDLElBQUQsRUFBTyxZQUFQLENBQS9COztBQUVBbUIsRUFBRSxDQUFDbUcsTUFBSCxHQUFZLENBQUNkLEVBQUQsRUFBS2xPLEdBQUwsRUFBVTJMLEdBQVYsRUFBZTlhLFFBQWYsS0FBNEJnWCxvQkFBb0IsQ0FBQyxJQUFELEVBQU8sUUFBUCxFQUFpQmhYLFFBQWpCLENBQTVEOztBQUVBZ1ksRUFBRSxDQUFDb0csVUFBSCxHQUFnQnZILGVBQWUsQ0FBQyxJQUFELEVBQU8sWUFBUCxDQUEvQjs7QUFFQW1CLEVBQUUsQ0FBQ3FHLFNBQUgsR0FBZSxDQUFDaEIsRUFBRCxFQUFLcmQsUUFBTCxLQUFrQmdYLG9CQUFvQixDQUFDLElBQUQsRUFBTyxXQUFQLEVBQW9CaFgsUUFBcEIsQ0FBckQ7O0FBRUFnWSxFQUFFLENBQUNzRyxhQUFILEdBQW1CekgsZUFBZSxDQUFDLElBQUQsRUFBTyxlQUFQLENBQWxDO0FBQ0E7Ozs7Ozs7QUFPQW1CLEVBQUUsQ0FBQ3VHLEtBQUgsR0FBVyxDQUFDbEIsRUFBRCxFQUFLOTNCLE9BQUwsRUFBY3lhLFFBQWQsS0FBMkI7QUFDcEMsTUFBSSxPQUFPemEsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ3lhLElBQUFBLFFBQVEsR0FBR3phLE9BQVg7QUFDQUEsSUFBQUEsT0FBTyxHQUFHLEVBQVY7QUFDRDs7QUFFRHlhLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsUUFBSW1jLEtBQUo7O0FBRUEsUUFBSTtBQUNGQSxNQUFBQSxLQUFLLEdBQUd4RyxFQUFFLENBQUN5RyxTQUFILENBQWFwQixFQUFiLEVBQWlCOTNCLE9BQWpCLENBQVI7QUFDRCxLQUZELENBRUUsT0FBT3BkLENBQVAsRUFBVTtBQUNWNjNCLE1BQUFBLFFBQVEsQ0FBQzczQixDQUFELENBQVI7QUFDQTtBQUNEOztBQUVENjNCLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU93ZSxLQUFQLENBQVI7QUFDRCxHQVhTLEVBV1AsQ0FYTyxDQUFWO0FBWUQsQ0FuQkQ7QUFvQkE7Ozs7Ozs7O0FBUUF4RyxFQUFFLENBQUN5RyxTQUFILEdBQWUsQ0FBQ3BCLEVBQUQsRUFBS3FCLFFBQUwsS0FBa0I7QUFDL0IsUUFBTXhuQixJQUFJLEdBQUd5bkIscUJBQXFCLENBQUN0QixFQUFELENBQWxDO0FBQ0EsU0FBT3JGLEVBQUUsQ0FBQzRHLFFBQUgsQ0FBWTFuQixJQUFaLENBQVA7QUFDRCxDQUhELEMsQ0FHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQThnQixFQUFFLENBQUM2RyxLQUFILEdBQVcsQ0FBQzNuQixJQUFELEVBQU8zUixPQUFQLEVBQWdCeWEsUUFBaEIsS0FBNkJnWSxFQUFFLENBQUM4RyxJQUFILENBQVE1bkIsSUFBUixFQUFjM1IsT0FBZCxFQUF1QnlhLFFBQXZCLENBQXhDOztBQUVBZ1ksRUFBRSxDQUFDK0csU0FBSCxHQUFlLENBQUM3bkIsSUFBRCxFQUFPM1IsT0FBUCxLQUFtQnl5QixFQUFFLENBQUM0RyxRQUFILENBQVkxbkIsSUFBWixFQUFrQjNSLE9BQWxCLENBQWxDO0FBQ0E7Ozs7Ozs7OztBQVNBeXlCLEVBQUUsQ0FBQ2dILEtBQUgsR0FBVyxDQUFDOW5CLElBQUQsRUFBTzNSLE9BQVAsRUFBZ0J5YSxRQUFoQixLQUE2QjtBQUN0QyxNQUFJLE9BQU96YSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDeWEsSUFBQUEsUUFBUSxHQUFHemEsT0FBWDtBQUNBQSxJQUFBQSxPQUFPLEdBQUc7QUFDUjA1QixNQUFBQSxTQUFTLEVBQUUsS0FESDtBQUVScHJDLE1BQUFBLElBQUksRUFBRSxLQUZFLEVBQVY7O0FBSUQ7O0FBRURtc0IsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBRCxDQUF4QjtBQUNBcUMsRUFBQUEsVUFBVSxDQUFDLE1BQU07QUFDZixRQUFJO0FBQ0YyVixNQUFBQSxFQUFFLENBQUNrSCxTQUFILENBQWFob0IsSUFBYixFQUFtQjNSLE9BQW5CO0FBQ0QsS0FGRCxDQUVFLE9BQU9wZCxDQUFQLEVBQVU7QUFDVjYzQixNQUFBQSxRQUFRLENBQUM3M0IsQ0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRDYzQixJQUFBQSxRQUFRLENBQUMsSUFBRCxDQUFSO0FBQ0QsR0FUUyxFQVNQLENBVE8sQ0FBVjtBQVVELENBcEJEO0FBcUJBOzs7Ozs7OztBQVFBZ1ksRUFBRSxDQUFDa0gsU0FBSCxHQUFlLENBQUNob0IsSUFBRCxFQUFPM1IsT0FBUCxLQUFtQjtBQUNoQyxRQUFNNDVCLE1BQU0sR0FBR3pELDBCQUEwQixDQUFDeGtCLElBQUQsQ0FBekM7O0FBRUEsTUFBSSxPQUFPM1IsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQkEsSUFBQUEsT0FBTyxHQUFHO0FBQ1IwNUIsTUFBQUEsU0FBUyxFQUFFLEtBREg7QUFFUnByQyxNQUFBQSxJQUFJLEVBQUUwUixPQUZFLEVBQVY7O0FBSUQsR0FMRCxNQUtPO0FBQ0xBLElBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckMwNUIsTUFBQUEsU0FBUyxFQUFFLEtBRDBCO0FBRXJDcHJDLE1BQUFBLElBQUksRUFBRSxLQUYrQixFQUFWLENBQTdCOztBQUlEOztBQUVELE1BQUksQ0FBQ3NyQyxNQUFNLENBQUNDLGVBQVAsQ0FBdUI3NUIsT0FBTyxDQUFDMDVCLFNBQS9CLENBQUQsSUFBOEMsQ0FBQzE1QixPQUFPLENBQUMwNUIsU0FBM0QsRUFBc0U7QUFDcEUsUUFBSUUsTUFBTSxDQUFDNWtCLE1BQVAsRUFBSixFQUFxQjtBQUNuQjtBQUNBLFlBQU1xZCxpQkFBaUIsQ0FBQyxPQUFELEVBQVUxZ0IsSUFBVixDQUF2QjtBQUNELEtBSm1FLENBSWxFOzs7QUFHRixVQUFNeWdCLFVBQVUsQ0FBQyxPQUFELEVBQVV6Z0IsSUFBVixDQUFoQjtBQUNEO0FBQ0YsQ0F4QkQ7QUF5QkE7Ozs7OztBQU1BOzs7Ozs7OztBQVFBOGdCLEVBQUUsQ0FBQ3FILE9BQUgsR0FBYSxDQUFDaDFCLE1BQUQsRUFBUzlFLE9BQVQsRUFBa0J5YSxRQUFsQixLQUErQjtBQUMxQzNDLEVBQUFBLGtCQUFrQixDQUFDaFQsTUFBRCxFQUFTLFFBQVQsRUFBbUIsUUFBbkIsQ0FBbEI7O0FBRUEsTUFBSSxPQUFPOUUsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ3lhLElBQUFBLFFBQVEsR0FBR3phLE9BQVg7QUFDQUEsSUFBQUEsT0FBTyxHQUFHLEVBQVY7QUFDRDs7QUFFRHlhLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXphLEVBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckNyUyxJQUFBQSxRQUFRLEVBQUUsT0FEMkIsRUFBVixDQUE3QjtBQUVJOztBQUVKLFFBQU1vc0MsVUFBVSxHQUFHLE1BQU07QUFDdkIsVUFBTUMsU0FBUyxHQUFHQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUlqNkIsT0FBTyxDQUFDclMsUUFBWixDQUFsQyxDQUR1QixDQUNrQzs7QUFFekQsVUFBTWdrQixJQUFJLEdBQUksR0FBRTdNLE1BQU8sR0FBRWsxQixTQUFVLEVBQW5DO0FBQ0F2SCxJQUFBQSxFQUFFLENBQUNnSCxLQUFILENBQVM5bkIsSUFBVCxFQUFlLEtBQWYsRUFBc0J6dUIsR0FBRyxJQUFJO0FBQzNCLFVBQUlBLEdBQUosRUFBUztBQUNQLFlBQUlBLEdBQUcsQ0FBQzJDLElBQUosS0FBYSxRQUFqQixFQUEyQjtBQUN6QjtBQUNBaTNCLFVBQUFBLFVBQVUsQ0FBQ2lkLFVBQUQsRUFBYSxDQUFiLENBQVY7QUFDQTtBQUNELFNBTE0sQ0FLTDs7O0FBR0Z0ZixRQUFBQSxRQUFRLENBQUN2M0IsR0FBRCxDQUFSO0FBQ0E7QUFDRCxPQVgwQixDQVd6Qjs7O0FBR0Z1M0IsTUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBTzlJLElBQVAsQ0FBUjtBQUNELEtBZkQ7QUFnQkQsR0FwQkQ7O0FBc0JBbUwsRUFBQUEsVUFBVSxDQUFDaWQsVUFBRCxFQUFhLENBQWIsQ0FBVjtBQUNELENBcENEO0FBcUNBOzs7Ozs7Ozs7QUFTQXRILEVBQUUsQ0FBQ3lILFdBQUgsR0FBaUIsQ0FBQ3AxQixNQUFELEVBQVM5RSxPQUFULEtBQXFCO0FBQ3BDOFgsRUFBQUEsa0JBQWtCLENBQUNoVCxNQUFELEVBQVMsUUFBVCxFQUFtQixRQUFuQixDQUFsQjtBQUNBOUUsRUFBQUEsT0FBTyxHQUFHcTNCLG1CQUFtQixDQUFDcjNCLE9BQUQsRUFBVTtBQUNyQ3JTLElBQUFBLFFBQVEsRUFBRSxPQUQyQixFQUFWLENBQTdCOztBQUdBLE1BQUl3c0MsVUFBVSxHQUFHLENBQWpCO0FBQ0EsUUFBTUMsV0FBVyxHQUFHLEdBQXBCOztBQUVBLFNBQU9ELFVBQVUsR0FBR0MsV0FBcEIsRUFBaUM7QUFDL0IsVUFBTUosU0FBUyxHQUFHQyxnQkFBZ0IsQ0FBQyxDQUFELEVBQUlqNkIsT0FBTyxDQUFDclMsUUFBWixDQUFsQyxDQUQrQixDQUMwQjs7QUFFekQsVUFBTWdrQixJQUFJLEdBQUksR0FBRTdNLE1BQU8sR0FBRWsxQixTQUFVLEVBQW5DOztBQUVBLFFBQUk7QUFDRnZILE1BQUFBLEVBQUUsQ0FBQ2tILFNBQUgsQ0FBYWhvQixJQUFiLEVBQW1CLEtBQW5CLEVBREUsQ0FDeUI7O0FBRTNCLGFBQU9BLElBQVA7QUFDRCxLQUpELENBSUUsT0FBTy91QixDQUFQLEVBQVU7QUFDVixVQUFJQSxDQUFDLENBQUNpRCxJQUFGLEtBQVcsUUFBZixFQUF5QjtBQUN2QixjQUFNakQsQ0FBTixDQUR1QixDQUNkO0FBQ1YsT0FIUyxDQUdSOzs7QUFHRnUzQyxNQUFBQSxVQUFVO0FBQ1g7QUFDRjs7QUFFRCxRQUFNLElBQUlyM0MsS0FBSixDQUFXLHdEQUF1RGdpQixNQUFPLEVBQXpFLENBQU47QUFDRCxDQTVCRDtBQTZCQTs7Ozs7O0FBTUE7Ozs7Ozs7O0FBUUEydEIsRUFBRSxDQUFDMkYsSUFBSCxHQUFVLENBQUN6bUIsSUFBRCxFQUFPeWMsS0FBUCxFQUFjOS9CLElBQWQsRUFBb0Jtc0IsUUFBcEIsS0FBaUM7QUFDekM7QUFDQSxNQUFJLE9BQU8yVCxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO0FBQy9CM1QsSUFBQUEsUUFBUSxHQUFHMlQsS0FBWDtBQUNBQSxJQUFBQSxLQUFLLEdBQUcsR0FBUjtBQUNBOS9CLElBQUFBLElBQUksR0FBRyxLQUFQO0FBQ0QsR0FKRCxNQUlPLElBQUksT0FBT0EsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUNyQ21zQixJQUFBQSxRQUFRLEdBQUduc0IsSUFBWDtBQUNBQSxJQUFBQSxJQUFJLEdBQUcsS0FBUDtBQUNEOztBQUVEbXNCLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsUUFBSXVkLGNBQUo7O0FBRUEsUUFBSTtBQUNGQSxNQUFBQSxjQUFjLEdBQUc1SCxFQUFFLENBQUM2SCxRQUFILENBQVkzb0IsSUFBWixFQUFrQnljLEtBQWxCLEVBQXlCOS9CLElBQXpCLENBQWpCO0FBQ0QsS0FGRCxDQUVFLE9BQU8xTCxDQUFQLEVBQVU7QUFDVjYzQixNQUFBQSxRQUFRLENBQUM3M0IsQ0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRDYzQixJQUFBQSxRQUFRLENBQUMsSUFBRCxFQUFPNGYsY0FBUCxDQUFSO0FBQ0QsR0FYUyxFQVdQLENBWE8sQ0FBVjtBQVlELENBeEJEO0FBeUJBOzs7Ozs7OztBQVFBNUgsRUFBRSxDQUFDNkgsUUFBSCxHQUFjLENBQUMzb0IsSUFBRCxFQUFPeWMsS0FBSyxHQUFHLEdBQWYsRUFBb0JtTSxLQUFLLEdBQUcsS0FBNUIsS0FBc0M7QUFDbEQsUUFBTVgsTUFBTSxHQUFHekQsMEJBQTBCLENBQUN4a0IsSUFBRCxDQUF6Qzs7QUFFQSxNQUFJLENBQUNpb0IsTUFBTSxDQUFDNWtCLE1BQVAsRUFBTCxFQUFzQjtBQUNwQjtBQUNBcWMsSUFBQUEsY0FBYyxDQUFDLGtCQUFELEVBQXFCLDhFQUFyQixDQUFkOztBQUVBLFFBQUksQ0FBQ3VJLE1BQU0sQ0FBQ1ksVUFBUCxFQUFMLEVBQTBCO0FBQ3hCO0FBQ0EsVUFBSSxDQUFDWixNQUFNLENBQUNhLE1BQVAsQ0FBY3psQixNQUFkLEVBQUwsRUFBNkI7QUFDM0I7QUFDQSxjQUFNb2QsVUFBVSxDQUFDLE1BQUQsRUFBU3pnQixJQUFULENBQWhCO0FBQ0Q7O0FBRUQsWUFBTSxJQUFJN3VCLEtBQUosQ0FBVyxpQ0FBZ0M2dUIsSUFBSyxFQUFoRCxDQUFOO0FBQ0Q7QUFDRixHQWJELE1BYU8sSUFBSXljLEtBQUosRUFBVztBQUNoQjtBQUNBLFFBQUksQ0FBQ0EsS0FBSyxDQUFDdjBCLE1BQU4sQ0FBYSxDQUFiLE1BQW9CLEdBQXBCLElBQTJCdTBCLEtBQUssQ0FBQ3YwQixNQUFOLENBQWEsQ0FBYixNQUFvQixHQUFoRCxLQUF3RCsvQixNQUFNLENBQUNwRCxXQUFQLEVBQTVELEVBQWtGO0FBQ2hGO0FBQ0EsWUFBTWhFLDRCQUE0QixDQUFDLE1BQUQsRUFBUzdnQixJQUFULENBQWxDO0FBQ0Q7O0FBRUQsUUFBSXljLEtBQUssQ0FBQzNwQyxNQUFOLEdBQWUsQ0FBZixJQUFvQjJwQyxLQUFLLENBQUN2MEIsTUFBTixDQUFhLENBQWIsTUFBb0IsR0FBNUMsRUFBaUQ7QUFDL0M7QUFDQSxZQUFNdzRCLGlCQUFpQixDQUFDLE1BQUQsRUFBUzFnQixJQUFULENBQXZCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFNK29CLE1BQU0sR0FBRzVJLGdCQUFnQixDQUFDeHJDLEdBQWpCLENBQXFCOG5DLEtBQXJCLENBQWY7O0FBRUEsTUFBSXNNLE1BQU0sS0FBS24zQyxTQUFmLEVBQTBCO0FBQ3hCO0FBQ0EsVUFBTUwsR0FBRyxHQUFHLElBQUk4SSxTQUFKLENBQWUsY0FBYVEsTUFBTSxDQUFDNGhDLEtBQUQsQ0FBUSxpQ0FBMUMsQ0FBWjtBQUNBbHJDLElBQUFBLEdBQUcsQ0FBQzJDLElBQUosR0FBVyx1QkFBWDtBQUNBLFVBQU0zQyxHQUFOO0FBQ0Q7O0FBRUQsU0FBT3kzQyxvQkFBb0IsQ0FBQ2hwQixJQUFELEVBQU9pb0IsTUFBTSxDQUFDeEIsSUFBUCxDQUFZc0MsTUFBWixDQUFQLENBQTNCO0FBQ0QsQ0F2Q0Q7QUF3Q0E7Ozs7Ozs7QUFPQTs7Ozs7Ozs7OztBQVVBakksRUFBRSxDQUFDdmQsSUFBSCxHQUFVLENBQUM0aUIsRUFBRCxFQUFLdHBDLE1BQUwsRUFBYVEsTUFBYixFQUFxQnZLLE1BQXJCLEVBQTZCMFYsUUFBN0IsRUFBdUNzZ0IsUUFBdkMsS0FBb0Q7QUFDNURBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQSxRQUFNbWdCLFlBQVksR0FBRzVDLG1CQUFtQixDQUFDRixFQUFELENBQXhDOztBQUVBLE1BQUksQ0FBQ2xxQyxNQUFNLENBQUN0TCxRQUFQLENBQWdCa00sTUFBaEIsQ0FBTCxFQUE4QjtBQUM1QkEsSUFBQUEsTUFBTSxHQUFHWixNQUFNLENBQUNrQixJQUFQLENBQVlOLE1BQVosQ0FBVDtBQUNELEdBTjJELENBTTFEOzs7QUFHRixNQUFJMkwsUUFBUSxLQUFLLElBQWpCLEVBQXVCO0FBQ3JCazNCLElBQUFBLGNBQWMsQ0FBQyxzQkFBRCxFQUF5Qix5RkFBekIsQ0FBZDtBQUNEOztBQUVEdUosRUFBQUEsWUFBWSxDQUFDMWxCLElBQWIsQ0FBa0IxbUIsTUFBTSxDQUFDcUIsVUFBUCxFQUFsQixFQUF1Q2IsTUFBdkMsRUFBK0N2SyxNQUEvQyxFQUF1RG8yQyxPQUFPLElBQUk7QUFDaEUsUUFBSSxDQUFDQSxPQUFPLENBQUNDLE9BQWIsRUFBc0I7QUFDcEJyZ0IsTUFBQUEsUUFBUSxDQUFDLElBQUkzM0IsS0FBSixDQUFVKzNDLE9BQU8sQ0FBQ3J4QyxLQUFsQixDQUFELENBQVI7QUFDQTtBQUNEOztBQUVEaXhCLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU9vZ0IsT0FBTyxDQUFDRSxjQUFmLEVBQStCdnNDLE1BQS9CLENBQVI7QUFDRCxHQVBEO0FBUUQsQ0FyQkQ7QUFzQkE7Ozs7Ozs7Ozs7QUFVQWlrQyxFQUFFLENBQUN1SSxRQUFILEdBQWMsQ0FBQ2xELEVBQUQsRUFBS3RwQyxNQUFMLEVBQWFRLE1BQWIsRUFBcUJ2SyxNQUFyQixFQUE2QncyQyxTQUE3QixLQUEyQztBQUN2RCxRQUFNQyxVQUFVLEdBQUdsRCxtQkFBbUIsQ0FBQ0YsRUFBRCxDQUF0Qzs7QUFFQSxNQUFJLENBQUNscUMsTUFBTSxDQUFDdEwsUUFBUCxDQUFnQmtNLE1BQWhCLENBQUwsRUFBOEI7QUFDNUJBLElBQUFBLE1BQU0sR0FBR1osTUFBTSxDQUFDa0IsSUFBUCxDQUFZTixNQUFaLENBQVQ7QUFDRCxHQUxzRCxDQUtyRDs7O0FBR0YsTUFBSXlzQyxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDdEI1SixJQUFBQSxjQUFjLENBQUMsc0JBQUQsRUFBeUIseUZBQXpCLENBQWQ7QUFDRDs7QUFFRCxTQUFPNkosVUFBVSxDQUFDaG1CLElBQVgsQ0FBZ0IxbUIsTUFBTSxDQUFDcUIsVUFBUCxFQUFoQixFQUFxQ2IsTUFBckMsRUFBNkN2SyxNQUE3QyxDQUFQO0FBQ0QsQ0FiRDtBQWNBOzs7Ozs7QUFNQTs7Ozs7Ozs7O0FBU0FndUMsRUFBRSxDQUFDMEksT0FBSCxHQUFhLENBQUN4cEIsSUFBRCxFQUFPM1IsT0FBUCxFQUFnQnlhLFFBQWhCLEtBQTZCO0FBQ3hDLE1BQUksT0FBT3phLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakN5YSxJQUFBQSxRQUFRLEdBQUd6YSxPQUFYO0FBQ0FBLElBQUFBLE9BQU8sR0FBRyxFQUFWO0FBQ0Q7O0FBRUR5YSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFELENBQXhCO0FBQ0FxQyxFQUFBQSxVQUFVLENBQUMsTUFBTTtBQUNmLFFBQUlwcEIsTUFBSjs7QUFFQSxRQUFJO0FBQ0ZBLE1BQUFBLE1BQU0sR0FBRysrQixFQUFFLENBQUMySSxXQUFILENBQWV6cEIsSUFBZixFQUFxQjNSLE9BQXJCLENBQVQ7QUFDRCxLQUZELENBRUUsT0FBT3BkLENBQVAsRUFBVTtBQUNWNjNCLE1BQUFBLFFBQVEsQ0FBQzczQixDQUFELENBQVI7QUFDQTtBQUNEOztBQUVENjNCLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8vbUIsTUFBUCxDQUFSO0FBQ0QsR0FYUyxFQVdQLENBWE8sQ0FBVjtBQVlELENBbkJEO0FBb0JBOzs7Ozs7Ozs7QUFTQSsrQixFQUFFLENBQUMySSxXQUFILEdBQWlCLENBQUMvb0IsUUFBRCxFQUFXclMsT0FBWCxLQUF1QjtBQUN0QyxRQUFNbzNCLElBQUksR0FBR2pCLDBCQUEwQixDQUFDOWpCLFFBQUQsQ0FBdkM7O0FBRUEsTUFBSSxDQUFDK2tCLElBQUksQ0FBQ3BpQixNQUFMLEVBQUwsRUFBb0I7QUFDbEIsVUFBTW9kLFVBQVUsQ0FBQyxTQUFELEVBQVkvZixRQUFaLENBQWhCO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDK2tCLElBQUksQ0FBQ1osV0FBTCxFQUFMLEVBQXlCO0FBQ3ZCLFVBQU1sRSxhQUFhLENBQUMsU0FBRCxFQUFZamdCLFFBQVosQ0FBbkI7QUFDRDs7QUFFRHJTLEVBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckNyUyxJQUFBQSxRQUFRLEVBQUUsT0FEMkI7QUFFckMwdEMsSUFBQUEsYUFBYSxFQUFFLEtBRnNCLEVBQVYsQ0FBN0I7O0FBSUEsUUFBTUMsT0FBTyxHQUFHbEUsSUFBSSxDQUFDbUUsbUJBQUwsRUFBaEI7O0FBRUEsTUFBSXY3QixPQUFPLENBQUNxN0IsYUFBUixLQUEwQixJQUE5QixFQUFvQztBQUNsQztBQUNBaEssSUFBQUEsY0FBYyxDQUFDLDZGQUFELENBQWQ7QUFDRCxHQUhELE1BR08sSUFBSXJ4QixPQUFPLENBQUNyUyxRQUFSLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ3hDLFdBQU8ydEMsT0FBTyxDQUFDL3VDLEdBQVIsQ0FBWTdGLElBQUksSUFBSWtILE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWXBJLElBQVosQ0FBcEIsQ0FBUDtBQUNEOztBQUVELFNBQU80MEMsT0FBUDtBQUNELENBekJEO0FBMEJBOzs7Ozs7QUFNQTs7Ozs7O0FBTUEsU0FBU0UsZ0JBQVQsQ0FBMEJuQixjQUExQixFQUEwQzVmLFFBQTFDLEVBQW9EO0FBQ2xEQSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFELENBQXhCO0FBQ0FnWSxFQUFBQSxFQUFFLENBQUN1RyxLQUFILENBQVNxQixjQUFULEVBQXlCLENBQUNuM0MsR0FBRCxFQUFNKzFDLEtBQU4sS0FBZ0I7QUFDdkMsUUFBSS8xQyxHQUFKLEVBQVM7QUFDUHUzQixNQUFBQSxRQUFRLENBQUN2M0IsR0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRCxVQUFNdTRDLFFBQVEsR0FBR3hDLEtBQUssQ0FBQ3owQixJQUF2QixDQU51QyxDQU1WOztBQUU3QixVQUFNaFcsTUFBTSxHQUFHN00sRUFBRSxDQUFDaU4sWUFBSCxDQUFnQjtBQUM3Qm5LLE1BQUFBLE1BQU0sRUFBRWczQyxRQURxQixFQUFoQixDQUFmO0FBRUk7O0FBRUosVUFBTUMsWUFBWSxHQUFHMUQsbUJBQW1CLENBQUNxQyxjQUFELENBQXhDO0FBQ0ExNEMsSUFBQUEsRUFBRSxDQUFDd00sTUFBSCxDQUFVTSxPQUFWLENBQWtCaXRDLFlBQWxCLEVBQWdDbHRDLE1BQWhDLEVBQXdDbXRDLFVBQVUsSUFBSTtBQUNwRCxVQUFJLENBQUNBLFVBQVUsQ0FBQ2IsT0FBaEIsRUFBeUI7QUFDdkJyZ0IsUUFBQUEsUUFBUSxDQUFDLElBQUkzM0IsS0FBSixDQUFVNjRDLFVBQVUsQ0FBQ255QyxLQUFyQixDQUFELENBQVI7QUFDQTtBQUNEOztBQUVEaXhCLE1BQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU9qc0IsTUFBUCxDQUFSO0FBQ0QsS0FQRDtBQVFELEdBckJEO0FBc0JEO0FBQ0Q7Ozs7OztBQU1BOzs7Ozs7Ozs7O0FBVUFpa0MsRUFBRSxDQUFDbUosUUFBSCxHQUFjLENBQUNqcUIsSUFBRCxFQUFPM1IsT0FBUCxFQUFnQnlhLFFBQWhCLEtBQTZCO0FBQ3pDLE1BQUksT0FBT3phLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDakN5YSxJQUFBQSxRQUFRLEdBQUd6YSxPQUFYO0FBQ0FBLElBQUFBLE9BQU8sR0FBRztBQUNSclMsTUFBQUEsUUFBUSxFQUFFLElBREY7QUFFUjJwQyxNQUFBQSxJQUFJLEVBQUUsR0FGRSxFQUFWOztBQUlELEdBTkQsTUFNTztBQUNMdDNCLElBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckNyUyxNQUFBQSxRQUFRLEVBQUUsSUFEMkI7QUFFckMycEMsTUFBQUEsSUFBSSxFQUFFLEdBRitCLEVBQVYsQ0FBN0I7O0FBSUQ7O0FBRUQ3YyxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFELENBQXhCO0FBQ0EsUUFBTW9oQixpQkFBaUIsR0FBRyxPQUFPbHFCLElBQVAsS0FBZ0IsUUFBMUM7QUFDQSxNQUFJMG9CLGNBQWMsR0FBRzFvQixJQUFyQixDQWhCeUMsQ0FnQmQ7O0FBRTNCOzs7OztBQUtBLFFBQU1tcUIsWUFBWSxHQUFHLENBQUM1NEMsR0FBRCxFQUFNc0wsTUFBTixLQUFpQjtBQUNwQyxRQUFJdEwsR0FBSixFQUFTO0FBQ1B1M0IsTUFBQUEsUUFBUSxDQUFDdjNCLEdBQUQsQ0FBUjtBQUNBO0FBQ0QsS0FKbUMsQ0FJbEM7OztBQUdGLFFBQUksQ0FBQzI0QyxpQkFBTCxFQUF3QjtBQUN0QnBKLE1BQUFBLEVBQUUsQ0FBQ3NGLFNBQUgsQ0FBYXNDLGNBQWI7QUFDRCxLQVRtQyxDQVNsQzs7O0FBR0Y1ZixJQUFBQSxRQUFRLENBQUMsSUFBRCxFQUFPc2hCLFlBQVksQ0FBQy83QixPQUFPLENBQUNyUyxRQUFULEVBQW1CYSxNQUFuQixDQUFuQixDQUFSO0FBQ0QsR0FiRDs7QUFlQSxNQUFJLENBQUNxdEMsaUJBQUwsRUFBd0I7QUFDdEJwSixJQUFBQSxFQUFFLENBQUMyRixJQUFILENBQVF6bUIsSUFBUixFQUFjM1IsT0FBTyxDQUFDczNCLElBQXRCLEVBQTRCLENBQUNwMEMsR0FBRCxFQUFNNDBDLEVBQU4sS0FBYTtBQUN2QyxVQUFJNTBDLEdBQUosRUFBUztBQUNQdTNCLFFBQUFBLFFBQVEsQ0FBQ3YzQixHQUFELENBQVI7QUFDQTtBQUNEOztBQUVEbTNDLE1BQUFBLGNBQWMsR0FBR3ZDLEVBQWpCO0FBQ0EwRCxNQUFBQSxnQkFBZ0IsQ0FBQzFELEVBQUQsRUFBS2dFLFlBQUwsQ0FBaEI7QUFDRCxLQVJEO0FBU0QsR0FWRCxNQVVPO0FBQ0xOLElBQUFBLGdCQUFnQixDQUFDN3BCLElBQUQsRUFBT21xQixZQUFQLENBQWhCO0FBQ0Q7QUFDRixDQW5ERDtBQW9EQTs7Ozs7Ozs7OztBQVVBckosRUFBRSxDQUFDdUosWUFBSCxHQUFrQixDQUFDcnFCLElBQUQsRUFBTzNSLE9BQVAsS0FBbUI7QUFDbkNBLEVBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckNyUyxJQUFBQSxRQUFRLEVBQUUsSUFEMkI7QUFFckMycEMsSUFBQUEsSUFBSSxFQUFFLEdBRitCLEVBQVYsQ0FBN0I7O0FBSUEsUUFBTXVFLGlCQUFpQixHQUFHLE9BQU9scUIsSUFBUCxLQUFnQixRQUExQztBQUNBLFFBQU0wb0IsY0FBYyxHQUFHd0IsaUJBQWlCLEdBQUdscUIsSUFBSCxHQUFVOGdCLEVBQUUsQ0FBQzZILFFBQUgsQ0FBWTNvQixJQUFaLEVBQWtCM1IsT0FBTyxDQUFDczNCLElBQTFCLENBQWxELENBTm1DLENBTWdEOztBQUVuRixRQUFNc0QsWUFBWSxHQUFHNUMsbUJBQW1CLENBQUNxQyxjQUFELENBQXhDLENBUm1DLENBUXVCOztBQUUxRCxRQUFNN3JDLE1BQU0sR0FBRzdNLEVBQUUsQ0FBQ3dNLE1BQUgsQ0FBVU0sT0FBVixDQUFrQm1zQyxZQUFsQixDQUFmLENBVm1DLENBVWE7O0FBRWhELE1BQUksQ0FBQ2lCLGlCQUFMLEVBQXdCO0FBQ3RCcEosSUFBQUEsRUFBRSxDQUFDc0YsU0FBSCxDQUFhc0MsY0FBYjtBQUNELEdBZGtDLENBY2pDOzs7QUFHRixTQUFPMEIsWUFBWSxDQUFDLzdCLE9BQU8sQ0FBQ3JTLFFBQVQsRUFBbUJhLE1BQW5CLENBQW5CO0FBQ0QsQ0FsQkQsQyxDQWtCRztBQUNIOztBQUVBOzs7Ozs7QUFNQTs7Ozs7Ozs7QUFRQWlrQyxFQUFFLENBQUN3SixRQUFILEdBQWMsQ0FBQzVwQixRQUFELEVBQVdyUyxPQUFYLEVBQW9CeWEsUUFBcEIsS0FBaUM7QUFDN0NBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQVEsSUFBSXphLE9BQWIsQ0FBeEI7QUFDQUEsRUFBQUEsT0FBTyxHQUFHcTNCLG1CQUFtQixDQUFDcjNCLE9BQUQsRUFBVTtBQUNyQ3JTLElBQUFBLFFBQVEsRUFBRSxNQUQyQixFQUFWLENBQTdCOztBQUdBbXZCLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2Y7QUFDQSxVQUFNcHBCLE1BQU0sR0FBR2llLElBQUksQ0FBQzJNLFNBQUwsQ0FBZWpNLFFBQWYsQ0FBZjtBQUNBb2dCLElBQUFBLEVBQUUsQ0FBQ3pkLE1BQUgsQ0FBVXRoQixNQUFWLEVBQWtCd29DLFlBQVksSUFBSTtBQUNoQyxVQUFJQSxZQUFKLEVBQWtCO0FBQ2hCLFlBQUlsOEIsT0FBTyxDQUFDclMsUUFBUixLQUFxQixRQUF6QixFQUFtQztBQUNqQyxpQkFBTzhzQixRQUFRLENBQUMsSUFBRCxFQUFPN3NCLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTRFLE1BQVosQ0FBUCxDQUFmO0FBQ0Q7O0FBRUQsZUFBTyttQixRQUFRLENBQUMsSUFBRCxFQUFPL21CLE1BQVAsQ0FBZjtBQUNELE9BUCtCLENBTzlCOzs7QUFHRixZQUFNeW9DLFFBQVEsR0FBR3pvQyxNQUFNLENBQUMvUCxLQUFQLENBQWFndUIsSUFBSSxDQUFDcU8sR0FBbEIsQ0FBakIsQ0FWZ0MsQ0FVUzs7QUFFekMsVUFBSW9jLGVBQWUsR0FBRyxFQUF0QjtBQUNBLFVBQUkzc0MsS0FBSyxHQUFHLENBQVosQ0FiZ0MsQ0FhakI7O0FBRWYsVUFBSTBzQyxRQUFRLENBQUMxc0MsS0FBRCxDQUFSLENBQWdCaEwsTUFBaEIsS0FBMkIsQ0FBL0IsRUFBa0M7QUFDaENnTCxRQUFBQSxLQUFLO0FBQ047O0FBRURxdEIsTUFBQUEsVUFBVSxDQUFDdWYsT0FBRCxFQUFVLENBQVYsQ0FBVjs7QUFFQSxlQUFTQSxPQUFULEdBQW1CO0FBQ2pCLFlBQUk1c0MsS0FBSyxJQUFJMHNDLFFBQVEsQ0FBQzEzQyxNQUF0QixFQUE4QjtBQUM1QjtBQUNBLGlCQUFPZzJCLFFBQVEsQ0FBQzJYLFVBQVUsQ0FBQzErQixNQUFELENBQVgsQ0FBZjtBQUNELFNBSmdCLENBSWY7OztBQUdGLGNBQU1pckIsT0FBTyxHQUFHd2QsUUFBUSxDQUFDMXNDLEtBQUssRUFBTixDQUF4Qjs7QUFFQSxZQUFJa3ZCLE9BQU8sQ0FBQ2w2QixNQUFSLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBT3E0QixVQUFVLENBQUN1ZixPQUFELEVBQVUsQ0FBVixDQUFqQjtBQUNELFNBYmdCLENBYWY7OztBQUdGRCxRQUFBQSxlQUFlLElBQUl6cUIsSUFBSSxDQUFDcU8sR0FBTCxHQUFXckIsT0FBOUIsQ0FoQmlCLENBZ0JzQjs7QUFFdkM4VCxRQUFBQSxFQUFFLENBQUN6ZCxNQUFILENBQVVvbkIsZUFBVixFQUEyQkUsYUFBYSxJQUFJO0FBQzFDLGNBQUksQ0FBQ0EsYUFBTCxFQUFvQjtBQUNsQjtBQUNBLG1CQUFPN2hCLFFBQVEsQ0FBQzJYLFVBQVUsQ0FBQyxPQUFELEVBQVVnSyxlQUFWLENBQVgsQ0FBZjtBQUNELFdBSnlDLENBSXhDOzs7QUFHRnRmLFVBQUFBLFVBQVUsQ0FBQ3VmLE9BQUQsRUFBVSxDQUFWLENBQVY7QUFDRCxTQVJEO0FBU0Q7QUFDRixLQWpERDtBQWtERCxHQXJEUyxFQXFEUCxDQXJETyxDQUFWO0FBc0RELENBM0REOztBQTZEQTVKLEVBQUUsQ0FBQ3dKLFFBQUgsQ0FBWU0sTUFBWixHQUFxQixDQUFDNXFCLElBQUQsRUFBTzNSLE9BQVAsRUFBZ0J5YSxRQUFoQixLQUE2QjtBQUNoRGdZLEVBQUFBLEVBQUUsQ0FBQ3dKLFFBQUgsQ0FBWXRxQixJQUFaLEVBQWtCM1IsT0FBbEIsRUFBMkJ5YSxRQUEzQjtBQUNELENBRkQ7QUFHQTs7Ozs7Ozs7QUFRQWdZLEVBQUUsQ0FBQytKLFlBQUgsR0FBa0IsQ0FBQ25xQixRQUFELEVBQVdyUyxPQUFYLEtBQXVCO0FBQ3ZDQSxFQUFBQSxPQUFPLEdBQUdxM0IsbUJBQW1CLENBQUNyM0IsT0FBRCxFQUFVO0FBQ3JDclMsSUFBQUEsUUFBUSxFQUFFLE1BRDJCLEVBQVYsQ0FBN0I7QUFFSTs7QUFFSixRQUFNK0YsTUFBTSxHQUFHaWUsSUFBSSxDQUFDMk0sU0FBTCxDQUFlak0sUUFBZixDQUFmOztBQUVBLE1BQUksQ0FBQ29nQixFQUFFLENBQUNnRyxVQUFILENBQWMva0MsTUFBZCxDQUFMLEVBQTRCO0FBQzFCO0FBQ0EsVUFBTXlvQyxRQUFRLEdBQUd6b0MsTUFBTSxDQUFDL1AsS0FBUCxDQUFhZ3VCLElBQUksQ0FBQ3FPLEdBQWxCLENBQWpCO0FBQ0EsUUFBSW9jLGVBQWUsR0FBRyxFQUF0Qjs7QUFFQSxTQUFLLE1BQU16ZCxPQUFYLElBQXNCd2QsUUFBdEIsRUFBZ0M7QUFDOUIsVUFBSXhkLE9BQU8sQ0FBQ2w2QixNQUFSLEtBQW1CLENBQXZCLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBRUQyM0MsTUFBQUEsZUFBZSxJQUFJenFCLElBQUksQ0FBQ3FPLEdBQUwsR0FBV3JCLE9BQTlCOztBQUVBLFVBQUksQ0FBQzhULEVBQUUsQ0FBQ2dHLFVBQUgsQ0FBYzJELGVBQWQsQ0FBTCxFQUFxQztBQUNuQyxjQUFNaEssVUFBVSxDQUFDLE9BQUQsRUFBVWdLLGVBQVYsQ0FBaEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSXA4QixPQUFPLENBQUNyUyxRQUFSLEtBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLFdBQU9DLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTRFLE1BQVosQ0FBUDtBQUNEOztBQUVELFNBQU9BLE1BQVA7QUFDRCxDQTlCRDs7QUFnQ0ErK0IsRUFBRSxDQUFDK0osWUFBSCxDQUFnQkQsTUFBaEIsR0FBeUIsQ0FBQzVxQixJQUFELEVBQU8zUixPQUFQLEtBQW1CO0FBQzFDeXlCLEVBQUFBLEVBQUUsQ0FBQytKLFlBQUgsQ0FBZ0I3cUIsSUFBaEIsRUFBc0IzUixPQUF0QjtBQUNELENBRkQ7QUFHQTs7Ozs7OztBQU9BeXlCLEVBQUUsQ0FBQ2dLLE1BQUgsR0FBWSxDQUFDQyxPQUFELEVBQVVDLE9BQVYsRUFBbUJsaUIsUUFBbkIsS0FBZ0M7QUFDMUNBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsUUFBSTtBQUNGMlYsTUFBQUEsRUFBRSxDQUFDbUssVUFBSCxDQUFjRixPQUFkLEVBQXVCQyxPQUF2QjtBQUNELEtBRkQsQ0FFRSxPQUFPLzVDLENBQVAsRUFBVTtBQUNWNjNCLE1BQUFBLFFBQVEsQ0FBQzczQixDQUFELENBQVI7QUFDQTtBQUNEOztBQUVENjNCLElBQUFBLFFBQVE7QUFDVCxHQVRTLEVBU1AsQ0FUTyxDQUFWO0FBVUQsQ0FaRDtBQWFBOzs7Ozs7QUFNQWdZLEVBQUUsQ0FBQ21LLFVBQUgsR0FBZ0IsQ0FBQ0YsT0FBRCxFQUFVQyxPQUFWLEtBQXNCO0FBQ3BDLFFBQU0vQyxNQUFNLEdBQUd6RCwwQkFBMEIsQ0FBQ3VHLE9BQUQsQ0FBekMsQ0FEb0MsQ0FDZ0I7O0FBRXBELE1BQUksQ0FBQzlDLE1BQU0sQ0FBQzVrQixNQUFQLEVBQUwsRUFBc0I7QUFDcEIsVUFBTTl4QixHQUFHLEdBQUdrdkMsVUFBVSxDQUFDLFFBQUQsRUFBV3NLLE9BQVgsQ0FBdEI7QUFDQXg1QyxJQUFBQSxHQUFHLENBQUMyRyxPQUFKLEdBQWUsR0FBRTNHLEdBQUcsQ0FBQzJHLE9BQVEsUUFBTzh5QyxPQUFRLEdBQTVDO0FBQ0F6NUMsSUFBQUEsR0FBRyxDQUFDNFAsSUFBSixHQUFXNnBDLE9BQVg7QUFDQSxVQUFNejVDLEdBQU47QUFDRDs7QUFFRCxRQUFNbTFDLFFBQVEsR0FBR2xDLDBCQUEwQixDQUFDd0csT0FBRCxDQUEzQzs7QUFFQSxNQUFJdEUsUUFBUSxDQUFDN0IsV0FBVCxFQUFKLEVBQTRCO0FBQzFCO0FBQ0EsVUFBTXR6QyxHQUFHLEdBQUdzdkMsNEJBQTRCLENBQUMsUUFBRCxFQUFXa0ssT0FBWCxDQUF4QztBQUNBeDVDLElBQUFBLEdBQUcsQ0FBQzJHLE9BQUosR0FBZSxHQUFFM0csR0FBRyxDQUFDMkcsT0FBUSxRQUFPOHlDLE9BQVEsR0FBNUM7QUFDQXo1QyxJQUFBQSxHQUFHLENBQUM0UCxJQUFKLEdBQVc2cEMsT0FBWDtBQUNBLFVBQU16NUMsR0FBTjtBQUNEOztBQUVELE1BQUkyNUMsUUFBSjs7QUFFQSxNQUFJeEUsUUFBUSxDQUFDOUIsTUFBVCxFQUFKLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQXNHLElBQUFBLFFBQVEsR0FBR2xyQixJQUFJLENBQUNydEIsSUFBTCxDQUFVbXVDLEVBQUUsQ0FBQ3lILFdBQUgsQ0FBZXZvQixJQUFJLENBQUNydEIsSUFBTCxDQUFVM0MsRUFBRSxDQUFDK2xCLFVBQUgsQ0FBYzhoQixhQUF4QixFQUF1QyxTQUF2QyxDQUFmLENBQVYsRUFBNkU3WCxJQUFJLENBQUN3TSxRQUFMLENBQWN3ZSxPQUFkLENBQTdFLENBQVg7QUFDQXRFLElBQUFBLFFBQVEsQ0FBQ3lFLElBQVQsQ0FBY0QsUUFBZDtBQUNEOztBQUVELE1BQUkvQixPQUFPLEdBQUcsS0FBZDs7QUFFQSxNQUFJO0FBQ0ZBLElBQUFBLE9BQU8sR0FBR2xCLE1BQU0sQ0FBQ2tELElBQVAsQ0FBWUgsT0FBWixDQUFWO0FBQ0QsR0FGRCxTQUVVO0FBQ1IsUUFBSUUsUUFBSixFQUFjO0FBQ1o7QUFDQSxVQUFJL0IsT0FBSixFQUFhO0FBQ1g7QUFDQXJJLFFBQUFBLEVBQUUsQ0FBQ3NLLE1BQUgsQ0FBVUYsUUFBVixFQUFvQkcsSUFBSSxJQUFJLENBQUUsQ0FBOUI7QUFDRCxPQUhELE1BR087QUFDTDtBQUNBLGNBQU1DLE9BQU8sR0FBRzlHLDBCQUEwQixDQUFDMEcsUUFBRCxDQUExQztBQUNBSSxRQUFBQSxPQUFPLENBQUNILElBQVIsQ0FBYUgsT0FBYjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLENBOUNEO0FBK0NBOzs7Ozs7QUFNQWxLLEVBQUUsQ0FBQ3lLLEtBQUgsR0FBVyxDQUFDdnJCLElBQUQsRUFBTzhJLFFBQVAsS0FBb0I7QUFDN0JBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQUQsQ0FBeEI7QUFDQXFDLEVBQUFBLFVBQVUsQ0FBQyxNQUFNO0FBQ2YsUUFBSTtBQUNGMlYsTUFBQUEsRUFBRSxDQUFDMEssU0FBSCxDQUFheHJCLElBQWI7QUFDRCxLQUZELENBRUUsT0FBTy91QixDQUFQLEVBQVU7QUFDVjYzQixNQUFBQSxRQUFRLENBQUM3M0IsQ0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRDYzQixJQUFBQSxRQUFRO0FBQ1QsR0FUUyxFQVNQLENBVE8sQ0FBVjtBQVVELENBWkQ7QUFhQTs7Ozs7QUFLQWdZLEVBQUUsQ0FBQzBLLFNBQUgsR0FBZXhyQixJQUFJLElBQUk7QUFDckIsUUFBTWlvQixNQUFNLEdBQUd6RCwwQkFBMEIsQ0FBQ3hrQixJQUFELENBQXpDOztBQUVBLE1BQUksQ0FBQ2lvQixNQUFNLENBQUN3RCxlQUFQLENBQXVCLEtBQXZCLENBQUwsRUFBb0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDeEQsTUFBTSxDQUFDNWtCLE1BQVAsRUFBTCxFQUFzQjtBQUNwQixZQUFNb2QsVUFBVSxDQUFDLE9BQUQsRUFBVXpnQixJQUFWLENBQWhCO0FBQ0QsS0FOaUMsQ0FNaEM7OztBQUdGLFFBQUlpb0IsTUFBTSxDQUFDckQsTUFBUCxFQUFKLEVBQXFCO0FBQ25CLFlBQU1qRSxhQUFhLENBQUMsT0FBRCxFQUFVM2dCLElBQVYsQ0FBbkI7QUFDRCxLQVhpQyxDQVdoQzs7O0FBR0YsVUFBTTByQixRQUFRLEdBQUd6RCxNQUFNLENBQUMyQixtQkFBUCxFQUFqQjs7QUFFQSxRQUFJOEIsUUFBUSxJQUFJQSxRQUFRLENBQUM1NEMsTUFBVCxHQUFrQixDQUFsQyxFQUFxQztBQUNuQyxZQUFNOHRDLGlCQUFpQixDQUFDLE9BQUQsRUFBVTVnQixJQUFWLENBQXZCO0FBQ0Q7QUFDRjtBQUNGLENBdkJEO0FBd0JBOzs7Ozs7OztBQVFBOGdCLEVBQUUsQ0FBQzhHLElBQUgsR0FBVSxDQUFDNW5CLElBQUQsRUFBTzNSLE9BQVAsRUFBZ0J5YSxRQUFoQixLQUE2QjtBQUNyQyxNQUFJLE9BQU96YSxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQ2pDeWEsSUFBQUEsUUFBUSxHQUFHemEsT0FBWDtBQUNBQSxJQUFBQSxPQUFPLEdBQUcsRUFBVjtBQUNEOztBQUVEeWEsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBRCxDQUF4QjtBQUNBcUMsRUFBQUEsVUFBVSxDQUFDLE1BQU07QUFDZnJDLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU8sSUFBSWdZLEVBQUUsQ0FBQ3lDLEtBQVAsQ0FBYXZqQixJQUFiLENBQVAsQ0FBUjtBQUNELEdBRlMsRUFFUCxDQUZPLENBQVY7QUFHRCxDQVZEO0FBV0E7Ozs7Ozs7O0FBUUE4Z0IsRUFBRSxDQUFDNEcsUUFBSCxHQUFjLENBQUMxbkIsSUFBRCxFQUFPd25CLFFBQVAsS0FBb0IsSUFBSTFHLEVBQUUsQ0FBQ3lDLEtBQVAsQ0FBYXZqQixJQUFiLENBQWxDOztBQUVBOGdCLEVBQUUsQ0FBQzZLLE9BQUgsR0FBYSxDQUFDdnRDLE1BQUQsRUFBUzRoQixJQUFULEVBQWU1bEIsSUFBZixFQUFxQjB1QixRQUFyQixLQUFrQ2dYLG9CQUFvQixDQUFDLElBQUQsRUFBTyxTQUFQLEVBQWtCaFgsUUFBbEIsQ0FBbkU7O0FBRUFnWSxFQUFFLENBQUM4SyxXQUFILEdBQWlCak0sZUFBZSxDQUFDLElBQUQsRUFBTyxhQUFQLENBQWhDO0FBQ0E7Ozs7OztBQU1BbUIsRUFBRSxDQUFDK0ssUUFBSCxHQUFjLENBQUM3ckIsSUFBRCxFQUFPcmxCLEdBQVAsRUFBWW11QixRQUFaLEtBQXlCO0FBQ3JDQSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFRLElBQUludUIsR0FBYixDQUF4Qjs7QUFFQSxNQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQkEsSUFBQUEsR0FBRyxHQUFHLENBQU47QUFDRDs7QUFFRCxNQUFJQSxHQUFHLElBQUksQ0FBWCxFQUFjO0FBQ1ptbUMsSUFBQUEsRUFBRSxDQUFDOEUsU0FBSCxDQUFhNWxCLElBQWIsRUFBbUIsRUFBbkIsRUFBdUI4SSxRQUF2QixFQURZLENBQ3NCOztBQUVsQztBQUNELEdBWG9DLENBV25DO0FBQ0Y7OztBQUdBZ1ksRUFBQUEsRUFBRSxDQUFDMkYsSUFBSCxDQUFRem1CLElBQVIsRUFBYyxDQUFDenVCLEdBQUQsRUFBTTQwQyxFQUFOLEtBQWE7QUFDekIsUUFBSTUwQyxHQUFKLEVBQVM7QUFDUCxhQUFPdTNCLFFBQVEsQ0FBQ3YzQixHQUFELENBQWY7QUFDRDs7QUFFRCxVQUFNc0wsTUFBTSxHQUFHWixNQUFNLENBQUNnRSxLQUFQLENBQWF0RixHQUFiLENBQWY7QUFDQW1tQyxJQUFBQSxFQUFFLENBQUN2ZCxJQUFILENBQVE0aUIsRUFBUixFQUFZdHBDLE1BQVosRUFBb0IsQ0FBcEIsRUFBdUJsQyxHQUF2QixFQUE0QixJQUE1QixFQUFrQyxDQUFDcEosR0FBRCxFQUFNdTZDLFNBQU4sRUFBaUJqdkMsTUFBakIsS0FBNEI7QUFDNUQsVUFBSXRMLEdBQUosRUFBUztBQUNQdXZDLFFBQUFBLEVBQUUsQ0FBQ3NGLFNBQUgsQ0FBYUQsRUFBYjtBQUNBLGVBQU9yZCxRQUFRLENBQUN2M0IsR0FBRCxDQUFmO0FBQ0Q7O0FBRUR1dkMsTUFBQUEsRUFBRSxDQUFDL2pDLEtBQUgsQ0FBU29wQyxFQUFULEVBQWE1MEMsR0FBRyxJQUFJO0FBQ2xCLFlBQUlBLEdBQUosRUFBUztBQUNQLGlCQUFPdTNCLFFBQVEsQ0FBQ3YzQixHQUFELENBQWY7QUFDRDs7QUFFRHV2QyxRQUFBQSxFQUFFLENBQUM4RSxTQUFILENBQWE1bEIsSUFBYixFQUFtQm5qQixNQUFuQixFQUEyQmlzQixRQUEzQjtBQUNELE9BTkQ7QUFPRCxLQWJEO0FBY0QsR0FwQkQ7QUFxQkQsQ0FwQ0Q7QUFxQ0E7Ozs7OztBQU1BZ1ksRUFBRSxDQUFDaUwsWUFBSCxHQUFrQixDQUFDL3JCLElBQUQsRUFBT3JsQixHQUFHLEdBQUcsQ0FBYixLQUFtQjtBQUNuQyxNQUFJQSxHQUFHLElBQUksQ0FBWCxFQUFjO0FBQ1o7QUFDQW1tQyxJQUFBQSxFQUFFLENBQUNnRixhQUFILENBQWlCOWxCLElBQWpCLEVBQXVCLEVBQXZCO0FBQ0E7QUFDRCxHQUxrQyxDQUtqQztBQUNGOzs7QUFHQSxRQUFNbW1CLEVBQUUsR0FBR3JGLEVBQUUsQ0FBQzZILFFBQUgsQ0FBWTNvQixJQUFaLENBQVg7QUFDQSxRQUFNbmpCLE1BQU0sR0FBR1osTUFBTSxDQUFDZ0UsS0FBUCxDQUFhdEYsR0FBYixDQUFmO0FBQ0FtbUMsRUFBQUEsRUFBRSxDQUFDdUksUUFBSCxDQUFZbEQsRUFBWixFQUFnQnRwQyxNQUFoQixFQUF3QixDQUF4QixFQUEyQmxDLEdBQTNCLEVBQWdDLElBQWhDO0FBQ0FtbUMsRUFBQUEsRUFBRSxDQUFDc0YsU0FBSCxDQUFhRCxFQUFiO0FBQ0FyRixFQUFBQSxFQUFFLENBQUNnRixhQUFILENBQWlCOWxCLElBQWpCLEVBQXVCbmpCLE1BQXZCO0FBQ0QsQ0FkRDtBQWVBOzs7Ozs7QUFNQWlrQyxFQUFFLENBQUNzSyxNQUFILEdBQVksQ0FBQ3ByQixJQUFELEVBQU84SSxRQUFQLEtBQW9CO0FBQzlCQSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFELENBQXhCO0FBQ0FxQyxFQUFBQSxVQUFVLENBQUMsTUFBTTtBQUNmLFFBQUk7QUFDRjJWLE1BQUFBLEVBQUUsQ0FBQ2tMLFVBQUgsQ0FBY2hzQixJQUFkO0FBQ0QsS0FGRCxDQUVFLE9BQU96dUIsR0FBUCxFQUFZO0FBQ1p1M0IsTUFBQUEsUUFBUSxDQUFDdjNCLEdBQUQsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUR1M0IsSUFBQUEsUUFBUTtBQUNULEdBVFMsRUFTUCxDQVRPLENBQVY7QUFVRCxDQVpEO0FBYUE7Ozs7OztBQU1BZ1ksRUFBRSxDQUFDa0wsVUFBSCxHQUFnQmhzQixJQUFJLElBQUk7QUFDdEIsUUFBTWlvQixNQUFNLEdBQUd6RCwwQkFBMEIsQ0FBQ3hrQixJQUFELENBQXpDOztBQUVBLE1BQUksQ0FBQ2lvQixNQUFNLENBQUNnRSxVQUFQLEVBQUwsRUFBMEI7QUFDeEI7QUFDQSxRQUFJLENBQUNoRSxNQUFNLENBQUM1a0IsTUFBUCxFQUFMLEVBQXNCO0FBQ3BCLFlBQU1vZCxVQUFVLENBQUMsUUFBRCxFQUFXemdCLElBQVgsQ0FBaEI7QUFDRDs7QUFFRCxRQUFJaW9CLE1BQU0sQ0FBQ3BELFdBQVAsRUFBSixFQUEwQjtBQUN4QixZQUFNaEUsNEJBQTRCLENBQUMsUUFBRCxFQUFXN2dCLElBQVgsQ0FBbEM7QUFDRDtBQUNGO0FBQ0YsQ0FiRDs7QUFlQThnQixFQUFFLENBQUNvTCxXQUFILEdBQWlCdk0sZUFBZSxDQUFDLElBQUQsRUFBTyxhQUFQLENBQWhDOztBQUVBbUIsRUFBRSxDQUFDcUwsTUFBSCxHQUFZLENBQUNuc0IsSUFBRCxFQUFPb2tCLEtBQVAsRUFBY0MsS0FBZCxFQUFxQnZiLFFBQXJCLEtBQWtDZ1gsb0JBQW9CLENBQUMsSUFBRCxFQUFPLFFBQVAsRUFBaUJoWCxRQUFqQixDQUFsRTs7QUFFQWdZLEVBQUUsQ0FBQ3NMLFVBQUgsR0FBZ0J6TSxlQUFlLENBQUMsSUFBRCxFQUFPLFlBQVAsQ0FBL0I7QUFDQW1CLEVBQUUsQ0FBQ3VMLEtBQUgsR0FBVzFNLGVBQWUsQ0FBQyxJQUFELEVBQU8sT0FBUCxDQUExQjtBQUNBbUIsRUFBRSxDQUFDd0wsU0FBSCxHQUFlM00sZUFBZSxDQUFDLElBQUQsRUFBTyxXQUFQLENBQTlCO0FBQ0E7Ozs7Ozs7Ozs7QUFVQW1CLEVBQUUsQ0FBQzhFLFNBQUgsR0FBZSxDQUFDSCxJQUFELEVBQU9wZ0MsSUFBUCxFQUFhZ0osT0FBYixFQUFzQnlhLFFBQXRCLEtBQW1DO0FBQ2hEQSxFQUFBQSxRQUFRLEdBQUdpWCxhQUFhLENBQUNqWCxRQUFRLElBQUl6YSxPQUFiLENBQXhCO0FBQ0FBLEVBQUFBLE9BQU8sR0FBR3EzQixtQkFBbUIsQ0FBQ3IzQixPQUFELEVBQVU7QUFDckNyUyxJQUFBQSxRQUFRLEVBQUUsTUFEMkI7QUFFckNXLElBQUFBLElBQUksRUFBRSxLQUYrQjtBQUdyQ2dwQyxJQUFBQSxJQUFJLEVBQUUsR0FIK0IsRUFBVixDQUE3QjtBQUlJOztBQUVKLFFBQU11RSxpQkFBaUIsR0FBRyxPQUFPekUsSUFBUCxLQUFnQixRQUExQztBQUNBLE1BQUlpRCxjQUFjLEdBQUdqRCxJQUFyQixDQVRnRCxDQVNyQjs7QUFFM0IsUUFBTThHLE1BQU0sR0FBR2g3QyxHQUFHLElBQUk7QUFDcEIsUUFBSUEsR0FBSixFQUFTO0FBQ1B1M0IsTUFBQUEsUUFBUSxDQUFDdjNCLEdBQUQsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSTI0QyxpQkFBSixFQUF1QjtBQUNyQnBoQixNQUFBQSxRQUFRO0FBQ1I7QUFDRCxLQVRtQixDQVNsQjs7O0FBR0ZnWSxJQUFBQSxFQUFFLENBQUMvakMsS0FBSCxDQUFTMnJDLGNBQVQsRUFBeUI1ZixRQUF6QjtBQUNELEdBYkQ7O0FBZUEsTUFBSSxDQUFDb2hCLGlCQUFMLEVBQXdCO0FBQ3RCcEosSUFBQUEsRUFBRSxDQUFDMkYsSUFBSCxDQUFRaEIsSUFBUixFQUFjcDNCLE9BQU8sQ0FBQ3MzQixJQUF0QixFQUE0QnQzQixPQUFPLENBQUMxUixJQUFwQyxFQUEwQyxDQUFDcEwsR0FBRCxFQUFNNDBDLEVBQU4sS0FBYTtBQUNyRCxVQUFJNTBDLEdBQUosRUFBUztBQUNQdTNCLFFBQUFBLFFBQVEsQ0FBQ3YzQixHQUFELENBQVI7QUFDQTtBQUNEOztBQUVEbTNDLE1BQUFBLGNBQWMsR0FBR3ZDLEVBQWpCO0FBQ0FyRixNQUFBQSxFQUFFLENBQUN0NkIsS0FBSCxDQUFTa2lDLGNBQVQsRUFBeUJyakMsSUFBekIsRUFBK0JrbkMsTUFBL0I7QUFDRCxLQVJEO0FBU0QsR0FWRCxNQVVPO0FBQ0x6TCxJQUFBQSxFQUFFLENBQUN0NkIsS0FBSCxDQUFTa2lDLGNBQVQsRUFBeUJyakMsSUFBekIsRUFBK0JrbkMsTUFBL0I7QUFDRDtBQUNGLENBdkNEO0FBd0NBOzs7Ozs7Ozs7O0FBVUF6TCxFQUFFLENBQUNnRixhQUFILEdBQW1CLENBQUNMLElBQUQsRUFBT3BnQyxJQUFQLEVBQWFnSixPQUFiLEtBQXlCO0FBQzFDQSxFQUFBQSxPQUFPLEdBQUdxM0IsbUJBQW1CLENBQUNyM0IsT0FBRCxFQUFVO0FBQ3JDclMsSUFBQUEsUUFBUSxFQUFFLE1BRDJCO0FBRXJDVyxJQUFBQSxJQUFJLEVBQUUsS0FGK0I7QUFHckNncEMsSUFBQUEsSUFBSSxFQUFFLEdBSCtCLEVBQVYsQ0FBN0I7QUFJSTs7QUFFSixRQUFNdUUsaUJBQWlCLEdBQUcsT0FBT3pFLElBQVAsS0FBZ0IsUUFBMUM7QUFDQSxRQUFNaUQsY0FBYyxHQUFHd0IsaUJBQWlCLEdBQUd6RSxJQUFILEdBQVUzRSxFQUFFLENBQUM2SCxRQUFILENBQVlsRCxJQUFaLEVBQWtCcDNCLE9BQU8sQ0FBQ3MzQixJQUExQixFQUFnQ3QzQixPQUFPLENBQUMxUixJQUF4QyxDQUFsRCxDQVIwQyxDQVF1RDs7QUFFakcsTUFBSSxDQUFDVixNQUFNLENBQUN0TCxRQUFQLENBQWdCMFUsSUFBaEIsQ0FBTCxFQUE0QjtBQUMxQkEsSUFBQUEsSUFBSSxHQUFHcEosTUFBTSxDQUFDa0IsSUFBUCxDQUFZLEtBQUtrSSxJQUFqQixFQUF1QmdKLE9BQU8sQ0FBQ3JTLFFBQS9CLENBQVAsQ0FEMEIsQ0FDdUI7QUFDbEQ7O0FBRUQ4a0MsRUFBQUEsRUFBRSxDQUFDMEwsU0FBSCxDQUFhOUQsY0FBYixFQUE2QnJqQyxJQUE3QixFQWQwQyxDQWNOOztBQUVwQyxNQUFJLENBQUM2a0MsaUJBQUwsRUFBd0I7QUFDdEJwSixJQUFBQSxFQUFFLENBQUNzRixTQUFILENBQWFzQyxjQUFiO0FBQ0Q7QUFDRixDQW5CRDtBQW9CQTs7Ozs7O0FBTUE7Ozs7Ozs7QUFPQSxTQUFTK0QsaUJBQVQsQ0FBMkJ4RCxZQUEzQixFQUF5Q3BzQyxNQUF6QyxFQUFpRGlzQixRQUFqRCxFQUEyRDtBQUN6REEsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBRCxDQUF4QjtBQUNBOTRCLEVBQUFBLEVBQUUsQ0FBQ3dNLE1BQUgsQ0FBVWdLLEtBQVYsQ0FBZ0J5aUMsWUFBaEIsRUFBOEJwc0MsTUFBTSxDQUFDcUIsVUFBUCxFQUE5QixFQUFtRHd1QyxRQUFRLElBQUk7QUFDN0QsUUFBSSxDQUFDQSxRQUFRLENBQUN2RCxPQUFkLEVBQXVCO0FBQ3JCcmdCLE1BQUFBLFFBQVEsQ0FBQyxJQUFJMzNCLEtBQUosQ0FBVXU3QyxRQUFRLENBQUM3MEMsS0FBbkIsQ0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRGl4QixJQUFBQSxRQUFRLENBQUMsSUFBRCxFQUFPNGpCLFFBQVEsQ0FBQ3RELGNBQWhCLENBQVI7QUFDRCxHQVBEO0FBUUQ7QUFDRDs7Ozs7Ozs7OztBQVVBdEksRUFBRSxDQUFDdDZCLEtBQUgsR0FBVyxDQUFDMi9CLEVBQUQsRUFBS3RwQyxNQUFMLEVBQWFRLE1BQWIsRUFBcUJ2SyxNQUFyQixFQUE2QjBWLFFBQTdCLEVBQXVDc2dCLFFBQXZDLEtBQW9EO0FBQzdELFFBQU1uNEIsUUFBUSxHQUFHc0wsTUFBTSxDQUFDdEwsUUFBUCxDQUFnQmtNLE1BQWhCLENBQWpCOztBQUVBLE1BQUlsTSxRQUFKLEVBQWM7QUFDWmc4QyxJQUFBQSxXQUFXLENBQUN4RyxFQUFELEVBQUt0cEMsTUFBTCxFQUFhUSxNQUFiLEVBQXFCdkssTUFBckIsRUFBNkIwVixRQUE3QixFQUF1Q3NnQixRQUF2QyxDQUFYO0FBQ0QsR0FGRCxNQUVPO0FBQ0w4akIsSUFBQUEsV0FBVyxDQUFDekcsRUFBRCxFQUFLdHBDLE1BQUwsRUFBYVEsTUFBYixFQUFxQnZLLE1BQXJCLEVBQTZCMFYsUUFBN0IsQ0FBWDtBQUNEO0FBQ0YsQ0FSRDtBQVNBOzs7Ozs7Ozs7O0FBVUFzNEIsRUFBRSxDQUFDMEwsU0FBSCxHQUFlLENBQUNyRyxFQUFELEVBQUt0cEMsTUFBTCxFQUFhUSxNQUFiLEVBQXFCdkssTUFBckIsRUFBNkIwVixRQUE3QixLQUEwQztBQUN2RCxRQUFNN1gsUUFBUSxHQUFHc0wsTUFBTSxDQUFDdEwsUUFBUCxDQUFnQmtNLE1BQWhCLENBQWpCOztBQUVBLE1BQUlsTSxRQUFKLEVBQWM7QUFDWixXQUFPazhDLGVBQWUsQ0FBQzFHLEVBQUQsRUFBS3RwQyxNQUFMLEVBQWFRLE1BQWIsRUFBcUJ2SyxNQUFyQixDQUF0QjtBQUNEOztBQUVELFNBQU9nNkMsZUFBZSxDQUFDM0csRUFBRCxFQUFLdHBDLE1BQUwsRUFBYVEsTUFBYixFQUFxQnZLLE1BQXJCLENBQXRCO0FBQ0QsQ0FSRCxDLENBUUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQSxNQUFNaTZDLGNBQU4sQ0FBcUI7QUFDbkJwMkMsRUFBQUEsV0FBVyxDQUFDMlksTUFBRCxFQUFTMFEsSUFBVCxFQUFlbEYsTUFBZixFQUF1QjtBQUNoQyxTQUFLa0YsSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBSzFRLE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUt3TCxNQUFMLEdBQWNBLE1BQWQ7QUFDRCxHQUxrQjs7O0FBUXJCOzs7Ozs7O0FBT0EsU0FBUzhyQixJQUFULENBQWNKLFNBQWQsRUFBeUJHLFVBQXpCLEVBQXFDN2QsUUFBckMsRUFBK0M7QUFDN0M7QUFDRTtBQUNBO0FBQ0Fra0IsSUFBQUEsa0JBQWtCLENBQUN4RyxTQUFELEVBQVlHLFVBQVosRUFBd0I3ZCxRQUF4QixDQUFsQjtBQUNBO0FBQ0QsR0FONEMsQ0FNM0M7QUFDSDtBQUNEOzs7Ozs7O0FBT0EsU0FBU2trQixrQkFBVCxDQUE0QnhHLFNBQTVCLEVBQXVDRyxVQUF2QyxFQUFtRDdkLFFBQW5ELEVBQTZEO0FBQzNEOTRCLEVBQUFBLEVBQUUsQ0FBQ3dNLE1BQUgsQ0FBVXl3QyxXQUFWLENBQXNCekcsU0FBdEIsRUFBaUNHLFVBQWpDLEVBQTZDM0csb0JBQTdDLEVBQW1FaitCLE1BQU0sSUFBSTtBQUMzRSxRQUFJLENBQUNBLE1BQU0sQ0FBQ29uQyxPQUFaLEVBQXFCO0FBQ25CLGFBQU9yZ0IsUUFBUSxDQUFDLElBQUkzM0IsS0FBSixDQUFVNFEsTUFBTSxDQUFDbEssS0FBakIsQ0FBRCxDQUFmO0FBQ0QsS0FIMEUsQ0FHekU7QUFDRjs7O0FBR0FpeEIsSUFBQUEsUUFBUTtBQUNULEdBUkQ7QUFTRDtBQUNEOzs7Ozs7O0FBT0EsU0FBU2tnQixvQkFBVCxDQUE4QmhwQixJQUE5QixFQUFvQ3VwQixVQUFwQyxFQUFnRDtBQUM5QyxRQUFNMkQsT0FBTyxHQUFHaE4sbUJBQW1CLEVBQW5DLENBRDhDLENBQ1A7O0FBRXZDLFFBQU1pRyxFQUFFLEdBQUcsSUFBSTRHLGNBQUosQ0FBbUJHLE9BQW5CLEVBQTRCbHRCLElBQTVCLEVBQWtDdXBCLFVBQWxDLENBQVg7QUFDQXRKLEVBQUFBLGVBQWUsQ0FBQ3JuQyxHQUFoQixDQUFvQnMwQyxPQUFwQixFQUE2Qi9HLEVBQTdCLEVBSjhDLENBSVo7O0FBRWxDLFNBQU8rRyxPQUFQO0FBQ0Q7QUFDRDs7Ozs7O0FBTUEsU0FBUzdHLG1CQUFULENBQTZCRixFQUE3QixFQUFpQztBQUMvQixRQUFNdmhCLE9BQU8sR0FBR3FiLGVBQWUsQ0FBQ3RyQyxHQUFoQixDQUFvQnd4QyxFQUFwQixDQUFoQjtBQUNBLFNBQU92aEIsT0FBTyxDQUFDOUosTUFBZjtBQUNEO0FBQ0Q7Ozs7OztBQU1BLFNBQVMyc0IscUJBQVQsQ0FBK0J0QixFQUEvQixFQUFtQztBQUNqQyxRQUFNdmhCLE9BQU8sR0FBR3FiLGVBQWUsQ0FBQ3RyQyxHQUFoQixDQUFvQnd4QyxFQUFwQixDQUFoQjtBQUNBLFNBQU92aEIsT0FBTyxDQUFDNUUsSUFBZjtBQUNEO0FBQ0Q7Ozs7Ozs7O0FBUUEsU0FBUzBsQixtQkFBVCxDQUE2QnIzQixPQUE3QixFQUFzQzgrQixRQUF0QyxFQUFnRDtBQUM5QyxNQUFJOStCLE9BQU8sS0FBSyxJQUFoQixFQUFzQjtBQUNwQixXQUFPOCtCLFFBQVA7QUFDRDs7QUFFRCxRQUFNQyxXQUFXLEdBQUcsT0FBTy8rQixPQUEzQjs7QUFFQSxVQUFRKytCLFdBQVI7QUFDRSxTQUFLLFdBQUw7QUFDQSxTQUFLLFVBQUw7QUFDRSxhQUFPRCxRQUFQOztBQUVGLFNBQUssUUFBTDtBQUNFO0FBQ0EsWUFBTUUsTUFBTSxHQUFHMTlDLE1BQU0sQ0FBQzJlLE1BQVAsQ0FBYyxFQUFkLEVBQWtCNitCLFFBQWxCLENBQWY7QUFDQUUsTUFBQUEsTUFBTSxDQUFDcnhDLFFBQVAsR0FBa0JxUyxPQUFsQjtBQUNBLGFBQU9nL0IsTUFBUDs7QUFFRixTQUFLLFFBQUw7QUFDRSxhQUFPaC9CLE9BQVA7O0FBRUY7QUFDRThYLE1BQUFBLGtCQUFrQixDQUFDOVgsT0FBRCxFQUFVLFNBQVYsRUFBcUIsUUFBckIsQ0FBbEI7QUFDQSxhQUFPLElBQVA7QUFDRjtBQWpCRjtBQW1CRDtBQUNEOzs7Ozs7OztBQVFBLFNBQVMweEIsYUFBVCxDQUF1QnVOLEVBQXZCLEVBQTJCO0FBQ3pCLE1BQUksT0FBT0EsRUFBUCxLQUFjLFVBQWxCLEVBQThCO0FBQzVCLFdBQU9BLEVBQVA7QUFDRDs7QUFFRCxRQUFNLzdDLEdBQUcsR0FBRyxJQUFJOEksU0FBSixDQUFlLHlDQUF3Q2l6QyxFQUFHLEVBQTFELENBQVo7QUFDQS83QyxFQUFBQSxHQUFHLENBQUMyQyxJQUFKLEdBQVcsc0JBQVg7QUFDQSxRQUFNM0MsR0FBTjtBQUNEO0FBQ0Q7Ozs7Ozs7O0FBUUEsU0FBUysyQyxnQkFBVCxDQUEwQngxQyxNQUExQixFQUFrQ3k2QyxTQUFTLEdBQUcsTUFBOUMsRUFBc0Q7QUFDcEQ7QUFDQSxTQUFPLENBQUNsc0MsSUFBSSxDQUFDbXNDLE1BQUwsR0FBY3g0QyxRQUFkLENBQXVCLEVBQXZCLElBQTZCLG1CQUE5QixFQUFtRDhGLEtBQW5ELENBQXlELENBQXpELEVBQTREaEksTUFBTSxHQUFHLENBQXJFLENBQVA7QUFDRDs7QUFFRCxTQUFTMHRDLFNBQVQsQ0FBbUJ0c0MsSUFBbkIsRUFBeUJnRSxPQUF6QixFQUFrQzAyQixLQUFsQyxFQUF5QzJSLE9BQXpDLEVBQWtEdmdCLElBQWxELEVBQXdEO0FBQ3RELFFBQU1ub0IsS0FBSyxHQUFHLElBQUkxRyxLQUFKLENBQVcsR0FBRStDLElBQUssS0FBSWdFLE9BQVEsS0FBSXFvQyxPQUFRLEtBQUl2Z0IsSUFBSyxHQUFuRCxDQUFkO0FBQ0Fub0IsRUFBQUEsS0FBSyxDQUFDKzJCLEtBQU4sR0FBY0EsS0FBZDtBQUNBLzJCLEVBQUFBLEtBQUssQ0FBQzBvQyxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBMW9DLEVBQUFBLEtBQUssQ0FBQzNELElBQU4sR0FBYUEsSUFBYjtBQUNBMkQsRUFBQUEsS0FBSyxDQUFDbW9CLElBQU4sR0FBYUEsSUFBYjtBQUNBLFNBQU9ub0IsS0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQSxTQUFTdXlDLFlBQVQsQ0FBc0JwdUMsUUFBdEIsRUFBZ0NSLFFBQWhDLEVBQTBDO0FBQ3hDLFVBQVFRLFFBQVI7QUFDRSxTQUFLLFFBQUw7QUFDQSxTQUFLLElBQUw7QUFDQSxTQUFLcEssU0FBTDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBT3FLLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTNCLFFBQVEsQ0FBQytKLE1BQVQsR0FBa0IvRSxhQUFsQixFQUFaLENBQVA7O0FBRUY7QUFDRTtBQUNBO0FBQ0EsYUFBT3ZFLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWTNCLFFBQVosRUFBc0J4RyxRQUF0QixDQUErQmdILFFBQS9CLENBQVAsQ0FiSjs7QUFlRDtBQUNEOzs7Ozs7QUFNQSxTQUFTd29DLDBCQUFULENBQW9DeGtCLElBQXBDLEVBQTBDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQUkvakIsTUFBTSxDQUFDdEwsUUFBUCxDQUFnQnF2QixJQUFoQixDQUFKLEVBQTJCO0FBQ3pCQSxJQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBQ2hyQixRQUFMLEVBQVAsQ0FEeUIsQ0FDRDtBQUN6QixHQU51QyxDQU10Qzs7O0FBR0ZteEIsRUFBQUEsa0JBQWtCLENBQUNuRyxJQUFELEVBQU8sTUFBUCxFQUFlLFFBQWYsQ0FBbEI7QUFDQSxTQUFPaHdCLEVBQUUsQ0FBQytsQixVQUFILENBQWNxTixPQUFkLENBQXNCcEQsSUFBdEIsQ0FBUDtBQUNEO0FBQ0Q7Ozs7Ozs7QUFPQTs7Ozs7Ozs7OztBQVVBLFNBQVMyc0IsV0FBVCxDQUFxQnhHLEVBQXJCLEVBQXlCdHBDLE1BQXpCLEVBQWlDUSxNQUFqQyxFQUF5Q3ZLLE1BQXpDLEVBQWlEMFYsUUFBakQsRUFBMkRzZ0IsUUFBM0QsRUFBcUU7QUFDbkVBLEVBQUFBLFFBQVEsR0FBR2lYLGFBQWEsQ0FBQ2pYLFFBQVEsSUFBSXRnQixRQUFaLElBQXdCMVYsTUFBeEIsSUFBa0N1SyxNQUFuQyxDQUF4Qjs7QUFFQSxNQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUJBLElBQUFBLE1BQU0sR0FBRyxDQUFUO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPdkssTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QkEsSUFBQUEsTUFBTSxHQUFHK0osTUFBTSxDQUFDL0osTUFBUCxHQUFnQnVLLE1BQXpCO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPbUwsUUFBUCxLQUFvQixRQUF4QixFQUFrQztBQUNoQ0EsSUFBQUEsUUFBUSxHQUFHLElBQVg7QUFDRCxHQWJrRSxDQWFqRTs7O0FBR0YsUUFBTXlnQyxZQUFZLEdBQUc1QyxtQkFBbUIsQ0FBQ0YsRUFBRCxDQUF4QyxDQWhCbUUsQ0FnQnJCOztBQUU5QyxNQUFJOW9DLE1BQU0sS0FBSyxDQUFYLElBQWdCdkssTUFBTSxLQUFLK0osTUFBTSxDQUFDL0osTUFBdEMsRUFBOEM7QUFDNUMrSixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQy9CLEtBQVAsQ0FBYXVDLE1BQWIsRUFBcUJ2SyxNQUFyQixDQUFUO0FBQ0QsR0FwQmtFLENBb0JqRTs7O0FBR0YyNUMsRUFBQUEsaUJBQWlCLENBQUN4RCxZQUFELEVBQWVwc0MsTUFBZixFQUF1QixDQUFDdEwsR0FBRCxFQUFNNjNDLGNBQU4sS0FBeUI7QUFDL0QsUUFBSTczQyxHQUFKLEVBQVM7QUFDUHUzQixNQUFBQSxRQUFRLENBQUN2M0IsR0FBRCxDQUFSO0FBQ0E7QUFDRDs7QUFFRHUzQixJQUFBQSxRQUFRLENBQUMsSUFBRCxFQUFPc2dCLGNBQVAsRUFBdUJ2c0MsTUFBdkIsQ0FBUjtBQUNELEdBUGdCLENBQWpCO0FBUUQ7QUFDRDs7Ozs7Ozs7OztBQVVBLFNBQVNnd0MsZUFBVCxDQUF5QjFHLEVBQXpCLEVBQTZCdHBDLE1BQTdCLEVBQXFDUSxNQUFyQyxFQUE2Q3ZLLE1BQTdDLEVBQXFEMFYsUUFBckQsRUFBK0Q7QUFDN0QsTUFBSSxPQUFPbkwsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QkEsSUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDRDs7QUFFRCxNQUFJLE9BQU92SyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCQSxJQUFBQSxNQUFNLEdBQUcrSixNQUFNLENBQUMvSixNQUFQLEdBQWdCdUssTUFBekI7QUFDRDs7O0FBR0QsUUFBTTRyQyxZQUFZLEdBQUc1QyxtQkFBbUIsQ0FBQ0YsRUFBRCxDQUF4QyxDQVY2RCxDQVVmOztBQUU5QyxNQUFJOW9DLE1BQU0sS0FBSyxDQUFYLElBQWdCdkssTUFBTSxLQUFLK0osTUFBTSxDQUFDL0osTUFBdEMsRUFBOEM7QUFDNUMrSixJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQy9CLEtBQVAsQ0FBYXVDLE1BQWIsRUFBcUJ2SyxNQUFyQixDQUFUO0FBQ0QsR0FkNEQsQ0FjM0Q7OztBQUdGLFNBQU9tMkMsWUFBWSxDQUFDemlDLEtBQWIsQ0FBbUIzSixNQUFNLENBQUNxQixVQUFQLEVBQW5CLENBQVA7QUFDRDtBQUNEOzs7Ozs7O0FBT0E7Ozs7Ozs7OztBQVNBLFNBQVMwdUMsV0FBVCxDQUFxQnpHLEVBQXJCLEVBQXlCMS9CLE1BQXpCLEVBQWlDK0IsUUFBakMsRUFBMkN4TSxRQUEzQyxFQUFxRDhzQixRQUFyRCxFQUErRDtBQUM3REEsRUFBQUEsUUFBUSxHQUFHaVgsYUFBYSxDQUFDalgsUUFBUSxJQUFJOXNCLFFBQVosSUFBd0J3TSxRQUF6QixDQUF4QixDQUQ2RCxDQUNEOztBQUU1RCxNQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaENBLElBQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0QsR0FMNEQsQ0FLM0Q7OztBQUdGLE1BQUksT0FBT3hNLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaENBLElBQUFBLFFBQVEsR0FBRyxNQUFYO0FBQ0Q7O0FBRUQsUUFBTWl0QyxZQUFZLEdBQUc1QyxtQkFBbUIsQ0FBQ0YsRUFBRCxDQUF4QztBQUNBMS9CLEVBQUFBLE1BQU0sSUFBSSxFQUFWLENBYjZELENBYS9DOztBQUVkLFFBQU01SixNQUFNLEdBQUdaLE1BQU0sQ0FBQ2tCLElBQVAsQ0FBWXNKLE1BQVosRUFBb0J6SyxRQUFwQixDQUFmLENBZjZELENBZWY7O0FBRTlDeXdDLEVBQUFBLGlCQUFpQixDQUFDeEQsWUFBRCxFQUFlcHNDLE1BQWYsRUFBdUIsQ0FBQ3RMLEdBQUQsRUFBTTYzQyxjQUFOLEtBQXlCO0FBQy9ELFFBQUk3M0MsR0FBSixFQUFTO0FBQ1B1M0IsTUFBQUEsUUFBUSxDQUFDdjNCLEdBQUQsQ0FBUjtBQUNBO0FBQ0Q7O0FBRUR1M0IsSUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBT3NnQixjQUFQLEVBQXVCM2lDLE1BQXZCLENBQVI7QUFDRCxHQVBnQixDQUFqQjtBQVFEO0FBQ0Q7Ozs7Ozs7OztBQVNBLFNBQVNxbUMsZUFBVCxDQUF5QjNHLEVBQXpCLEVBQTZCMS9CLE1BQTdCLEVBQXFDK0IsUUFBckMsRUFBK0N4TSxRQUEvQyxFQUF5RDs7QUFFdkQsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDQSxJQUFBQSxRQUFRLEdBQUcsTUFBWDtBQUNEOztBQUVELFFBQU1pdEMsWUFBWSxHQUFHNUMsbUJBQW1CLENBQUNGLEVBQUQsQ0FBeEM7QUFDQTEvQixFQUFBQSxNQUFNLElBQUksRUFBVixDQVB1RCxDQU96Qzs7QUFFZCxRQUFNNUosTUFBTSxHQUFHWixNQUFNLENBQUNrQixJQUFQLENBQVlzSixNQUFaLEVBQW9CekssUUFBcEIsQ0FBZixDQVR1RCxDQVNUOztBQUU5QyxTQUFPaXRDLFlBQVksQ0FBQ3ppQyxLQUFiLENBQW1CM0osTUFBTSxDQUFDcUIsVUFBUCxFQUFuQixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzFCLE1BQVQsQ0FBZ0JtUixJQUFoQixFQUFzQjtBQUNwQjtBQUNBLE9BQUswVyxrQkFBTCxHQUEwQixFQUExQjtBQUNBLE9BQUtZLGFBQUwsR0FBcUJyekIsU0FBckIsQ0FIb0IsQ0FHWTtBQUNoQztBQUNEOztBQUVEakMsTUFBTSxDQUFDZ1IsY0FBUCxDQUFzQm5FLE1BQU0sQ0FBQ2pJLFNBQTdCLEVBQXdDeXdCLFlBQVksQ0FBQ3p3QixTQUFyRDtBQUNBNUUsTUFBTSxDQUFDZ1IsY0FBUCxDQUFzQm5FLE1BQXRCLEVBQThCd29CLFlBQTlCLEUsQ0FBNkM7O0FBRTdDLFNBQVN5b0IsUUFBVCxDQUFrQnAvQixPQUFsQixFQUEyQjtBQUN6QixNQUFJLEVBQUUsZ0JBQWdCby9CLFFBQWxCLENBQUosRUFBaUM7QUFDL0IsV0FBTyxJQUFJQSxRQUFKLENBQWFwL0IsT0FBYixDQUFQO0FBQ0QsR0FId0IsQ0FHdkI7OztBQUdGLE9BQUtxL0IsUUFBTCxHQUFnQixJQUFoQjs7QUFFQSxNQUFJci9CLE9BQUosRUFBYTtBQUNYLFFBQUksT0FBT0EsT0FBTyxDQUFDa1YsSUFBZixLQUF3QixVQUE1QixFQUF3QztBQUN0QyxXQUFLb3FCLEtBQUwsR0FBYXQvQixPQUFPLENBQUNrVixJQUFyQjtBQUNEOztBQUVELFFBQUksT0FBT2xWLE9BQU8sQ0FBQ3UvQixPQUFmLEtBQTJCLFVBQS9CLEVBQTJDO0FBQ3pDLFdBQUtDLFFBQUwsR0FBZ0J4L0IsT0FBTyxDQUFDdS9CLE9BQXhCO0FBQ0Q7QUFDRjs7QUFFRHB4QyxFQUFBQSxNQUFNLENBQUNySixJQUFQLENBQVksSUFBWjtBQUNEOztBQUVEdWxDLElBQUksQ0FBQ2dCLFFBQUwsQ0FBYytULFFBQWQsRUFBd0JqeEMsTUFBeEI7O0FBRUFpeEMsUUFBUSxDQUFDbDVDLFNBQVQsQ0FBbUJzNUMsUUFBbkIsR0FBOEIsVUFBVXQ4QyxHQUFWLEVBQWUrN0MsRUFBZixFQUFtQjtBQUMvQ0EsRUFBQUEsRUFBRSxDQUFDLzdDLEdBQUQsQ0FBRjtBQUNELENBRkQ7O0FBSUFrOEMsUUFBUSxDQUFDbDVDLFNBQVQsQ0FBbUJvNUMsS0FBbkIsR0FBMkIsVUFBVTNuQixDQUFWLEVBQWE7QUFDdEMsUUFBTSxJQUFJNzBCLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTMjhDLFFBQVQsQ0FBa0J6L0IsT0FBbEIsRUFBMkI7QUFDekIsUUFBTTAvQixRQUFRLEdBQUcsZ0JBQWdCQyxNQUFqQzs7QUFFQSxNQUFJLENBQUNELFFBQUQsSUFBYSxFQUFFLGdCQUFnQkQsUUFBbEIsQ0FBakIsRUFBOEM7QUFDNUMsV0FBTyxJQUFJQSxRQUFKLENBQWF6L0IsT0FBYixDQUFQO0FBQ0Q7O0FBRUQsT0FBS3ZlLFFBQUwsR0FBZ0IsSUFBaEI7O0FBRUEsTUFBSXVlLE9BQUosRUFBYTtBQUNYLFFBQUksT0FBT0EsT0FBTyxDQUFDN0gsS0FBZixLQUF5QixVQUE3QixFQUF5QztBQUN2QyxXQUFLeW5DLE1BQUwsR0FBYzUvQixPQUFPLENBQUM3SCxLQUF0QjtBQUNEOztBQUVELFFBQUksT0FBTzZILE9BQU8sQ0FBQzYvQixNQUFmLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3hDLFdBQUtDLE9BQUwsR0FBZTkvQixPQUFPLENBQUM2L0IsTUFBdkI7QUFDRDs7QUFFRCxRQUFJLE9BQU83L0IsT0FBTyxDQUFDdS9CLE9BQWYsS0FBMkIsVUFBL0IsRUFBMkM7QUFDekMsV0FBS0MsUUFBTCxHQUFnQngvQixPQUFPLENBQUN1L0IsT0FBeEI7QUFDRDs7QUFFRCxRQUFJLE9BQU92L0IsT0FBTyxDQUFDKy9CLEtBQWYsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkMsV0FBS0MsTUFBTCxHQUFjaGdDLE9BQU8sQ0FBQysvQixLQUF0QjtBQUNEO0FBQ0Y7O0FBRUQ1eEMsRUFBQUEsTUFBTSxDQUFDckosSUFBUCxDQUFZLElBQVo7QUFDRDs7QUFFRHVsQyxJQUFJLENBQUNnQixRQUFMLENBQWNvVSxRQUFkLEVBQXdCdHhDLE1BQXhCOztBQUVBLFNBQVN3eEMsTUFBVCxDQUFnQjMvQixPQUFoQixFQUF5QjtBQUN2QixNQUFJLEVBQUUsZ0JBQWdCMi9CLE1BQWxCLENBQUosRUFBK0I7QUFDN0IsV0FBTyxJQUFJQSxNQUFKLENBQVczL0IsT0FBWCxDQUFQO0FBQ0Q7O0FBRURvL0IsRUFBQUEsUUFBUSxDQUFDdDZDLElBQVQsQ0FBYyxJQUFkLEVBQW9Ca2IsT0FBcEI7QUFDQXkvQixFQUFBQSxRQUFRLENBQUMzNkMsSUFBVCxDQUFjLElBQWQsRUFBb0JrYixPQUFwQixFQU51QixDQU1POztBQUU5QixPQUFLaWdDLGFBQUwsR0FBcUIsSUFBckI7O0FBRUEsTUFBSWpnQyxPQUFKLEVBQWE7QUFDWCxRQUFJQSxPQUFPLENBQUNxL0IsUUFBUixLQUFxQixLQUF6QixFQUFnQztBQUM5QixXQUFLQSxRQUFMLEdBQWdCLEtBQWhCO0FBQ0Q7O0FBRUQsUUFBSXIvQixPQUFPLENBQUN2ZSxRQUFSLEtBQXFCLEtBQXpCLEVBQWdDO0FBQzlCLFdBQUtBLFFBQUwsR0FBZ0IsS0FBaEI7QUFDRDs7QUFFRCxRQUFJdWUsT0FBTyxDQUFDaWdDLGFBQVIsS0FBMEIsS0FBOUIsRUFBcUM7QUFDbkMsV0FBS0EsYUFBTCxHQUFxQixLQUFyQixDQURtQyxDQUNQO0FBQzdCO0FBQ0Y7QUFDRjs7QUFFRDVWLElBQUksQ0FBQ2dCLFFBQUwsQ0FBY3NVLE1BQWQsRUFBc0JQLFFBQXRCLEUsQ0FBaUM7O0FBRWpDLE1BQU1jLGVBQWUsR0FBRzUrQyxNQUFNLENBQUNrRSxJQUFQLENBQVlpNkMsUUFBUSxDQUFDdjVDLFNBQXJCLENBQXhCOztBQUVBLEtBQUssSUFBSXZCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1N0MsZUFBZSxDQUFDejdDLE1BQXBDLEVBQTRDRSxDQUFDLEVBQTdDLEVBQWlEO0FBQy9DLFFBQU13N0MsTUFBTSxHQUFHRCxlQUFmOztBQUVBLE1BQUksQ0FBQ1AsTUFBTSxDQUFDejVDLFNBQVAsQ0FBaUJpNkMsTUFBakIsQ0FBTCxFQUErQjtBQUM3QlIsSUFBQUEsTUFBTSxDQUFDejVDLFNBQVAsQ0FBaUJpNkMsTUFBakIsSUFBMkJWLFFBQVEsQ0FBQ3Y1QyxTQUFULENBQW1CaTZDLE1BQW5CLENBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTQyxTQUFULENBQW1CcGdDLE9BQW5CLEVBQTRCO0FBQzFCLE1BQUksRUFBRSxnQkFBZ0JvZ0MsU0FBbEIsQ0FBSixFQUFrQztBQUNoQyxXQUFPLElBQUlBLFNBQUosQ0FBY3BnQyxPQUFkLENBQVA7QUFDRDs7QUFFRDIvQixFQUFBQSxNQUFNLENBQUM3NkMsSUFBUCxDQUFZLElBQVosRUFBa0JrYixPQUFsQixFQUwwQixDQUtFOztBQUU1QixNQUFJQSxPQUFKLEVBQWE7QUFDWCxRQUFJLE9BQU9BLE9BQU8sQ0FBQ3FnQyxTQUFmLEtBQTZCLFVBQWpDLEVBQTZDO0FBQzNDLFdBQUtDLFVBQUwsR0FBa0J0Z0MsT0FBTyxDQUFDcWdDLFNBQTFCO0FBQ0Q7O0FBRUQsUUFBSSxPQUFPcmdDLE9BQU8sQ0FBQ3VnQyxLQUFmLEtBQXlCLFVBQTdCLEVBQXlDO0FBQ3ZDLFdBQUtDLE1BQUwsR0FBY3hnQyxPQUFPLENBQUN1Z0MsS0FBdEI7QUFDRDtBQUNGLEdBZnlCLENBZXhCO0FBQ0Y7O0FBRUQ7O0FBRURsVyxJQUFJLENBQUNnQixRQUFMLENBQWMrVSxTQUFkLEVBQXlCVCxNQUF6QjtBQUNBeHhDLE1BQU0sQ0FBQ0EsTUFBUCxHQUFnQkEsTUFBaEIsQyxDQUF3Qjs7QUFFeEJBLE1BQU0sQ0FBQ2l5QyxTQUFQLEdBQW1CQSxTQUFuQjtBQUNBanlDLE1BQU0sQ0FBQ2l4QyxRQUFQLEdBQWtCQSxRQUFsQjtBQUNBanhDLE1BQU0sQ0FBQ3N4QyxRQUFQLEdBQWtCQSxRQUFsQjtBQUNBdHhDLE1BQU0sQ0FBQ3d4QyxNQUFQLEdBQWdCQSxNQUFoQixDLENBQXdCOztBQUV4QjtBQUNBenRCLFFBQVEsQ0FBQyxNQUFELEVBQVNQLElBQVQsQ0FBUjtBQUNBTyxRQUFRLENBQUMsSUFBRCxFQUFPNFYsRUFBUCxDQUFSO0FBQ0E1VixRQUFRLENBQUMsS0FBRCxFQUFROFgsR0FBUixDQUFSO0FBQ0E5WCxRQUFRLENBQUMsTUFBRCxFQUFTbVksSUFBVCxDQUFSO0FBQ0FuWSxRQUFRLENBQUMsUUFBRCxFQUFXZ2IsUUFBWCxDQUFSO0FBQ0FoYixRQUFRLENBQUMsUUFBRCxFQUFXeUUsWUFBWCxDQUFSO0FBQ0F6RSxRQUFRLENBQUMsUUFBRCxFQUFXaFgsWUFBWCxDQUFSO0FBQ0FnWCxRQUFRLENBQUMsZ0JBQUQsRUFBbUJpZixlQUFuQixDQUFSO0FBQ0FqZixRQUFRLENBQUMsSUFBRCxFQUFPdWdCLEVBQVAsQ0FBUjtBQUNBdmdCLFFBQVEsQ0FBQyxRQUFELEVBQVcvakIsTUFBWCxDQUFSLEMsQ0FBNEI7O0FBRTVCL00sTUFBTSxDQUFDd00sTUFBUCxHQUFnQnNOLFlBQVksQ0FBQ3ROLE1BQTdCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTs7Ozs7Ozs7O0FBU0EsU0FBUzZ5QyxvQkFBVCxHQUFnQztBQUM5QixRQUFNQyxjQUFjLEdBQUcsZ0JBQXZCOztBQUVBLE1BQUk7QUFDRixVQUFNNW1CLFFBQVEsR0FBR240QixFQUFFLENBQUMrbEIsVUFBSCxDQUFjcU4sT0FBZCxDQUFzQnB6QixFQUFFLENBQUMrbEIsVUFBSCxDQUFjQyxrQkFBcEMsRUFBeUQsZUFBYys0QixjQUFlLEVBQXRGLENBQWpCOztBQUVBLFFBQUk1bUIsUUFBUSxDQUFDOUUsTUFBVCxFQUFKLEVBQXVCO0FBQ3JCLFlBQU0yckIsUUFBUSxHQUFHMzFCLElBQUksQ0FBQ2lLLEtBQUwsQ0FBVzZFLFFBQVEsQ0FBQzVFLElBQVQsR0FBZ0JDLElBQTNCLENBQWpCOztBQUVBLFVBQUlqeEIsS0FBSyxDQUFDQyxPQUFOLENBQWN3OEMsUUFBUSxDQUFDQyxPQUF2QixDQUFKLEVBQXFDO0FBQ25DLGVBQU9ELFFBQVEsQ0FBQ0MsT0FBaEI7QUFDRDs7QUFFRCxhQUFPLEVBQVA7QUFDRDtBQUNGLEdBWkQsQ0FZRSxPQUFPcDNDLEtBQVAsRUFBYztBQUNkN0gsSUFBQUEsRUFBRSxDQUFDeXRCLEdBQUgsQ0FBTzVsQixLQUFQLENBQWMsbUJBQWtCazNDLGNBQWUsY0FBYWwzQyxLQUFLLENBQUNLLE9BQVEsRUFBMUU7QUFDRDs7QUFFRCxTQUFPLElBQVA7QUFDRDtBQUNEOzs7Ozs7OztBQVFBLFNBQVNnM0Msa0NBQVQsR0FBOEM7QUFDNUMsUUFBTUMsaUJBQWlCLEdBQUduL0MsRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY3FOLE9BQWQsQ0FBc0JwekIsRUFBRSxDQUFDK2xCLFVBQUgsQ0FBY0Msa0JBQXBDLENBQTFCO0FBQ0EsUUFBTW81QiwyQkFBMkIsR0FBR0QsaUJBQWlCLENBQUNFLFVBQWxCLENBQTZCdjhDLE1BQWpFO0FBQ0EsUUFBTXc4QyxnQkFBZ0IsR0FBRyxFQUF6Qjs7QUFFQSxXQUFTQyxRQUFULENBQWtCOUosSUFBbEIsRUFBd0I7QUFDdEIsUUFBSUEsSUFBSixFQUFVO0FBQ1IsVUFBSUEsSUFBSSxDQUFDWixXQUFMLEVBQUosRUFBd0I7QUFDdEI7QUFDQSxjQUFNMkssYUFBYSxHQUFHL0osSUFBSSxDQUFDbUUsbUJBQUwsRUFBdEI7O0FBRUEsWUFBSTRGLGFBQUosRUFBbUI7QUFDakIsZUFBSyxJQUFJMXhDLEtBQUssR0FBRyxDQUFqQixFQUFvQkEsS0FBSyxHQUFHMHhDLGFBQWEsQ0FBQzE4QyxNQUExQyxFQUFrRGdMLEtBQUssRUFBdkQsRUFBMkQ7QUFDekR5eEMsWUFBQUEsUUFBUSxDQUFDdi9DLEVBQUUsQ0FBQytsQixVQUFILENBQWNxTixPQUFkLENBQXNCcWlCLElBQUksQ0FBQzRKLFVBQTNCLEVBQXVDRyxhQUFhLENBQUMxeEMsS0FBRCxDQUFwRCxDQUFELENBQVI7QUFDRDtBQUNGO0FBQ0YsT0FURCxNQVNPLElBQUkybkMsSUFBSSxDQUFDMXdDLElBQUwsQ0FBVTA2QyxNQUFWLENBQWlCLGdCQUFqQixLQUFzQyxDQUExQyxFQUE2QztBQUNsRDtBQUNBO0FBQ0EsWUFBSUMsYUFBYSxHQUFHakssSUFBSSxDQUFDNEosVUFBekI7QUFDQUssUUFBQUEsYUFBYSxHQUFHQSxhQUFhLENBQUN0MEMsTUFBZCxDQUFxQmcwQywyQkFBckIsRUFBa0RNLGFBQWEsQ0FBQzU4QyxNQUFkLEdBQXVCczhDLDJCQUF2QixHQUFxRCxNQUFNdDhDLE1BQTdHLENBQWhCO0FBQ0F3OEMsUUFBQUEsZ0JBQWdCLENBQUNqOUMsSUFBakIsQ0FBc0JxOUMsYUFBdEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRURILEVBQUFBLFFBQVEsQ0FBQ0osaUJBQUQsQ0FBUjtBQUNBLFNBQU9HLGdCQUFQO0FBQ0Q7QUFDRDs7Ozs7O0FBTUEsU0FBU0ssU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBSU4sZ0JBQWdCLEdBQUdSLG9CQUFvQixFQUEzQzs7QUFFQSxNQUFJLENBQUNRLGdCQUFMLEVBQXVCO0FBQ3JCQSxJQUFBQSxnQkFBZ0IsR0FBR0osa0NBQWtDLEVBQXJEO0FBQ0QsR0FSMEIsQ0FRekI7OztBQUdGLE1BQUksQ0FBQ0ksZ0JBQUQsSUFBcUJBLGdCQUFnQixDQUFDeDhDLE1BQWpCLElBQTJCLENBQXBELEVBQXVEO0FBQ3JEODhDLElBQUFBLFFBQVE7QUFDUjtBQUNELEdBZDBCLENBY3pCOzs7QUFHRk4sRUFBQUEsZ0JBQWdCLENBQUN0NkIsSUFBakIsR0FqQjJCLENBaUJGOztBQUV6QixXQUFTNjZCLG9CQUFULENBQThCRCxRQUE5QixFQUF3QztBQUN0QyxRQUFJRSxjQUFjLEdBQUcsQ0FBckI7O0FBRUEsYUFBU0MsTUFBVCxHQUFrQjtBQUNoQjtBQUNBLGFBQU9ELGNBQWMsR0FBR1IsZ0JBQWdCLENBQUN4OEMsTUFBekMsRUFBaUQ7QUFDL0M7QUFDQSxjQUFNbTNCLFFBQVEsR0FBR3FsQixnQkFBZ0IsQ0FBQ1EsY0FBRCxDQUFqQzs7QUFFQSxjQUFNRSxTQUFTLEdBQUc3dkIsT0FBTyxDQUFDOEosUUFBRCxDQUF6QixDQUorQyxDQUlWO0FBQ3JDO0FBQ0E7QUFDQTs7O0FBR0EsWUFBSStsQixTQUFTLENBQUM3UyxPQUFkLEVBQXVCO0FBQ3JCNlMsVUFBQUEsU0FBUyxDQUFDN1MsT0FBVixDQUFrQjhTLDRCQUFsQjtBQUNBO0FBQ0QsU0FiOEMsQ0FhN0M7OztBQUdGSCxRQUFBQSxjQUFjO0FBQ2YsT0FuQmUsQ0FtQmQ7OztBQUdGRixNQUFBQSxRQUFRO0FBQ1Q7O0FBRUQsYUFBU0ssNEJBQVQsR0FBd0M7QUFDdEM7QUFDQTtBQUNBSCxNQUFBQSxjQUFjO0FBQ2Qza0IsTUFBQUEsVUFBVSxDQUFDLE1BQU00a0IsTUFBTSxFQUFiLEVBQWlCLENBQWpCLENBQVY7QUFDRDs7QUFFREEsSUFBQUEsTUFBTTtBQUNQLEdBdkQwQixDQXVEekI7QUFDRjs7O0FBR0FGLEVBQUFBLG9CQUFvQixDQUFDRCxRQUFELENBQXBCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E1L0MsRUFBRSxDQUFDeXRCLEdBQUgsQ0FBT2xCLElBQVAsQ0FBYSxHQUFFdnNCLEVBQUUsQ0FBQ2c1QixHQUFILENBQU9qMEIsSUFBSyxJQUFHL0UsRUFBRSxDQUFDZzVCLEdBQUgsQ0FBT0ssT0FBUSx5QkFBd0IsT0FBUSxJQUFHLFlBQWEsR0FBN0YsRSxDQUFrRztBQUNsRzs7QUFFQSxJQUFJO0FBQ0ZsSixFQUFBQSxPQUFPLENBQUMsc0JBQUQsQ0FBUDtBQUNELENBRkQsQ0FFRSxPQUFPbHZCLENBQVAsRUFBVSxDQUFFLEMsQ0FBQztBQUNmMCtDLFNBQVMsQ0FBQyxZQUFZO0FBQ3BCO0FBQ0E7QUFDQXh2QixFQUFBQSxPQUFPLENBQUMsT0FBRCxDQUFQLENBSG9CLENBR0Y7QUFDbEI7QUFDQTs7O0FBR0Fud0IsRUFBQUEsRUFBRSxDQUFDZzVCLEdBQUgsQ0FBT2tuQixTQUFQLENBQWlCLFNBQWpCO0FBQ0QsQ0FUUSxDQUFUIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgcXVvdGUtcHJvcHMgKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lELCBPU19JT1MgKi9cbi8vIEFkZCBnbG9iYWwgY29uc3RhbnRzLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb21tb25qc0dsb2JhbCwge1xuICAnT1NfQU5EUk9JRCc6IHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgJ09TX0lPUyc6IHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0sXG4gIE9TX1ZFUlNJT05fTUFKT1I6IHtcbiAgICB2YWx1ZTogVGkuUGxhdGZvcm0udmVyc2lvbk1ham9yLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPU19WRVJTSU9OX01JTk9SOiB7XG4gICAgdmFsdWU6IFRpLlBsYXRmb3JtLnZlcnNpb25NaW5vcixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgT1NfVkVSU0lPTl9QQVRDSDoge1xuICAgIHZhbHVlOiBUaS5QbGF0Zm9ybS52ZXJzaW9uUGF0Y2gsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH1cbn0pO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBrTm9kZU1vZHVsZXNSRSA9IC9eKC4qKVtcXFxcL11ub2RlX21vZHVsZXNbXFxcXC9dLztcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPSBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpO1xuY29uc3QgaXNCdWZmZXIgPSBTeW1ib2wuZm9yKCd0aXRhbml1bS5idWZmZXIuaXNCdWZmZXInKTtcbmNvbnN0IGNvbG9yUmVnRXhwID0gL1xcdTAwMWJcXFtcXGRcXGQ/bS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuZnVuY3Rpb24gcmVtb3ZlQ29sb3JzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY29sb3JSZWdFeHAsICcnKTtcbn1cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICAvLyBBbiBlcnJvciBjb3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB3aGlsZSBub3QgYmVpbmcgYSBuYXRpdmUgZXJyb3JcbiAgLy8gb3IgY291bGQgYmUgZnJvbSBhIGRpZmZlcmVudCByZWFsbSBhbmQgbm90IGJlIGluc3RhbmNlIG9mIEVycm9yIGJ1dCBzdGlsbFxuICAvLyBiZSBhIG5hdGl2ZSBlcnJvci5cbiAgcmV0dXJuIGlzTmF0aXZlRXJyb3IoZSkgfHwgZSBpbnN0YW5jZW9mIEVycm9yO1xufVxubGV0IGdldFN0cnVjdHVyZWRTdGFjaztcblxuY2xhc3MgU3RhY2tUcmFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuU3RhY2tUcmFjZUVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gKGVyciwgdHJhY2UpID0+IHRyYWNlO1xuXG5TdGFja1RyYWNlRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gSW5maW5pdHk7XG5mdW5jdGlvbiBpc0luc2lkZU5vZGVNb2R1bGVzKCkge1xuICBpZiAoZ2V0U3RydWN0dXJlZFN0YWNrID09PSB1bmRlZmluZWQpIHtcbiAgICBnZXRTdHJ1Y3R1cmVkU3RhY2sgPSAoKSA9PiBuZXcgU3RhY2tUcmFjZUVycm9yKCkuc3RhY2s7XG4gIH1cblxuICBsZXQgc3RhY2sgPSBnZXRTdHJ1Y3R1cmVkU3RhY2soKTsgLy8gc3RhY2sgaXMgb25seSBhbiBhcnJheSBvbiB2OCwgdHJ5IHRvIGNvbnZlcnQgbWFudWFsbHkgaWYgc3RyaW5nXG5cbiAgaWYgKHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBzdGFja0ZyYW1lcyA9IFtdO1xuICAgIGNvbnN0IGxpbmVzID0gc3RhY2suc3BsaXQoL1xcbi8pO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBjb25zdCBsaW5lSW5mbyA9IGxpbmUubWF0Y2goLyguKilAKC4qKTooXFxkKyk6KFxcZCspLyk7XG5cbiAgICAgIGlmIChsaW5lSW5mbykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGxpbmVJbmZvWzJdLnJlcGxhY2UoJ2ZpbGU6Ly8nLCAnJyk7XG4gICAgICAgIHN0YWNrRnJhbWVzLnB1c2goe1xuICAgICAgICAgIGdldEZpbGVOYW1lOiAoKSA9PiBmaWxlbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGFjayA9IHN0YWNrRnJhbWVzO1xuICB9IC8vIEl0ZXJhdGUgb3ZlciBhbGwgc3RhY2sgZnJhbWVzIGFuZCBsb29rIGZvciB0aGUgZmlyc3Qgb25lIG5vdCBjb21pbmdcbiAgLy8gZnJvbSBpbnNpZGUgTm9kZS5qcyBpdHNlbGY6XG5cblxuICBpZiAoQXJyYXkuaXNBcnJheShzdGFjaykpIHtcbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIHN0YWNrKSB7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGZyYW1lLmdldEZpbGVOYW1lKCk7IC8vIElmIGEgZmlsZW5hbWUgZG9lcyBub3Qgc3RhcnQgd2l0aCAvIG9yIGNvbnRhaW4gXFwsXG4gICAgICAvLyBpdCdzIGxpa2VseSBmcm9tIE5vZGUuanMgY29yZS5cblxuICAgICAgaWYgKCEvXlxcL3xcXFxcLy50ZXN0KGZpbGVuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGtOb2RlTW9kdWxlc1JFLnRlc3QoZmlsZW5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGpvaW4ob3V0cHV0LCBzZXBhcmF0b3IpIHtcbiAgbGV0IHN0ciA9ICcnO1xuXG4gIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAvLyBJdCBpcyBmYXN0ZXIgbm90IHRvIHVzZSBhIHRlbXBsYXRlIHN0cmluZyBoZXJlXG4gICAgICBzdHIgKz0gb3V0cHV0W2ldO1xuICAgICAgc3RyICs9IHNlcGFyYXRvcjtcbiAgICB9XG5cbiAgICBzdHIgKz0gb3V0cHV0W2xhc3RJbmRleF07XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmLmNhbGwuYXBwbHkoZiwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmNvbnN0IEFMTF9QUk9QRVJUSUVTID0gMDtcbmNvbnN0IE9OTFlfRU5VTUVSQUJMRSA9IDI7XG5jb25zdCBwcm9wZXJ0eUZpbHRlciA9IHtcbiAgQUxMX1BST1BFUlRJRVMsXG4gIE9OTFlfRU5VTUVSQUJMRVxufTtcbmZ1bmN0aW9uIGdldE93bk5vbkluZGV4UHJvcGVydGllcyhvYmosIGZpbHRlcikge1xuICBjb25zdCBwcm9wcyA9IFtdO1xuICBjb25zdCBrZXlzID0gZmlsdGVyID09PSBPTkxZX0VOVU1FUkFCTEUgPyBPYmplY3Qua2V5cyhvYmopIDogT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuXG4gICAgaWYgKCFpc0FsbERpZ2l0cyhrZXkpKSB7XG4gICAgICBwcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG5mdW5jdGlvbiBpc0FsbERpZ2l0cyhzKSB7XG4gIGlmIChzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY29kZSA8IDQ4IHx8IGNvZGUgPiA1Nykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBUeXBlZEFycmF5UHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbmNvbnN0IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyA9IHVuY3VycnlUaGlzKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoVHlwZWRBcnJheVByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnKS5nZXQpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgbmFtZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gYFtvYmplY3QgJHtuYW1lfV1gO1xufVxuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNBcmd1bWVudHNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ0FyZ3VtZW50cycpO1xufVxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXJyYXlCdWZmZXInKTtcbn0gLy8gQ2FjaGVkIHRvIG1ha2Ugc3VyZSBubyB1c2VybGFuZCBjb2RlIGNhbiB0YW1wZXIgd2l0aCBpdC5cblxuY29uc3QgaXNBcnJheUJ1ZmZlclZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5mdW5jdGlvbiBpc0FzeW5jRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnQXN5bmNGdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnSW50NjRBcnJheSc7XG59XG5mdW5jdGlvbiBpc0JpZ1VpbnQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnQmlnVWludDY0QXJyYXknO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdCb29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB8fCBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHwgaXNCb29sZWFuT2JqZWN0KHZhbHVlKSAvLyB8fCBpc0JpZ0ludE9iamVjdCh2YWx1ZSlcbiAgfHwgaXNTeW1ib2xPYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNEYXRhVmlldyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnRGF0YVZpZXcnKTtcbn1cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnRGF0ZScpO1xufSAvLyBAdG9kbyBpc0V4dGVybmFsXG5cbmZ1bmN0aW9uIGlzRmxvYXQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQzMkFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzRmxvYXQ2NEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnRmxvYXQ2NEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnR2VuZXJhdG9yRnVuY3Rpb24nKTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdG9yT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdHZW5lcmF0b3InKTtcbn1cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzSW50MTZBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ0ludDE2QXJyYXknO1xufVxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5mdW5jdGlvbiBpc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnTWFwJyk7XG59XG5mdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSAmJiBwcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01hcCBJdGVyYXRvcic7XG59IC8vIEB0b2RvIGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0XG5cbmZ1bmN0aW9uIGlzTmF0aXZlRXJyb3IodmFsdWUpIHtcbiAgLy8gaWYgbm90IGFuIGluc3RhbmNlIG9mIGFuIEVycm9yLCBkZWZpbml0ZWx5IG5vdCBhIG5hdGl2ZSBlcnJvclxuICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghdmFsdWUgfHwgIXZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFsnRXJyb3InLCAnRXZhbEVycm9yJywgJ1JhbmdlRXJyb3InLCAnUmVmZXJlbmNlRXJyb3InLCAnU3ludGF4RXJyb3InLCAnVHlwZUVycm9yJywgJ1VSSUVycm9yJ10uaW5jbHVkZXModmFsdWUuY29uc3RydWN0b3IubmFtZSk7XG59XG5mdW5jdGlvbiBpc051bWJlck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnTnVtYmVyJyk7XG59XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1Byb21pc2UnKTtcbn0gLy8gQHRvZG8gaXNQcm94eVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnUmVnRXhwJyk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU2V0Jyk7XG59XG5mdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgcmV0dXJuIHByb3RvdHlwZSAmJiBwcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ1NldCBJdGVyYXRvcic7XG59XG5mdW5jdGlvbiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICghZ2xvYmFsLlNoYXJlZEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1NoYXJlZEFycmF5QnVmZmVyJyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGNoZWNrUHJvdG90eXBlKHZhbHVlLCAnU3ltYm9sJyk7XG59XG5mdW5jdGlvbiBpc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgY29uc3QgaXNCdWlsdEluVHlwZWRBcnJheSA9IFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgIT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNCdWlsdEluVHlwZWRBcnJheSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlW2lzQnVmZmVyXSA9PT0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gVHlwZWRBcnJheVByb3RvX3RvU3RyaW5nVGFnKHZhbHVlKSA9PT0gJ1VpbnQ4Q2xhbXBlZEFycmF5Jztcbn1cbmZ1bmN0aW9uIGlzVWludDE2QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIFR5cGVkQXJyYXlQcm90b190b1N0cmluZ1RhZyh2YWx1ZSkgPT09ICdVaW50MTZBcnJheSc7XG59XG5mdW5jdGlvbiBpc1VpbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBUeXBlZEFycmF5UHJvdG9fdG9TdHJpbmdUYWcodmFsdWUpID09PSAnVWludDMyQXJyYXknO1xufVxuZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgY2hlY2tQcm90b3R5cGUodmFsdWUsICdXZWFrTWFwJyk7XG59XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSAmJiBjaGVja1Byb3RvdHlwZSh2YWx1ZSwgJ1dlYWtTZXQnKTtcbn0gLy8gQHRvZG8gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlXG5cbnZhciB0eXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRpc0FueUFycmF5QnVmZmVyOiBpc0FueUFycmF5QnVmZmVyLFxuXHRpc0FyZ3VtZW50c09iamVjdDogaXNBcmd1bWVudHNPYmplY3QsXG5cdGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG5cdGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcblx0aXNBc3luY0Z1bmN0aW9uOiBpc0FzeW5jRnVuY3Rpb24sXG5cdGlzQmlnSW50NjRBcnJheTogaXNCaWdJbnQ2NEFycmF5LFxuXHRpc0JpZ1VpbnQ2NEFycmF5OiBpc0JpZ1VpbnQ2NEFycmF5LFxuXHRpc0Jvb2xlYW5PYmplY3Q6IGlzQm9vbGVhbk9iamVjdCxcblx0aXNCb3hlZFByaW1pdGl2ZTogaXNCb3hlZFByaW1pdGl2ZSxcblx0aXNEYXRhVmlldzogaXNEYXRhVmlldyxcblx0aXNEYXRlOiBpc0RhdGUsXG5cdGlzRmxvYXQzMkFycmF5OiBpc0Zsb2F0MzJBcnJheSxcblx0aXNGbG9hdDY0QXJyYXk6IGlzRmxvYXQ2NEFycmF5LFxuXHRpc0dlbmVyYXRvckZ1bmN0aW9uOiBpc0dlbmVyYXRvckZ1bmN0aW9uLFxuXHRpc0dlbmVyYXRvck9iamVjdDogaXNHZW5lcmF0b3JPYmplY3QsXG5cdGlzSW50OEFycmF5OiBpc0ludDhBcnJheSxcblx0aXNJbnQxNkFycmF5OiBpc0ludDE2QXJyYXksXG5cdGlzSW50MzJBcnJheTogaXNJbnQzMkFycmF5LFxuXHRpc01hcDogaXNNYXAsXG5cdGlzTWFwSXRlcmF0b3I6IGlzTWFwSXRlcmF0b3IsXG5cdGlzTmF0aXZlRXJyb3I6IGlzTmF0aXZlRXJyb3IsXG5cdGlzTnVtYmVyT2JqZWN0OiBpc051bWJlck9iamVjdCxcblx0aXNQcm9taXNlOiBpc1Byb21pc2UsXG5cdGlzUmVnRXhwOiBpc1JlZ0V4cCxcblx0aXNTZXQ6IGlzU2V0LFxuXHRpc1NldEl0ZXJhdG9yOiBpc1NldEl0ZXJhdG9yLFxuXHRpc1NoYXJlZEFycmF5QnVmZmVyOiBpc1NoYXJlZEFycmF5QnVmZmVyLFxuXHRpc1N0cmluZ09iamVjdDogaXNTdHJpbmdPYmplY3QsXG5cdGlzU3ltYm9sT2JqZWN0OiBpc1N5bWJvbE9iamVjdCxcblx0aXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG5cdGlzVWludDhBcnJheTogaXNVaW50OEFycmF5LFxuXHRpc1VpbnQ4Q2xhbXBlZEFycmF5OiBpc1VpbnQ4Q2xhbXBlZEFycmF5LFxuXHRpc1VpbnQxNkFycmF5OiBpc1VpbnQxNkFycmF5LFxuXHRpc1VpbnQzMkFycmF5OiBpc1VpbnQzMkFycmF5LFxuXHRpc1dlYWtNYXA6IGlzV2Vha01hcCxcblx0aXNXZWFrU2V0OiBpc1dlYWtTZXRcbn0pO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5sZXQgZXJyb3I7XG5cbmZ1bmN0aW9uIGxhenlFcnJvcigpIHtcbiAgaWYgKCFlcnJvcikge1xuICAgIC8vIEBmaXhtZSByb2xsdXAgY2Fubm90IGhhbmRsZSBsYXp5IGxvYWRlZCBtb2R1bGVzLCBtYXliZSBtb3ZlIHRvIHdlYnBhY2s/XG4gICAgLy8gZXJyb3IgPSByZXF1aXJlKCcuL2Vycm9ycycpLmNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRJT047XG4gICAgZXJyb3IgPSBjb2Rlcy5FUlJfSU5URVJOQUxfQVNTRVJUSU9OO1xuICB9XG5cbiAgcmV0dXJuIGVycm9yO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIGNvbnN0IEVSUl9JTlRFUk5BTF9BU1NFUlRJT04gPSBsYXp5RXJyb3IoKTtcbiAgICB0aHJvdyBuZXcgRVJSX0lOVEVSTkFMX0FTU0VSVElPTihtZXNzYWdlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgY29uc3QgRVJSX0lOVEVSTkFMX0FTU0VSVElPTiA9IGxhenlFcnJvcigpO1xuICB0aHJvdyBuZXcgRVJSX0lOVEVSTkFMX0FTU0VSVElPTihtZXNzYWdlKTtcbn1cblxuYXNzZXJ0LmZhaWwgPSBmYWlsO1xuXG4vLyBDb3B5cmlnaHQgTm9kZS5qcyBjb250cmlidXRvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5jb25zdCBtZXNzYWdlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IGNvZGVzID0ge307IC8vIEB0b2RvIGltcGxlbWVudCB0aGlzIG9uY2UgbmVlZGVkXG5cbmNsYXNzIFN5c3RlbUVycm9yIGV4dGVuZHMgRXJyb3Ige30gLy8gVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgdGhlIGVycm9yIGNvZGVzLlxuXG5cbmZ1bmN0aW9uIEUoc3ltLCB2YWwsIGRlZiwgLi4ub3RoZXJDbGFzc2VzKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgU3lzdGVtRXJyb3IgdGhhdCBmb3JtYXRzIHRoZSBlcnJvciBtZXNzYWdlIGRpZmZlcmVudGx5XG4gIC8vIFRoZSBTeXN0ZW1FcnJvcnMgb25seSBoYXZlIFN5c3RlbUVycm9yIGFzIHRoZWlyIGJhc2UgY2xhc3Nlcy5cbiAgbWVzc2FnZXMuc2V0KHN5bSwgdmFsKTtcblxuICBpZiAoZGVmID09PSBTeXN0ZW1FcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBjb21wYXRpYmxlIFN5c3RlbUVycm9yIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gIH0gZWxzZSB7XG4gICAgZGVmID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGRlZiwgc3ltKTtcbiAgfVxuXG4gIGlmIChvdGhlckNsYXNzZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgb3RoZXJDbGFzc2VzLmZvckVhY2goY2xhenogPT4ge1xuICAgICAgZGVmW2NsYXp6Lm5hbWVdID0gbWFrZU5vZGVFcnJvcldpdGhDb2RlKGNsYXp6LCBzeW0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29kZXNbc3ltXSA9IGRlZjtcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVFcnJvcldpdGhDb2RlKEJhc2UsIGtleSkge1xuICByZXR1cm4gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBnZXRNZXNzYWdlKGtleSwgYXJncywgdGhpcyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBhZGRDb2RlVG9OYW1lKHRoaXMsIHN1cGVyLm5hbWUsIGtleSk7XG4gICAgfVxuXG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cblxuICAgIHNldCBjb2RlKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske2tleX1dOiAke3RoaXMubWVzc2FnZX1gO1xuICAgIH1cblxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNZXNzYWdlKGtleSwgYXJncywgc2VsZikge1xuICBjb25zdCBtc2cgPSBtZXNzYWdlcy5nZXQoa2V5KTtcbiAgLypcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgaWYgKGFzc2VydCA9PT0gdW5kZWZpbmVkKSB7XG4gIFx0YXNzZXJ0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hc3NlcnQnKTtcbiAgfVxuICAqL1xuXG4gIGlmICh0eXBlb2YgbXNnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXNzZXJ0KG1zZy5sZW5ndGggPD0gYXJncy5sZW5ndGgsIC8vIERlZmF1bHQgb3B0aW9ucyBkbyBub3QgY291bnQuXG4gICAgYENvZGU6ICR7a2V5fTsgVGhlIHByb3ZpZGVkIGFyZ3VtZW50cyBsZW5ndGggKCR7YXJncy5sZW5ndGh9KSBkb2VzIG5vdCBgICsgYG1hdGNoIHRoZSByZXF1aXJlZCBvbmVzICgke21zZy5sZW5ndGh9KS5gKTtcbiAgICByZXR1cm4gbXNnLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgY29uc3QgZXhwZWN0ZWRMZW5ndGggPSAobXNnLm1hdGNoKC8lW2RmaWpvT3NdL2cpIHx8IFtdKS5sZW5ndGg7XG4gIGFzc2VydChleHBlY3RlZExlbmd0aCA9PT0gYXJncy5sZW5ndGgsIGBDb2RlOiAke2tleX07IFRoZSBwcm92aWRlZCBhcmd1bWVudHMgbGVuZ3RoICgke2FyZ3MubGVuZ3RofSkgZG9lcyBub3QgYCArIGBtYXRjaCB0aGUgcmVxdWlyZWQgb25lcyAoJHtleHBlY3RlZExlbmd0aH0pLmApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtc2c7XG4gIH1cblxuICBhcmdzLnVuc2hpZnQobXNnKTtcbiAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBhcmdzKTsgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgLy8gcmV0dXJuIGxhenlJbnRlcm5hbFV0aWxJbnNwZWN0KCkuZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBhZGRDb2RlVG9OYW1lKGVyciwgbmFtZSwgY29kZSkge1xuICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gIGVyci5uYW1lID0gYCR7bmFtZX0gWyR7Y29kZX1dYDsgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgLy8gQGZpeG1lOiBUaGlzIG9ubHkgd29ya3Mgb24gVjgvQW5kcm9pZCwgaU9TL0pTQyBoYXMgYSBkaWZmZXJlbnQgRXJyb3Igc3RydWN0dXJlLlxuICAvLyBzaG91bGQgd2UgdHJ5IHRvIG1ha2UgZXJyb3JzIGJlaGF2ZSB0aGUgc2FtZSBhY3Jvc3MgcGxhdGZvcm1zP1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgZXJyLnN0YWNrOyAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG5cbiAgaWYgKG5hbWUgPT09ICdTeXN0ZW1FcnJvcicpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBlcnIubmFtZTtcbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLCAvLyBVc2luZyBhIGRlZmF1bHQgYXJndW1lbnQgaGVyZSBpcyBpbXBvcnRhbnQgc28gdGhlIGFyZ3VtZW50IGlzIG5vdCBjb3VudGVkXG4vLyB0b3dhcmRzIGBGdW5jdGlvbiNsZW5ndGhgLlxuKG5hbWUgPSB1bmRlZmluZWQpID0+IHtcbiAgaWYgKG5hbWUpIHtcbiAgICByZXR1cm4gYFwiJHtuYW1lfVwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2A7XG4gIH1cblxuICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnO1xufSwgUmFuZ2VFcnJvcik7XG5FKCdFUlJfSU5URVJOQUxfQVNTRVJUSU9OJywgbWVzc2FnZSA9PiB7XG4gIGNvbnN0IHN1ZmZpeCA9ICdUaGlzIGlzIGNhdXNlZCBieSBlaXRoZXIgYSBidWcgaW4gVGl0YW5pdW0gJyArICdvciBpbmNvcnJlY3QgdXNhZ2Ugb2YgVGl0YW5pdW0gaW50ZXJuYWxzLlxcbicgKyAnUGxlYXNlIG9wZW4gYW4gaXNzdWUgd2l0aCB0aGlzIHN0YWNrIHRyYWNlIGF0ICcgKyAnaHR0cHM6Ly9qaXJhLmFwcGNlbGVyYXRvci5vcmdcXG4nO1xuICByZXR1cm4gbWVzc2FnZSA9PT0gdW5kZWZpbmVkID8gc3VmZml4IDogYCR7bWVzc2FnZX1cXG4ke3N1ZmZpeH1gO1xufSwgRXJyb3IpO1xuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLCAobmFtZSwgZXhwZWN0ZWQsIGFjdHVhbCkgPT4ge1xuICBhc3NlcnQodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnLCAnXFwnbmFtZVxcJyBtdXN0IGJlIGEgc3RyaW5nJyk7IC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG5cbiAgbGV0IGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgZXhwZWN0ZWQuc3RhcnRzV2l0aCgnbm90ICcpKSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5yZXBsYWNlKC9ebm90IC8sICcnKTtcbiAgfSBlbHNlIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3QgYmUnO1xuICB9XG5cbiAgbGV0IG1zZztcblxuICBpZiAobmFtZS5lbmRzV2l0aCgnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gYFRoZSAke25hbWV9ICR7ZGV0ZXJtaW5lcn0gJHtvbmVPZihleHBlY3RlZCwgJ3R5cGUnKX1gO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHR5cGUgPSBuYW1lLmluY2x1ZGVzKCcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSAke29uZU9mKGV4cGVjdGVkLCAndHlwZScpfWA7XG4gIH0gLy8gVE9ETyhCcmlkZ2VBUik6IEltcHJvdmUgdGhlIG91dHB1dCBieSBzaG93aW5nIGBudWxsYCBhbmQgc2ltaWxhci5cblxuXG4gIG1zZyArPSBgLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmxldCBtYXhTdGFja19FcnJvck5hbWU7XG5sZXQgbWF4U3RhY2tfRXJyb3JNZXNzYWdlO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYGVyci5uYW1lYCBhbmQgYGVyci5tZXNzYWdlYCBhcmUgZXF1YWwgdG8gZW5naW5lLXNwZWNpZmljXG4gKiB2YWx1ZXMgaW5kaWNhdGluZyBtYXggY2FsbCBzdGFjayBzaXplIGhhcyBiZWVuIGV4Y2VlZGVkLlxuICogXCJNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiIGluIFY4LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzU3RhY2tPdmVyZmxvd0Vycm9yKGVycikge1xuICBpZiAobWF4U3RhY2tfRXJyb3JNZXNzYWdlID09PSB1bmRlZmluZWQpIHtcbiAgICB0cnkge1xuICAgICAgZnVuY3Rpb24gb3ZlcmZsb3dTdGFjaygpIHtcbiAgICAgICAgb3ZlcmZsb3dTdGFjaygpO1xuICAgICAgfVxuXG4gICAgICBvdmVyZmxvd1N0YWNrKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbWF4U3RhY2tfRXJyb3JNZXNzYWdlID0gZS5tZXNzYWdlO1xuICAgICAgbWF4U3RhY2tfRXJyb3JOYW1lID0gZS5uYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnIubmFtZSA9PT0gbWF4U3RhY2tfRXJyb3JOYW1lICYmIGVyci5tZXNzYWdlID09PSBtYXhTdGFja19FcnJvck1lc3NhZ2U7XG59XG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBhc3NlcnQodHlwZW9mIHRoaW5nID09PSAnc3RyaW5nJywgJ2B0aGluZ2AgaGFzIHRvIGJlIG9mIHR5cGUgc3RyaW5nJyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpKSB7XG4gICAgY29uc3QgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGFzc2VydChsZW4gPiAwLCAnQXQgbGVhc3Qgb25lIGV4cGVjdGVkIHZhbHVlIG5lZWRzIHRvIGJlIHNwZWNpZmllZCcpO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGkgPT4gU3RyaW5nKGkpKTtcblxuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICByZXR1cm4gYG9uZSBvZiAke3RoaW5nfSAke2V4cGVjdGVkLnNsaWNlKDAsIGxlbiAtIDEpLmpvaW4oJywgJyl9LCBvciBgICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBgb25lIG9mICR7dGhpbmd9ICR7ZXhwZWN0ZWRbMF19IG9yICR7ZXhwZWN0ZWRbMV19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGBvZiAke3RoaW5nfSAke2V4cGVjdGVkWzBdfWA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgb2YgJHt0aGluZ30gJHtTdHJpbmcoZXhwZWN0ZWQpfWA7XG4gIH1cbn1cblxuY2xhc3MgRmFzdEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXkge31cbi8qKlxuICogbG9vcCBvdmVyIGlucHV0LCBldmVyeSAyIGNoYXJhY3RlcnMsIHBhcnNlIGFzIGFuIGludFxuICogYmFzaWNhbGx5IGVhY2ggdHdvIGNoYXJhY3RlcnMgYXJlIGEgXCJieXRlXCIgb3IgYW4gOC1iaXQgdWludFxuICogd2UgYXBwZW5kIHRoZW0gYWxsIHRvZ2V0aGVyIHRvIGZvcm0gYSBzaW5nbGUgYnVmZmVyIGhvbGRpbmcgYWxsIHRoZSB2YWx1ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBzdHJpbmcgd2UncmUgZW5jb2RpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7aW50ZWdlcltdfSBhcnJheSBvZiBlbmNvZGVkIGJ5dGVzXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nVG9IZXhCeXRlcyh2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGggLyAyO1xuICBjb25zdCBieXRlQXJyYXkgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obnVtZXJpY1ZhbHVlKSkge1xuICAgICAgLy8gZHJvcCBiYWQgaGV4IGNoYXJhY3RlcnNcbiAgICAgIGJ5dGVBcnJheS5wdXNoKG51bWVyaWNWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuLy8gYXMgYSByZXN1bHQgaXQgaXMgKm11Y2gqIHNsb3dlciB0byByZWFkL3dyaXRlIHZhbHVlc1xuLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIGFjcm9zcyB0aGUgSlMvTmF0aXZlIGJvdW5kYXJ5IHBlci1ieXRlIVxuLy8gV2UgYWxzbyBuZWVkIHRvIHVzZSBhIFByb3h5IHRvIGhhbmRsZSBpbnRlcmNlcHRpbmcgc2V0L2dldCBvZiBpbmRpY2VzIHRvIHJlZGlyZWN0IHRvIHRoZSB1bmRlcmx5aW5nIFRpLkJ1ZmZlclxuXG5jbGFzcyBTbG93QnVmZmVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyLlxuICAgKlxuICAgKiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoaXMgbW9kdWxlIHRvZ2V0aGVyIHdpdGggYG5ld0J1ZmZlcmAgdG9cbiAgICogY3JlYXRlIGEgbmV3IEJ1ZmZlciBpbnN0YW5jZSB3cmFwcGluZyBhIFRpLkJ1ZmZlci5cbiAgICpcbiAgICogQWxzbyBzdXBwb3J0cyB0aGUgZGVwcmVjYXRlZCBCdWZmZXIoKSBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIHNhZmVcbiAgICogdG8gdXNlIG91dHNpZGUgb2YgdGhpcyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VGkuQnVmZmVyfSB0aUJ1ZmZlciB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gW3N0YXJ0PTBdIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkvYnVmZmVyIHRvIHdyYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRpQnVmZmVyLCBzdGFydCA9IDAsIGxlbmd0aCA9IHRpQnVmZmVyLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgYnl0ZU9mZnNldDoge1xuICAgICAgICB2YWx1ZTogc3RhcnRcbiAgICAgIH0sXG4gICAgICBsZW5ndGg6IHtcbiAgICAgICAgdmFsdWU6IGxlbmd0aFxuICAgICAgfSxcbiAgICAgIF90aUJ1ZmZlcjoge1xuICAgICAgICB2YWx1ZTogdGlCdWZmZXJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogV3JhcHMgY3JlYXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UgaW5zaWRlIGEgUHJveHkgc28gd2UgY2FuIGhhbmRsZSBhcnJheSBpbmRleCBhY2Nlc3NcbiAgICogQHBhcmFtIHtUaS5CdWZmZXJ9IHRpQnVmZmVyIHRoZSB1bmRlcmx5aW5nIGRhdGEvYnl0ZXNcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gc3RhcnQgb2Zmc2V0IG9mIGFycmF5L2J1ZmZlclxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICAgKiBAcmV0dXJucyB7QnVmZmVyfSB3cmFwcGVkIGluc2lkZSBhIFByb3h5XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21UaUJ1ZmZlcih0aUJ1ZmZlciwgc3RhcnQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJveHkobmV3IFNsb3dCdWZmZXIodGlCdWZmZXIsIHN0YXJ0LCBsZW5ndGgpLCBhcnJheUluZGV4SGFuZGxlcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5ldy1idWZmZXJcbiAgfVxuXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cblxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgIGNvbnN0IGJsb2IgPSBUaS5VdGlscy5iYXNlNjRkZWNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgYmxvYlN0cmVhbSA9IFRpLlN0cmVhbS5jcmVhdGVTdHJlYW0oe1xuICAgICAgICBzb3VyY2U6IGJsb2IsXG4gICAgICAgIG1vZGU6IFRpLlN0cmVhbS5NT0RFX1JFQURcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYnVmZmVyID0gVGkuU3RyZWFtLnJlYWRBbGwoYmxvYlN0cmVhbSk7XG4gICAgICBibG9iU3RyZWFtLmNsb3NlKCk7XG4gICAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIoYnVmZmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgICBjb25zdCBieXRlcyA9IHN0cmluZ1RvSGV4Qnl0ZXModmFsdWUpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRpQnVmZmVyW2ldID0gYnl0ZXNbaV0gJiAweEZGOyAvLyBtYXNrIHRvIG9uZSBieXRlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTbG93QnVmZmVyLmZyb21UaUJ1ZmZlcih0aUJ1ZmZlcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGlCdWZmZXIgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdHlwZTogZ2V0VGlDb2RlY0NoYXJzZXQoZW5jb2RpbmcpXG4gICAgfSk7XG4gICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHRpQnVmZmVyKTtcbiAgfSAvLyBUaGlzIGlzIGEgbWV0aG9kIHdlIHNob3VsZCBnZXQgYnkgZXh0ZW5kaW5nIFVpbnQ4QXJyYXksIHNvIHJlYWxseSBzaG91bGQgb25seSBiZSBvdmVycmlkZW4gb24gYSBcIlNsb3dCdWZmZXJcIiB0aGF0IHdyYXBzIFRpLkJ1ZmZlclxuXG5cbiAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAvLyBHZXQgdGhlIHNsaWNlIG9mIHRoZSBhcnJheSBmcm9tIGJ5dGVPZmZzZXQgdG8gbGVuZ3RoXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh0aGlzKS5idWZmZXI7XG4gIH1cblxuICBfc2xpY2Uob2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gU2xvd0J1ZmZlci5mcm9tVGlCdWZmZXIodGhpcy5fdGlCdWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIF9maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgYnVmVG9GaWxsV2l0aCA9IFNsb3dCdWZmZXIuZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuXG4gICAgICBpZiAoZmlsbEJ1Zkxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHZhbGlkIGZpbGwgZGF0YScpO1xuICAgICAgfSAvLyBJZiB0aGUgYnVmZmVyIGxlbmd0aCA9PT0gMSwgd2UgY2FuIGp1c3QgZG8gdGhpcy5fdGlCdWZmZXIuZmlsbCh2YWx1ZSwgb2Zmc2V0LCBlbmQpO1xuXG5cbiAgICAgIGlmIChmaWxsQnVmTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwoYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gLy8gbXVsdGlwbGUgYnl0ZSBmaWxsIVxuXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuZCAtIG9mZnNldDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZSAob24gYHRoaXNgLCBub3Qgb24gdGhlIGJ1ZmZlciB3ZSBqdXN0IGNyZWF0ZWQpP1xuICAgICAgICBjb25zdCBmaWxsQ2hhciA9IGJ1ZlRvRmlsbFdpdGguX3RpQnVmZmVyW2kgJSBmaWxsQnVmTGVuZ3RoXTtcbiAgICAgICAgdGhpcy5fdGlCdWZmZXJbaSArIG9mZnNldF0gPSBmaWxsQ2hhcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSAvLyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgKG9yIGEgYnVmZmVyIHdpdGggYSBzaW5nbGUgYnl0ZSkgd2UgY2FuIHVzZSB0aUJ1ZmZlci5maWxsKCk7XG5cblxuICAgIHRoaXMuX3RpQnVmZmVyLmZpbGwodmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfVxuXG4gIGdldEFkanVzdGVkSW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0QWRqdXN0ZWRJbmRleCh0aGlzLCBpbmRleCk7XG4gIH1cblxuICBzZXRBZGp1c3RlZEluZGV4KGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiBzZXRBZGp1c3RlZEluZGV4KHRoaXMsIGluZGV4LCB2YWx1ZSk7XG4gIH0gLy8gVGhpcyBpcyBhIG1ldGhvZCB3ZSBzaG91bGQgZ2V0IGJ5IGV4dGVuZGluZyBVaW50OEFycmF5LCBzbyByZWFsbHkgc2hvdWxkIG9ubHkgYmUgb3ZlcnJpZGVuIG9uIGEgXCJTbG93QnVmZmVyXCIgdGhhdCB3cmFwcyBUaS5CdWZmZXJcblxuXG4gIHNldChzcmMsIG9mZnNldCA9IDApIHtcbiAgICBjb25zdCBudW1CeXRlcyA9IHNyYy5sZW5ndGg7IC8vIGNoZWNrIHNyYy5sZW5ndGggKyBvZmZzZXQgZG9lc24ndCBnbyBiZXlvbmQgb3VyIGxlbmd0aCFcbiAgICAvLyBGSVhNRTogUmUtZW5hYmxlXG4gICAgLy8gY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBudW1CeXRlcyk7XG4gICAgLy8gY29weSBzcmMgdmFsdWVzIGludG8gdGhpcyBidWZmZXIgc3RhcnRpbmcgYXQgb2Zmc2V0XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJ5dGVzOyBpKyspIHtcbiAgICAgIHNldEFkanVzdGVkSW5kZXgodGhpcywgaSArIG9mZnNldCwgc3JjW2ldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgY29udmVyc2lvbiBtZXRob2QgZm9yIGludGVyYWN0aW5nIHdpdGggVGkgQVBJcyB0aGF0IHJlcXVpcmUgYSBUaS5CdWZmZXJcbiAgICogQHJldHVybnMge1RpLkJ1ZmZlcn0gdGhlIHVuZGVybHlpbmcgVGkuQnVmZmVyIGJhY2tpbmcgdGhpcyBCdWZmZXIgaW5zdGFuY2VcbiAgICovXG5cblxuICB0b1RpQnVmZmVyKCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdGhpcy5fdGlCdWZmZXIubGVuZ3RoICYmIHRoaXMuYnl0ZU9mZnNldCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpQnVmZmVyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90aUJ1ZmZlci5jbG9uZSh0aGlzLmJ5dGVPZmZzZXQsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG59IC8vIFVzZSBhIFByb3h5IHRvIGhhY2sgYXJyYXkgc3R5bGUgaW5kZXggYWNjZXNzb3JzXG5cbmNvbnN0IGFycmF5SW5kZXhIYW5kbGVyID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wS2V5LCByZWNlaXZlcikge1xuICAgIGlmICh0eXBlb2YgcHJvcEtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihwcm9wS2V5KTtcblxuICAgICAgaWYgKE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gaXNCdWZmZXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BLZXksIHJlY2VpdmVyKTtcbiAgfSxcblxuICBzZXQodGFyZ2V0LCBwcm9wS2V5LCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHByb3BLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBudW0gPSBOdW1iZXIocHJvcEtleSk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gICAgICAgIHNldEFkanVzdGVkSW5kZXgodGFyZ2V0LCBudW0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcEtleSwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgfSxcblxuICBoYXModGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihrZXkpO1xuXG4gICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSkge1xuICAgICAgICAvLyBlbnN1cmUgaXQncyBhIHBvc2l0aXZlIFwic2FmZVwiIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgYnVmZmVyXG4gICAgICAgIHJldHVybiBudW0gPj0gMCAmJiBudW0gPCB0YXJnZXQuX3RpQnVmZmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5IGluIHRhcmdldDtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBnZXRBZGp1c3RlZEluZGV4KGJ1ZiwgaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gLy8gV3JhcHBpbmcgVGkuQnVmZmVyP1xuXG5cbiAgaWYgKGJ1Zi5fdGlCdWZmZXIpIHtcbiAgICBpZiAoaW5kZXggPj0gYnVmLl90aUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1Zi5fdGlCdWZmZXJbaW5kZXggKyBidWYuYnl0ZU9mZnNldF07XG4gIH0gLy8gUmF3IFR5cGVkQXJyYXkvQXJyYXlCdWZmZXJcbiAgLy8gRklYTUU6IGRvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgYnl0ZU9mZnNldCBoZXJlP1xuXG5cbiAgcmV0dXJuIGJ1ZltpbmRleF07XG59XG5cbmZ1bmN0aW9uIHNldEFkanVzdGVkSW5kZXgoYnVmLCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBXcmFwcGluZyBUaS5CdWZmZXI/XG5cblxuICBpZiAoYnVmLl90aUJ1ZmZlcikge1xuICAgIGlmIChpbmRleCA8IGJ1Zi5fdGlCdWZmZXIubGVuZ3RoKSB7XG4gICAgICBidWYuX3RpQnVmZmVyW2luZGV4ICsgYnVmLmJ5dGVPZmZzZXRdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFJhdyBUeXBlZEFycmF5L0FycmF5QnVmZmVyXG4gIC8vIEZJWE1FOiBkbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZT9cblxuXG4gIGJ1ZltpbmRleF0gPSB2YWx1ZTtcbn0gLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmZmVyc19hbmRfY2hhcmFjdGVyX2VuY29kaW5nc1xuXG5cbmNvbnN0IFRJX0NPREVDX01BUCA9IG5ldyBNYXAoKTtcblRJX0NPREVDX01BUC5zZXQoJ3V0Zi04JywgVGkuQ29kZWMuQ0hBUlNFVF9VVEY4KTtcblRJX0NPREVDX01BUC5zZXQoJ3V0ZjgnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjgpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmLTE2bGUnLCBUaS5Db2RlYy5DSEFSU0VUX1VURjE2TEUpO1xuVElfQ09ERUNfTUFQLnNldCgndXRmMTZsZScsIFRpLkNvZGVjLkNIQVJTRVRfVVRGMTZMRSk7XG5USV9DT0RFQ19NQVAuc2V0KCd1Y3MyJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ3Vjcy0yJywgVGkuQ29kZWMuQ0hBUlNFVF9VVEYxNkxFKTtcblRJX0NPREVDX01BUC5zZXQoJ2xhdGluMScsIFRpLkNvZGVjLkNIQVJTRVRfSVNPX0xBVElOXzEpO1xuVElfQ09ERUNfTUFQLnNldCgnYmluYXJ5JywgVGkuQ29kZWMuQ0hBUlNFVF9JU09fTEFUSU5fMSk7XG5USV9DT0RFQ19NQVAuc2V0KCdhc2NpaScsIFRpLkNvZGVjLkNIQVJTRVRfQVNDSUkpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgZGVzaXJlZCBlbmNvZGluZyBuYW1lXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gVGkuQ29kZWMgY29uc3RhbnQgdGhhdCBtYXBzIHRvIHRoZSBlbmNvZGluZ1xuICovXG5cbmZ1bmN0aW9uIGdldFRpQ29kZWNDaGFyc2V0KGVuY29kaW5nKSB7XG4gIHJldHVybiBUSV9DT0RFQ19NQVAuZ2V0KGVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIG9mIEJ1ZmZlciB1c2VzIGEgVGkuQnVmZmVyIGludGVybmFsbHkgdG8gYmFjayBpdC5cbiAqIFRoaXMgaXMgbGlrbGV5IGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBzbG93ZXIgdGhhbiB1c2luZyBhIHZhcmlhbnQgdGhhdCBleHRlbmRzIFVpbnQ4QXJyYXkhXG4gKiBJIHRoaW5rIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IHdyYXBwaW5nIGEgVGkuQnVmZmVyLCBpdCBtYXkgYmUgYmV0dGVyIHRvIGhhdmUgdHdvIGltcGxlbWVudGF0aW9uc1xuICogYW5kLCBsaWtlIGJyb3dzZXJpZnksIGp1c3QgZXh0ZW5kIFVpbnQ4QXJyYXkgZm9yIGFueSBCdWZmZXJzIHdlIG5lZWQgdG8gcmVhZC93cml0ZSBhIGxvdFxuICogYW5kIHRoZW4gYWRkIGEgc2ltcGxlIGNvbnZlcnNpb24gbWV0aG9kIHRvIHR1cm4gaXQgaW50byBhIFRpLkJ1ZmZlciB3aGVuIG5lZWRlZC5cbiAqXG4gKiBUaGUgVGkuQnVmZmVyIGltcGwgaGFzIHRvIGdvIHRocm91Z2ggdGhlIGJpbmRpbmcgbGF5ZXIgZm9yIHJlYWRpbmcvd3JpdGluZyBldmVyeSBieXRlLlxuICogSWYgd2UgYW50aWNpcGF0ZSB0aGUgQnVmZmVyIHN0YXlpbmcgb24gdGhlIEpTIHNpZGUsIEknbSB3aWxsaW5nIHRvIGJldCB0aGF0IHRoZSBVaW50OEFycmF5XG4gKiB0aGUgSlMgZW5naW5lIHByb3ZpZGVzIHdvdWxkIGJlICp3YXkqIGZhc3Rlci5cbiAqXG4gKiBBbHNvIG5vdGUgdGhhdCBib3RoIFRpLkJ1ZmZlciBhbmQgTm9kZSdzIEJ1ZmZlciB3ZXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBKUyBlbmdpbmVzIGhhZCB0eXBlZCBhcnJheXNcbiAqIChhbmQgVWludDhBcnJheSBpbiBwYXJ0aWN1bGFyKSBhcyBhIG1lYW5zIG9mIGVuY2Fwc3VsYXRpbmcgYSBieXRlIGFycmF5LiBXZSBzaG91bGQgY29uc2lkZXIgYWNjZXB0aW5nXG4gKiBhIFVpbnQ4QXJyYXkgaW4gYW55IG9mIG91ciBBUElzIHRoYXQgdGFrZSBhIFRpLkJ1ZmZlciBhbmQgZXZlbnR1YWxseSBkZXByZWNhdGluZy9yZW1vdmluZyBUaS5CdWZmZXIuXG4gKi9cbmNvbnN0IHtcbiAgQUxMX1BST1BFUlRJRVM6IEFMTF9QUk9QRVJUSUVTJDEsXG4gIE9OTFlfRU5VTUVSQUJMRTogT05MWV9FTlVNRVJBQkxFJDFcbn0gPSBwcm9wZXJ0eUZpbHRlcjtcbmNvbnN0IFZBTElEX0VOQ09ESU5HUyA9IFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnbGF0aW4xJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJ107IC8vIFVzZWQgdG8gY2hlYXQgZm9yIHJlYWQvd3JpdGVzIG9mIGRvdWJsZXNcblxuY29uc3QgZG91YmxlQXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KDEpO1xuY29uc3QgdWludDhEb3VibGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGRvdWJsZUFycmF5LmJ1ZmZlcik7IC8vIFVzZWQgdG8gY2hlYXQgdG8gcmVhZC93cml0ZSBmbG9hdHNcblxuY29uc3QgZmxvYXRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG5jb25zdCB1aW50OEZsb2F0QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdEFycmF5LmJ1ZmZlcik7IC8vIE5vZGUuanMgZG9lcyBzb21lIHZlcnkgd2VpcmQgc3R1ZmYgaGVyZVxuXG5GYXN0QnVmZmVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJ1ZmZlciQxOyAvLyBuZXcgRmFzdEJ1ZmZlcigpIGNhbGxzIEJ1ZmZlciBmdW5jdGlvbj9cblxuQnVmZmVyJDEucHJvdG90eXBlID0gRmFzdEJ1ZmZlci5wcm90b3R5cGU7IC8vIFRoZW4gaXQgaGlqYWNrcyBCdWZmZXIncyBwcm90b3R5cGUgdG8gcG9pbnQgYXQgRmFzdEJ1ZmZlcidzPyFcbi8vIERvZXMgdGhpcyBlZmZlY3RpdmVseSBtZWFuIEJ1ZmZlciBleHRlbmRzIFVpbnQ4QXJyYXksIGJlY2F1c2UgRmFzdEJ1ZmZlciBkaWQ/IFRoaXMgZmFpbHMgZm9yIG1lXG4vLyBIb3cgdGhlIGhlbGwgY2FuIHdlIG1ha2UgaXQgaGFwcHk/IFdlIHJlYWxseSB3YW50IHRvIGV4dGVuZCBVaW50OEFycmF5IGlmIHdlIGNhblxuLy8gYWRkQnVmZmVyUHJvdG90eXBlTWV0aG9kcyhCdWZmZXIucHJvdG90eXBlKTsgLy8gSGVyZSdzIHdoZXJlIGl0IGhhbmdzIHNvbWUgb2YgdGhlIG1ldGhvZHNcblxuQnVmZmVyJDEucG9vbFNpemUgPSA4MTkyO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlci5cbiAqXG4gKiBQcmltYXJpbHkgdXNlZCBpbnRlcm5hbGx5IGluIHRoaXMgbW9kdWxlIHRvZ2V0aGVyIHdpdGggYG5ld0J1ZmZlcmAgdG9cbiAqIGNyZWF0ZSBhIG5ldyBCdWZmZXIgaW5zdGFuY2Ugd3JhcHBpbmcgYSBUaS5CdWZmZXIuXG4gKlxuICogQWxzbyBzdXBwb3J0cyB0aGUgZGVwcmVjYXRlZCBCdWZmZXIoKSBjb25zdHJ1Y3RvcnMgd2hpY2ggYXJlIHNhZmVcbiAqIHRvIHVzZSBvdXRzaWRlIG9mIHRoaXMgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcltdfEJ1ZmZlcnxpbnRlZ2VyfHN0cmluZ3xUaS5CdWZmZXJ9IGFyZyB0aGUgdW5kZXJseWluZyBkYXRhL2J5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBlbmNvZGluZ09yT2Zmc2V0IGVuY29kaW5nIG9mIHRoZSBzdHJpbmcsIG9yIHN0YXJ0IG9mZnNldCBvZiBhcnJheS9idWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVuZ3RoIGxlbmd0aCBvZiB0aGUgdW5kZXJseWluZyBhcnJheS9idWZmZXIgdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIkMShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgfHwgYXJnLmFwaU5hbWUgIT09ICdUaS5CdWZmZXInKSB7XG4gICAgc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpO1xuXG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBcInN0cmluZ1wiLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFyZ31gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jKGFyZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlciQxLmZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpO1xuICB9IC8vIFRoZSBzbG93IGNhc2UgLSB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlclxuXG5cbiAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyW118QnVmZmVyfHN0cmluZ30gdmFsdWUgdmFsdWUgd2UncmUgd3JhcHBpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2VuY29kaW5nT3JPZmZzZXRdXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3QgdmFsdWVUeXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmICh2YWx1ZVR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpO1xuICB9IGVsc2UgaWYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlciQxLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZyb21CdWZmZXIodmFsdWUpO1xuICAgIH0gLy8gV2Ugd2FudCB0byBsaW1pdCB0aGUgdXNlIG9mIFNsb3dCdWZmZXJzIHRvIG9ubHkgd2hlbiB3ZSdyZSB3cmFwcGluZyBhIFRpLkJ1ZmZlciwgaG9wZWZ1bGx5IVxuXG5cbiAgICBpZiAodmFsdWUuYXBpTmFtZSAmJiB2YWx1ZS5hcGlOYW1lID09PSAnVGkuQnVmZmVyJykge1xuICAgICAgcmV0dXJuIFNsb3dCdWZmZXIuZnJvbVRpQnVmZmVyKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXFwndmFsdWVcXCcgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZTogXFwnc3RyaW5nXFwnLCBcXCdBcnJheVxcJywgXFwnQnVmZmVyXFwnLCBcXCdUaS5CdWZmZXJcXCcnKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IG9iaiBBcnJheUJ1ZmZlciB0byB3cmFwXG4gKiBAcGFyYW0ge251bWJlcn0gW2J5dGVPZmZzZXQ9MF0gYnl0ZSBvZmZzdGUgdG8gYmVnaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBsZW5ndGggdG8gd3JhcFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb252ZXJ0IGJ5dGVPZmZzZXQgdG8gaW50ZWdlclxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0O1xuXG4gICAgaWYgKE51bWJlci5pc05hTihieXRlT2Zmc2V0KSkge1xuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0O1xuXG4gIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygnb2Zmc2V0Jyk7XG4gIH1cblxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSBtYXhMZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udmVydCBsZW5ndGggdG8gbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gICAgbGVuZ3RoID0gK2xlbmd0aDtcblxuICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBjb2Rlcy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoJ2xlbmd0aCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihvYmosIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB2YWx1ZSB0byB3cmFwXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gY2hhcmFjdGVyIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVua25vd24gZW5jb2Rpbmc6ICR7ZW5jb2Rpbmd9YCk7XG4gIH1cblxuICBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0Jykge1xuICAgIGNvbnN0IGJsb2IgPSBUaS5VdGlscy5iYXNlNjRkZWNvZGUodmFsdWUpO1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihibG9iLnRvQXJyYXlCdWZmZXIoKSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheShzdHJpbmdUb0hleEJ5dGVzKHZhbHVlKSk7XG4gIH0gLy8gQ29udmVydCB0aGUgU2xvd0J1ZmZlciB0byBhIGZhc3QgYnVmZmVyIGJ5IGp1c3QgY29weWluZyBieXRlcyByZWN1cnNpdmVseSBoZXJlXG5cblxuICByZXR1cm4gZnJvbUJ1ZmZlcihTbG93QnVmZmVyLmZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcltdfFVpbnQ4QXJyYXl8YXJyYXl9IHZhbHVlIHZhbHVlcyB0byB3cmFwXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbUFycmF5KHZhbHVlKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7XG4gIH1cblxuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIodmFsdWUpO1xufVxuLyoqXG4gKiBJZGVhbGx5IHRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHdlJ3JlIGNvcHlpbmcgYSBTbG93QnVmZmVyIGludG8gYSBuZXcgRmFzdEJ1ZmZlclxuICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIGJ1ZmZlciB0byBjb3B5XG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuZnVuY3Rpb24gZnJvbUJ1ZmZlcih2YWx1ZSkge1xuICBjb25zdCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcigpO1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyJDEuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFsdWUuY29weShidWZmZXIsIDAsIDAsIGxlbmd0aCk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIkMSwgVWludDhBcnJheSk7IC8vIFdoYXQgaXMgdGhpcyBkb2luZz8hIE1ha2luZyBCdWZmZXIucHJvdG90eXBlIHBvaW50IGF0IFVpbnQ4QXJyYXkgbm93XG5cbi8qKlxuICogMCBpcyByZXR1cm5lZCBpZiB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgYnVmXG4gKiAxIGlzIHJldHVybmVkIGlmIHRhcmdldCBzaG91bGQgY29tZSBiZWZvcmUgYnVmIHdoZW4gc29ydGVkLlxuICogLTEgaXMgcmV0dXJuZWQgaWYgdGFyZ2V0IHNob3VsZCBjb21lIGFmdGVyIGJ1ZiB3aGVuIHNvcnRlZC5cbiAqIEBwYXJhbSB7QnVmZmVyfSB0YXJnZXQgQnVmZmVyIHRvIGNvbXBhcmUgYWdhaW5zdFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gaW5kZXggdG8gc3RhcnQgaW4gdGFyZ2V0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0YXJnZXRFbmQ9dGFyZ2V0Lmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRhcmdldFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlU3RhcnQ9MF0gaW5kZXggdG8gc3RhcnQgaW4gdGhpcyBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gaW5kZXggdG8gZW5kIGluIHRoaXMgQnVmZmVyXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgaWYgKCFCdWZmZXIkMS5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9XG5cbiAgaWYgKHRhcmdldFN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0YXJnZXRTdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc291cmNlU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHNvdXJjZVN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmICh0YXJnZXRFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldEVuZCA9IHRhcmdldC5sZW5ndGg7XG4gIH1cblxuICBpZiAoc291cmNlRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2VFbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSAvLyBFUlJfT1VUX09GX1JBTkdFIGlzIHRocm93biBpZiB0YXJnZXRTdGFydCA8IDAsIHNvdXJjZVN0YXJ0IDwgMCwgdGFyZ2V0RW5kID4gdGFyZ2V0LmJ5dGVMZW5ndGgsIG9yIHNvdXJjZUVuZCA+IHNvdXJjZS5ieXRlTGVuZ3RoXG5cblxuICBpZiAodGFyZ2V0U3RhcnQgPCAwIHx8IHNvdXJjZVN0YXJ0IDwgMCB8fCB0YXJnZXRFbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHNvdXJjZUVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpOyAvLyBGSVhNRTogc2V0IFwiY29kZVwiIHRvIEVSUl9JTkRFWF9PVVRfT0ZfUkFOR0VcbiAgfSAvLyBVc2Ugc2xpY2VzIHRvIG1ha2UgdGhlIGxvb3AgZWFzaWVyXG5cblxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNsaWNlKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICBjb25zdCBzb3VyY2VMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICBjb25zdCBkZXN0ID0gdGFyZ2V0LnNsaWNlKHRhcmdldFN0YXJ0LCB0YXJnZXRFbmQpO1xuICBjb25zdCBkZXN0TGVuZ3RoID0gZGVzdC5sZW5ndGg7XG4gIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKHNvdXJjZUxlbmd0aCwgZGVzdExlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhcmdldFZhbHVlID0gZGVzdC5nZXRBZGp1c3RlZEluZGV4KGkpO1xuICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlLmdldEFkanVzdGVkSW5kZXgoaSk7XG5cbiAgICBpZiAodGFyZ2V0VmFsdWUgIT09IHNvdXJjZVZhbHVlKSB7XG4gICAgICAvLyBObyBtYXRjaCEgUmV0dXJuIDEgb3IgLTEgYmFzZWQgb24gd2hhdCBpcyBncmVhdGVyIVxuICAgICAgaWYgKHNvdXJjZVZhbHVlIDwgdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0gLy8gc29ydCBiYXNlZCBvbiBsZW5ndGghXG5cblxuICBpZiAoc291cmNlTGVuZ3RoIDwgZGVzdExlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChzb3VyY2VMZW5ndGggPiBkZXN0TGVuZ3RoKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gMDtcbn07XG4vKipcbiAqIENvcGllcyBmcm9tIHRoaXMgdG8gdGFyZ2V0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdGFyZ2V0IGRlc3RpbmF0aW9uIHdlJ3JlIGNvcHlpbmcgaW50b1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbdGFyZ2V0U3RhcnQ9MF0gc3RhcnQgaW5kZXggdG8gY29weSBpbnRvIGluIGRlc3RpbmF0aW9uIEJ1ZmZlclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc291cmNlU3RhcnQ9MF0gc3RhcnQgaW5kZXggdG8gY29weSBmcm9tIHdpdGhpbiBgdGhpc2BcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3NvdXJjZUVuZD10aGlzLmxlbmd0aF0gZW5kIGluZGV4IHRvIGNvcHkgZnJvbSB3aXRoaW4gYHRoaXNgXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIGNvcGllZFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuICBpZiAodGFyZ2V0U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRhcmdldFN0YXJ0ID0gMDtcbiAgfVxuXG4gIGlmIChzb3VyY2VTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlU3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHNvdXJjZUVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc291cmNlRW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoc291cmNlU3RhcnQgPT09IHNvdXJjZUVuZCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBUT0RPOiBjaGVjayBmb3Igb3V0IG9mIGJvdW5kcz9cblxuXG4gIGxldCBsZW5ndGggPSBzb3VyY2VFbmQgLSBzb3VyY2VTdGFydDsgLy8gQ2FwIGxlbmd0aCB0byByZW1haW5pbmcgYnl0ZXMgaW4gdGFyZ2V0IVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydDtcblxuICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgc291cmNlRW5kID0gc291cmNlU3RhcnQgKyByZW1haW5pbmc7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IC8vIERldGVybWluZSBhY3R1YWwgbnVtYmVyIG9mIGJ5dGVzIHdlJ2xsIGNvcHksIGNvbnN0cmFpbiBieSBzb3VyY2UgYnVmZmVyIGxlbmd0aCBhcyB3ZWxsIGFzIHRhcmdldCAoYWJvdmUpXG5cblxuICBsZXQgbnVtQnl0ZXMgPSBsZW5ndGg7XG4gIGNvbnN0IHNvdXJjZUxlbiA9IHRoaXMubGVuZ3RoIC0gc291cmNlU3RhcnQ7XG5cbiAgaWYgKG51bUJ5dGVzID4gc291cmNlTGVuKSB7XG4gICAgbnVtQnl0ZXMgPSBzb3VyY2VMZW47XG4gIH0gLy8gVE9ETzogaGFuZGxlIG92ZXJsYXAgd2hlbiB0YXJnZXQgPT09IHRoaXMhXG4gIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gdGFrZSB0YXJnZXQgYnl0ZU9mZnNldCBpbnRvIGFjY291bnQgaGVyZT9cblxuXG4gIGxldCBzb3VyY2UgPSB0aGlzO1xuXG4gIGlmIChzb3VyY2VTdGFydCAhPT0gMCB8fCBzb3VyY2VFbmQgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmZXIsIHRoaXMuYnl0ZU9mZnNldCArIHNvdXJjZVN0YXJ0LCBudW1CeXRlcyk7XG4gIH1cblxuICB0YXJnZXQuc2V0KHNvdXJjZSwgdGFyZ2V0U3RhcnQpO1xuICByZXR1cm4gbnVtQnl0ZXM7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGl0ZXJhdG9yIG9mIFtpbmRleCwgYnl0ZV0gcGFpcnMgZnJvbSB0aGUgY29udGVudHMgb2YgYnVmLlxuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG4vLyBUT0RPOiBJcyB0aGlzIG9ubHkgbmVjZXNzYXJ5IGZvciBTbG93QnVmZmVyP1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBidWZmZXIgPSB0aGlzO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IGVudHJ5SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IFtuZXh0SW5kZXgsIGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KG5leHRJbmRleCldLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5pdGVyYXRvcl06IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5SXRlcmF0b3I7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyQnVmZmVyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIob3RoZXJCdWZmZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpO1xuICB9XG5cbiAgaWYgKG90aGVyQnVmZmVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyQnVmZmVyKSA9PT0gMDtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVSW50OEFycmF5fGludGVnZXJ9IHZhbHVlIFRoZSB2YWx1ZSB3aXRoIHdoaWNoIHRvIGZpbGwgYGJ1ZmAuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIGZpbGwgYGJ1ZmBcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2VuZF0gV2hlcmUgdG8gc3RvcCBmaWxsaW5nIGJ1ZiAobm90IGluY2x1c2l2ZSkuIGBidWYubGVuZ3RoYCBieSBkZWZhdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGVuY29kaW5nIGZvciBgdmFsdWVgIGlmIGB2YWx1ZWAgaXMgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7dGhpc31cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgY29uc3Qgb2Zmc2V0VHlwZSA9IHR5cGVvZiBvZmZzZXQ7XG5cbiAgaWYgKG9mZnNldFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gdmFsdWUgc3VwcGxpZWRcbiAgICBvZmZzZXQgPSAwO1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9IGVsc2UgaWYgKG9mZnNldFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gdmFsdWUsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgIC8vIHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nIHN1cHBsaWVkXG4gICAgZW5jb2RpbmcgPSBlbmQ7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICB0aGlzLl9maWxsKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuY29uc3QgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkucHJvdG90eXBlKTtcbmNvbnN0IFR5cGVkQXJyYXlQcm90b19ieXRlTGVuZ3RoID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihUeXBlZEFycmF5UHJvdG90eXBlJDEsICdieXRlTGVuZ3RoJykuZ2V0O1xuY29uc3QgVHlwZWRBcnJheUZpbGwgPSBUeXBlZEFycmF5UHJvdG90eXBlJDEuZmlsbDtcblxuQnVmZmVyJDEucHJvdG90eXBlLl9maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBPT0IgY2hlY2tcbiAgICBjb25zdCBieXRlTGVuID0gVHlwZWRBcnJheVByb3RvX2J5dGVMZW5ndGguY2FsbCh0aGlzKTtcbiAgICBjb25zdCBmaWxsTGVuZ3RoID0gZW5kIC0gb2Zmc2V0O1xuXG4gICAgaWYgKG9mZnNldCA+IGVuZCB8fCBmaWxsTGVuZ3RoICsgb2Zmc2V0ID4gYnl0ZUxlbikge1xuICAgICAgdGhyb3cgbmV3IGNvZGVzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpO1xuICAgIH1cblxuICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgdmFsdWUsIG9mZnNldCwgZW5kKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBidWZUb0ZpbGxXaXRoID0gU2xvd0J1ZmZlci5mcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgY29uc3QgZmlsbEJ1Zkxlbmd0aCA9IGJ1ZlRvRmlsbFdpdGgubGVuZ3RoO1xuXG4gICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm8gdmFsaWQgZmlsbCBkYXRhJyk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGxCdWZMZW5ndGggPT09IDEpIHtcbiAgICAgIFR5cGVkQXJyYXlGaWxsLmNhbGwodGhpcywgYnVmVG9GaWxsV2l0aC5fdGlCdWZmZXJbMF0sIG9mZnNldCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gbXVsdGlwbGUgYnl0ZSBmaWxsIVxuXG5cbiAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBvZmZzZXQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIGJ5dGVPZmZzZXQgaGVyZSAob24gYHRoaXNgLCBub3Qgb24gdGhlIGJ1ZmZlciB3ZSBqdXN0IGNyZWF0ZWQpP1xuICAgICAgY29uc3QgZmlsbENoYXIgPSBidWZUb0ZpbGxXaXRoLl90aUJ1ZmZlcltpICUgZmlsbEJ1Zkxlbmd0aF07XG4gICAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIG9mZnNldCwgZmlsbENoYXIpO1xuICAgIH1cbiAgfVxufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbHVlLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfGludGVnZXJ9IHZhbHVlIFdoYXQgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtIHtpbnRlZ2VyfSBbYnl0ZU9mZnNldD0wXSBXaGVyZSB0byBiZWdpbiBzZWFyY2hpbmcgaW4gYnVmLiBJZiBuZWdhdGl2ZSwgdGhlbiBvZmZzZXQgaXMgY2FsY3VsYXRlZCBmcm9tIHRoZSBlbmQgb2YgYnVmXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gSWYgdmFsdWUgaXMgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIGVuY29kaW5nIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0cmluZyB0aGF0IHdpbGwgYmUgc2VhcmNoZWQgZm9yIGluIGJ1ZlxuICogQHJldHVybnMge2ludGVnZXJ9IFRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiB2YWx1ZSBpbiBidWYsIG9yIC0xIGlmIGJ1ZiBkb2VzIG5vdCBjb250YWluIHZhbHVlLlxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAodmFsdWUsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGVtcHR5IGJ1ZmZlcj8gY2FuJ3QgZmluZCBhbnl0aGluZyFcbiAgICByZXR1cm4gLTE7XG4gIH0gLy8gaWYgYnl0ZU9mZnNldCBpcyB1bmRlZmluZWQsIG1ha2UgaXQgMFxuXG5cbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgIGJ5dGVPZmZzZXQgPSAwO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIC8vIGlmIGl0J3MgYSBzdHJpbmcsIHRoYXQncyBhY3R1YWxseSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldDtcbiAgICBieXRlT2Zmc2V0ID0gMDtcbiAgfSAvLyBpZiB3ZSBkb24ndCBoYXZlIGFuIGVuY29kaW5nIHlldCwgdXNlIHV0ZjhcblxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAvLyBjb252ZXJ0IG5lZ2F0aXZlIGluZGljZXNcbiAgICBieXRlT2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0O1xuXG4gICAgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgICAvLyBzdGlsbCBuZWdhdGl2ZT8gc3RhcnQgYXQgMFxuICAgICAgYnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7IC8vIGNhbid0IGZpbmQgcGFzdCBlbmQgb2YgYnVmZmVyIVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB2YWx1ZSAmPSAweEZGOyAvLyBjbGFtcCB0byAyNTVcbiAgICAvLyBUaGlzIGlzIGEgc2ltcGxlciBjYXNlLCB3ZSBoYXZlIGEgc2luZ2xlIGJ5dGUgd2UgbmVlZCB0byBzZWFyY2ggZm9yXG4gICAgLy8gc28ganVzdCBsb29wIHRocm91Z2ggYW5kIHRyeSB0byBmaW5kIGl0XG5cbiAgICByZXR1cm4gaW5kZXhPZih0aGlzLCB2YWx1ZSwgYnl0ZU9mZnNldCk7XG4gIH0gLy8gY29lcmNlIGEgc3RyaW5nIHRvIGEgQnVmZmVyXG5cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmcpO1xuICB9IC8vIHZhbHVlIGlzIG5vdyBhIEJ1ZmZlci4uLlxuXG5cbiAgY29uc3QgbWF0Y2hMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xOyAvLyBuZXZlciBmaW5kIGVtcHR5IHZhbHVlIVxuICB9XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID09PSAxKSB7XG4gICAgLy8gc2ltcGxlIGNhc2UsIG1hdGNoIG9uZSBieXRlIVxuICAgIHJldHVybiBpbmRleE9mKHRoaXMsIHZhbHVlWzBdLCBieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5kZXggPSBieXRlT2Zmc2V0O1xuICBjb25zdCB0aGlzTGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKG1hdGNoTGVuZ3RoID4gdGhpc0xlbmd0aCkge1xuICAgIHJldHVybiAtMTsgLy8gY2FuJ3QgbWF0Y2ggaWYgdGhlIHZhbHVlIGlzIGxvbmdlciB0aGFuIHRoaXMgQnVmZmVyIVxuICB9IC8vIEZJWE1FOiBDYW4gd2UgcmV3cml0ZSB0aGlzIGluIGEgbGVzcyBmdW5reSB3YXk/XG4gIC8vIEZJWE1FOiBDYW4gc3RvcCBlYXJsaWVyIGJhc2VkIG9uIG1hdGNoTGVuZ3RoIVxuXG5cbiAgZmlyc3RNYXRjaDogd2hpbGUgKGN1cnJlbnRJbmRleCA8IHRoaXNMZW5ndGgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgIC8vIG1hdGNoIGZpcnN0IGJ5dGUhXG4gICAgbGV0IGZpcnN0Qnl0ZU1hdGNoID0gaW5kZXhPZih0aGlzLCB2YWx1ZVswXSwgY3VycmVudEluZGV4KTtcblxuICAgIGlmIChmaXJzdEJ5dGVNYXRjaCA9PT0gLTEpIHtcbiAgICAgIC8vIGNvdWxkbid0IGV2ZW4gbWF0Y2ggdGhlIHZlcnkgZmlyc3QgYnl0ZSwgc28gbm8gbWF0Y2ggb3ZlcmFsbCFcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IC8vIG9rLCB3ZSBmb3VuZCB0aGUgZmlyc3QgYnl0ZSwgbm93IHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBuZXh0IGNvbnNlY3V0aXZlIGJ5dGVzIG1hdGNoIVxuXG5cbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8IG1hdGNoTGVuZ3RoOyB4KyspIHtcbiAgICAgIGlmIChmaXJzdEJ5dGVNYXRjaCArIHggPj0gdGhpc0xlbmd0aCkge1xuICAgICAgICBjdXJyZW50SW5kZXggPSBmaXJzdEJ5dGVNYXRjaCArIDE7IC8vIG1vdmUgcGFzdCBvdXIgZmlyc3QgbWF0Y2hcblxuICAgICAgICBjb250aW51ZSBmaXJzdE1hdGNoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxhYmVsc1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tmaXJzdEJ5dGVNYXRjaCArIHhdICE9PSB2YWx1ZVt4XSkge1xuICAgICAgICAvLyBkaWRuJ3QgbWF0Y2ghXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGZpcnN0Qnl0ZU1hdGNoICsgMTsgLy8gbW92ZSBwYXN0IG91ciBmaXJzdCBtYXRjaFxuXG4gICAgICAgIGNvbnRpbnVlIGZpcnN0TWF0Y2g7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbGFiZWxzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0Qnl0ZU1hdGNoOyAvLyB0aGUgcmVzdCBtYXRjaGVkLCBodXJyYXkhXG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG5leHRJbmRleCA9IDA7XG4gIGNvbnN0IGVuZCA9IHRoaXMubGVuZ3RoO1xuICBjb25zdCBteUl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChuZXh0SW5kZXggPCBlbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHZhbHVlOiBuZXh0SW5kZXgsXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQ2NEFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDY0QXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhEb3VibGVBcnJheVs3XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzZdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs0XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVsxXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA4XG4gKiBAcmV0dXJucyB7ZG91YmxlfSBSZWFkcyBhIDY0LWJpdCBkb3VibGUgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQ2NEFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDY0QXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhEb3VibGVBcnJheVswXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbMl0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVszXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzRdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RG91YmxlQXJyYXlbNV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhEb3VibGVBcnJheVs2XSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OERvdWJsZUFycmF5WzddID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBkb3VibGVBcnJheVswXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0XG4gKiBAcmV0dXJucyB7ZmxvYXR9IFJlYWRzIGEgMzItYml0IGZsb2F0IGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IHdpdGggc3BlY2lmaWVkIGVuZGlhbiBmb3JtYXRcbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7IC8vIE5vZGUgY2hlYXRzIGFuZCB1c2VzIGEgRmxvYXQzMkFycmF5IGFuZCBVSW50OEFycmF5IGJhY2tlZCBieSB0aGUgc2FtZSBidWZmZXJcbiAgLy8gc28gYmFzaWNhbGx5IGl0IHJlYWRzIGluIHRoZSBieXRlcyBzdHVmZmluZyB0aGVtIGludG8gVWludDhBcnJheSwgdGhlbiByZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSBGbG9hdDMyQXJyYXlcbiAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBMRSBzeXN0ZW0gYnl0ZU9yZGVyXG5cbiAgdWludDhGbG9hdEFycmF5WzNdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbMV0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzBdID0gdGhpc1tvZmZzZXQrK107XG4gIHJldHVybiBmbG9hdEFycmF5WzBdO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDRcbiAqIEByZXR1cm5zIHtmbG9hdH0gUmVhZHMgYSAzMi1iaXQgZmxvYXQgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgd2l0aCBzcGVjaWZpZWQgZW5kaWFuIGZvcm1hdFxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTsgLy8gTm9kZSBjaGVhdHMgYW5kIHVzZXMgYSBGbG9hdDMyQXJyYXkgYW5kIFVJbnQ4QXJyYXkgYmFja2VkIGJ5IHRoZSBzYW1lIGJ1ZmZlclxuICAvLyBzbyBiYXNpY2FsbHkgaXQgcmVhZHMgaW4gdGhlIGJ5dGVzIHN0dWZmaW5nIHRoZW0gaW50byBVaW50OEFycmF5LCB0aGVuIHJldHVybnMgdGhlIHZhbHVlIGZyb20gdGhlIEZsb2F0MzJBcnJheVxuICAvLyBGSVhNRTogVGhpcyBhc3N1bWVzIExFIHN5c3RlbSBieXRlT3JkZXJcblxuICB1aW50OEZsb2F0QXJyYXlbMF0gPSB0aGlzW29mZnNldCsrXTtcbiAgdWludDhGbG9hdEFycmF5WzFdID0gdGhpc1tvZmZzZXQrK107XG4gIHVpbnQ4RmxvYXRBcnJheVsyXSA9IHRoaXNbb2Zmc2V0KytdO1xuICB1aW50OEZsb2F0QXJyYXlbM10gPSB0aGlzW29mZnNldCsrXTtcbiAgcmV0dXJuIGZsb2F0QXJyYXlbMF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQ4KG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50MTZMRShvZmZzZXQpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCAyKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICBjb25zdCB1bnNpZ25lZFZhbHVlID0gdGhpcy5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgNCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gIHJldHVybiB1bnNpZ25lZFRvU2lnbmVkKHVuc2lnbmVkVmFsdWUsIDQpO1xufTtcbi8qKlxuICogUmVhZHMgYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgZnJvbSBidWYgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQgYW5kIGludGVycHJldHMgdGhlIHJlc3VsdCBhcyBhIHR3bydzIGNvbXBsZW1lbnQgc2lnbmVkIHZhbHVlLiBTdXBwb3J0cyB1cCB0byA0OCBiaXRzIG9mIGFjY3VyYWN5LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCB1bWJlciBvZiBieXRlcyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8IGJ5dGVMZW5ndGggPD0gNi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgdW5zaWduZWRWYWx1ZSA9IHRoaXMucmVhZFVJbnRCRShvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICByZXR1cm4gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCBieXRlTGVuZ3RoKTtcbn07XG4vKipcbiAqIFJlYWRzIGJ5dGVMZW5ndGggbnVtYmVyIG9mIGJ5dGVzIGZyb20gYnVmIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0IGFuZCBpbnRlcnByZXRzIHRoZSByZXN1bHQgYXMgYSB0d28ncyBjb21wbGVtZW50IHNpZ25lZCB2YWx1ZS4gU3VwcG9ydHMgdXAgdG8gNDggYml0cyBvZiBhY2N1cmFjeS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IHVuc2lnbmVkVmFsdWUgPSB0aGlzLnJlYWRVSW50TEUob2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgcmV0dXJuIHVuc2lnbmVkVG9TaWduZWQodW5zaWduZWRWYWx1ZSwgYnl0ZUxlbmd0aCk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIHJldHVybiB0aGlzW29mZnNldF07XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7IC8vIGZpcnN0IGJ5dGUgc2hpZnRlZCBhbmQgT1InZCB3aXRoIHNlY29uZCBieXRlXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSA8PCA4IHwgdGhpc1tvZmZzZXQgKyAxXTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTsgLy8gZmlyc3QgYnl0ZSBPUidkIHdpdGggc2Vjb25kIGJ5dGUgc2hpZnRlZFxuXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgNCk7XG4gIHJldHVybiB0aGlzW29mZnNldF0gKiAweDEwMDAwMDAgKyAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNiB8IHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCB8IHRoaXNbb2Zmc2V0ICsgM10pOyAvLyByYXRoZXIgdGhhbiBzaGlmdGluZyBieSA8PCAyNCwgbXVsdGlwbHkgdGhlIGZpcnN0IGJ5dGUgYW5kIGFkZCBpdCBpbiBzbyB3ZSBkb24ndCByZXRhaW4gdGhlIFwic2lnbiBiaXRcIlxuICAvLyAoYmVjYXVzZSBiaXQtd2lzZSBvcGVyYXRvcnMgYXNzdW1lIGEgMzItYml0IG51bWJlcilcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSA0LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gfCB0aGlzW29mZnNldCArIDFdIDw8IDggfCB0aGlzW29mZnNldCArIDJdIDw8IDE2KSArIHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDA7IC8vIHJhdGhlciB0aGFuIHNoaWZ0aW5nIGJ5IDw8IDI0LCBtdWx0aXBseSB0aGUgbGFzdCBieXRlIGFuZCBhZGQgaXQgaW4gc28gd2UgZG9uJ3QgcmV0YWluIHRoZSBcInNpZ24gYml0XCJcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byByZWFkLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIGJ5dGVMZW5ndGguXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVMZW5ndGggTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgbXVsdGlwbGllciA9IDE7IC8vIHdlIHVzZSBhIG11bHRpcGxlciBmb3IgZWFjaCBieXRlXG4gIC8vIHdlJ3JlIGRvaW5nIHRoZSBzYW1lIGxvb3AgYXMgI3JlYWRVSW50TEUsIGp1c3QgYmFja3dhcmRzIVxuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICByZXN1bHQgKz0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGkpICogbXVsdGlwbGllcjtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwOyAvLyBtb3ZlIG11bHRpcGxpZXIgdG8gbmV4dCBieXRlXG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlYWQuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVMZW5ndGggPiA2KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG5cbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgbGV0IHJlc3VsdCA9IDA7XG4gIGxldCBtdWx0aXBsaWVyID0gMTsgLy8gd2UgdXNlIGEgbXVsdGlwbGVyIGZvciBlYWNoIGJ5dGVcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVMZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSB0aGlzLmdldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSkgKiBtdWx0aXBsaWVyO1xuICAgIG11bHRpcGxpZXIgKj0gMHgxMDA7IC8vIG1vdmUgbXVsdGlwbGllciB0byBuZXh0IGJ5dGVcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtzdGFydD0wXSBXaGVyZSB0aGUgbmV3IGBCdWZmZXJgIHdpbGwgc3RhcnQuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmQ9dGhpcy5sZW5ndGhdIFdoZXJlIHRoZSBuZXcgQnVmZmVyIHdpbGwgZW5kIChub3QgaW5jbHVzaXZlKS4gRGVmYXVsdDogYGJ1Zi5sZW5ndGhgLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IHRoaXNMZW5ndGggKyBzdGFydDtcblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIC8vIGlmIHRoaXMgaXMgc3RpbGwgbmVnYXRpdmUsIHVzZSAwICh0aGF0IG1hdGNoZXMgTm9kZSlcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoICsgZW5kO1xuICB9IC8vIFNwZWNpZnlpbmcgZW5kIGdyZWF0ZXIgdGhhbiBidWYubGVuZ3RoIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHJlc3VsdCBhcyB0aGF0IG9mIGVuZCBlcXVhbCB0byBidWYubGVuZ3RoLlxuXG5cbiAgaWYgKGVuZCA+IHRoaXNMZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzTGVuZ3RoO1xuICB9IC8vIFdoYXQgaWYgZW5kIGlzIGxlc3MgdGhhbiBzdGFydD9cblxuXG4gIGxldCBsZW5ndGggPSBlbmQgLSBzdGFydDtcblxuICBpZiAobGVuZ3RoIDw9IDApIHtcbiAgICBsZW5ndGggPSAwOyAvLyByZXR1cm4gZW1wdHkgdmlldyBvZiBCdWZmZXIhIHJldGFpbiBieXRlIG9mZnNldCwgc2V0IGxlbmd0aCB0byAwXG4gIH0gLy8gV3JhcCB0aGUgc2FtZSBBcnJheUJ1ZmZlciBvYmplY3QgYnV0IHNwZWNpZnkgdGhlIHN0YXJ0L2VuZCB0byBcImNyb3BcIiB3aXRoXG5cblxuICByZXR1cm4gdGhpcy5fc2xpY2UodGhpcy5ieXRlT2Zmc2V0ICsgc3RhcnQsIGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUuX3NsaWNlID0gZnVuY3Rpb24gKG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0aGlzLmJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gV2hlcmUgdGhlIG5ldyBgQnVmZmVyYCB3aWxsIHN0YXJ0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbZW5kPXRoaXMubGVuZ3RoXSBXaGVyZSB0aGUgbmV3IEJ1ZmZlciB3aWxsIGVuZCAobm90IGluY2x1c2l2ZSkuIERlZmF1bHQ6IGBidWYubGVuZ3RoYC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUuc3ViYXJyYXkgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKTtcbn07XG4vKipcbiAqIEludGVycHJldHMgYnVmIGFzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VycyBhbmQgc3dhcHMgdGhlIGJ5dGUgb3JkZXIgaW4tcGxhY2UuXG4gKiBUaHJvd3MgRVJSX0lOVkFMSURfQlVGRkVSX1NJWkUgaWYgYnVmLmxlbmd0aCBpcyBub3QgYSBtdWx0aXBsZSBvZiAyLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJyk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSk7XG4gICAgY29uc3Qgc2Vjb25kID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAxKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIGZpcnN0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgMzItYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIGNvbnN0IHRoaXJkID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAyKTtcbiAgICBjb25zdCBmb3VydGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDMpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpLCBmb3VydGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMSwgdGhpcmQpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMiwgc2Vjb25kKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDMsIGZpcnN0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogSW50ZXJwcmV0cyBidWYgYXMgYW4gYXJyYXkgb2YgdW5zaWduZWQgNjQtYml0IGludGVnZXJzIGFuZCBzd2FwcyB0aGUgYnl0ZSBvcmRlciBpbi1wbGFjZS5cbiAqIFRocm93cyBFUlJfSU5WQUxJRF9CVUZGRVJfU0laRSBpZiBidWYubGVuZ3RoIGlzIG5vdCBhIG11bHRpcGxlIG9mIDguXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpKTtcbiAgICBjb25zdCBzZWNvbmQgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDEpO1xuICAgIGNvbnN0IHRoaXJkID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyAyKTtcbiAgICBjb25zdCBmb3VydGggPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSArIDMpO1xuICAgIGNvbnN0IGZpZnRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA0KTtcbiAgICBjb25zdCBzaXh0aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNSk7XG4gICAgY29uc3Qgc2V2ZW50aCA9IHRoaXMuZ2V0QWRqdXN0ZWRJbmRleChpICsgNik7XG4gICAgY29uc3QgZWlnaHRoID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkgKyA3KTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSwgZWlnaHRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDEsIHNldmVudGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMiwgc2l4dGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgMywgZmlmdGgpO1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChpICsgNCwgZm91cnRoKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDUsIHRoaXJkKTtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgoaSArIDYsIHNlY29uZCk7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KGkgKyA3LCBmaXJzdCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIC8vIFRha2UgYWR2YW50YWdlIG9mIHNsaWNlIHdvcmtpbmcgb24gXCJBcnJheS1saWtlXCIgb2JqZWN0cyAoanVzdCBsaWtlIGBhcmd1bWVudHNgKVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NsaWNlI0FycmF5LWxpa2Vfb2JqZWN0c1xuICAgIGRhdGE6IFtdLnNsaWNlLmNhbGwodGhpcylcbiAgfTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIHRvIHVzZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbc3RhcnQ9MF0gVGhlIGJ5dGUgb2Zmc2V0IHRvIHN0YXJ0IGRlY29kaW5nIGF0XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtlbmRdIFRoZSBieXRlIG9mZnNldCB0byBzdG9wIGRlY29kaW5nIGF0IChub3QgaW5jbHVzaXZlKS4gYGJ1Zi5sZW5ndGhgIGRlZmF1bHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgLy8gZmFzdCBjYXNlIG9mIG5vIGFyZ3NcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy50b1RpQnVmZmVyKCkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChzdGFydCA+PSBsZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7IC8vIHN0YXJ0IGlzIHBhc3QgZW5kIG9mIGJ1ZmZlciwgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKGVuZCA+IGxlbmd0aCB8fCB0eXBlb2YgZW5kICE9PSAnbnVtYmVyJykge1xuICAgIC8vIG5vIGVuZCBzcGVjaWZpZWQsIG9yIHBhc3QgZW5kIG9mIGJ1ZmZlciwgdXNlIGxlbmd0aCBvZiBidWZmZXJcbiAgICBlbmQgPSBsZW5ndGg7XG4gIH0gLy8gZWxzZSBrZWVwIGVuZCBhcyBwYXNzZWQgaW5cblxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7IC8vIGlmIGVuZCBpcyBiZWZvcmUgc3RhcnQgcmV0dXJuIGVtcHR5IHN0cmluZ1xuICB9IC8vIElmIHN0YXJ0ICE9PSAwIGFuZCBlbmQgIT09IGxlbmd0aCwgbWF5YmUgd2Ugc2hvdWxkIGRvIGEgQnVmZmVyLnN1YmFycmF5L3NsaWNlIG92ZXIgdGhlIHJhbmdlIGFuZCBjYWxsIHRvU3RyaW5nKCkgb24gdGhhdD9cblxuXG4gIGlmIChzdGFydCAhPT0gMCB8fCBlbmQgIT09IGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKHN0YXJ0LCBlbmQpLnRvU3RyaW5nKGVuY29kaW5nKTtcbiAgfSAvLyBiYXNlIGNhc2UsIHN0YXJ0IGlzIDAsIGVuZCBpcyBsZW5ndGhcblxuXG4gIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gIH0gZWxzZSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpOyAvLyBUaHJvdyBpZiBiYWQgZW5jb2RpbmchXG5cbiAgICBpZiAoIUJ1ZmZlciQxLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBVbmtub3duIGVuY29kaW5nOiAke2VuY29kaW5nfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHRoaXMudG9UaUJ1ZmZlcigpLnRvU3RyaW5nKCk7IC8vIHdlIHJldHVybiB1dGYtOCBieSBkZWZhdWx0IG5hdGl2ZWx5XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgcmV0dXJuIFRpLlV0aWxzLmJhc2U2NGVuY29kZSh0aGlzLnRvVGlCdWZmZXIoKS50b0Jsb2IoKSkudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gdGhpcy5oZXhTbGljZSgwLCBsZW5ndGgpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnbGF0aW4xJyB8fCBlbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICBsZXQgbGF0aW4xU3RyaW5nID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBlYWNoIG9uZSBpcyBhIFwiYnl0ZVwiXG4gICAgICBsYXRpbjFTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmdldEFkanVzdGVkSW5kZXgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBsYXRpbjFTdHJpbmc7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICBsZXQgYXNjaWkgPSAnJztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHdlIHN0b3JlIGJ5dGVzICg4LWJpdCksIGJ1dCBhc2NpaSBpcyA3LWJpdC4gTm9kZSBcIm1hc2tzXCIgdGhlIGxhc3QgYml0IG9mZiwgc28gbGV0J3MgZG8gdGhlIHNhbWVcbiAgICAgIGFzY2lpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHg3Rik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFzY2lpO1xuICB9IC8vIFVDUzIvVVRGMTZcblxuXG4gIHJldHVybiB0aGlzLnVjczJTbGljZSgwLCBsZW5ndGgpO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmdldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXNbaW5kZXhdO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLnNldEFkanVzdGVkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gIHJldHVybiB0aGlzW2luZGV4XSA9IHZhbHVlO1xufTtcblxuQnVmZmVyJDEucHJvdG90eXBlLmhleFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGhleFN0ciA9ICcnO1xuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgLy8gZWFjaCBvbmUgaXMgYSBcImJ5dGVcIlxuICAgIGxldCBoZXggPSAodGhpcy5nZXRBZGp1c3RlZEluZGV4KGkpICYgMHhmZikudG9TdHJpbmcoMTYpO1xuICAgIGhleCA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgaGV4U3RyICs9IGhleDtcbiAgfVxuXG4gIHJldHVybiBoZXhTdHI7XG59O1xuXG5CdWZmZXIkMS5wcm90b3R5cGUudWNzMlNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgbGV0IG91dCA9ICcnO1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgLy8gdXRmLTE2L3Vjcy0yIGlzIDItYnl0ZXMgcGVyIGNoYXJhY3RlclxuICAgIGNvbnN0IGJ5dGUxID0gdGhpcy5nZXRBZGp1c3RlZEluZGV4KGkrKyk7XG4gICAgY29uc3QgYnl0ZTIgPSB0aGlzLmdldEFkanVzdGVkSW5kZXgoaSsrKTtcbiAgICBjb25zdCBjb2RlX3VuaXQgPSAoYnl0ZTIgPDwgOCkgKyBieXRlMTsgLy8gd2UgbWFzaCB0b2dldGhlciB0aGUgdHdvIGJ5dGVzXG5cbiAgICBvdXQgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZV91bml0KTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyoqXG4gKiBQcm92aWRlcyBhIGNvbnZlcnNpb24gbWV0aG9kIGZvciBpbnRlcmFjdGluZyB3aXRoIFRpIEFQSXMgdGhhdCByZXF1aXJlIGEgVGkuQnVmZmVyXG4gKiBAcmV0dXJucyB7VGkuQnVmZmVyfSB0aGUgdW5kZXJseWluZyBUaS5CdWZmZXIgYmFja2luZyB0aGlzIEJ1ZmZlciBpbnN0YW5jZVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLnRvVGlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHRpQnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgICBsZW5ndGg6IHRoaXMubGVuZ3RoXG4gIH0pO1xuICBjb3B5QnVmZmVyKHRoaXMsIHRpQnVmZmVyLCAwLCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiB0aUJ1ZmZlcjtcbn07XG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBzcmMgc291cmNlIEJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuQnVmZmVyfSBkZXN0IGRlc3RpbmF0aW9uIFRpLkJ1ZmZlciB3ZSdyZSBjb3B5aW5nIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHN0YXJ0IG9mZnNldCB3ZSdyZSBjb3B5aW5nIHRvIGluIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgdG8gY29weVxuICogQHJldHVybnMge2ludGVnZXJ9IGFjdHVhbCBudW1iZXIgb2YgYnl0ZXMgY29waWVkXG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgZGVzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgY29uc3QgZGVzdExlbmd0aCA9IGRlc3QubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRlc3RJbmRleCA9IGkgKyBvZmZzZXQ7IC8vIGFyZSB3ZSB0cnlpbmcgdG8gd3JpdGUgcGFzdCBlbmQgb2YgZGVzdGluYXRpb24/IE9yIHJlYWQgcGFzdCBlbmQgb2Ygc291cmNlPyBTdG9wIVxuXG4gICAgaWYgKGRlc3RJbmRleCA+PSBkZXN0TGVuZ3RoIHx8IGkgPj0gc3JjTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkZXN0W2Rlc3RJbmRleF0gPSBzcmNbaV07XG4gIH1cblxuICByZXR1cm4gaTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBpdGVyYXRvciBmb3IgYnVmIHZhbHVlcyAoYnl0ZXMpXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IE1vdmUgdG8gU2xvd0J1ZmZlcj9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBidWZmZXIgPSB0aGlzO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgY29uc3QgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGNvbnN0IG15SXRlcmF0b3IgPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKG5leHRJbmRleCA8IGVuZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdmFsdWU6IGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KG5leHRJbmRleCksXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgbmV4dEluZGV4Kys7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfSxcbiAgICBbU3ltYm9sLml0ZXJhdG9yXTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXlJdGVyYXRvcjtcbn07XG4vKipcbiAqIENhbGxlZCB3aGVuIGJ1ZmZlciBpcyB1c2VkIGluIGEgZm9yLi5vZiBsb29wLiBEZWxlZ2F0ZXMgdG8gI3ZhbHVlcygpXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbi8vIFRPRE86IE1vdmUgdG8gU2xvd0J1ZmZlcj9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XG59O1xuLyoqXG4gKiBXcml0ZXMgc3RyaW5nIHRvIGJ1ZiBhdCBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBjaGFyYWN0ZXIgZW5jb2RpbmcgaW4gZW5jb2RpbmcuXG4gKiBUaGUgbGVuZ3RoIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLiBJZiBidWYgZGlkIG5vdCBjb250YWluIGVub3VnaCBzcGFjZSB0b1xuICogZml0IHRoZSBlbnRpcmUgc3RyaW5nLCBvbmx5IHBhcnQgb2Ygc3RyaW5nIHdpbGwgYmUgd3JpdHRlbi4gSG93ZXZlciwgcGFydGlhbGx5IGVuY29kZWRcbiAqIGNoYXJhY3RlcnMgd2lsbCBub3QgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHdyaXRlIHRvIGBidWZgLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZSBzdHJpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbmd0aD1idWYubGVuZ3RoIC0gb2Zmc2V0XSBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIHN0cmluZ1xuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gMDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbGVuZ3RoID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gbGVuZ3RoO1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIHdlIGNhcCBgbGVuZ3RoYCBhdCB0aGUgbGVuZ3RoIG9mIG91ciBidWZmZXJcbiAgICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldDtcblxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8ICd1dGY4JzsgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IGByZW1haW5pbmdgIGJ5dGVzIG9mIG91ciBzdHJpbmcgaW50byBhIGJ5dGUgYXJyYXkvYnVmZmVyXG5cbiAgY29uc3Qgc3JjID0gZnJvbVN0cmluZyhzdHJpbmcsIGVuY29kaW5nKTsgLy8gRklYTUU6IENhbiB3ZSBsZXQgaXQga25vdyB0byBvbmx5IGNvbnZlcnQgYHJlbWFpbmluZ2AgYnl0ZXM/XG4gIC8vIHRoZW4gc3RpY2sgdGhhdCBpbnRvIG91ciBidWZmZXIgc3RhcnRpbmcgYXQgYG9mZnNldGAhXG5cbiAgcmV0dXJuIHNyYy5jb3B5KHRoaXMsIG9mZnNldCwgMCwgbGVuZ3RoKTtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgOCk7XG4gIGRvdWJsZUFycmF5WzBdID0gdmFsdWU7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsxXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVsyXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs0XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs1XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs2XSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhEb3VibGVBcnJheVs3XSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgOCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzJdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMV0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgZmxvYXRBcnJheVswXSA9IHZhbHVlO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVswXSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQrKywgdWludDhGbG9hdEFycmF5WzFdKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCsrLCB1aW50OEZsb2F0QXJyYXlbMl0pO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0KyssIHVpbnQ4RmxvYXRBcnJheVszXSk7XG4gIHJldHVybiBvZmZzZXQ7IC8vIGF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYWRkZWQgNCB0byBvZmZzZXRcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAxLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMSk7XG4gIGNoZWNrVmFsdWUodmFsdWUsIC0xMjgsIDEyNyk7XG5cbiAgaWYgKHZhbHVlID49IDApIHtcbiAgICAvLyBqdXN0IHdyaXRlIGl0IG5vcm1hbGx5XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnZlcnQgZnJvbSBzaWduZWQgdG8gMidzIGNvbXBsZW1lbnQgYml0c1xuICAgIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIDB4RkYgKyB2YWx1ZSArIDEpOyAvLyBtYXggdmFsdWUsIHBsdXMgdGhlIG5lZ2F0aXZlIG51bWJlciwgYWRkIG9uZVxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIDE7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMi5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgPj4+IDgpOyAvLyBqdXN0IHNoaWZ0IG92ZXIgYSBieXRlXG5cbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhGRik7IC8vIG1hc2sgdG8gZmlyc3QgYnl0ZVxuXG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAyKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhGRik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSA+Pj4gMjQpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDIsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlICYgMHhGRik7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDQuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDcpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0LCB2YWx1ZSAmIDB4RkYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMSwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDE2KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDMsIHZhbHVlID4+PiAyNCk7XG4gIHJldHVybiBvZmZzZXQgKyA0O1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gYnl0ZUxlbmd0aC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBOdW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDwgYnl0ZUxlbmd0aCA8PSA2LlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjb25zdCBtaW5NYXhCYXNlID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgLW1pbk1heEJhc2UsIG1pbk1heEJhc2UgLSAxKTtcblxuICBpZiAodmFsdWUgPCAwKSB7XG4gICAgdmFsdWUgPSBtaW5NYXhCYXNlICogMiArIHZhbHVlO1xuICB9XG5cbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDB4MTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKGJ5dGVMZW5ndGggPD0gMCB8fCBieXRlTGVuZ3RoID4gNikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuXG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIGNvbnN0IG1pbk1heEJhc2UgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAtbWluTWF4QmFzZSwgbWluTWF4QmFzZSAtIDEpO1xuXG4gIGlmICh2YWx1ZSA8IDApIHtcbiAgICB2YWx1ZSA9IG1pbk1heEJhc2UgKiAyICsgdmFsdWU7XG4gIH1cblxuICBsZXQgbXVsdGlwbGllciA9IDE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gMS5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCAxKTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgMjU1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUpO1xuICByZXR1cm4gb2Zmc2V0ICsgMTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgTnVtYmVyIHRvIGJlIHdyaXR0ZW4gdG8gYnVmLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0PTBdIE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSAyLlxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblxuXG5CdWZmZXIkMS5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIDIpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCA2NTUzNSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiA4KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlICYgMHhmZik7XG4gIHJldHVybiBvZmZzZXQgKyAyO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSB2YWx1ZSBOdW1iZXIgdG8gYmUgd3JpdHRlbiB0byBidWYuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXQ9MF0gTnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAgYmVmb3JlIHN0YXJ0aW5nIHRvIHdyaXRlLiBNdXN0IHNhdGlzZnkgMCA8PSBvZmZzZXQgPD0gYnVmLmxlbmd0aCAtIDIuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIGNoZWNrT2Zmc2V0KHRoaXMsIG9mZnNldCwgMik7XG4gIGNoZWNrVmFsdWUodmFsdWUsIDAsIDY1NTM1KTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCwgdmFsdWUgJiAweGZmKTtcbiAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIDEsIHZhbHVlID4+PiA4KTtcbiAgcmV0dXJuIG9mZnNldCArIDI7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNDI5NDk2NzI5NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlID4+PiAyNCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMiwgdmFsdWUgPj4+IDgpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgJiAweGZmKTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldD0wXSBOdW1iZXIgb2YgYnl0ZXMgdG8gc2tpcCBiZWZvcmUgc3RhcnRpbmcgdG8gd3JpdGUuIE11c3Qgc2F0aXNmeSAwIDw9IG9mZnNldCA8PSBidWYubGVuZ3RoIC0gNC5cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuQnVmZmVyJDEucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgY2hlY2tPZmZzZXQodGhpcywgb2Zmc2V0LCA0KTtcbiAgY2hlY2tWYWx1ZSh2YWx1ZSwgMCwgNDI5NDk2NzI5NSk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQsIHZhbHVlICYgMHhmZik7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAxLCB2YWx1ZSA+Pj4gOCk7XG4gIHRoaXMuc2V0QWRqdXN0ZWRJbmRleChvZmZzZXQgKyAyLCB2YWx1ZSA+Pj4gMTYpO1xuICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgMywgdmFsdWUgPj4+IDI0KTtcbiAgcmV0dXJuIG9mZnNldCArIDQ7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSBieXRlTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYnl0ZVZhbHVlID0gdmFsdWUgLyBtdWx0aXBsaWVyICYgMHhGRjtcbiAgICB0aGlzLnNldEFkanVzdGVkSW5kZXgob2Zmc2V0ICsgaSwgYnl0ZVZhbHVlKTtcbiAgICBtdWx0aXBsaWVyICo9IDBYMTAwO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGg7XG59O1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHZhbHVlIE51bWJlciB0byBiZSB3cml0dGVuIHRvIGJ1Zi5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IE51bWJlciBvZiBieXRlcyB0byBza2lwIGJlZm9yZSBzdGFydGluZyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPD0gb2Zmc2V0IDw9IGJ1Zi5sZW5ndGggLSBieXRlTGVuZ3RoLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIE51bWJlciBvZiBieXRlcyB0byB3cml0ZS4gTXVzdCBzYXRpc2Z5IDAgPCBieXRlTGVuZ3RoIDw9IDYuXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmIChieXRlTGVuZ3RoIDw9IDAgfHwgYnl0ZUxlbmd0aCA+IDYpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cblxuICBjaGVja09mZnNldCh0aGlzLCBvZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICBjaGVja1ZhbHVlKHZhbHVlLCAwLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxKTtcbiAgbGV0IG11bHRpcGxpZXIgPSAxO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGJ5dGVWYWx1ZSA9IHZhbHVlIC8gbXVsdGlwbGllciAmIDB4RkY7XG4gICAgdGhpcy5zZXRBZGp1c3RlZEluZGV4KG9mZnNldCArIGksIGJ5dGVWYWx1ZSk7XG4gICAgbXVsdGlwbGllciAqPSAwWDEwMDtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoO1xufTsgLy8gVE9ETzogSW1wbGVtZW50IHJlbWFpbmluZyBpbnN0YW5jZSBtZXRob2RzOlxuLy8gYnVmLmxhc3RJbmRleE9mKHZhbHVlWywgYnl0ZU9mZnNldF1bLCBlbmNvZGluZ10pXG4vLyBidWYucmVhZEJpZ0ludDY0QkUoW29mZnNldF0pXG4vLyBidWYucmVhZEJpZ0ludDY0TEUoW29mZnNldF0pXG4vLyBidWYucmVhZEJpZ1VJbnQ2NEJFKFtvZmZzZXRdKVxuLy8gYnVmLnJlYWRCaWdVSW50NjRMRShbb2Zmc2V0XSlcbi8vIGJ1Zi53cml0ZUJpZ0ludDY0QkUodmFsdWVbLCBvZmZzZXRdKVxuLy8gYnVmLndyaXRlQmlnSW50NjRMRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBidWYud3JpdGVCaWdVSW50NjRCRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBidWYud3JpdGVCaWdVSW50NjRMRSh2YWx1ZVssIG9mZnNldF0pXG4vLyBGSVhNRTogV2UgbmVlZCB0byBtaW5pbWl6ZSB1c2luZyBhIGJhY2tpbmcgVGkuQnVmZmVyIHdoZW5ldmVyIHBvc3NpYmxlLCBiZWNhdXNlXG4vLyBnb2luZyBiYWNrIGFuZCBmb3J0aCBhY3Jvc3MgdGhlIGJyaWRnZSBmb3IgZXZlcnkgYnl0ZSBpcyAqdmVyeSogZXhwZW5zaXZlXG4vLyBJZGVhbGx5IHdlIHNob3VsZCBoYXZlIGEgXCJTbG93QnVmZmVyXCIgdGhhdCBpcyB1c2VkIHdoZW4gd2UgZXhwbGljaXRseSB3cmFwIGEgVGkuQnVmZmVyXG4vLyBTbyB0aGF0IHdyaXRlcyBhcmUgcGFzc2VkIHRocm91Z2guIE90aGVyd2lzZSB3ZSBzaG91bGQgYXZvaWQgdXNpbmcgb25lIGF0IGFsbCBjb3N0c1xuLy8gaS5lLiB3aGVuIHdlIGRvIEJ1ZmZlci5jb25jYXQgYW5kIGFyZSBvbmx5IGRvaW5nIHJlYWRzIC0gd2h5IGRvIHdlIG5lZWQgYSBUaS5CdWZmZXI/XG4vLyBDYW4gd2UgaGF2ZSBUaS5CdWZmZXIgcmVhbGx5IGp1c3Qgd3JhcCBhIFVpbnQ4QXJyYXkgYW5kIGFkZCBpdCdzIG93biBtZXRob2RzP1xuXG5cbkJ1ZmZlciQxLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICByZXR1cm4gbmV3IEZhc3RCdWZmZXIobGVuZ3RoKTtcbn07XG5cbkJ1ZmZlciQxLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlciQxLmFsbG9jVW5zYWZlKGxlbmd0aCk7XG59O1xuXG5CdWZmZXIkMS5hbGxvYyA9IGZ1bmN0aW9uIChsZW5ndGgsIGZpbGwgPSAwLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBjb25zdCBidWYgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZShsZW5ndGgpO1xuXG4gIGlmIChmaWxsICE9PSAwKSB7XG4gICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fEFycmF5QnVmZmVyfFNoYXJlZEFycmF5QnVmZmVyfSBzdHJpbmcgb3JpZ2luYWwgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZW5jb2Rpbmcgd2hvc2UgYnl0ZSBsZW5ndGggd2UgbmVlZCB0byBncmFiXG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5cbkJ1ZmZlciQxLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyaW5nLCBlbmNvZGluZyA9ICd1dGY4Jykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBpZiAoQnVmZmVyJDEuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgICAgcmV0dXJuIHN0cmluZy5sZW5ndGg7IC8vIHJldHVybiBCdWZmZXIncyBsZW5ndGhcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGg7IC8vIFR5cGVkQXJyYXksIEFycmF5QnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlciwgRGF0YVZpZXdcbiAgfVxuXG4gIGxldCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xuXG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBsZW5ndGg7XG5cbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmMTYtbGUnOlxuICAgICAgcmV0dXJuIDIgKiBsZW5ndGg7XG5cbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIGxlbmd0aCAvIDI7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gU3VidHJhY3QgdXAgdG8gdHdvIHBhZGRpbmcgY2hhcnMgZnJvbSBlbmQgb2Ygc3RyaW5nIVxuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgc3RyaW5nLmNoYXJBdChsZW5ndGggLSAxKSA9PT0gJz0nKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID4gMSAmJiBzdHJpbmcuY2hhckF0KGxlbmd0aCAtIDEpID09PSAnPScpIHtcbiAgICAgICAgbGVuZ3RoLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGxlbmd0aCAqIDMgLyA0KTtcbiAgICAvLyBkcm9wIGZyYWN0aW9uYWwgdmFsdWVcbiAgfVxuXG4gIHJldHVybiB1dGY4Qnl0ZUxlbmd0aChzdHJpbmcpO1xufTtcblxuQnVmZmVyJDEuY29tcGFyZSA9IGZ1bmN0aW9uIChidWYxLCBidWYyKSB7XG4gIGlmICghQnVmZmVyJDEuaXNCdWZmZXIoYnVmMSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJidWYxXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBidWYxfWApO1xuICB9IC8vIFRPRE86IFdyYXAgVUludDhBcnJheSBhcmdzIGluIGJ1ZmZlcnM/XG5cblxuICByZXR1cm4gYnVmMS5jb21wYXJlKGJ1ZjIpO1xufTtcbi8qKlxuICogQHBhcmFtIHtCdWZmZXJbXXxVSW50OEFycmF5W119IGxpc3QgbGlzdCBvZiBCdWZmZXJzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFt0b3RhbExlbmd0aF0gVG90YWwgbGVuZ3RoIG9mIHRoZSBCdWZmZXIgaW5zdGFuY2VzIGluIGxpc3Qgd2hlbiBjb25jYXRlbmF0ZWQuXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5cblxuQnVmZmVyJDEuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKCk7IC8vIG9uZSBlbXB0eSBCdWZmZXIhXG4gIH0gLy8gYWxsb2NhdGUgb25lIEJ1ZmZlciBvZiBgdG90YWxMZW5ndGhgPyBDYXAgYXQgdG90YWxMZW5ndGg/XG5cblxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMDsgLy8gZ2VuZXJhdGUgdGhlIHRvdGFsIGxlbmd0aCBmcm9tIGVhY2ggYnVmZmVyJ3MgbGVuZ3RoP1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBCdWZmZXIkMS5hbGxvY1Vuc2FmZSh0b3RhbExlbmd0aCk7XG4gIGxldCBwb3NpdGlvbiA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICBidWYuY29weShyZXN1bHQsIHBvc2l0aW9uKTtcbiAgICBwb3NpdGlvbiArPSBidWYubGVuZ3RoO1xuXG4gICAgaWYgKHBvc2l0aW9uID49IHRvdGFsTGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nIHBvc3NpYmxlIGVuY29kaW5nIG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuQnVmZmVyJDEuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBWQUxJRF9FTkNPRElOR1MuaW5jbHVkZXMoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSk7XG59O1xuLyoqXG4gKiBAcGFyYW0geyp9IG9iaiBwb3NzaWJsZSBCdWZmZXIgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuQnVmZmVyJDEuaXNCdWZmZXIgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQgJiYgKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlciQxIHx8IG9ialtpc0J1ZmZlcl0gPT09IHRydWUpO1xufTtcblxubGV0IElOU1BFQ1RfTUFYX0JZVEVTID0gNTA7IC8vIE92ZXJyaWRlIGhvdyBidWZmZXJzIGFyZSBwcmVzZW50ZWQgYnkgdXRpbC5pbnNwZWN0KCkuXG5cbkJ1ZmZlciQxLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IGZ1bmN0aW9uIChyZWN1cnNlVGltZXMsIGN0eCkge1xuICBjb25zdCBtYXggPSBJTlNQRUNUX01BWF9CWVRFUztcbiAgY29uc3QgYWN0dWFsTWF4ID0gTWF0aC5taW4obWF4LCB0aGlzLmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gbWF4O1xuICBsZXQgc3RyID0gdGhpcy5zbGljZSgwLCBhY3R1YWxNYXgpLnRvU3RyaW5nKCdoZXgnKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIHN0ciArPSBgIC4uLiAke3JlbWFpbmluZ30gbW9yZSBieXRlJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfSAvLyBJbnNwZWN0IHNwZWNpYWwgcHJvcGVydGllcyBhcyB3ZWxsLCBpZiBwb3NzaWJsZS5cblxuXG4gIGlmIChjdHgpIHtcbiAgICBsZXQgZXh0cmFzID0gZmFsc2U7XG4gICAgY29uc3QgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyQxIDogT05MWV9FTlVNRVJBQkxFJDE7XG4gICAgY29uc3Qgb2JqID0gZ2V0T3duTm9uSW5kZXhQcm9wZXJ0aWVzKHRoaXMsIGZpbHRlcikucmVkdWNlKChvYmosIGtleSkgPT4ge1xuICAgICAgZXh0cmFzID0gdHJ1ZTtcbiAgICAgIG9ialtrZXldID0gdGhpc1trZXldO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcblxuICAgIGlmIChleHRyYXMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH0gLy8gJ1tPYmplY3Q6IG51bGwgcHJvdG90eXBlXSB7Jy5sZW5ndGggPT09IDI2XG4gICAgICAvLyBUaGlzIGlzIGd1YXJkZWQgd2l0aCBhIHRlc3QuXG5cblxuICAgICAgc3RyICs9IGluc3BlY3Qob2JqLCB7IC4uLmN0eCxcbiAgICAgICAgYnJlYWtMZW5ndGg6IEluZmluaXR5LFxuICAgICAgICBjb21wYWN0OiB0cnVlXG4gICAgICB9KS5zbGljZSgyNywgLTIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBgPCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSAke3N0cn0+YDtcbn07XG5cbkJ1ZmZlciQxLnByb3RvdHlwZS5pbnNwZWN0ID0gQnVmZmVyJDEucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdOyAvLyBIQUNLOiBBcnJheUJ1ZmZlci5pc1ZpZXcgcmV0dXJucyB0cnVlIGZvciBOb2RlIEJ1ZmZlciwgYnV0IGZhbHNlIGZvciB1cy4gVW50aWwgd2UgY2FuIGV4dGVuZCBVaW50OEFycmF5LCB3ZSBuZWVkIHRvIGhhY2sgdGhpcyBzbmlmZmluZyBtZXRob2RcblxuY29uc3QgQXJyYXlCdWZmZXJJc1ZpZXcgPSBBcnJheUJ1ZmZlci5pc1ZpZXc7XG5cbkFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uICh0aGluZykge1xuICByZXR1cm4gQXJyYXlCdWZmZXJJc1ZpZXcodGhpbmcpIHx8IHRoaW5nIGluc3RhbmNlb2YgQnVmZmVyJDE7XG59O1xuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU2xvd0J1ZmZlci5wcm90b3R5cGUsIEJ1ZmZlciQxLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU2xvd0J1ZmZlciwgQnVmZmVyJDEpO1xudmFyIEJ1ZmZlck1vZHVsZSA9IHtcbiAgQnVmZmVyOiBCdWZmZXIkMSxcbiAgLy8gVE9ETzogSW1wbGVtZW50IHRyYW5zY29kZSgpIVxuICB0cmFuc2NvZGU6IChfc291cmNlLCBfZnJvbUVuY29kaW5nLCBfdG9FbmNvZGluZykgPT4ge30sXG4gIElOU1BFQ1RfTUFYX0JZVEVTOiA1MCxcbiAga01heExlbmd0aDogMjE0NzQ4MzY0NyxcbiAga1N0cmluZ01heExlbmd0aDogMTA3Mzc0MTc5OSxcbiAgY29uc3RhbnRzOiB7XG4gICAgTUFYX0xFTkdUSDogMjE0NzQ4MzY0NyxcbiAgICBNQVhfU1RSSU5HX0xFTkdUSDogMTA3Mzc0MTc5OVxuICB9XG59O1xuLyoqXG4gKiBTZWFyY2hlcyBhIEJ1ZmZlciBmb3IgdGhlIGluZGV4IG9mIGEgc2luZ2xlIGJ5dGUuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byBzZWFyY2hcbiAqIEBwYXJhbSB7aW50ZWdlcn0gc2luZ2xlQnl0ZSBieXRlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gKiBAcGFyYW0ge2ludGVnZXJ9IG9mZnNldCBzdGFydCBvZmZzZXQgd2Ugc2VhcmNoIGF0XG4gKiBAcmV0dXJucyB7aW50ZWdlcn1cbiAqL1xuXG5mdW5jdGlvbiBpbmRleE9mKGJ1ZmZlciwgc2luZ2xlQnl0ZSwgb2Zmc2V0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGJ1ZmZlci5nZXRBZGp1c3RlZEluZGV4KGkpID09PSBzaW5nbGVCeXRlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZXhwbGljaXRseSBhdm9pZHMgYml0d2lzZSBvcGVyYXRpb25zIGJlY2F1c2UgSlMgYXNzdW1lcyAzMi1iaXQgc2VxdWVuY2VzIGZvciB0aG9zZS5cbiAqIEl0J3MgcG9zc2libGUgd2UgbWF5IGJlIGFibGUgdG8gdXNlIHRoZW0gd2hlbiBieXRlTGVuZ3RoIDwgNCBpZiB0aGF0J3MgZmFzdGVyLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdW5zaWduZWRWYWx1ZSB2YWx1ZSBiZWZvcmUgY29udmVydGluZyBiYWNrIHRvIHNpZ25lZFxuICogQHBhcmFtIHtpbnRlZ2VyfSBieXRlTGVuZ3RoIG51bWJlciBvZiBieXRlc1xuICogQHJldHVybnMge2ludGVnZXJ9IHRoZSBzaWduZWQgdmFsdWUgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgdW5zaWduZWQgdmFsdWUncyBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gdW5zaWduZWRUb1NpZ25lZCh1bnNpZ25lZFZhbHVlLCBieXRlTGVuZ3RoKSB7XG4gIGNvbnN0IGJpdExlbmd0aCA9IGJ5dGVMZW5ndGggKiA4O1xuICBjb25zdCBtYXhQb3NpdGl2ZVZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSk7XG5cbiAgaWYgKHVuc2lnbmVkVmFsdWUgPCBtYXhQb3NpdGl2ZVZhbHVlKSB7XG4gICAgcmV0dXJuIHVuc2lnbmVkVmFsdWU7XG4gIH1cblxuICBjb25zdCBtYXhVbnNpZ25lZFZhbHVlID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcbiAgdW5zaWduZWRWYWx1ZSAtPSBtYXhVbnNpZ25lZFZhbHVlO1xuICByZXR1cm4gdW5zaWduZWRWYWx1ZTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyB1dGYtOCBzdHJpbmdcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuZnVuY3Rpb24gdXRmOEJ5dGVMZW5ndGgoc3RyaW5nKSB7XG4gIC8vIEp1c3QgY29udmVydCB0byBhIFRpLkJ1ZmZlciBhbmQgbGV0IGl0IHRlbGwgdXMgdGhlIGxlbmd0aFxuICBjb25zdCBidWYgPSBUaS5jcmVhdGVCdWZmZXIoe1xuICAgIHZhbHVlOiBzdHJpbmcsXG4gICAgdHlwZTogVGkuQ29kZWMuQ0hBUlNFVF9VVEY4XG4gIH0pO1xuICBjb25zdCBsZW5ndGggPSBidWYubGVuZ3RoO1xuICBidWYucmVsZWFzZSgpOyAvLyByZWxlYXNlIHRoZSBidWZmZXIgc2luY2Ugd2UganVzdCBuZWVkZWQgdGhlIGxlbmd0aFxuXG4gIHJldHVybiBsZW5ndGg7XG59XG4vKipcbiAqIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgb2Zmc2V0IGlzIG91dCBvZiBib3VuZHNcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyIHdlJ3JlIG9wZXJhdGluZyBvblxuICogQHBhcmFtIHtpbnRlZ2VyfSBvZmZzZXQgdXNlciBzdXBwbGllZCBvZmZzZXRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gYnl0ZUxlbmd0aCBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIGluIHJhbmdlXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5cblxuZnVuY3Rpb24gY2hlY2tPZmZzZXQoYnVmZmVyLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29uc3QgZW5kT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIGJ5dGVMZW5ndGg7XG5cbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gZW5kT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZSB2YWx1ZSBvZiBcIm9mZnNldFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSA+PSAwIGFuZCA8PSAke2VuZE9mZnNldH0uIFJlY2VpdmVkICR7b2Zmc2V0fWApO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gdmFsdWUgdXNlci1zdXBwbGllZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtaW4gbWluaW11bSB2YWxpZCB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBtYXggbWF4aW11bSB2YWxpZCB2YWx1ZVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNoZWNrVmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgdmFsdWUgb2YgXCJ2YWx1ZVwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSA+PSAke21pbn0gYW5kIDw9ICR7bWF4fS4gUmVjZWl2ZWQgJHt2YWx1ZX1gKTtcbiAgfVxufVxuXG5sZXQgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gZmFsc2U7XG5sZXQgbm9kZU1vZHVsZXNDaGVja0NvdW50ZXIgPSAwO1xuY29uc3QgYnVmZmVyV2FybmluZyA9ICdCdWZmZXIoKSBpcyBkZXByZWNhdGVkIGR1ZSB0byBzZWN1cml0eSBhbmQgdXNhYmlsaXR5ICcgKyAnaXNzdWVzLiBQbGVhc2UgdXNlIHRoZSBCdWZmZXIuYWxsb2MoKSwgJyArICdCdWZmZXIuYWxsb2NVbnNhZmUoKSwgb3IgQnVmZmVyLmZyb20oKSBtZXRob2RzIGluc3RlYWQuJztcblxuZnVuY3Rpb24gc2hvd0ZsYWdnZWREZXByZWNhdGlvbigpIHtcbiAgaWYgKGJ1ZmZlcldhcm5pbmdBbHJlYWR5RW1pdHRlZCB8fCArK25vZGVNb2R1bGVzQ2hlY2tDb3VudGVyID4gMTAwMDAgfHwgaXNJbnNpZGVOb2RlTW9kdWxlcygpKSB7XG4gICAgLy8gV2UgZG9uJ3QgZW1pdCBhIHdhcm5pbmcsIGJlY2F1c2Ugd2UgZWl0aGVyOlxuICAgIC8vIC0gQWxyZWFkeSBkaWQgc28sIG9yXG4gICAgLy8gLSBBbHJlYWR5IGNoZWNrZWQgdG9vIG1hbnkgdGltZXMgd2hldGhlciBhIGNhbGwgaXMgY29taW5nXG4gICAgLy8gICBmcm9tIG5vZGVfbW9kdWxlcyBhbmQgd2FudCB0byBzdG9wIHNsb3dpbmcgZG93biB0aGluZ3MsIG9yXG4gICAgLy8gLSBUaGUgY29kZSBpcyBpbnNpZGUgYG5vZGVfbW9kdWxlc2AuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJvY2Vzcy5lbWl0V2FybmluZyhidWZmZXJXYXJuaW5nLCAnRGVwcmVjYXRpb25XYXJuaW5nJywgJ0RFUDAwMDUnKTtcbiAgYnVmZmVyV2FybmluZ0FscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbn1cblxuLy8gQ29weXJpZ2h0IE5vZGUuanMgY29udHJpYnV0b3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuY29uc3Qge1xuICBBTExfUFJPUEVSVElFUzogQUxMX1BST1BFUlRJRVMkMixcbiAgT05MWV9FTlVNRVJBQkxFOiBPTkxZX0VOVU1FUkFCTEUkMlxufSA9IHByb3BlcnR5RmlsdGVyO1xuY29uc3QgQm9vbGVhblByb3RvdHlwZSA9IEJvb2xlYW4ucHJvdG90eXBlO1xuY29uc3QgRGF0ZVByb3RvdHlwZSA9IERhdGUucHJvdG90eXBlO1xuY29uc3QgRXJyb3JQcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5jb25zdCBOdW1iZXJQcm90b3R5cGUgPSBOdW1iZXIucHJvdG90eXBlO1xuY29uc3QgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbmNvbnN0IFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5jb25zdCBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xuY29uc3QgU2V0UHJvdG90eXBlID0gU2V0LnByb3RvdHlwZTtcbmNvbnN0IFN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbC5wcm90b3R5cGU7XG5jb25zdCBpc0lvcyA9IFsnaXBhZCcsICdpcGhvbmUnXS5pbmNsdWRlcyhcImFuZHJvaWRcIik7XG5jb25zdCB7XG4gIEVSUl9JTlZBTElEX0FSR19UWVBFXG59ID0gY29kZXM7XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuY29uc3QgcHJvcGVydHlJc0VudW1lcmFibGUgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKTtcbmxldCBoZXhTbGljZSA9IHVuY3VycnlUaGlzKEJ1ZmZlck1vZHVsZS5CdWZmZXIucHJvdG90eXBlLmhleFNsaWNlKTtcbmNvbnN0IGJ1aWx0SW5PYmplY3RzID0gbmV3IFNldChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnbG9iYWwpLmZpbHRlcihlID0+IC9eKFtBLVpdW2Etel0rKSskLy50ZXN0KGUpKSk7XG5jb25zdCBpbnNwZWN0RGVmYXVsdE9wdGlvbnMgPSBPYmplY3Quc2VhbCh7XG4gIHNob3dIaWRkZW46IGZhbHNlLFxuICBkZXB0aDogMixcbiAgY29sb3JzOiBmYWxzZSxcbiAgY3VzdG9tSW5zcGVjdDogdHJ1ZSxcbiAgc2hvd1Byb3h5OiBmYWxzZSxcbiAgbWF4QXJyYXlMZW5ndGg6IDEwMCxcbiAgYnJlYWtMZW5ndGg6IDgwLFxuICBjb21wYWN0OiAzLFxuICBzb3J0ZWQ6IGZhbHNlLFxuICBnZXR0ZXJzOiBmYWxzZVxufSk7XG5jb25zdCBrT2JqZWN0VHlwZSA9IDA7XG5jb25zdCBrQXJyYXlUeXBlID0gMTtcbmNvbnN0IGtBcnJheUV4dHJhc1R5cGUgPSAyO1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29udHJvbC1yZWdleCAqL1xuXG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXIgPSAvW1xceDAwLVxceDFmXFx4MjdcXHg1Y10vZztcbmNvbnN0IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZSA9IC9bXFx4MDAtXFx4MWZcXHg1Y10vO1xuY29uc3Qgc3RyRXNjYXBlU2VxdWVuY2VzUmVwbGFjZXJTaW5nbGUgPSAvW1xceDAwLVxceDFmXFx4NWNdL2c7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnRyb2wtcmVnZXggKi9cblxuY29uc3Qga2V5U3RyUmVnRXhwID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC87XG5jb25zdCBudW1iZXJSZWdFeHAgPSAvXigwfFsxLTldWzAtOV0qKSQvO1xuY29uc3Qgbm9kZU1vZHVsZXNSZWdFeHAgPSAvWy9cXFxcXW5vZGVfbW9kdWxlc1svXFxcXF0oLis/KSg/PVsvXFxcXF0pL2c7XG5jb25zdCBrTWluTGluZUxlbmd0aCA9IDE2OyAvLyBDb25zdGFudHMgdG8gbWFwIHRoZSBpdGVyYXRvciBzdGF0ZS5cblxuY29uc3Qga1dlYWsgPSAwO1xuY29uc3Qga0l0ZXJhdG9yID0gMTtcbmNvbnN0IGtNYXBFbnRyaWVzID0gMjsgLy8gRXNjYXBlZCBzcGVjaWFsIGNoYXJhY3RlcnMuIFVzZSBlbXB0eSBzdHJpbmdzIHRvIGZpbGwgdXAgdW51c2VkIGVudHJpZXMuXG5cbi8qIGVzbGludC1kaXNhYmxlIHF1b3RlcyAqL1xuXG5jb25zdCBtZXRhID0gWydcXFxcdTAwMDAnLCAnXFxcXHUwMDAxJywgJ1xcXFx1MDAwMicsICdcXFxcdTAwMDMnLCAnXFxcXHUwMDA0JywgJ1xcXFx1MDAwNScsICdcXFxcdTAwMDYnLCAnXFxcXHUwMDA3JywgJ1xcXFxiJywgJ1xcXFx0JywgJ1xcXFxuJywgJ1xcXFx1MDAwYicsICdcXFxcZicsICdcXFxccicsICdcXFxcdTAwMGUnLCAnXFxcXHUwMDBmJywgJ1xcXFx1MDAxMCcsICdcXFxcdTAwMTEnLCAnXFxcXHUwMDEyJywgJ1xcXFx1MDAxMycsICdcXFxcdTAwMTQnLCAnXFxcXHUwMDE1JywgJ1xcXFx1MDAxNicsICdcXFxcdTAwMTcnLCAnXFxcXHUwMDE4JywgJ1xcXFx1MDAxOScsICdcXFxcdTAwMWEnLCAnXFxcXHUwMDFiJywgJ1xcXFx1MDAxYycsICdcXFxcdTAwMWQnLCAnXFxcXHUwMDFlJywgJ1xcXFx1MDAxZicsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCBcIlxcXFwnXCIsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnXFxcXFxcXFwnXTtcbi8qIGVzbGludC1lbmFibGUgcXVvdGVzICovXG5cbmZ1bmN0aW9uIGdldFVzZXJPcHRpb25zKGN0eCkge1xuICBjb25zdCBvYmogPSB7XG4gICAgc3R5bGl6ZTogY3R4LnN0eWxpemVcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnNwZWN0RGVmYXVsdE9wdGlvbnMpKSB7XG4gICAgb2JqW2tleV0gPSBjdHhba2V5XTtcbiAgfVxuXG4gIGlmIChjdHgudXNlck9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4geyAuLi5vYmosXG4gICAgLi4uY3R4LnVzZXJPcHRpb25zXG4gIH07XG59XG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhbnkgaW5wdXQuIFRyaWVzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgdmFsdWVgXG4gKi9cblxuXG5mdW5jdGlvbiBpbnNwZWN0KHZhbHVlLCBvcHRzKSB7XG4gIC8vIERlZmF1bHQgb3B0aW9uc1xuICBjb25zdCBjdHggPSB7XG4gICAgYnVkZ2V0OiB7fSxcbiAgICBpbmRlbnRhdGlvbkx2bDogMCxcbiAgICBzZWVuOiBbXSxcbiAgICBjdXJyZW50RGVwdGg6IDAsXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3IsXG4gICAgc2hvd0hpZGRlbjogaW5zcGVjdERlZmF1bHRPcHRpb25zLnNob3dIaWRkZW4sXG4gICAgZGVwdGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5kZXB0aCxcbiAgICBjb2xvcnM6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5jb2xvcnMsXG4gICAgY3VzdG9tSW5zcGVjdDogaW5zcGVjdERlZmF1bHRPcHRpb25zLmN1c3RvbUluc3BlY3QsXG4gICAgc2hvd1Byb3h5OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuc2hvd1Byb3h5LFxuICAgIG1heEFycmF5TGVuZ3RoOiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMubWF4QXJyYXlMZW5ndGgsXG4gICAgYnJlYWtMZW5ndGg6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5icmVha0xlbmd0aCxcbiAgICBjb21wYWN0OiBpbnNwZWN0RGVmYXVsdE9wdGlvbnMuY29tcGFjdCxcbiAgICBzb3J0ZWQ6IGluc3BlY3REZWZhdWx0T3B0aW9ucy5zb3J0ZWQsXG4gICAgZ2V0dGVyczogaW5zcGVjdERlZmF1bHRPcHRpb25zLmdldHRlcnNcbiAgfTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMZWdhY3kuLi5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICAgICAgfVxuICAgIH0gLy8gU2V0IHVzZXItc3BlY2lmaWVkIG9wdGlvbnNcblxuXG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAgIGNvbnN0IG9wdEtleXMgPSBPYmplY3Qua2V5cyhvcHRzKTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Ygb3B0S2V5cykge1xuICAgICAgICAvLyBUT0RPKEJyaWRnZUFSKTogRmluZCBhIHNvbHV0aW9uIHdoYXQgdG8gZG8gYWJvdXQgc3R5bGl6ZS4gRWl0aGVyIG1ha2VcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBwdWJsaWMgb3IgYWRkIGEgbmV3IEFQSSB3aXRoIGEgc2ltaWxhciBvciBiZXR0ZXJcbiAgICAgICAgLy8gZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KGluc3BlY3REZWZhdWx0T3B0aW9ucywga2V5KSB8fCBrZXkgPT09ICdzdHlsaXplJykge1xuICAgICAgICAgIGN0eFtrZXldID0gb3B0c1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGN0eC51c2VyT3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCB0byBwYXNzIHRocm91Z2ggdGhlIGFjdHVhbCB1c2VyIGlucHV0LlxuICAgICAgICAgIGN0eC51c2VyT3B0aW9ucyA9IG9wdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY3R4LmNvbG9ycykge1xuICAgIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgfVxuXG4gIGlmIChjdHgubWF4QXJyYXlMZW5ndGggPT09IG51bGwpIHtcbiAgICBjdHgubWF4QXJyYXlMZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCAwKTtcbn1cbmluc3BlY3QuY3VzdG9tID0gY3VzdG9tSW5zcGVjdFN5bWJvbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnNwZWN0LCAnZGVmYXVsdE9wdGlvbnMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gaW5zcGVjdERlZmF1bHRPcHRpb25zO1xuICB9LFxuXG4gIHNldChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ29wdGlvbnMnLCAnT2JqZWN0Jywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihpbnNwZWN0RGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICB9XG5cbn0pOyAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3NcblxuaW5zcGVjdC5jb2xvcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgYm9sZDogWzEsIDIyXSxcbiAgaXRhbGljOiBbMywgMjNdLFxuICB1bmRlcmxpbmU6IFs0LCAyNF0sXG4gIGludmVyc2U6IFs3LCAyN10sXG4gIHdoaXRlOiBbMzcsIDM5XSxcbiAgZ3JleTogWzkwLCAzOV0sXG4gIGJsYWNrOiBbMzAsIDM5XSxcbiAgYmx1ZTogWzM0LCAzOV0sXG4gIGN5YW46IFszNiwgMzldLFxuICBncmVlbjogWzMyLCAzOV0sXG4gIG1hZ2VudGE6IFszNSwgMzldLFxuICByZWQ6IFszMSwgMzldLFxuICB5ZWxsb3c6IFszMywgMzldXG59KTsgLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5cbmluc3BlY3Quc3R5bGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIHNwZWNpYWw6ICdjeWFuJyxcbiAgbnVtYmVyOiAneWVsbG93JyxcbiAgYmlnaW50OiAneWVsbG93JyxcbiAgYm9vbGVhbjogJ3llbGxvdycsXG4gIHVuZGVmaW5lZDogJ2dyZXknLFxuICBudWxsOiAnYm9sZCcsXG4gIHN0cmluZzogJ2dyZWVuJyxcbiAgc3ltYm9sOiAnZ3JlZW4nLFxuICBkYXRlOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gIHJlZ2V4cDogJ3JlZCcsXG4gIG1vZHVsZTogJ3VuZGVybGluZSdcbn0pO1xuXG5mdW5jdGlvbiBhZGRRdW90ZXMoc3RyLCBxdW90ZXMpIHtcbiAgaWYgKHF1b3RlcyA9PT0gLTEpIHtcbiAgICByZXR1cm4gYFwiJHtzdHJ9XCJgO1xuICB9XG5cbiAgaWYgKHF1b3RlcyA9PT0gLTIpIHtcbiAgICByZXR1cm4gYFxcYCR7c3RyfVxcYGA7XG4gIH1cblxuICByZXR1cm4gYCcke3N0cn0nYDtcbn1cblxuY29uc3QgZXNjYXBlRm4gPSBzdHIgPT4gbWV0YVtzdHIuY2hhckNvZGVBdCgwKV07IC8vIEVzY2FwZSBjb250cm9sIGNoYXJhY3RlcnMsIHNpbmdsZSBxdW90ZXMgYW5kIHRoZSBiYWNrc2xhc2guXG4vLyBUaGlzIGlzIHNpbWlsYXIgdG8gSlNPTiBzdHJpbmdpZnkgZXNjYXBpbmcuXG5cblxuZnVuY3Rpb24gc3RyRXNjYXBlKHN0cikge1xuICBsZXQgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cDtcbiAgbGV0IGVzY2FwZVJlcGxhY2UgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlcjtcbiAgbGV0IHNpbmdsZVF1b3RlID0gMzk7IC8vIENoZWNrIGZvciBkb3VibGUgcXVvdGVzLiBJZiBub3QgcHJlc2VudCwgZG8gbm90IGVzY2FwZSBzaW5nbGUgcXVvdGVzIGFuZFxuICAvLyBpbnN0ZWFkIHdyYXAgdGhlIHRleHQgaW4gZG91YmxlIHF1b3Rlcy4gSWYgZG91YmxlIHF1b3RlcyBleGlzdCwgY2hlY2sgZm9yXG4gIC8vIGJhY2t0aWNrcy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIHVzZSB0aG9zZSBhcyBmYWxsYmFjayBpbnN0ZWFkIG9mIHRoZVxuICAvLyBkb3VibGUgcXVvdGVzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcXVvdGVzXG5cbiAgaWYgKHN0ci5pbmNsdWRlcyhcIidcIikpIHtcbiAgICAvLyBUaGlzIGludmFsaWRhdGVzIHRoZSBjaGFyQ29kZSBhbmQgdGhlcmVmb3JlIGNhbiBub3QgYmUgbWF0Y2hlZCBmb3JcbiAgICAvLyBhbnltb3JlLlxuICAgIGlmICghc3RyLmluY2x1ZGVzKCdcIicpKSB7XG4gICAgICBzaW5nbGVRdW90ZSA9IC0xO1xuICAgIH0gZWxzZSBpZiAoIXN0ci5pbmNsdWRlcygnYCcpICYmICFzdHIuaW5jbHVkZXMoJyR7JykpIHtcbiAgICAgIHNpbmdsZVF1b3RlID0gLTI7XG4gICAgfVxuXG4gICAgaWYgKHNpbmdsZVF1b3RlICE9PSAzOSkge1xuICAgICAgZXNjYXBlVGVzdCA9IHN0ckVzY2FwZVNlcXVlbmNlc1JlZ0V4cFNpbmdsZTtcbiAgICAgIGVzY2FwZVJlcGxhY2UgPSBzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlclNpbmdsZTtcbiAgICB9XG4gIH0gLy8gU29tZSBtYWdpYyBudW1iZXJzIHRoYXQgd29ya2VkIG91dCBmaW5lIHdoaWxlIGJlbmNobWFya2luZyB3aXRoIHY4IDYuMFxuXG5cbiAgaWYgKHN0ci5sZW5ndGggPCA1MDAwICYmICFlc2NhcGVUZXN0LnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBhZGRRdW90ZXMoc3RyLCBzaW5nbGVRdW90ZSk7XG4gIH1cblxuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHN0ciA9IHN0ci5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGVzY2FwZUZuKTtcbiAgICByZXR1cm4gYWRkUXVvdGVzKHN0ciwgc2luZ2xlUXVvdGUpO1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBsZXQgbGFzdCA9IDA7XG4gIGNvbnN0IGxhc3RJbmRleCA9IHN0ci5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgIGNvbnN0IHBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAocG9pbnQgPT09IHNpbmdsZVF1b3RlIHx8IHBvaW50ID09PSA5MiB8fCBwb2ludCA8IDMyKSB7XG4gICAgICBpZiAobGFzdCA9PT0gaSkge1xuICAgICAgICByZXN1bHQgKz0gbWV0YVtwb2ludF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gYCR7c3RyLnNsaWNlKGxhc3QsIGkpfSR7bWV0YVtwb2ludF19YDtcbiAgICAgIH1cblxuICAgICAgbGFzdCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsYXN0ICE9PSBsYXN0SW5kZXgpIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3QpO1xuICB9XG5cbiAgcmV0dXJuIGFkZFF1b3RlcyhyZXN1bHQsIHNpbmdsZVF1b3RlKTtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICBjb25zdCBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb2xvciA9IGluc3BlY3QuY29sb3JzW3N0eWxlXTtcbiAgICByZXR1cm4gYFxcdTAwMWJbJHtjb2xvclswXX1tJHtzdHJ9XFx1MDAxYlske2NvbG9yWzFdfW1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyKSB7XG4gIHJldHVybiBzdHI7XG59IC8vIFJldHVybiBhIG5ldyBlbXB0eSBhcnJheSB0byBwdXNoIGluIHRoZSByZXN1bHRzIG9mIHRoZSBkZWZhdWx0IGZvcm1hdHRlci5cblxuXG5mdW5jdGlvbiBnZXRFbXB0eUZvcm1hdEFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGdldENvbnN0cnVjdG9yTmFtZShvYmosIF9jdHgpIHtcbiAgbGV0IGZpcnN0UHJvdG87IC8vIGNvbnN0IHRtcCA9IG9iajtcblxuICB3aGlsZSAob2JqKSB7XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCAnY29uc3RydWN0b3InKTtcblxuICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGRlc2NyaXB0b3IudmFsdWUgPT09ICdmdW5jdGlvbicgJiYgZGVzY3JpcHRvci52YWx1ZS5uYW1lICE9PSAnJykge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUubmFtZTtcbiAgICB9XG5cbiAgICBvYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcblxuICAgIGlmIChmaXJzdFByb3RvID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpcnN0UHJvdG8gPSBvYmo7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0UHJvdG8gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKlxuICAgQHRvZG8gdGhpcyBjYWxscyBpbnRvIG5hdGl2ZSwgY2FuIHdlIHJlcGxhY2UgdGhpcyBzb21laG93P1xuICByZXR1cm4gYCR7aW50ZXJuYWxHZXRDb25zdHJ1Y3Rvck5hbWUodG1wKX0gPCR7aW5zcGVjdChmaXJzdFByb3RvLCB7XG4gIFx0Li4uY3R4LFxuICBcdGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gIH0pfT5gO1xuICAqL1xuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjaykge1xuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBpZiAodGFnICE9PSAnJykge1xuICAgICAgcmV0dXJuIGBbJHtmYWxsYmFja306IG51bGwgcHJvdG90eXBlXSBbJHt0YWd9XSBgO1xuICAgIH1cblxuICAgIHJldHVybiBgWyR7ZmFsbGJhY2t9OiBudWxsIHByb3RvdHlwZV0gYDtcbiAgfVxuXG4gIGlmICh0YWcgIT09ICcnICYmIGNvbnN0cnVjdG9yICE9PSB0YWcpIHtcbiAgICByZXR1cm4gYCR7Y29uc3RydWN0b3J9IFske3RhZ31dIGA7XG4gIH1cblxuICByZXR1cm4gYCR7Y29uc3RydWN0b3J9IGA7XG59IC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cblxuXG5mdW5jdGlvbiBnZXRLZXlzKHZhbHVlLCBzaG93SGlkZGVuKSB7XG4gIGxldCBrZXlzO1xuICBjb25zdCBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh2YWx1ZSk7XG5cbiAgaWYgKHNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuXG4gICAgaWYgKHN5bWJvbHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBrZXlzLnB1c2goLi4uc3ltYm9scyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgbWlnaHQgdGhyb3cgaWYgYHZhbHVlYCBpcyBhIE1vZHVsZSBOYW1lc3BhY2UgT2JqZWN0IGZyb20gYW5cbiAgICAvLyB1bmV2YWx1YXRlZCBtb2R1bGUsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIHBlcmZvcm0gdGhlIGFjdHVhbCB0eXBlXG4gICAgLy8gY2hlY2sgYmVjYXVzZSBpdCdzIGV4cGVuc2l2ZS5cbiAgICAvLyBUT0RPKGRldnNuZWspOiB0cmFjayBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9lY21hMjYyL2lzc3Vlcy8xMjA5XG4gICAgLy8gYW5kIG1vZGlmeSB0aGlzIGxvZ2ljIGFzIG5lZWRlZC5cbiAgICB0cnkge1xuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEBmaXhtZSBob3cgdG8gZHUgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG5cbiAgICAgIC8qXG4gICAgICBhc3NlcnQoaXNOYXRpdmVFcnJvcihlcnIpICYmIGVyci5uYW1lID09PSAnUmVmZXJlbmNlRXJyb3InICYmXG4gICAgICBcdFx0XHQgaXNNb2R1bGVOYW1lc3BhY2VPYmplY3QodmFsdWUpKTtcbiAgICAgICovXG4gICAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChzeW1ib2xzLmxlbmd0aCAhPT0gMCkge1xuICAgICAga2V5cy5wdXNoKC4uLnN5bWJvbHMuZmlsdGVyKGtleSA9PiBwcm9wZXJ0eUlzRW51bWVyYWJsZSh2YWx1ZSwga2V5KSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICBsZXQgZmFsbGJhY2sgPSAnJztcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICBmYWxsYmFjayA9ICdPYmplY3QnO1xuICB9XG5cbiAgcmV0dXJuIGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKSB7XG4gIGZvciAoY29uc3QgW2NoZWNrLCBjbGF6el0gb2YgW1tpc1VpbnQ4QXJyYXksIFVpbnQ4QXJyYXldLCBbaXNVaW50OENsYW1wZWRBcnJheSwgVWludDhDbGFtcGVkQXJyYXldLCBbaXNVaW50MTZBcnJheSwgVWludDE2QXJyYXldLCBbaXNVaW50MzJBcnJheSwgVWludDMyQXJyYXldLCBbaXNJbnQ4QXJyYXksIEludDhBcnJheV0sIFtpc0ludDE2QXJyYXksIEludDE2QXJyYXldLCBbaXNJbnQzMkFycmF5LCBJbnQzMkFycmF5XSwgW2lzRmxvYXQzMkFycmF5LCBGbG9hdDMyQXJyYXldLCBbaXNGbG9hdDY0QXJyYXksIEZsb2F0NjRBcnJheV1dKSB7XG4gICAgaWYgKGNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsYXp6O1xuICAgIH1cbiAgfVxufVxuXG5sZXQgbGF6eU51bGxQcm90b3R5cGVDYWNoZTsgLy8gQ3JlYXRlcyBhIHN1YmNsYXNzIGFuZCBuYW1lXG4vLyB0aGUgY29uc3RydWN0b3IgYXMgYCR7Y2xhenp9IDogbnVsbCBwcm90b3R5cGVgXG5cbmZ1bmN0aW9uIGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY2xhenosIG5hbWUpIHtcbiAgaWYgKGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGxhenlOdWxsUHJvdG90eXBlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2FjaGVkQ2xhc3MgPSBsYXp5TnVsbFByb3RvdHlwZUNhY2hlLmdldChjbGF6eik7XG5cbiAgICBpZiAoY2FjaGVkQ2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZENsYXNzO1xuICAgIH1cbiAgfVxuXG4gIGNsYXNzIE51bGxQcm90b3R5cGUgZXh0ZW5kcyBjbGF6eiB7XG4gICAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE51bGxQcm90b3R5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yLCAnbmFtZScsIHtcbiAgICB2YWx1ZTogYFske25hbWV9OiBudWxsIHByb3RvdHlwZV1gXG4gIH0pO1xuICBsYXp5TnVsbFByb3RvdHlwZUNhY2hlLnNldChjbGF6eiwgTnVsbFByb3RvdHlwZSk7XG4gIHJldHVybiBOdWxsUHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBub1Byb3RvdHlwZUl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICBsZXQgbmV3VmFsO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoU2V0LCAnU2V0Jyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KFNldFByb3RvdHlwZS52YWx1ZXModmFsdWUpKTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoTWFwLCAnTWFwJyk7XG4gICAgbmV3VmFsID0gbmV3IGNsYXp6KE1hcFByb3RvdHlwZS5lbnRyaWVzKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoQXJyYXksICdBcnJheScpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGZpbmRUeXBlZENvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICBjb25zdCBjbGF6eiA9IGNsYXp6V2l0aE51bGxQcm90b3R5cGUoY29uc3RydWN0b3IsIGNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIG5ld1ZhbCA9IG5ldyBjbGF6eih2YWx1ZSk7XG4gIH1cblxuICBpZiAobmV3VmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuZXdWYWwsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHZhbHVlKSk7XG4gICAgcmV0dXJuIGZvcm1hdFJhdyhjdHgsIG5ld1ZhbCwgcmVjdXJzZVRpbWVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXMuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmb3JtYXRQcmltaXRpdmUoY3R4LnN0eWxpemUsIHZhbHVlLCBjdHgpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbiAgfSAvLyBNZW1vcml6ZSB0aGUgY29udGV4dCBmb3IgY3VzdG9tIGluc3BlY3Rpb24gb24gcHJveGllcy5cblxuXG4gIGNvbnN0IGNvbnRleHQgPSB2YWx1ZTtcbiAgLypcbiAgQGZpeG1lIGNoZWNrIGZvciBwcm94aWVzXG4gIC8vIEFsd2F5cyBjaGVjayBmb3IgcHJveGllcyB0byBwcmV2ZW50IHNpZGUgZWZmZWN0cyBhbmQgdG8gcHJldmVudCB0cmlnZ2VyaW5nXG4gIC8vIGFueSBwcm94eSBoYW5kbGVycy5cbiAgY29uc3QgcHJveHkgPSBnZXRQcm94eURldGFpbHModmFsdWUpO1xuICBpZiAocHJveHkgIT09IHVuZGVmaW5lZCkge1xuICBcdGlmIChjdHguc2hvd1Byb3h5KSB7XG4gIFx0XHRyZXR1cm4gZm9ybWF0UHJveHkoY3R4LCBwcm94eSwgcmVjdXJzZVRpbWVzKTtcbiAgXHR9XG4gIFx0dmFsdWUgPSBwcm94eVswXTtcbiAgfVxuICAqL1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdC5cblxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QpIHtcbiAgICBjb25zdCBtYXliZUN1c3RvbSA9IHZhbHVlW2N1c3RvbUluc3BlY3RTeW1ib2xdO1xuXG4gICAgaWYgKHR5cGVvZiBtYXliZUN1c3RvbSA9PT0gJ2Z1bmN0aW9uJyAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXRzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbC5cbiAgICAmJiBtYXliZUN1c3RvbSAhPT0gaW5zcGVjdCAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAmJiAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhlIHJlY3Vyc2VUaW1lcyBhcmUgcmVwb3J0ZWQgYXMgYmVmb3JlIHdoaWxlIHVzaW5nXG4gICAgICAvLyBhIGNvdW50ZXIgaW50ZXJuYWxseS5cbiAgICAgIGNvbnN0IGRlcHRoID0gY3R4LmRlcHRoID09PSBudWxsID8gbnVsbCA6IGN0eC5kZXB0aCAtIHJlY3Vyc2VUaW1lcztcbiAgICAgIGNvbnN0IHJldCA9IG1heWJlQ3VzdG9tLmNhbGwoY29udGV4dCwgZGVwdGgsIGdldFVzZXJPcHRpb25zKGN0eCkpOyAvLyBJZiB0aGUgY3VzdG9tIGluc3BlY3Rpb24gbWV0aG9kIHJldHVybmVkIGB0aGlzYCwgZG9uJ3QgZ28gaW50b1xuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gICAgICBpZiAocmV0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQucmVwbGFjZSgvXFxuL2csIGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gVXNpbmcgYW4gYXJyYXkgaGVyZSBpcyBhY3R1YWxseSBiZXR0ZXIgZm9yIHRoZSBhdmVyYWdlIGNhc2UgdGhhbiB1c2luZ1xuICAvLyBhIFNldC4gYHNlZW5gIHdpbGwgb25seSBjaGVjayBmb3IgdGhlIGRlcHRoIGFuZCB3aWxsIG5ldmVyIGdyb3cgdG9vIGxhcmdlLlxuXG5cbiAgaWYgKGN0eC5zZWVuLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgIGxldCBpbmRleCA9IDE7XG5cbiAgICBpZiAoY3R4LmNpcmN1bGFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5jaXJjdWxhciA9IG5ldyBNYXAoW1t2YWx1ZSwgaW5kZXhdXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLmdldCh2YWx1ZSk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gY3R4LmNpcmN1bGFyLnNpemUgKyAxO1xuICAgICAgICBjdHguY2lyY3VsYXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGBbQ2lyY3VsYXIgKiR7aW5kZXh9XWAsICdzcGVjaWFsJyk7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0UmF3KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdHlwZWRBcnJheSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFJhdyhjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHR5cGVkQXJyYXkpIHtcbiAgbGV0IGtleXM7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3JOYW1lKHZhbHVlKTtcbiAgbGV0IHRhZyA9IHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ107IC8vIE9ubHkgbGlzdCB0aGUgdGFnIGluIGNhc2UgaXQncyBub24tZW51bWVyYWJsZSAvIG5vdCBhbiBvd24gcHJvcGVydHkuXG4gIC8vIE90aGVyd2lzZSB3ZSdkIHByaW50IHRoaXMgdHdpY2UuXG5cbiAgaWYgKHR5cGVvZiB0YWcgIT09ICdzdHJpbmcnIHx8IHRhZyAhPT0gJycgJiYgKGN0eC5zaG93SGlkZGVuID8gaGFzT3duUHJvcGVydHkgOiBwcm9wZXJ0eUlzRW51bWVyYWJsZSkodmFsdWUsIFN5bWJvbC50b1N0cmluZ1RhZykpIHtcbiAgICB0YWcgPSAnJztcbiAgfVxuXG4gIGxldCBiYXNlID0gJyc7XG4gIGxldCBmb3JtYXR0ZXIgPSBnZXRFbXB0eUZvcm1hdEFycmF5O1xuICBsZXQgYnJhY2VzO1xuICBsZXQgbm9JdGVyYXRvciA9IHRydWU7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgZmlsdGVyID0gY3R4LnNob3dIaWRkZW4gPyBBTExfUFJPUEVSVElFUyQyIDogT05MWV9FTlVNRVJBQkxFJDI7XG4gIGxldCBleHRyYXNUeXBlID0ga09iamVjdFR5cGU7IC8vIEl0ZXJhdG9ycyBhbmQgdGhlIHJlc3QgYXJlIHNwbGl0IHRvIHJlZHVjZSBjaGVja3MuXG5cbiAgaWYgKHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICBub0l0ZXJhdG9yID0gZmFsc2U7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUsIGZpbHRlcik7IC8vIE9ubHkgc2V0IHRoZSBjb25zdHJ1Y3RvciBmb3Igbm9uIG9yZGluYXJ5IChcIkFycmF5IFsuLi5dXCIpIGFycmF5cy5cblxuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdBcnJheScpO1xuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeCA9PT0gJ0FycmF5ICcgPyAnJyA6IHByZWZpeH1bYCwgJ10nXTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfV1gO1xuICAgICAgfVxuXG4gICAgICBleHRyYXNUeXBlID0ga0FycmF5RXh0cmFzVHlwZTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5O1xuICAgIH0gZWxzZSBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgICBrZXlzID0gZ2V0S2V5cyh2YWx1ZSwgY3R4LnNob3dIaWRkZW4pO1xuICAgICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdTZXQnKTtcblxuICAgICAgaWYgKHZhbHVlLnNpemUgPT09IDAgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH17fWA7XG4gICAgICB9XG5cbiAgICAgIGJyYWNlcyA9IFtgJHtwcmVmaXh9e2AsICd9J107XG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRTZXQ7XG4gICAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRLZXlzKHZhbHVlLCBjdHguc2hvd0hpZGRlbik7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ01hcCcpO1xuXG4gICAgICBpZiAodmFsdWUuc2l6ZSA9PT0gMCAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXt9YDtcbiAgICAgIH1cblxuICAgICAgYnJhY2VzID0gW2Ake3ByZWZpeH17YCwgJ30nXTtcbiAgICAgIGZvcm1hdHRlciA9IGZvcm1hdE1hcDtcbiAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGtleXMgPSBnZXRPd25Ob25JbmRleFByb3BlcnRpZXModmFsdWUsIGZpbHRlcik7XG4gICAgICBjb25zdCBwcmVmaXggPSBjb25zdHJ1Y3RvciAhPT0gbnVsbCA/IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnKSA6IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBmaW5kVHlwZWRDb25zdHJ1Y3Rvcih2YWx1ZSkubmFtZSk7XG4gICAgICBicmFjZXMgPSBbYCR7cHJlZml4fVtgLCAnXSddO1xuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmIGtleXMubGVuZ3RoID09PSAwICYmICFjdHguc2hvd0hpZGRlbikge1xuICAgICAgICByZXR1cm4gYCR7YnJhY2VzWzBdfV1gO1xuICAgICAgfVxuXG4gICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRUeXBlZEFycmF5O1xuICAgICAgZXh0cmFzVHlwZSA9IGtBcnJheUV4dHJhc1R5cGU7XG4gICAgfSBlbHNlIGlmIChpc01hcEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdNYXAnLCB0YWcpO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgfSBlbHNlIGlmIChpc1NldEl0ZXJhdG9yKHZhbHVlKSkge1xuICAgICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdTZXQnLCB0YWcpO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0SXRlcmF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vSXRlcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub0l0ZXJhdG9yKSB7XG4gICAga2V5cyA9IGdldEtleXModmFsdWUsIGN0eC5zaG93SGlkZGVuKTtcbiAgICBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gICAgaWYgKGNvbnN0cnVjdG9yID09PSAnT2JqZWN0Jykge1xuICAgICAgaWYgKGlzQXJndW1lbnRzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBicmFjZXNbMF0gPSAnW0FyZ3VtZW50c10geyc7XG4gICAgICB9IGVsc2UgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdPYmplY3QnKX17YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBgJHticmFjZXNbMF19fWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJhc2UgPSBnZXRGdW5jdGlvbkJhc2UodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdzcGVjaWFsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLXJlZ2V4cFxuICAgICAgY29uc3QgcmVnRXhwID0gY29uc3RydWN0b3IgIT09IG51bGwgPyB2YWx1ZSA6IG5ldyBSZWdFeHAodmFsdWUpO1xuICAgICAgYmFzZSA9IFJlZ0V4cFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlZ0V4cCk7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1JlZ0V4cCcpO1xuXG4gICAgICBpZiAocHJlZml4ICE9PSAnUmVnRXhwICcpIHtcbiAgICAgICAgYmFzZSA9IGAke3ByZWZpeH0ke2Jhc2V9YDtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwIHx8IHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdyZWdleHAnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICAgICAgYmFzZSA9IE51bWJlci5pc05hTihEYXRlUHJvdG90eXBlLmdldFRpbWUuY2FsbCh2YWx1ZSkpID8gRGF0ZVByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA6IERhdGVQcm90b3R5cGUudG9JU09TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBjb25zdCBwcmVmaXggPSBnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ0RhdGUnKTtcblxuICAgICAgaWYgKHByZWZpeCAhPT0gJ0RhdGUgJykge1xuICAgICAgICBiYXNlID0gYCR7cHJlZml4fSR7YmFzZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsICdkYXRlJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgYmFzZSA9IGZvcm1hdEVycm9yKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnLCBjdHgpO1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzSW9zKSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVycm9yUHJvcHMgPSBbJ2xpbmUnLCAnY29sdW1uJywgJ3NvdXJjZVVSTCddO1xuXG4gICAgICAgIGlmIChrZXlzLmV2ZXJ5KGtleSA9PiBuYXRpdmVFcnJvclByb3BzLmluY2x1ZGVzKGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQW55QXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIEFycmF5QnVmZmVyIGFuZCBTaGFyZWRBcnJheUJ1ZmZlci5cbiAgICAgIC8vIENhbid0IGRvIHRoZSBzYW1lIGZvciBEYXRhVmlldyBiZWNhdXNlIGl0IGhhcyBhIG5vbi1wcmltaXRpdmVcbiAgICAgIC8vIC5idWZmZXIgcHJvcGVydHkgdGhhdCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZm9yLlxuICAgICAgY29uc3QgYXJyYXlUeXBlID0gaXNBcnJheUJ1ZmZlcih2YWx1ZSkgPyAnQXJyYXlCdWZmZXInIDogJ1NoYXJlZEFycmF5QnVmZmVyJztcbiAgICAgIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCBhcnJheVR5cGUpO1xuXG4gICAgICBpZiAodHlwZWRBcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEFycmF5QnVmZmVyO1xuICAgICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fXsgYnl0ZUxlbmd0aDogJHtmb3JtYXROdW1iZXIoY3R4LnN0eWxpemUsIHZhbHVlLmJ5dGVMZW5ndGgpfSB9YDtcbiAgICAgIH1cblxuICAgICAgYnJhY2VzWzBdID0gYCR7cHJlZml4fXtgO1xuICAgICAga2V5cy51bnNoaWZ0KCdieXRlTGVuZ3RoJyk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGFWaWV3KHZhbHVlKSkge1xuICAgICAgYnJhY2VzWzBdID0gYCR7Z2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsICdEYXRhVmlldycpfXtgOyAvLyAuYnVmZmVyIGdvZXMgbGFzdCwgaXQncyBub3QgYSBwcmltaXRpdmUgbGlrZSB0aGUgb3RoZXJzLlxuXG4gICAgICBrZXlzLnVuc2hpZnQoJ2J5dGVMZW5ndGgnLCAnYnl0ZU9mZnNldCcsICdidWZmZXInKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnUHJvbWlzZScpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gZm9ybWF0UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKGlzV2Vha1NldCh2YWx1ZSkpIHtcbiAgICAgIGJyYWNlc1swXSA9IGAke2dldFByZWZpeChjb25zdHJ1Y3RvciwgdGFnLCAnV2Vha1NldCcpfXtgO1xuICAgICAgZm9ybWF0dGVyID0gY3R4LnNob3dIaWRkZW4gPyBmb3JtYXRXZWFrU2V0IDogZm9ybWF0V2Vha0NvbGxlY3Rpb247XG4gICAgfSBlbHNlIGlmIChpc1dlYWtNYXAodmFsdWUpKSB7XG4gICAgICBicmFjZXNbMF0gPSBgJHtnZXRQcmVmaXgoY29uc3RydWN0b3IsIHRhZywgJ1dlYWtNYXAnKX17YDtcbiAgICAgIGZvcm1hdHRlciA9IGN0eC5zaG93SGlkZGVuID8gZm9ybWF0V2Vha01hcCA6IGZvcm1hdFdlYWtDb2xsZWN0aW9uO1xuICAgICAgLypcbiAgICAgICAqIEBmaXhtZSBob3cgdG8gZG8gaXNNb2R1bGVOYW1lc3BhY2VPYmplY3Q/XG4gICAgICB9IGVsc2UgaWYgKGlzTW9kdWxlTmFtZXNwYWNlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXHRicmFjZXNbMF0gPSBgWyR7dGFnfV0ge2A7XG4gICAgICBcdGZvcm1hdHRlciA9IGZvcm1hdE5hbWVzcGFjZU9iamVjdDtcbiAgICAgICovXG4gICAgfSBlbHNlIGlmIChpc0JveGVkUHJpbWl0aXZlKHZhbHVlKSkge1xuICAgICAgYmFzZSA9IGdldEJveGVkQmFzZSh2YWx1ZSwgY3R4LCBrZXlzLCBjb25zdHJ1Y3RvciwgdGFnKTtcblxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgaW5wdXQgcHJvdG90eXBlIGdvdCBtYW5pcHVsYXRlZC4gU3BlY2lhbCBoYW5kbGUgdGhlc2UuIFdlIGhhdmUgdG9cbiAgICAgIC8vIHJlYnVpbGQgdGhlIGluZm9ybWF0aW9uIHNvIHdlIGFyZSBhYmxlIHRvIGRpc3BsYXkgZXZlcnl0aGluZy5cbiAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBzcGVjaWFsSXRlcmF0b3IgPSBub1Byb3RvdHlwZUl0ZXJhdG9yKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcyk7XG5cbiAgICAgICAgaWYgKHNwZWNpYWxJdGVyYXRvcikge1xuICAgICAgICAgIHJldHVybiBzcGVjaWFsSXRlcmF0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWFwSXRlcmF0b3IodmFsdWUpKSB7XG4gICAgICAgIGJyYWNlcyA9IGdldEl0ZXJhdG9yQnJhY2VzKCdNYXAnLCB0YWcpO1xuICAgICAgICBmb3JtYXR0ZXIgPSBmb3JtYXRJdGVyYXRvcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZXRJdGVyYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgYnJhY2VzID0gZ2V0SXRlcmF0b3JCcmFjZXMoJ1NldCcsIHRhZyk7XG4gICAgICAgIGZvcm1hdHRlciA9IGZvcm1hdEl0ZXJhdG9yOyAvLyBIYW5kbGUgb3RoZXIgcmVndWxhciBvYmplY3RzIGFnYWluLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2dldEN0eFN0eWxlKHZhbHVlLCBjb25zdHJ1Y3RvciwgdGFnKX17fWA7XG4gICAgICAgIH1cblxuICAgICAgICBicmFjZXNbMF0gPSBgJHtnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZyl9e2A7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA+IGN0eC5kZXB0aCAmJiBjdHguZGVwdGggIT09IG51bGwpIHtcbiAgICBsZXQgY29uc3RydWN0b3JOYW1lID0gZ2V0Q3R4U3R5bGUodmFsdWUsIGNvbnN0cnVjdG9yLCB0YWcpLnNsaWNlKDAsIC0xKTtcblxuICAgIGlmIChjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgICAgY29uc3RydWN0b3JOYW1lID0gYFske2NvbnN0cnVjdG9yTmFtZX1dYDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3R4LnN0eWxpemUoY29uc3RydWN0b3JOYW1lLCAnc3BlY2lhbCcpO1xuICB9XG5cbiAgcmVjdXJzZVRpbWVzICs9IDE7XG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuICBjdHguY3VycmVudERlcHRoID0gcmVjdXJzZVRpbWVzO1xuICBsZXQgb3V0cHV0O1xuICBjb25zdCBpbmRlbnRhdGlvbkx2bCA9IGN0eC5pbmRlbnRhdGlvbkx2bDtcblxuICB0cnkge1xuICAgIG91dHB1dCA9IGZvcm1hdHRlcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleXMsIGJyYWNlcyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCBrZXlzW2ldLCBleHRyYXNUeXBlKSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBnZXRDdHhTdHlsZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykuc2xpY2UoMCwgLTEpO1xuICAgIHJldHVybiBoYW5kbGVNYXhDYWxsU3RhY2tTaXplKGN0eCwgZXJyLCBjb25zdHJ1Y3Rvck5hbWUsIGluZGVudGF0aW9uTHZsKTtcbiAgfVxuXG4gIGlmIChjdHguY2lyY3VsYXIgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGluZGV4ID0gY3R4LmNpcmN1bGFyLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgcmVmZXJlbmNlID0gY3R4LnN0eWxpemUoYDxyZWYgKiR7aW5kZXh9PmAsICdzcGVjaWFsJyk7IC8vIEFkZCByZWZlcmVuY2UgYWx3YXlzIHRvIHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiB0aGUgb3V0cHV0LlxuXG4gICAgICBpZiAoY3R4LmNvbXBhY3QgIT09IHRydWUpIHtcbiAgICAgICAgYmFzZSA9IGJhc2UgPT09ICcnID8gcmVmZXJlbmNlIDogYCR7cmVmZXJlbmNlfSAke2Jhc2V9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyYWNlc1swXSA9IGAke3JlZmVyZW5jZX0gJHticmFjZXNbMF19YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICBpZiAoY3R4LnNvcnRlZCkge1xuICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBjdHguc29ydGVkID09PSB0cnVlID8gdW5kZWZpbmVkIDogY3R4LnNvcnRlZDtcblxuICAgIGlmIChleHRyYXNUeXBlID09PSBrT2JqZWN0VHlwZSkge1xuICAgICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoY29tcGFyYXRvcik7XG4gICAgfSBlbHNlIGlmIChrZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNvcnRlZCA9IG91dHB1dC5zbGljZShvdXRwdXQubGVuZ3RoIC0ga2V5cy5sZW5ndGgpLnNvcnQoY29tcGFyYXRvcik7XG4gICAgICBvdXRwdXQuc3BsaWNlKG91dHB1dC5sZW5ndGggLSBrZXlzLmxlbmd0aCwga2V5cy5sZW5ndGgsIC4uLnNvcnRlZCk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzID0gcmVkdWNlVG9TaW5nbGVTdHJpbmcoY3R4LCBvdXRwdXQsIGJhc2UsIGJyYWNlcywgZXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzLCB2YWx1ZSk7XG4gIGNvbnN0IGJ1ZGdldCA9IGN0eC5idWRnZXRbY3R4LmluZGVudGF0aW9uTHZsXSB8fCAwO1xuICBjb25zdCBuZXdMZW5ndGggPSBidWRnZXQgKyByZXMubGVuZ3RoO1xuICBjdHguYnVkZ2V0W2N0eC5pbmRlbnRhdGlvbkx2bF0gPSBuZXdMZW5ndGg7IC8vIElmIGFueSBpbmRlbnRhdGlvbkx2bCBleGNlZWRzIHRoaXMgbGltaXQsIGxpbWl0IGZ1cnRoZXIgaW5zcGVjdGluZyB0byB0aGVcbiAgLy8gbWluaW11bS4gT3RoZXJ3aXNlIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtIG1pZ2h0IGNvbnRpbnVlIGluc3BlY3RpbmcgdGhlXG4gIC8vIG9iamVjdCBldmVuIHRob3VnaCB0aGUgbWF4aW11bSBzdHJpbmcgc2l6ZSAofjIgKiogMjggb24gMzIgYml0IHN5c3RlbXMgYW5kXG4gIC8vIH4yICoqIDMwIG9uIDY0IGJpdCBzeXN0ZW1zKSBleGNlZWRlZC4gVGhlIGFjdHVhbCBvdXRwdXQgaXMgbm90IGxpbWl0ZWQgYXRcbiAgLy8gZXhhY3RseSAyICoqIDI3IGJ1dCBhIGJpdCBoaWdoZXIuIFRoaXMgZGVwZW5kcyBvbiB0aGUgb2JqZWN0IHNoYXBlLlxuICAvLyBUaGlzIGxpbWl0IGFsc28gbWFrZXMgc3VyZSB0aGF0IGh1Z2Ugb2JqZWN0cyBkb24ndCBibG9jayB0aGUgZXZlbnQgbG9vcFxuICAvLyBzaWduaWZpY2FudGx5LlxuXG4gIGlmIChuZXdMZW5ndGggPiAyICoqIDI3KSB7XG4gICAgY3R4LmRlcHRoID0gLTE7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckJyYWNlcyh0eXBlLCB0YWcpIHtcbiAgaWYgKHRhZyAhPT0gYCR7dHlwZX0gSXRlcmF0b3JgKSB7XG4gICAgaWYgKHRhZyAhPT0gJycpIHtcbiAgICAgIHRhZyArPSAnXSBbJztcbiAgICB9XG5cbiAgICB0YWcgKz0gYCR7dHlwZX0gSXRlcmF0b3JgO1xuICB9XG5cbiAgcmV0dXJuIFtgWyR7dGFnfV0ge2AsICd9J107XG59XG5cbmZ1bmN0aW9uIGdldEJveGVkQmFzZSh2YWx1ZSwgY3R4LCBrZXlzLCBjb25zdHJ1Y3RvciwgdGFnKSB7XG4gIGxldCBmbjtcbiAgbGV0IHR5cGU7XG5cbiAgaWYgKGlzTnVtYmVyT2JqZWN0KHZhbHVlKSkge1xuICAgIGZuID0gTnVtYmVyUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnTnVtYmVyJztcbiAgfSBlbHNlIGlmIChpc1N0cmluZ09iamVjdCh2YWx1ZSkpIHtcbiAgICBmbiA9IFN0cmluZ1Byb3RvdHlwZTtcbiAgICB0eXBlID0gJ1N0cmluZyc7IC8vIEZvciBib3hlZCBTdHJpbmdzLCB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgMC1uIGluZGV4ZWQgZW50cmllcyxcbiAgICAvLyBzaW5jZSB0aGV5IGp1c3Qgbm9pc3kgdXAgdGhlIG91dHB1dCBhbmQgYXJlIHJlZHVuZGFudFxuICAgIC8vIE1ha2UgYm94ZWQgcHJpbWl0aXZlIFN0cmluZ3MgbG9vayBsaWtlIHN1Y2hcblxuICAgIGtleXMuc3BsaWNlKDAsIHZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAoaXNCb29sZWFuT2JqZWN0KHZhbHVlKSkge1xuICAgIGZuID0gQm9vbGVhblByb3RvdHlwZTtcbiAgICB0eXBlID0gJ0Jvb2xlYW4nO1xuICB9IGVsc2Uge1xuICAgIGZuID0gU3ltYm9sUHJvdG90eXBlO1xuICAgIHR5cGUgPSAnU3ltYm9sJztcbiAgfVxuXG4gIGxldCBiYXNlID0gYFske3R5cGV9YDtcblxuICBpZiAodHlwZSAhPT0gY29uc3RydWN0b3IpIHtcbiAgICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwpIHtcbiAgICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSArPSBgICgke2NvbnN0cnVjdG9yfSlgO1xuICAgIH1cbiAgfVxuXG4gIGJhc2UgKz0gYDogJHtmb3JtYXRQcmltaXRpdmUoc3R5bGl6ZU5vQ29sb3IsIGZuLnZhbHVlT2YodmFsdWUpLCBjdHgpfV1gO1xuXG4gIGlmICh0YWcgIT09ICcnICYmIHRhZyAhPT0gY29uc3RydWN0b3IpIHtcbiAgICBiYXNlICs9IGAgWyR7dGFnfV1gO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoICE9PSAwIHx8IGN0eC5zdHlsaXplID09PSBzdHlsaXplTm9Db2xvcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG5cbiAgcmV0dXJuIGN0eC5zdHlsaXplKGJhc2UsIHR5cGUudG9Mb3dlckNhc2UoKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQmFzZSh2YWx1ZSwgY29uc3RydWN0b3IsIHRhZykge1xuICBsZXQgdHlwZSA9ICdGdW5jdGlvbic7XG5cbiAgaWYgKGlzR2VuZXJhdG9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdHlwZSA9IGBHZW5lcmF0b3Ike3R5cGV9YDtcbiAgfVxuXG4gIGlmIChpc0FzeW5jRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdHlwZSA9IGBBc3luYyR7dHlwZX1gO1xuICB9XG5cbiAgbGV0IGJhc2UgPSBgWyR7dHlwZX1gO1xuXG4gIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgIGJhc2UgKz0gJyAobnVsbCBwcm90b3R5cGUpJztcbiAgfVxuXG4gIGlmICh2YWx1ZS5uYW1lID09PSAnJykge1xuICAgIGJhc2UgKz0gJyAoYW5vbnltb3VzKSc7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSArPSBgOiAke3ZhbHVlLm5hbWV9YDtcbiAgfVxuXG4gIGJhc2UgKz0gJ10nO1xuXG4gIGlmIChjb25zdHJ1Y3RvciAhPT0gdHlwZSAmJiBjb25zdHJ1Y3RvciAhPT0gbnVsbCkge1xuICAgIGJhc2UgKz0gYCAke2NvbnN0cnVjdG9yfWA7XG4gIH1cblxuICBpZiAodGFnICE9PSAnJyAmJiBjb25zdHJ1Y3RvciAhPT0gdGFnKSB7XG4gICAgYmFzZSArPSBgIFske3RhZ31dYDtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnIsIGNvbnN0cnVjdG9yLCB0YWcsIGN0eCkge1xuICBsZXQgc3RhY2sgPSBlcnIuc3RhY2sgfHwgRXJyb3JQcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpOyAvLyB0cnkgdG8gbm9ybWFsaXplIEphdmFTY3JpcHRDb3JlIHN0YWNrIHRvIG1hdGNoIHY4XG5cbiAgaWYgKGlzSW9zKSB7XG4gICAgY29uc3QgbGluZXMgPSBzdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgc3RhY2sgPSBgJHtlcnIubmFtZX06ICR7ZXJyLm1lc3NhZ2V9YDtcblxuICAgIGlmIChsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFjayArPSBsaW5lcy5tYXAoc3RhY2tMaW5lID0+IHtcbiAgICAgICAgY29uc3QgYXRTeW1ib2xJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCdAJyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHN0YWNrTGluZS5zbGljZShhdFN5bWJvbEluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVBhdHRlcm4gPSAvKC4qKTooXFxkKyk6KFxcZCspLztcbiAgICAgICAgbGV0IHN5bWJvbE5hbWUgPSAndW5rbm93bic7XG5cbiAgICAgICAgaWYgKGF0U3ltYm9sSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgc3ltYm9sTmFtZSA9IHN0YWNrTGluZS5zbGljZSgwLCBhdFN5bWJvbEluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNvdXJjZU1hdGNoID0gc291cmNlLm1hdGNoKHNvdXJjZVBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChzb3VyY2VNYXRjaCkge1xuICAgICAgICAgIGxldCBmaWxlUGF0aCA9IHNvdXJjZU1hdGNoWzFdO1xuICAgICAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBzb3VyY2VNYXRjaFsyXTtcbiAgICAgICAgICBjb25zdCBjb2x1bW4gPSBzb3VyY2VNYXRjaFszXTtcblxuICAgICAgICAgIGlmIChmaWxlUGF0aC5zdGFydHNXaXRoKCdmaWxlOicpKSB7XG4gICAgICAgICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnJlcGxhY2UoYGZpbGU6Ly8ke1RpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5fWAsICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYFxcbiAgICBhdCAke3N5bWJvbE5hbWV9ICgke2ZpbGVQYXRofToke2xpbmVOdW1iZXJ9OiR7Y29sdW1ufSlgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgXFxuICAgIGF0ICR7c3ltYm9sTmFtZX0gKCR7c291cmNlfSlgO1xuICAgICAgICB9XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gIH0gLy8gQSBzdGFjayB0cmFjZSBtYXkgY29udGFpbiBhcmJpdHJhcnkgZGF0YS4gT25seSBtYW5pcHVsYXRlIHRoZSBvdXRwdXRcbiAgLy8gZm9yIFwicmVndWxhciBlcnJvcnNcIiAoZXJyb3JzIHRoYXQgXCJsb29rIG5vcm1hbFwiKSBmb3Igbm93LlxuXG5cbiAgY29uc3QgbmFtZSA9IGVyci5uYW1lIHx8ICdFcnJvcic7XG4gIGxldCBsZW4gPSBuYW1lLmxlbmd0aDtcblxuICBpZiAoY29uc3RydWN0b3IgPT09IG51bGwgfHwgbmFtZS5lbmRzV2l0aCgnRXJyb3InKSAmJiBzdGFjay5zdGFydHNXaXRoKG5hbWUpICYmIChzdGFjay5sZW5ndGggPT09IGxlbiB8fCBzdGFja1tsZW5dID09PSAnOicgfHwgc3RhY2tbbGVuXSA9PT0gJ1xcbicpKSB7XG4gICAgbGV0IGZhbGxiYWNrID0gJ0Vycm9yJztcblxuICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RhcnQgPSBzdGFjay5tYXRjaCgvXihbQS1aXVthLXpfIEEtWjAtOVtcXF0oKS1dKykoPzo6fFxcbiB7NH1hdCkvKSB8fCBzdGFjay5tYXRjaCgvXihbYS16X0EtWjAtOS1dKkVycm9yKSQvKTtcbiAgICAgIGZhbGxiYWNrID0gc3RhcnQgJiYgc3RhcnRbMV0gfHwgJyc7XG4gICAgICBsZW4gPSBmYWxsYmFjay5sZW5ndGg7XG4gICAgICBmYWxsYmFjayA9IGZhbGxiYWNrIHx8ICdFcnJvcic7XG4gICAgfVxuXG4gICAgY29uc3QgcHJlZml4ID0gZ2V0UHJlZml4KGNvbnN0cnVjdG9yLCB0YWcsIGZhbGxiYWNrKS5zbGljZSgwLCAtMSk7XG5cbiAgICBpZiAobmFtZSAhPT0gcHJlZml4KSB7XG4gICAgICBpZiAocHJlZml4LmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICBzdGFjayA9IGAke3ByZWZpeH06ICR7c3RhY2t9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFjayA9IGAke3ByZWZpeH0ke3N0YWNrLnNsaWNlKGxlbil9YDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2sgPSBgJHtwcmVmaXh9IFske25hbWV9XSR7c3RhY2suc2xpY2UobGVuKX1gO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZ25vcmUgdGhlIGVycm9yIG1lc3NhZ2UgaWYgaXQncyBjb250YWluZWQgaW4gdGhlIHN0YWNrLlxuXG5cbiAgbGV0IHBvcyA9IGVyci5tZXNzYWdlICYmIHN0YWNrLmluZGV4T2YoZXJyLm1lc3NhZ2UpIHx8IC0xO1xuXG4gIGlmIChwb3MgIT09IC0xKSB7XG4gICAgcG9zICs9IGVyci5tZXNzYWdlLmxlbmd0aDtcbiAgfSAvLyBXcmFwIHRoZSBlcnJvciBpbiBicmFja2V0cyBpbiBjYXNlIGl0IGhhcyBubyBzdGFjayB0cmFjZS5cblxuXG4gIGxldCBzdGFja1N0YXJ0ID0gc3RhY2suaW5kZXhPZignXFxuICAgIGF0JywgcG9zKTtcblxuICBpZiAoc3RhY2tTdGFydCA9PT0gLTEpIHtcbiAgICBzdGFjayA9IGBbJHtzdGFja31dYDtcbiAgfSBlbHNlIGlmIChjdHguY29sb3JzKSB7XG4gICAgLy8gSGlnaGxpZ2h0IHVzZXJsYW5kIGNvZGUgYW5kIG5vZGUgbW9kdWxlcy5cbiAgICBsZXQgbmV3U3RhY2sgPSBzdGFjay5zbGljZSgwLCBzdGFja1N0YXJ0KTtcbiAgICBjb25zdCBsaW5lcyA9IHN0YWNrLnNsaWNlKHN0YWNrU3RhcnQgKyAxKS5zcGxpdCgnXFxuJyk7XG5cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIC8vIFRoaXMgYWRkcyB1bmRlcnNjb3JlcyB0byBhbGwgbm9kZV9tb2R1bGVzIHRvIHF1aWNrbHkgaWRlbnRpZnkgdGhlbS5cbiAgICAgIGxldCBub2RlTW9kdWxlO1xuICAgICAgbmV3U3RhY2sgKz0gJ1xcbic7XG4gICAgICBsZXQgcG9zID0gMDtcblxuICAgICAgd2hpbGUgKG5vZGVNb2R1bGUgPSBub2RlTW9kdWxlc1JlZ0V4cC5leGVjKGxpbmUpKSB7XG4gICAgICAgIC8vICcvbm9kZV9tb2R1bGVzLycubGVuZ3RoID09PSAxNFxuICAgICAgICBuZXdTdGFjayArPSBsaW5lLnNsaWNlKHBvcywgbm9kZU1vZHVsZS5pbmRleCArIDE0KTtcbiAgICAgICAgbmV3U3RhY2sgKz0gY3R4LnN0eWxpemUobm9kZU1vZHVsZVsxXSwgJ21vZHVsZScpO1xuICAgICAgICBwb3MgPSBub2RlTW9kdWxlLmluZGV4ICsgbm9kZU1vZHVsZVswXS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIG5ld1N0YWNrICs9IHBvcyA9PT0gMCA/IGxpbmUgOiBsaW5lLnNsaWNlKHBvcyk7XG4gICAgfVxuXG4gICAgc3RhY2sgPSBuZXdTdGFjaztcbiAgfSAvLyBUaGUgbWVzc2FnZSBhbmQgdGhlIHN0YWNrIGhhdmUgdG8gYmUgaW5kZW50ZWQgYXMgd2VsbCFcblxuXG4gIGlmIChjdHguaW5kZW50YXRpb25MdmwgIT09IDApIHtcbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9ICcgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKTtcbiAgICBzdGFjayA9IHN0YWNrLnJlcGxhY2UoL1xcbi9nLCBgXFxuJHtpbmRlbnRhdGlvbn1gKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJvbWlzZShjdHgsIF92YWx1ZSwgX3JlY3Vyc2VUaW1lcykge1xuICAvLyBOb2RlIGNhbGxzIGludG8gbmF0aXZlIHRvIGdldCBwcm9taXNlIGRldGFpbHMgd2hpY2ggd2UgY2FuJ3QgZG9cbiAgcmV0dXJuIFtjdHguc3R5bGl6ZSgnPHVua25vd24+JywgJ3NwZWNpYWwnKV07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywga2V5LCB0eXBlKSB7XG4gIGxldCBuYW1lLCBzdHI7XG4gIGxldCBleHRyYSA9ICcgJztcbiAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwge1xuICAgIHZhbHVlOiB2YWx1ZVtrZXldLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfTtcblxuICBpZiAoZGVzYy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgZGlmZiA9IHR5cGUgIT09IGtPYmplY3RUeXBlIHx8IGN0eC5jb21wYWN0ICE9PSB0cnVlID8gMiA6IDM7XG4gICAgY3R4LmluZGVudGF0aW9uTHZsICs9IGRpZmY7XG4gICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMpO1xuXG4gICAgaWYgKGRpZmYgPT09IDMpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGN0eC5jb2xvcnMgPyByZW1vdmVDb2xvcnMoc3RyKS5sZW5ndGggOiBzdHIubGVuZ3RoO1xuXG4gICAgICBpZiAoY3R4LmJyZWFrTGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIGV4dHJhID0gYFxcbiR7JyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpfWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LmluZGVudGF0aW9uTHZsIC09IGRpZmY7XG4gIH0gZWxzZSBpZiAoZGVzYy5nZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxhYmVsID0gZGVzYy5zZXQgIT09IHVuZGVmaW5lZCA/ICdHZXR0ZXIvU2V0dGVyJyA6ICdHZXR0ZXInO1xuICAgIGNvbnN0IHMgPSBjdHguc3R5bGl6ZTtcbiAgICBjb25zdCBzcCA9ICdzcGVjaWFsJztcblxuICAgIGlmIChjdHguZ2V0dGVycyAmJiAoY3R4LmdldHRlcnMgPT09IHRydWUgfHwgY3R4LmdldHRlcnMgPT09ICdnZXQnICYmIGRlc2Muc2V0ID09PSB1bmRlZmluZWQgfHwgY3R4LmdldHRlcnMgPT09ICdzZXQnICYmIGRlc2Muc2V0ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0bXAgPSB2YWx1ZVtrZXldO1xuICAgICAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICAgICAgICBpZiAodG1wID09PSBudWxsKSB7XG4gICAgICAgICAgc3RyID0gYCR7cyhgWyR7bGFiZWx9OmAsIHNwKX0gJHtzKCdudWxsJywgJ251bGwnKX0ke3MoJ10nLCBzcCl9YDtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdG1wID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfV1gLCBzcCl9ICR7Zm9ybWF0VmFsdWUoY3R4LCB0bXAsIHJlY3Vyc2VUaW1lcyl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUocywgdG1wLCBjdHgpO1xuICAgICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7cHJpbWl0aXZlfSR7cygnXScsIHNwKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmluZGVudGF0aW9uTHZsIC09IDI7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGA8SW5zcGVjdGlvbiB0aHJldyAoJHtlcnIubWVzc2FnZX0pPmA7XG4gICAgICAgIHN0ciA9IGAke3MoYFske2xhYmVsfTpgLCBzcCl9ICR7bWVzc2FnZX0ke3MoJ10nLCBzcCl9YDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoYFske2xhYmVsfV1gLCBzcCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlc2Muc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICB9IGVsc2Uge1xuICAgIHN0ciA9IGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIH1cblxuICBpZiAodHlwZSA9PT0ga0FycmF5VHlwZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICBjb25zdCB0bXAgPSBrZXkudG9TdHJpbmcoKS5yZXBsYWNlKHN0ckVzY2FwZVNlcXVlbmNlc1JlcGxhY2VyLCBlc2NhcGVGbik7XG4gICAgbmFtZSA9IGBbJHtjdHguc3R5bGl6ZSh0bXAsICdzeW1ib2wnKX1dYDtcbiAgfSBlbHNlIGlmIChkZXNjLmVudW1lcmFibGUgPT09IGZhbHNlKSB7XG4gICAgbmFtZSA9IGBbJHtrZXkucmVwbGFjZShzdHJFc2NhcGVTZXF1ZW5jZXNSZXBsYWNlciwgZXNjYXBlRm4pfV1gO1xuICB9IGVsc2UgaWYgKGtleVN0clJlZ0V4cC50ZXN0KGtleSkpIHtcbiAgICBuYW1lID0gY3R4LnN0eWxpemUoa2V5LCAnbmFtZScpO1xuICB9IGVsc2Uge1xuICAgIG5hbWUgPSBjdHguc3R5bGl6ZShzdHJFc2NhcGUoa2V5KSwgJ3N0cmluZycpO1xuICB9XG5cbiAgcmV0dXJuIGAke25hbWV9OiR7ZXh0cmF9JHtzdHJ9YDtcbn1cblxuZnVuY3Rpb24gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSkge1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICBsZXQgbWF4TGVuZ3RoID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgb3V0cHV0TGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuICBpZiAoY3R4Lm1heEFycmF5TGVuZ3RoIDwgb3V0cHV0Lmxlbmd0aCkge1xuICAgIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGUgXCIuLi4gbiBtb3JlIGl0ZW1zXCIgcGFydCBpcyBub3QgdGFrZW4gaW50byBhY2NvdW50LlxuICAgIG91dHB1dExlbmd0aC0tO1xuICB9XG5cbiAgY29uc3Qgc2VwYXJhdG9yU3BhY2UgPSAyOyAvLyBBZGQgMSBmb3IgdGhlIHNwYWNlIGFuZCAxIGZvciB0aGUgc2VwYXJhdG9yLlxuXG4gIGNvbnN0IGRhdGFMZW4gPSBuZXcgQXJyYXkob3V0cHV0TGVuZ3RoKTsgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBsZW5ndGggb2YgYWxsIG91dHB1dCBlbnRyaWVzIGFuZCB0aGUgaW5kaXZpZHVhbCBtYXhcbiAgLy8gZW50cmllcyBsZW5ndGggb2YgYWxsIG91dHB1dCBlbnRyaWVzLiBXZSBoYXZlIHRvIHJlbW92ZSBjb2xvcnMgZmlyc3QsXG4gIC8vIG90aGVyd2lzZSB0aGUgbGVuZ3RoIHdvdWxkIG5vdCBiZSBjYWxjdWxhdGVkIHByb3Blcmx5LlxuXG4gIGZvciAoOyBpIDwgb3V0cHV0TGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsZW4gPSBjdHguY29sb3JzID8gcmVtb3ZlQ29sb3JzKG91dHB1dFtpXSkubGVuZ3RoIDogb3V0cHV0W2ldLmxlbmd0aDtcbiAgICBkYXRhTGVuW2ldID0gbGVuO1xuICAgIHRvdGFsTGVuZ3RoICs9IGxlbiArIHNlcGFyYXRvclNwYWNlO1xuXG4gICAgaWYgKG1heExlbmd0aCA8IGxlbikge1xuICAgICAgbWF4TGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfSAvLyBBZGQgdHdvIHRvIGBtYXhMZW5ndGhgIGFzIHdlIGFkZCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3RlciBwbHVzIGEgY29tbWFcbiAgLy8gaW4tYmV0d2VlbiB0d28gZW50cmllcy5cblxuXG4gIGNvbnN0IGFjdHVhbE1heCA9IG1heExlbmd0aCArIHNlcGFyYXRvclNwYWNlOyAvLyBDaGVjayBpZiBhdCBsZWFzdCB0aHJlZSBlbnRyaWVzIGZpdCBuZXh0IHRvIGVhY2ggb3RoZXIgYW5kIHByZXZlbnQgZ3JvdXBpbmdcbiAgLy8gb2YgYXJyYXlzIHRoYXQgY29udGFpbnMgZW50cmllcyBvZiB2ZXJ5IGRpZmZlcmVudCBsZW5ndGggKGkuZS4sIGlmIGEgc2luZ2xlXG4gIC8vIGVudHJ5IGlzIGxvbmdlciB0aGFuIDEvNSBvZiBhbGwgb3RoZXIgZW50cmllcyBjb21iaW5lZCkuIE90aGVyd2lzZSB0aGVcbiAgLy8gc3BhY2UgaW4tYmV0d2VlbiBzbWFsbCBlbnRyaWVzIHdvdWxkIGJlIGVub3Jtb3VzLlxuXG4gIGlmIChhY3R1YWxNYXggKiAzICsgY3R4LmluZGVudGF0aW9uTHZsIDwgY3R4LmJyZWFrTGVuZ3RoICYmICh0b3RhbExlbmd0aCAvIGFjdHVhbE1heCA+IDUgfHwgbWF4TGVuZ3RoIDw9IDYpKSB7XG4gICAgY29uc3QgYXBwcm94Q2hhckhlaWdodHMgPSAyLjU7XG4gICAgY29uc3QgYXZlcmFnZUJpYXMgPSBNYXRoLnNxcnQoYWN0dWFsTWF4IC0gdG90YWxMZW5ndGggLyBvdXRwdXQubGVuZ3RoKTtcbiAgICBjb25zdCBiaWFzZWRNYXggPSBNYXRoLm1heChhY3R1YWxNYXggLSAzIC0gYXZlcmFnZUJpYXMsIDEpOyAvLyBEeW5hbWljYWxseSBjaGVjayBob3cgbWFueSBjb2x1bW5zIHNlZW0gcG9zc2libGUuXG5cbiAgICBjb25zdCBjb2x1bW5zID0gTWF0aC5taW4oIC8vIElkZWFsbHkgYSBzcXVhcmUgc2hvdWxkIGJlIGRyYXduLiBXZSBleHBlY3QgYSBjaGFyYWN0ZXIgdG8gYmUgYWJvdXQgMi41XG4gICAgLy8gdGltZXMgYXMgaGlnaCBhcyB3aWRlLiBUaGlzIGlzIHRoZSBhcmVhIGZvcm11bGEgdG8gY2FsY3VsYXRlIGEgc3F1YXJlXG4gICAgLy8gd2hpY2ggY29udGFpbnMgbiByZWN0YW5nbGVzIG9mIHNpemUgYGFjdHVhbE1heCAqIGFwcHJveENoYXJIZWlnaHRzYC5cbiAgICAvLyBEaXZpZGUgdGhhdCBieSBgYWN0dWFsTWF4YCB0byByZWNlaXZlIHRoZSBjb3JyZWN0IG51bWJlciBvZiBjb2x1bW5zLlxuICAgIC8vIFRoZSBhZGRlZCBiaWFzIGluY3JlYXNlcyB0aGUgY29sdW1ucyBmb3Igc2hvcnQgZW50cmllcy5cbiAgICBNYXRoLnJvdW5kKE1hdGguc3FydChhcHByb3hDaGFySGVpZ2h0cyAqIGJpYXNlZE1heCAqIG91dHB1dExlbmd0aCkgLyBiaWFzZWRNYXgpLCAvLyBEbyBub3QgZXhjZWVkIHRoZSBicmVha0xlbmd0aC5cbiAgICBNYXRoLmZsb29yKChjdHguYnJlYWtMZW5ndGggLSBjdHguaW5kZW50YXRpb25MdmwpIC8gYWN0dWFsTWF4KSwgLy8gTGltaXQgYXJyYXkgZ3JvdXBpbmcgZm9yIHNtYWxsIGBjb21wYWN0YCBtb2RlcyBhcyB0aGUgdXNlciByZXF1ZXN0ZWRcbiAgICAvLyBtaW5pbWFsIGdyb3VwaW5nLlxuICAgIGN0eC5jb21wYWN0ICogNCwgLy8gTGltaXQgdGhlIGNvbHVtbnMgdG8gYSBtYXhpbXVtIG9mIGZpZnRlZW4uXG4gICAgMTUpOyAvLyBSZXR1cm4gd2l0aCB0aGUgb3JpZ2luYWwgb3V0cHV0IGlmIG5vIGdyb3VwaW5nIHNob3VsZCBoYXBwZW4uXG5cbiAgICBpZiAoY29sdW1ucyA8PSAxKSB7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIGNvbnN0IHRtcCA9IFtdO1xuICAgIGNvbnN0IG1heExpbmVMZW5ndGggPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICBsZXQgbGluZU1heExlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgb3V0cHV0Lmxlbmd0aDsgaiArPSBjb2x1bW5zKSB7XG4gICAgICAgIGlmIChkYXRhTGVuW2pdID4gbGluZU1heExlbmd0aCkge1xuICAgICAgICAgIGxpbmVNYXhMZW5ndGggPSBkYXRhTGVuW2pdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpbmVNYXhMZW5ndGggKz0gc2VwYXJhdG9yU3BhY2U7XG4gICAgICBtYXhMaW5lTGVuZ3RoW2ldID0gbGluZU1heExlbmd0aDtcbiAgICB9XG5cbiAgICBsZXQgb3JkZXIgPSAncGFkU3RhcnQnO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JkZXIgPSAncGFkRW5kJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gRWFjaCBpdGVyYXRpb24gY3JlYXRlcyBhIHNpbmdsZSBsaW5lIG9mIGdyb3VwZWQgZW50cmllcy5cblxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRMZW5ndGg7IGkgKz0gY29sdW1ucykge1xuICAgICAgLy8gVGhlIGxhc3QgbGluZXMgbWF5IGNvbnRhaW4gbGVzcyBlbnRyaWVzIHRoYW4gY29sdW1ucy5cbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWluKGkgKyBjb2x1bW5zLCBvdXRwdXRMZW5ndGgpO1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgbGV0IGogPSBpO1xuXG4gICAgICBmb3IgKDsgaiA8IG1heCAtIDE7IGorKykge1xuICAgICAgICAvLyBDYWxjdWxhdGUgZXh0cmEgY29sb3IgcGFkZGluZyBpbiBjYXNlIGl0J3MgYWN0aXZlLiBUaGlzIGhhcyB0byBiZVxuICAgICAgICAvLyBkb25lIGxpbmUgYnkgbGluZSBhcyBzb21lIGxpbmVzIG1pZ2h0IGNvbnRhaW4gbW9yZSBjb2xvcnMgdGhhblxuICAgICAgICAvLyBvdGhlcnMuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBtYXhMaW5lTGVuZ3RoW2ogLSBpXSArIG91dHB1dFtqXS5sZW5ndGggLSBkYXRhTGVuW2pdO1xuICAgICAgICBzdHIgKz0gYCR7b3V0cHV0W2pdfSwgYFtvcmRlcl0ocGFkZGluZywgJyAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yZGVyID09PSAncGFkU3RhcnQnKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBtYXhMaW5lTGVuZ3RoW2ogLSBpXSArIG91dHB1dFtqXS5sZW5ndGggLSBkYXRhTGVuW2pdIC0gc2VwYXJhdG9yU3BhY2U7XG4gICAgICAgIHN0ciArPSBvdXRwdXRbal0ucGFkU3RhcnQocGFkZGluZywgJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciArPSBvdXRwdXRbal07XG4gICAgICB9XG5cbiAgICAgIHRtcC5wdXNoKHN0cik7XG4gICAgfVxuXG4gICAgaWYgKGN0eC5tYXhBcnJheUxlbmd0aCA8IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgIHRtcC5wdXNoKG91dHB1dFtvdXRwdXRMZW5ndGhdKTtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSB0bXA7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXhDYWxsU3RhY2tTaXplKGN0eCwgZXJyLCBjb25zdHJ1Y3Rvck5hbWUsIGluZGVudGF0aW9uTHZsKSB7XG4gIGlmIChpc1N0YWNrT3ZlcmZsb3dFcnJvcihlcnIpKSB7XG4gICAgY3R4LnNlZW4ucG9wKCk7XG4gICAgY3R4LmluZGVudGF0aW9uTHZsID0gaW5kZW50YXRpb25Mdmw7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKGBbJHtjb25zdHJ1Y3Rvck5hbWV9OiBJbnNwZWN0aW9uIGludGVycnVwdGVkICdwcmVtYXR1cmVseS4gTWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWQuXWAsICdzcGVjaWFsJyk7XG4gIH1cblxuICB0aHJvdyBlcnI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihmbiwgdmFsdWUpIHtcbiAgLy8gRm9ybWF0IC0wIGFzICctMCcuIENoZWNraW5nIGB2YWx1ZSA9PT0gLTBgIHdvbid0IGRpc3Rpbmd1aXNoIDAgZnJvbSAtMC5cbiAgcmV0dXJuIGZuKE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wJyA6IGAke3ZhbHVlfWAsICdudW1iZXInKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0QmlnSW50KGZuLCB2YWx1ZSkge1xuICByZXR1cm4gZm4oYCR7dmFsdWV9bmAsICdiaWdpbnQnKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGZuLCB2YWx1ZSwgY3R4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlICYmIHZhbHVlLmxlbmd0aCA+IGtNaW5MaW5lTGVuZ3RoICYmIHZhbHVlLmxlbmd0aCA+IGN0eC5icmVha0xlbmd0aCAtIGN0eC5pbmRlbnRhdGlvbkx2bCAtIDQpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5zcGxpdCgvXFxuLykubWFwKGxpbmUgPT4gZm4oc3RyRXNjYXBlKGxpbmUpLCAnc3RyaW5nJykpLmpvaW4oYCArXFxuJHsnICcucmVwZWF0KGN0eC5pbmRlbnRhdGlvbkx2bCArIDIpfWApO1xuICAgIH1cblxuICAgIHJldHVybiBmbihzdHJFc2NhcGUodmFsdWUpLCAnc3RyaW5nJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIoZm4sIHZhbHVlKTtcbiAgfVxuICAvKlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICBcdHJldHVybiBmb3JtYXRCaWdJbnQoZm4sIHZhbHVlKTtcbiAgfVxuICAqL1xuXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIGZuKGAke3ZhbHVlfWAsICdib29sZWFuJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmbigndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICB9IC8vIGVzNiBzeW1ib2wgcHJpbWl0aXZlXG5cblxuICByZXR1cm4gZm4oU3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnc3ltYm9sJyk7XG59IC8vIFRoZSBhcnJheSBpcyBzcGFyc2UgYW5kL29yIGhhcyBleHRyYSBrZXlzXG5cblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lhbEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgbWF4TGVuZ3RoLCBvdXRwdXQsIGkpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgbGV0IGluZGV4ID0gaTtcblxuICBmb3IgKDsgaSA8IGtleXMubGVuZ3RoICYmIG91dHB1dC5sZW5ndGggPCBtYXhMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgY29uc3QgdG1wID0gK2tleTsgLy8gQXJyYXlzIGNhbiBvbmx5IGhhdmUgdXAgdG8gMl4zMiAtIDEgZW50cmllc1xuXG4gICAgaWYgKHRtcCA+IDIgKiogMzIgLSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoYCR7aW5kZXh9YCAhPT0ga2V5KSB7XG4gICAgICBpZiAoIW51bWJlclJlZ0V4cC50ZXN0KGtleSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVtcHR5SXRlbXMgPSB0bXAgLSBpbmRleDtcbiAgICAgIGNvbnN0IGVuZGluZyA9IGVtcHR5SXRlbXMgPiAxID8gJ3MnIDogJyc7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYDwke2VtcHR5SXRlbXN9IGVtcHR5IGl0ZW0ke2VuZGluZ30+YDtcbiAgICAgIG91dHB1dC5wdXNoKGN0eC5zdHlsaXplKG1lc3NhZ2UsICd1bmRlZmluZWQnKSk7XG4gICAgICBpbmRleCA9IHRtcDtcblxuICAgICAgaWYgKG91dHB1dC5sZW5ndGggPT09IG1heExlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIGtleSwga0FycmF5VHlwZSkpO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB2YWx1ZS5sZW5ndGggLSBpbmRleDtcblxuICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gbWF4TGVuZ3RoKSB7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGNvbnN0IGVuZGluZyA9IHJlbWFpbmluZyA+IDEgPyAncycgOiAnJztcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgPCR7cmVtYWluaW5nfSBlbXB0eSBpdGVtJHtlbmRpbmd9PmA7XG4gICAgICBvdXRwdXQucHVzaChjdHguc3R5bGl6ZShtZXNzYWdlLCAndW5kZWZpbmVkJykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheUJ1ZmZlcihjdHgsIHZhbHVlKSB7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgLypcbiAgLy8gQGZpeG1lIHJvbGx1cCBjYW5ub3QgaGFuZGxlIGxhenkgbG9hZGVkIG1vZHVsZXMsIG1heWJlIG1vdmUgdG8gd2VicGFjaz9cbiAgaWYgKGhleFNsaWNlID09PSB1bmRlZmluZWQpIHtcbiAgXHRoZXhTbGljZSA9IHVuY3VycnlUaGlzKHJlcXVpcmUoJy4uLy4uL2J1ZmZlcicpLmRlZmF1bHQuQnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSk7XG4gIH1cbiAgKi9cblxuICBsZXQgc3RyID0gaGV4U2xpY2UoYnVmZmVyLCAwLCBNYXRoLm1pbihjdHgubWF4QXJyYXlMZW5ndGgsIGJ1ZmZlci5sZW5ndGgpKS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKTtcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmZmVyLmxlbmd0aCAtIGN0eC5tYXhBcnJheUxlbmd0aDtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIHN0ciArPSBgIC4uLiAke3JlbWFpbmluZ30gbW9yZSBieXRlJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YDtcbiAgfVxuXG4gIHJldHVybiBbYCR7Y3R4LnN0eWxpemUoJ1tVaW50OENvbnRlbnRzXScsICdzcGVjaWFsJyl9OiA8JHtzdHJ9PmBdO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3QgdmFsTGVuID0gdmFsdWUubGVuZ3RoO1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihNYXRoLm1heCgwLCBjdHgubWF4QXJyYXlMZW5ndGgpLCB2YWxMZW4pO1xuICBjb25zdCByZW1haW5pbmcgPSB2YWxMZW4gLSBsZW47XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBTcGVjaWFsIGhhbmRsZSBzcGFyc2UgYXJyYXlzLlxuICAgIGlmICghaGFzT3duUHJvcGVydHkodmFsdWUsIGkpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0U3BlY2lhbEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgbGVuLCBvdXRwdXQsIGkpO1xuICAgIH1cblxuICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgaSwga0FycmF5VHlwZSkpO1xuICB9XG5cbiAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICBvdXRwdXQucHVzaChgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFR5cGVkQXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGN0eC5tYXhBcnJheUxlbmd0aCksIHZhbHVlLmxlbmd0aCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IHZhbHVlLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGNvbnN0IGVsZW1lbnRGb3JtYXR0ZXIgPSB2YWx1ZS5sZW5ndGggPiAwICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicgPyBmb3JtYXROdW1iZXIgOiBmb3JtYXRCaWdJbnQ7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhMZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFtpXSA9IGVsZW1lbnRGb3JtYXR0ZXIoY3R4LnN0eWxpemUsIHZhbHVlW2ldKTtcbiAgfVxuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0W21heExlbmd0aF0gPSBgLi4uICR7cmVtYWluaW5nfSBtb3JlIGl0ZW0ke3JlbWFpbmluZyA+IDEgPyAncycgOiAnJ31gO1xuICB9XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgLy8gLmJ1ZmZlciBnb2VzIGxhc3QsIGl0J3Mgbm90IGEgcHJpbWl0aXZlIGxpa2UgdGhlIG90aGVycy5cbiAgICBjdHguaW5kZW50YXRpb25MdmwgKz0gMjtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIFsnQllURVNfUEVSX0VMRU1FTlQnLCAnbGVuZ3RoJywgJ2J5dGVMZW5ndGgnLCAnYnl0ZU9mZnNldCcsICdidWZmZXInXSkge1xuICAgICAgY29uc3Qgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMsIHRydWUpO1xuICAgICAgb3V0cHV0LnB1c2goYFske2tleX1dOiAke3N0cn1gKTtcbiAgICB9XG5cbiAgICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFNldChjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgIG91dHB1dC5wdXNoKGZvcm1hdFZhbHVlKGN0eCwgdiwgcmVjdXJzZVRpbWVzKSk7XG4gIH1cblxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjsgLy8gV2l0aCBgc2hvd0hpZGRlbmAsIGBsZW5ndGhgIHdpbGwgZGlzcGxheSBhcyBhIGhpZGRlbiBwcm9wZXJ0eSBmb3JcbiAgLy8gYXJyYXlzLiBGb3IgY29uc2lzdGVuY3kncyBzYWtlLCBkbyB0aGUgc2FtZSBmb3IgYHNpemVgLCBldmVuIHRob3VnaCB0aGlzXG4gIC8vIHByb3BlcnR5IGlzbid0IHNlbGVjdGVkIGJ5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkuXG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAgb3V0cHV0LnB1c2goYFtzaXplXTogJHtjdHguc3R5bGl6ZShgJHt2YWx1ZS5zaXplfWAsICdudW1iZXInKX1gKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1hcChjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGN0eC5pbmRlbnRhdGlvbkx2bCArPSAyO1xuXG4gIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlKSB7XG4gICAgb3V0cHV0LnB1c2goYCR7Zm9ybWF0VmFsdWUoY3R4LCBrLCByZWN1cnNlVGltZXMpfSA9PiAke2Zvcm1hdFZhbHVlKGN0eCwgdiwgcmVjdXJzZVRpbWVzKX1gKTtcbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyOyAvLyBTZWUgY29tbWVudCBpbiBmb3JtYXRTZXRcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBvdXRwdXQucHVzaChgW3NpemVdOiAke2N0eC5zdHlsaXplKGAke3ZhbHVlLnNpemV9YCwgJ251bWJlcicpfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2V0SXRlcklubmVyKGN0eCwgcmVjdXJzZVRpbWVzLCBlbnRyaWVzLCBzdGF0ZSkge1xuICBjb25zdCBtYXhBcnJheUxlbmd0aCA9IE1hdGgubWF4KGN0eC5tYXhBcnJheUxlbmd0aCwgMCk7XG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWluKG1heEFycmF5TGVuZ3RoLCBlbnRyaWVzLmxlbmd0aCk7XG4gIGxldCBvdXRwdXQgPSBuZXcgQXJyYXkobWF4TGVuZ3RoKTtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhMZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtpXSA9IGZvcm1hdFZhbHVlKGN0eCwgZW50cmllc1tpXSwgcmVjdXJzZVRpbWVzKTtcbiAgfVxuXG4gIGN0eC5pbmRlbnRhdGlvbkx2bCAtPSAyO1xuXG4gIGlmIChzdGF0ZSA9PT0ga1dlYWsgJiYgIWN0eC5zb3J0ZWQpIHtcbiAgICAvLyBTb3J0IGFsbCBlbnRyaWVzIHRvIGhhdmUgYSBoYWxmd2F5IHJlbGlhYmxlIG91dHB1dCAoaWYgbW9yZSBlbnRyaWVzIHRoYW5cbiAgICAvLyByZXRyaWV2ZWQgb25lcyBleGlzdCwgd2UgY2FuIG5vdCByZWxpYWJseSByZXR1cm4gdGhlIHNhbWUgb3V0cHV0KSBpZiB0aGVcbiAgICAvLyBvdXRwdXQgaXMgbm90IHNvcnRlZCBhbnl3YXkuXG4gICAgb3V0cHV0ID0gb3V0cHV0LnNvcnQoKTtcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IGVudHJpZXMubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuXG4gIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgb3V0cHV0LnB1c2goYC4uLiAke3JlbWFpbmluZ30gbW9yZSBpdGVtJHtyZW1haW5pbmcgPiAxID8gJ3MnIDogJyd9YCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNYXBJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIHN0YXRlKSB7XG4gIGNvbnN0IG1heEFycmF5TGVuZ3RoID0gTWF0aC5tYXgoY3R4Lm1heEFycmF5TGVuZ3RoLCAwKTsgLy8gRW50cmllcyBleGlzdCBhcyBba2V5MSwgdmFsMSwga2V5MiwgdmFsMiwgLi4uXVxuXG4gIGNvbnN0IGxlbiA9IGVudHJpZXMubGVuZ3RoIC8gMjtcbiAgY29uc3QgcmVtYWluaW5nID0gbGVuIC0gbWF4QXJyYXlMZW5ndGg7XG4gIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWluKG1heEFycmF5TGVuZ3RoLCBsZW4pO1xuICBsZXQgb3V0cHV0ID0gbmV3IEFycmF5KG1heExlbmd0aCk7XG4gIGxldCBpID0gMDtcbiAgY3R4LmluZGVudGF0aW9uTHZsICs9IDI7XG5cbiAgaWYgKHN0YXRlID09PSBrV2Vhaykge1xuICAgIGZvciAoOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBvcyA9IGkgKiAyO1xuICAgICAgb3V0cHV0W2ldID0gYCR7Zm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3Bvc10sIHJlY3Vyc2VUaW1lcyl9YCArIGAgPT4gJHtmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zICsgMV0sIHJlY3Vyc2VUaW1lcyl9YDtcbiAgICB9IC8vIFNvcnQgYWxsIGVudHJpZXMgdG8gaGF2ZSBhIGhhbGZ3YXkgcmVsaWFibGUgb3V0cHV0IChpZiBtb3JlIGVudHJpZXMgdGhhblxuICAgIC8vIHJldHJpZXZlZCBvbmVzIGV4aXN0LCB3ZSBjYW4gbm90IHJlbGlhYmx5IHJldHVybiB0aGUgc2FtZSBvdXRwdXQpIGlmIHRoZVxuICAgIC8vIG91dHB1dCBpcyBub3Qgc29ydGVkIGFueXdheS5cblxuXG4gICAgaWYgKCFjdHguc29ydGVkKSB7XG4gICAgICBvdXRwdXQgPSBvdXRwdXQuc29ydCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwb3MgPSBpICogMjtcbiAgICAgIGNvbnN0IHJlcyA9IFtmb3JtYXRWYWx1ZShjdHgsIGVudHJpZXNbcG9zXSwgcmVjdXJzZVRpbWVzKSwgZm9ybWF0VmFsdWUoY3R4LCBlbnRyaWVzW3BvcyArIDFdLCByZWN1cnNlVGltZXMpXTtcbiAgICAgIG91dHB1dFtpXSA9IHJlZHVjZVRvU2luZ2xlU3RyaW5nKGN0eCwgcmVzLCAnJywgWydbJywgJ10nXSwga0FycmF5RXh0cmFzVHlwZSwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gIH1cblxuICBjdHguaW5kZW50YXRpb25MdmwgLT0gMjtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIG91dHB1dC5wdXNoKGAuLi4gJHtyZW1haW5pbmd9IG1vcmUgaXRlbSR7cmVtYWluaW5nID4gMSA/ICdzJyA6ICcnfWApO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vha0NvbGxlY3Rpb24oY3R4KSB7XG4gIHJldHVybiBbY3R4LnN0eWxpemUoJzxpdGVtcyB1bmtub3duPicsICdzcGVjaWFsJyldO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWFrU2V0KGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IGEgcHJldmlldyBvZiBhY3R1YWwgdmFsdWVzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWFrTWFwKGN0eCwgX3ZhbHVlLCBfcmVjdXJzZVRpbWVzKSB7XG4gIC8vIE5vZGUgY2FsbHMgaW50byBuYXRpdmUgdG8gZ2V0IGEgcHJldmlldyBvZiBhY3R1YWwgdmFsdWVzIHdoaWNoIHdlIGNhbid0IGRvXG4gIHJldHVybiBmb3JtYXRXZWFrQ29sbGVjdGlvbihjdHgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJdGVyYXRvcihjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIF9rZXlzLCBicmFjZXMpIHtcbiAgY29uc3QgZW50cmllcyA9IFtdO1xuICBsZXQgaXNLZXlWYWx1ZSA9IGZhbHNlO1xuICBsZXQgcmVzdWx0ID0gdmFsdWUubmV4dCgpO1xuXG4gIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICBjb25zdCBjdXJyZW50RW50cnkgPSByZXN1bHQudmFsdWU7XG4gICAgZW50cmllcy5wdXNoKGN1cnJlbnRFbnRyeSk7XG5cbiAgICBpZiAoY3VycmVudEVudHJ5WzBdICE9PSBjdXJyZW50RW50cnlbMV0pIHtcbiAgICAgIGlzS2V5VmFsdWUgPSB0cnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IHZhbHVlLm5leHQoKTtcbiAgfVxuXG4gIGlmIChpc0tleVZhbHVlKSB7XG4gICAgLy8gTWFyayBlbnRyeSBpdGVyYXRvcnMgYXMgc3VjaC5cbiAgICBicmFjZXNbMF0gPSBicmFjZXNbMF0ucmVwbGFjZSgvIEl0ZXJhdG9yXSB7JC8sICcgRW50cmllc10geycpO1xuICAgIHJldHVybiBmb3JtYXRNYXBJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIGtNYXBFbnRyaWVzKTtcbiAgfVxuXG4gIHJldHVybiBmb3JtYXRTZXRJdGVySW5uZXIoY3R4LCByZWN1cnNlVGltZXMsIGVudHJpZXMsIGtJdGVyYXRvcik7XG59XG5cbmZ1bmN0aW9uIGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpIHtcbiAgLy8gRWFjaCBlbnRyeSBpcyBzZXBhcmF0ZWQgYnkgYXQgbGVhc3QgYSBjb21tYS4gVGh1cywgd2Ugc3RhcnQgd2l0aCBhIHRvdGFsXG4gIC8vIGxlbmd0aCBvZiBhdCBsZWFzdCBgb3V0cHV0Lmxlbmd0aGAuIEluIGFkZGl0aW9uLCBzb21lIGNhc2VzIGhhdmUgYVxuICAvLyB3aGl0ZXNwYWNlIGluLWJldHdlZW4gZWFjaCBvdGhlciB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0b3RhbCBhcyB3ZWxsLlxuICBsZXQgdG90YWxMZW5ndGggPSBvdXRwdXQubGVuZ3RoICsgc3RhcnQ7XG5cbiAgaWYgKHRvdGFsTGVuZ3RoICsgb3V0cHV0Lmxlbmd0aCA+IGN0eC5icmVha0xlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGN0eC5jb2xvcnMpIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHJlbW92ZUNvbG9ycyhvdXRwdXRbaV0pLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG90YWxMZW5ndGggKz0gb3V0cHV0W2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodG90YWxMZW5ndGggPiBjdHguYnJlYWtMZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gRG8gbm90IGxpbmUgdXAgcHJvcGVydGllcyBvbiB0aGUgc2FtZSBsaW5lIGlmIGBiYXNlYCBjb250YWlucyBsaW5lIGJyZWFrcy5cblxuXG4gIHJldHVybiBiYXNlID09PSAnJyB8fCAhYmFzZS5pbmNsdWRlcygnXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKGN0eCwgb3V0cHV0LCBiYXNlLCBicmFjZXMsIGV4dHJhc1R5cGUsIHJlY3Vyc2VUaW1lcywgdmFsdWUpIHtcbiAgaWYgKGN0eC5jb21wYWN0ICE9PSB0cnVlKSB7XG4gICAgaWYgKHR5cGVvZiBjdHguY29tcGFjdCA9PT0gJ251bWJlcicgJiYgY3R4LmNvbXBhY3QgPj0gMSkge1xuICAgICAgLy8gTWVtb3JpemUgdGhlIG9yaWdpbmFsIG91dHB1dCBsZW5ndGguIEluIGNhc2UgdGhlIHRoZSBvdXRwdXQgaXMgZ3JvdXBlZCxcbiAgICAgIC8vIHByZXZlbnQgbGluaW5nIHVwIHRoZSBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUuXG4gICAgICBjb25zdCBlbnRyaWVzID0gb3V0cHV0Lmxlbmd0aDsgLy8gR3JvdXAgYXJyYXkgZWxlbWVudHMgdG9nZXRoZXIgaWYgdGhlIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IHNpeFxuICAgICAgLy8gc2VwYXJhdGUgZW50cmllcy5cblxuICAgICAgaWYgKGV4dHJhc1R5cGUgPT09IGtBcnJheUV4dHJhc1R5cGUgJiYgZW50cmllcyA+IDYpIHtcbiAgICAgICAgb3V0cHV0ID0gZ3JvdXBBcnJheUVsZW1lbnRzKGN0eCwgb3V0cHV0LCB2YWx1ZSk7XG4gICAgICB9IC8vIGBjdHguY3VycmVudERlcHRoYCBpcyBzZXQgdG8gdGhlIG1vc3QgaW5uZXIgZGVwdGggb2YgdGhlIGN1cnJlbnRseVxuICAgICAgLy8gaW5zcGVjdGVkIG9iamVjdCBwYXJ0IHdoaWxlIGByZWN1cnNlVGltZXNgIGlzIHRoZSBhY3R1YWwgY3VycmVudCBkZXB0aFxuICAgICAgLy8gdGhhdCBpcyBpbnNwZWN0ZWQuXG4gICAgICAvL1xuICAgICAgLy8gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyBjb25zdCBhID0geyBmaXJzdDogWyAxLCAyLCAzIF0sIHNlY29uZDogeyBpbm5lcjogWyAxLCAyLCAzIF0gfSB9XG4gICAgICAvL1xuICAgICAgLy8gVGhlIGRlZXBlc3QgZGVwdGggb2YgYGFgIGlzIDIgKGEuc2Vjb25kLmlubmVyKSBhbmQgYGEuZmlyc3RgIGhhcyBhIG1heFxuICAgICAgLy8gZGVwdGggb2YgMS5cbiAgICAgIC8vXG4gICAgICAvLyBDb25zb2xpZGF0ZSBhbGwgZW50cmllcyBvZiB0aGUgbG9jYWwgbW9zdCBpbm5lciBkZXB0aCB1cCB0b1xuICAgICAgLy8gYGN0eC5jb21wYWN0YCwgYXMgbG9uZyBhcyB0aGUgcHJvcGVydGllcyBhcmUgc21hbGxlciB0aGFuXG4gICAgICAvLyBgY3R4LmJyZWFrTGVuZ3RoYC5cblxuXG4gICAgICBpZiAoY3R4LmN1cnJlbnREZXB0aCAtIHJlY3Vyc2VUaW1lcyA8IGN0eC5jb21wYWN0ICYmIGVudHJpZXMgPT09IG91dHB1dC5sZW5ndGgpIHtcbiAgICAgICAgLy8gTGluZSB1cCBhbGwgZW50cmllcyBvbiBhIHNpbmdsZSBsaW5lIGluIGNhc2UgdGhlIGVudHJpZXMgZG8gbm90XG4gICAgICAgIC8vIGV4Y2VlZCBgYnJlYWtMZW5ndGhgLiBBZGQgMTAgYXMgY29uc3RhbnQgdG8gc3RhcnQgbmV4dCB0byBhbGwgb3RoZXJcbiAgICAgICAgLy8gZmFjdG9ycyB0aGF0IG1heSByZWR1Y2UgYGJyZWFrTGVuZ3RoYC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvdXRwdXQubGVuZ3RoICsgY3R4LmluZGVudGF0aW9uTHZsICsgYnJhY2VzWzBdLmxlbmd0aCArIGJhc2UubGVuZ3RoICsgMTA7XG5cbiAgICAgICAgaWYgKGlzQmVsb3dCcmVha0xlbmd0aChjdHgsIG91dHB1dCwgc3RhcnQsIGJhc2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2UgPyBgJHtiYXNlfSBgIDogJyd9JHticmFjZXNbMF19ICR7am9pbihvdXRwdXQsICcsICcpfSAke2JyYWNlc1sxXX1gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBMaW5lIHVwIGVhY2ggZW50cnkgb24gYW4gaW5kaXZpZHVhbCBsaW5lLlxuXG5cbiAgICBjb25zdCBpbmRlbnRhdGlvbiA9IGBcXG4keycgJy5yZXBlYXQoY3R4LmluZGVudGF0aW9uTHZsKX1gO1xuICAgIHJldHVybiBgJHtiYXNlID8gYCR7YmFzZX0gYCA6ICcnfSR7YnJhY2VzWzBdfSR7aW5kZW50YXRpb259ICBgICsgYCR7am9pbihvdXRwdXQsIGAsJHtpbmRlbnRhdGlvbn0gIGApfSR7aW5kZW50YXRpb259JHticmFjZXNbMV19YDtcbiAgfSAvLyBMaW5lIHVwIGFsbCBlbnRyaWVzIG9uIGEgc2luZ2xlIGxpbmUgaW4gY2FzZSB0aGUgZW50cmllcyBkbyBub3QgZXhjZWVkXG4gIC8vIGBicmVha0xlbmd0aGAuXG5cblxuICBpZiAoaXNCZWxvd0JyZWFrTGVuZ3RoKGN0eCwgb3V0cHV0LCAwLCBiYXNlKSkge1xuICAgIHJldHVybiBgJHticmFjZXNbMF19JHtiYXNlID8gYCAke2Jhc2V9YCA6ICcnfSAke2pvaW4ob3V0cHV0LCAnLCAnKX0gYCArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGNvbnN0IGluZGVudGF0aW9uID0gJyAnLnJlcGVhdChjdHguaW5kZW50YXRpb25MdmwpOyAvLyBJZiB0aGUgb3BlbmluZyBcImJyYWNlXCIgaXMgdG9vIGxhcmdlLCBsaWtlIGluIHRoZSBjYXNlIG9mIFwiU2V0IHtcIixcbiAgLy8gd2UgbmVlZCB0byBmb3JjZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBvbiB0aGUgbmV4dCBsaW5lIG9yIHRoZVxuICAvLyBpdGVtcyB3aWxsIG5vdCBsaW5lIHVwIGNvcnJlY3RseS5cblxuICBjb25zdCBsbiA9IGJhc2UgPT09ICcnICYmIGJyYWNlc1swXS5sZW5ndGggPT09IDEgPyAnICcgOiBgJHtiYXNlID8gYCAke2Jhc2V9YCA6ICcnfVxcbiR7aW5kZW50YXRpb259ICBgOyAvLyBMaW5lIHVwIGVhY2ggZW50cnkgb24gYW4gaW5kaXZpZHVhbCBsaW5lLlxuXG4gIHJldHVybiBgJHticmFjZXNbMF19JHtsbn0ke2pvaW4ob3V0cHV0LCBgLFxcbiR7aW5kZW50YXRpb259ICBgKX0gJHticmFjZXNbMV19YDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KC4uLmFyZ3MpIHtcbiAgcmV0dXJuIGZvcm1hdFdpdGhPcHRpb25zKHVuZGVmaW5lZCwgLi4uYXJncyk7XG59XG5cbmNvbnN0IGZpcnN0RXJyb3JMaW5lID0gZXJyb3IgPT4gZXJyb3IubWVzc2FnZS5zcGxpdCgnXFxuJylbMF07XG5cbmxldCBDSVJDVUxBUl9FUlJPUl9NRVNTQUdFO1xuXG5mdW5jdGlvbiB0cnlTdHJpbmdpZnkoYXJnKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFBvcHVsYXRlIHRoZSBjaXJjdWxhciBlcnJvciBtZXNzYWdlIGxhemlseVxuICAgIGlmICghQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYSA9IHt9O1xuICAgICAgICBhLmEgPSBhO1xuICAgICAgICBKU09OLnN0cmluZ2lmeShhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSA9IGZpcnN0RXJyb3JMaW5lKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnIubmFtZSA9PT0gJ1R5cGVFcnJvcicgJiYgZmlyc3RFcnJvckxpbmUoZXJyKSA9PT0gQ0lSQ1VMQVJfRVJST1JfTUVTU0FHRSkge1xuICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbi8qIGVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdFdpdGhPcHRpb25zKGluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSB7XG4gIGNvbnN0IGZpcnN0ID0gYXJnc1swXTtcbiAgbGV0IGEgPSAwO1xuICBsZXQgc3RyID0gJyc7XG4gIGxldCBqb2luID0gJyc7XG5cbiAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBmaXJzdDtcbiAgICB9XG5cbiAgICBsZXQgdGVtcFN0cjtcbiAgICBsZXQgbGFzdFBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGZpcnN0LmNoYXJDb2RlQXQoaSkgPT09IDM3KSB7XG4gICAgICAgIC8vICclJ1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IGZpcnN0LmNoYXJDb2RlQXQoKytpKTtcblxuICAgICAgICBpZiAoYSArIDEgIT09IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXh0Q2hhcikge1xuICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgIC8vICdzJ1xuICAgICAgICAgICAgICBjb25zdCB0ZW1wQXJnID0gYXJnc1srK2FdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEFyZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCB0ZW1wQXJnKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRlbXBBcmcgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcEFyZ31uYDtcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb25zdHI7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBBcmcgIT09ICdvYmplY3QnIHx8IHRlbXBBcmcgPT09IG51bGwgfHwgdHlwZW9mIHRlbXBBcmcudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgKGhhc093blByb3BlcnR5KHRlbXBBcmcsICd0b1N0cmluZycpIC8vIEEgZGlyZWN0IG93biBwcm9wZXJ0eSBvbiB0aGUgY29uc3RydWN0b3IgcHJvdG90eXBlIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSB0aGUgY29uc3RydWN0b3IgaXMgbm90IGFuIGJ1aWx0LWluIG9iamVjdC5cbiAgICAgICAgICAgICAgICB8fCAoY29uc3RyID0gdGVtcEFyZy5jb25zdHJ1Y3RvcikgJiYgIWJ1aWx0SW5PYmplY3RzLmhhcyhjb25zdHIubmFtZSkgJiYgY29uc3RyLnByb3RvdHlwZSAmJiBoYXNPd25Qcm9wZXJ0eShjb25zdHIucHJvdG90eXBlLCAndG9TdHJpbmcnKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBTdHJpbmcodGVtcEFyZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KHRlbXBBcmcsIHsgLi4uaW5zcGVjdE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3Q6IDMsXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiAwXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMDY6XG4gICAgICAgICAgICAgIC8vICdqJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gdHJ5U3RyaW5naWZ5KGFyZ3NbKythXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgLy8gJ2QnXG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBOdW0gPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcE51bSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgXHR0ZW1wU3RyID0gYCR7dGVtcE51bX1uYDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wTnVtID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBOdW1iZXIodGVtcE51bSkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNzk6XG4gICAgICAgICAgICAgIC8vICdPJ1xuICAgICAgICAgICAgICB0ZW1wU3RyID0gaW5zcGVjdChhcmdzWysrYV0sIGluc3BlY3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgICAvLyAnbydcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSBpbnNwZWN0KGFyZ3NbKythXSwgeyAuLi5pbnNwZWN0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgIHNob3dIaWRkZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICBzaG93UHJveHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkZXB0aDogNFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgICAvLyAnaSdcbiAgICAgICAgICAgICAgY29uc3QgdGVtcEludGVnZXIgPSBhcmdzWysrYV07XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEludGVnZXIgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgIFx0dGVtcFN0ciA9IGAke3RlbXBJbnRlZ2VyfW5gO1xuICAgICAgICAgICAgICB9IGVsc2UgKi9cblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBJbnRlZ2VyID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUludCh0ZW1wSW50ZWdlcikpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgICAgICAvLyAnZidcbiAgICAgICAgICAgICAgY29uc3QgdGVtcEZsb2F0ID0gYXJnc1srK2FdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcEZsb2F0ID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHRlbXBTdHIgPSAnTmFOJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wU3RyID0gZm9ybWF0TnVtYmVyKHN0eWxpemVOb0NvbG9yLCBwYXJzZUZsb2F0KHRlbXBGbG9hdCkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAgIC8vICclJ1xuICAgICAgICAgICAgICBzdHIgKz0gZmlyc3Quc2xpY2UobGFzdFBvcywgaSk7XG4gICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEFueSBvdGhlciBjaGFyYWN0ZXIgaXMgbm90IGEgY29ycmVjdCBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gaSAtIDEpIHtcbiAgICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpIC0gMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RyICs9IHRlbXBTdHI7XG4gICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRDaGFyID09PSAzNykge1xuICAgICAgICAgIHN0ciArPSBmaXJzdC5zbGljZShsYXN0UG9zLCBpKTtcbiAgICAgICAgICBsYXN0UG9zID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFzdFBvcyAhPT0gMCkge1xuICAgICAgYSsrO1xuICAgICAgam9pbiA9ICcgJztcblxuICAgICAgaWYgKGxhc3RQb3MgPCBmaXJzdC5sZW5ndGgpIHtcbiAgICAgICAgc3RyICs9IGZpcnN0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChhIDwgYXJncy5sZW5ndGgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFyZ3NbYV07XG4gICAgc3RyICs9IGpvaW47XG4gICAgc3RyICs9IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgPyBpbnNwZWN0KHZhbHVlLCBpbnNwZWN0T3B0aW9ucykgOiB2YWx1ZTtcbiAgICBqb2luID0gJyAnO1xuICAgIGErKztcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1kZXB0aCAqL1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gbG9nVGltZShzZWxmLCBsYWJlbCwgbG9nRGF0YSkge1xuICBsYWJlbCA9IGAke2xhYmVsfWA7XG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gc2VsZi5fdGltZXMuZ2V0KGxhYmVsKTtcblxuICBpZiAoIXN0YXJ0VGltZSkge1xuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYExhYmVsIFwiJHtsYWJlbH1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuXG4gIGlmIChsb2dEYXRhKSB7XG4gICAgc2VsZi5sb2coYCR7bGFiZWx9OiAke2R1cmF0aW9ufW1zYCwgLi4ubG9nRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5sb2coYCR7bGFiZWx9OiAke2R1cmF0aW9ufW1zYCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGtDb2xvckluc3BlY3RPcHRpb25zID0ge1xuICBjb2xvcnM6IHRydWVcbn07XG5jb25zdCBrTm9Db2xvckluc3BlY3RPcHRpb25zID0ge307XG5sZXQgdGFibGVXYXJuZWQ7IC8vIGJvb2xlYW4gZmxhZyBmb3Igb25lLXRpbWUgd2FybmluZyBhYm91dCBjb25zb2xlLnRhYmxlIG5vdCBiZWluZyBpbXBsZW1lbnRlZFxuLy8gTWFrZSBhIGZ1bmN0aW9uIHRoYXQgY2FuIHNlcnZlIGFzIHRoZSBjYWxsYmFjayBwYXNzZWQgdG8gYHN0cmVhbS53cml0ZSgpYC5cblxuZnVuY3Rpb24gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIoc3RyZWFtKSB7XG4gIHJldHVybiBlcnIgPT4ge1xuICAgIC8vIFRoaXMgY29uZGl0aW9uYWwgZXZhbHVhdGVzIHRvIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgLy8gdGhhdCB3YXMgbm90IGFscmVhZHkgZW1pdHRlZCAod2hpY2ggaGFwcGVucyB3aGVuIHRoZSBfd3JpdGUgY2FsbGJhY2tcbiAgICAvLyBpcyBpbnZva2VkIGFzeW5jaHJvbm91c2x5KS5cbiAgICBpZiAoZXJyICE9PSBudWxsICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGl0IHdpbGwgYmUgZW1pdHRlZCBvbiBgc3RyZWFtYCBhc1xuICAgICAgLy8gYW4gYGVycm9yYCBldmVudC4gQWRkaW5nIGEgYG9uY2VgIGxpc3RlbmVyIHdpbGwga2VlcCB0aGF0IGVycm9yXG4gICAgICAvLyBmcm9tIGJlY29taW5nIGFuIHVuY2F1Z2h0IGV4Y2VwdGlvbiwgYnV0IHNpbmNlIHRoZSBoYW5kbGVyIGlzXG4gICAgICAvLyByZW1vdmVkIGFmdGVyIHRoZSBldmVudCwgbm9uLWNvbnNvbGUuKiB3cml0ZXMgd29uJ3QgYmUgYWZmZWN0ZWQuXG4gICAgICAvLyB3ZSBhcmUgb25seSBhZGRpbmcgbm9vcCBpZiB0aGVyZSBpcyBubyBvbmUgZWxzZSBsaXN0ZW5pbmcgZm9yICdlcnJvcidcbiAgICAgIGlmIChzdHJlYW0ubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub29wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNsYXNzIENvbnNvbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBzdGRlcnIsIGlnbm9yZUVycm9ycykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBpTmFtZSA9PT0gJ1RpLkFQSScpIHtcbiAgICAgIC8vIFBhc3NpbmcgaW4gVGkuQVBJIG1vZHVsZSB3aGVyZSB3ZSByZXRhaW4gbG9nIGxldmVsc1xuICAgICAgdGhpcy5fYXBpTW9kdWxlID0gb3B0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm9kZS5KUyBzdHJlYW1zXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm8gYXJncywgb3IgZmlyc3QgYXJnIGlzIGEgc3RyZWFtXG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3Rkb3V0OiBvcHRpb25zLFxuICAgICAgICAgIHN0ZGVycixcbiAgICAgICAgICBpZ25vcmVFcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3Rkb3V0ID0gb3B0aW9ucy5zdGRvdXQ7IC8vIFRPRE86IGVuZm9yY2UgaGFzIHdyaXRlIGZ1bmN0aW9uP1xuXG4gICAgICB0aGlzLl9zdGRlcnIgPSBvcHRpb25zLnN0ZGVyciB8fCB0aGlzLl9zdGRvdXQ7XG4gICAgICB0aGlzLl9pZ25vcmVFcnJvcnMgPSBvcHRpb25zLmlnbm9yZUVycm9ycyAhPT0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLl9pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhpcy5fc3Rkb3V0RXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3Rkb3V0KTtcbiAgICAgICAgdGhpcy5fc3RkZXJyRXJyb3JIYW5kbGVyID0gY3JlYXRlV3JpdGVFcnJvckhhbmRsZXIodGhpcy5fc3RkZXJyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29sb3JNb2RlID0gb3B0aW9ucy5jb2xvck1vZGUgfHwgJ2F1dG8nOyAvLyBUT0RPOiBlbmZvcmNlIGJvb2xlYW4gb3IgJ2F1dG8nXG5cbiAgICAgIHRoaXMuX2luc3BlY3RPcHRpb25zID0gb3B0aW9ucy5pbnNwZWN0T3B0aW9uczsgLy8gVE9ETzogZW5mb3JjZSB1bmRlZmluZWQgb3IgdHlwZW9mICdvYmplY3QnXG4gICAgfVxuXG4gICAgdGhpcy5fdGltZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY291bnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2dyb3VwSW5kZW50ID0gJyc7XG4gIH1cblxuICBfd3JpdGVUb0NvbnNvbGUobGV2ZWwsIHN0cmluZykge1xuICAgIGlmICh0aGlzLl9ncm91cEluZGVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIGlmIChzdHJpbmcuaW5jbHVkZXMoJ1xcbicpKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9cXG4vZywgYFxcbiR7dGhpcy5fZ3JvdXBJbmRlbnR9YCk7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHRoaXMuX2dyb3VwSW5kZW50ICsgc3RyaW5nO1xuICAgIH0gLy8gU3VwcG9ydCB3cmFwcGluZyBUaS5BUEkgKHdoaWNoIHJldGFpbnMgbG9nIGxldmVsKVxuXG5cbiAgICBpZiAodGhpcy5fYXBpTW9kdWxlKSB7XG4gICAgICB0aGlzLl9hcGlNb2R1bGVbbGV2ZWxdKHN0cmluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1cHBvcnQgTm9kZS5KUyBzdHJlYW1zIGxpa2Ugc3Rkb3V0L3N0ZGVyciB3aGljaCBkb24ndCBoYXZlIGxvZyBsZXZlbHNcbiAgICAgIGNvbnN0IHVzZVN0ZEVyciA9IGxldmVsID09PSAnd2FybicgfHwgbGV2ZWwgPT09ICdlcnJvcicgfHwgbGV2ZWwgPT09ICd0cmFjZSc7XG4gICAgICBjb25zdCBzdHJlYW0gPSB1c2VTdGRFcnIgPyB0aGlzLl9zdGRlcnIgOiB0aGlzLl9zdGRvdXQ7XG5cbiAgICAgIGlmICh0aGlzLl9pZ25vcmVFcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ud3JpdGUoc3RyaW5nKTtcbiAgICAgIH0gLy8gVGhlcmUgbWF5IGJlIGFuIGVycm9yIG9jY3VycmluZyBzeW5jaHJvbm91c2x5IChlLmcuIGZvciBmaWxlcyBvciBUVFlzXG4gICAgICAvLyBvbiBQT1NJWCBzeXN0ZW1zKSBvciBhc3luY2hyb25vdXNseSAoZS5nLiBwaXBlcyBvbiBQT1NJWCBzeXN0ZW1zKSwgc29cbiAgICAgIC8vIGhhbmRsZSBib3RoIHNpdHVhdGlvbnMuXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQWRkIGFuZCBsYXRlciByZW1vdmUgYSBub29wIGVycm9yIGhhbmRsZXIgdG8gY2F0Y2ggc3luY2hyb25vdXMgZXJyb3JzLlxuICAgICAgICBpZiAoc3RyZWFtLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAgICAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBub29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IHVzZVN0ZEVyciA/IHRoaXMuX3N0ZGVyckVycm9ySGFuZGxlciA6IHRoaXMuX3N0ZG91dEVycm9ySGFuZGxlcjtcbiAgICAgICAgc3RyZWFtLndyaXRlKHN0cmluZywgZXJyb3JIYW5kbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ29uc29sZSBpcyBhIGRlYnVnZ2luZyB1dGlsaXR5LCBzbyBpdCBzd2FsbG93aW5nIGVycm9ycyBpcyBub3QgZGVzaXJhYmxlXG4gICAgICAgIC8vIGV2ZW4gaW4gZWRnZSBjYXNlcyBzdWNoIGFzIGxvdyBzdGFjayBzcGFjZS5cbiAgICAgICAgaWYgKGlzU3RhY2tPdmVyZmxvd0Vycm9yKGUpKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSAvLyBTb3JyeSwgdGhlcmUncyBubyBwcm9wZXIgd2F5IHRvIHBhc3MgYWxvbmcgdGhlIGVycm9yIGhlcmUuXG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lciAmJiBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbm9vcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5mbyguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2luZm8nLCBmb3JtYXRXaXRoT3B0aW9ucyhrQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG5cbiAgd2FybiguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ3dhcm4nLCBmb3JtYXRXaXRoT3B0aW9ucyhrTm9Db2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cblxuICBlcnJvciguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ2Vycm9yJywgZm9ybWF0V2l0aE9wdGlvbnMoa05vQ29sb3JJbnNwZWN0T3B0aW9ucywgLi4uYXJncykpO1xuICB9XG5cbiAgZGVidWcoLi4uYXJncykge1xuICAgIHRoaXMuX3dyaXRlVG9Db25zb2xlKCdkZWJ1ZycsIGZvcm1hdFdpdGhPcHRpb25zKGtDb2xvckluc3BlY3RPcHRpb25zLCAuLi5hcmdzKSk7XG4gIH1cblxuICB0cmFjZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fd3JpdGVUb0NvbnNvbGUoJ3RyYWNlJywgZm9ybWF0V2l0aE9wdGlvbnMoa0NvbG9ySW5zcGVjdE9wdGlvbnMsIC4uLmFyZ3MpKTtcbiAgfVxuXG4gIGNsZWFyKCkge30gLy8gbm8tb3BcblxuXG4gIGdyb3VwKC4uLmRhdGEpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmxvZyguLi5kYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ncm91cEluZGVudCArPSAnICAnO1xuICB9XG5cbiAgZ3JvdXBFbmQoKSB7XG4gICAgdGhpcy5fZ3JvdXBJbmRlbnQgPSB0aGlzLl9ncm91cEluZGVudC5zbGljZSgwLCB0aGlzLl9ncm91cEluZGVudC5sZW5ndGggLSAyKTtcbiAgfVxuXG4gIGRpcihvYmosIG9wdGlvbnMpIHtcbiAgICB0aGlzLl93cml0ZVRvQ29uc29sZSgnaW5mbycsIGluc3BlY3Qob2JqLCB7XG4gICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KSk7XG4gIH1cblxuICBhc3NlcnQodmFsdWUsIC4uLmFyZ3MpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICBhcmdzWzBdID0gYEFzc2VydGlvbiBmYWlsZWQke2FyZ3MubGVuZ3RoID09PSAwID8gJycgOiBgOiAke2FyZ3NbMF19YH1gO1xuICAgICAgdGhpcy53YXJuKC4uLmFyZ3MpOyAvLyBUaGUgYXJndW1lbnRzIHdpbGwgYmUgZm9ybWF0dGVkIGluIHdhcm4oKSBhZ2FpblxuICAgIH1cbiAgfVxuXG4gIGNvdW50KGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgLy8gRW5zdXJlcyB0aGF0IGxhYmVsIGlzIGEgc3RyaW5nLCBhbmQgb25seSB0aGluZ3MgdGhhdCBjYW4gYmVcbiAgICAvLyBjb2VyY2VkIHRvIHN0cmluZ3MuIGUuZy4gU3ltYm9sIGlzIG5vdCBhbGxvd2VkXG4gICAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuXG4gICAgbGV0IGNvdW50ID0gdGhpcy5fY291bnRzLmdldChsYWJlbCk7XG5cbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY291bnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCsrO1xuICAgIH1cblxuICAgIHRoaXMuX2NvdW50cy5zZXQobGFiZWwsIGNvdW50KTtcblxuICAgIHRoaXMubG9nKGAke2xhYmVsfTogJHtjb3VudH1gKTtcbiAgfVxuXG4gIGNvdW50UmVzZXQobGFiZWwgPSAnZGVmYXVsdCcpIHtcbiAgICBpZiAoIXRoaXMuX2NvdW50cy5oYXMobGFiZWwpKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKGBDb3VudCBmb3IgJyR7bGFiZWx9JyBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvdW50cy5kZWxldGUoYCR7bGFiZWx9YCk7XG4gIH1cblxuICB0aW1lKGxhYmVsID0gJ2RlZmF1bHQnKSB7XG4gICAgbGFiZWwgPSBgJHtsYWJlbH1gO1xuXG4gICAgaWYgKHRoaXMuX3RpbWVzLmhhcyhsYWJlbCkpIHtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYExhYmVsICR7bGFiZWx9XCIgYWxyZWFkeSBleGlzdHNgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lcy5zZXQobGFiZWwsIERhdGUubm93KCkpO1xuICB9XG5cbiAgdGltZUVuZChsYWJlbCA9ICdkZWZhdWx0Jykge1xuICAgIGNvbnN0IHdhcm5lZCA9IGxvZ1RpbWUodGhpcywgbGFiZWwpO1xuXG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHRoaXMuX3RpbWVzLmRlbGV0ZShsYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgdGltZUxvZyhsYWJlbCA9ICdkZWZhdWx0JywgLi4ubG9nRGF0YSkge1xuICAgIGxvZ1RpbWUodGhpcywgbGFiZWwsIGxvZ0RhdGEpO1xuICB9IC8vIFRPRE86IGltcGxlbWVudCBjb25zb2xlLnRhYmxlKClcblxuXG4gIHRhYmxlKCkge1xuICAgIGlmICghdGFibGVXYXJuZWQpIHtcbiAgICAgIHRhYmxlV2FybmVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1wiY29uc29sZS50YWJsZVwiIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW4gVGl0YW5pdW0hJyk7XG4gICAgfVxuICB9XG5cbn1cblxuQ29uc29sZS5wcm90b3R5cGUubG9nID0gQ29uc29sZS5wcm90b3R5cGUuaW5mbzsgLy8gVHJlYXQgbG9nIGFzIGFsaWFzIHRvIGluZm9cblxuQ29uc29sZS5wcm90b3R5cGUuZGlyeG1sID0gQ29uc29sZS5wcm90b3R5cGUubG9nOyAvLyBUcmVhdCBkaXJ4bWwgYXMgYWxpYXMgdG8gbG9nXG5cbkNvbnNvbGUucHJvdG90eXBlLmdyb3VwQ29sbGFwc2VkID0gQ29uc29sZS5wcm90b3R5cGUuZ3JvdXA7XG5jb25zdCBnbG9iYWxDb25zb2xlID0gbmV3IENvbnNvbGUoVGkuQVBJKTtcbmdsb2JhbENvbnNvbGUuQ29uc29sZSA9IENvbnNvbGU7XG5nbG9iYWwuY29uc29sZSA9IGdsb2JhbENvbnNvbGU7XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBEYXRlLnByb3RvdHlwZS50b0xvY2FsZURhdGVTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IEludGwuRGF0ZVRpbWVGb3JtYXQuX21ha2VUaUNyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJndW1lbnRzKTtcblxuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGRhdGVTdHlsZTogJ3Nob3J0J1xuICAgIH0sIHByb3BlcnRpZXMub3B0aW9ucyk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcy5sb2NhbGUsIG1lcmdlZE9wdGlvbnMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMpO1xuICB9O1xuXG4gIERhdGUucHJvdG90eXBlLnRvTG9jYWxlVGltZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gSW50bC5EYXRlVGltZUZvcm1hdC5fbWFrZVRpQ3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMpO1xuXG4gICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdGltZVN0eWxlOiAnc2hvcnQnXG4gICAgfSwgcHJvcGVydGllcy5vcHRpb25zKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChwcm9wZXJ0aWVzLmxvY2FsZSwgbWVyZ2VkT3B0aW9ucyk7XG4gICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodGhpcyk7XG4gIH07XG5cbiAgRGF0ZS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBEYXRlLnByb3RvdHlwZS50b0xvY2FsZURhdGVTdHJpbmc7XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG4vLyBBZGQgYSB0b0pTT04oKSBtZXRob2QgdG8gYWxsIEVycm9yIG9iamVjdHMgbmVlZGVkIHRvIG91dHB1dCBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuLy8gVGhlIEpTT04uc3RyaW5naWZ5KCkgd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGwgdGhpcyBtZXRob2QgaWYgaXQgZXhpc3RzIHRvIHByb3ZpZGUgY3VzdG9tIG91dHB1dC5cbi8vIE5vdGVzOlxuLy8gLSBJbiBWOCwgYWxsIEVycm9yIHByb3BlcnRpZXMgYXJlIG5vdCBlbnVtZXJhYmxlLiBXZSBuZWVkIHRoaXMgb3IgZWxzZSBzdHJpbmdpZnkoKSB3aWxsIHJldHVybiBcInt9XCIuXG4vLyAtIEluIEphdmFTY3JpcHRDb3JlLCBvbmx5IHRoZSBcInN0YWNrXCIgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGUuIFdlIHdhbnQgdG8gcmV2ZWFsIHRoaXMuXG5pZiAodHlwZW9mIEVycm9yLnByb3RvdHlwZS50b0pTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgRXJyb3IucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHByb3BlcnRpZXNbbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9O1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAyMCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0FORFJPSUQgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBcImNyZWF0aW9uXCIgcHJvcGVydGllcyBkaWN0aW9uYXJ5IGZvciBUaXRhbml1bSdzIENvbGxhdG9yLCBEYXRlVGltZUZvcm1hdCwgYW5kIE51bWJlckZvcm1hdCBwcm94aWVzXG4gKiBmcm9tIHRoZSBnaXZlbiBJbnRsIHR5cGUncyBjb25zdHJ1Y3RvciBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge09iamVjdFtdfSBhcmdzXG4gKiBUaGUgYXJndW1lbnRzIGFycmF5IHRoYXQgd2FzIHBhc3NlZCBpbnRvIEludGwgQ29sbGF0b3IsIERhdGVUaW1lRm9ybWF0LCBvciBOdW1iZXJGb3JtYXQgdHlwZSdzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uIFJlZmVyZW5jZSB0byBhIHN1cHBvcnRlZExvY2FsZXNPZigpIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgcHJvcGVydGllcyBkaWN0aW9uYXJ5IHRvIGJlIHBhc3NlZCBpbnRvIGEgVGl0YW5pdW0gcHJveHkncyBjb25zdHJ1Y3Rvci5cbiAqL1xuXG5mdW5jdGlvbiBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3MsIHN1cHBvcnRlZEZvcm1hdExvY2FsZXNGdW5jdGlvbikge1xuICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG5cbiAgaWYgKGFyZ3MubGVuZ3RoID49IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm9wZXJ0aWVzLmxvY2FsZSA9IGFyZ3NbMF07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWRMb2NhbGVzID0gc3VwcG9ydGVkRm9ybWF0TG9jYWxlc0Z1bmN0aW9uKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAoc3VwcG9ydGVkTG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMubG9jYWxlID0gc3VwcG9ydGVkTG9jYWxlc1swXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYXJncy5sZW5ndGggPj0gMiAmJiB0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBhcmdzWzFdO1xuICB9XG5cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59IC8vIEFkZCBcIkludGxcIiBBUElzIG1pc3Npbmcgb24gQW5kcm9pZC5cblxuXG57XG4gIC8vIFNldCB1cCBhbiBcIkludGwuQ29sbGF0b3JcIiB0eXBlIHdoaWNoIHdyYXBzIG91ciB1bmRvY3VtZW50ZWQgXCJUaS5Mb2NhbGUuQ29sbGF0b3JcIiBwcm94eS5cbiAgZnVuY3Rpb24gVGlDb2xsYXRvcigpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMsIFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXMpO1xuICAgIGNvbnN0IGNvbGxhdG9yID0gbmV3IFRpLkxvY2FsZS5Db2xsYXRvcihwcm9wZXJ0aWVzKTtcbiAgICBjb2xsYXRvci5jb21wYXJlID0gY29sbGF0b3IuY29tcGFyZS5iaW5kKGNvbGxhdG9yKTtcbiAgICByZXR1cm4gY29sbGF0b3I7XG4gIH1cblxuICBUaUNvbGxhdG9yLnN1cHBvcnRlZExvY2FsZXNPZiA9IFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWRDb2xsYXRvckxvY2FsZXM7IC8vIFNldCB1cCBhbiBcIkludGwuRGF0ZVRpbWVGb3JtYXRcIiB0eXBlIHdoaWNoIHdyYXBzIG91ciB1bmRvY3VtZW50ZWQgXCJUaS5Mb2NhbGUuRGF0ZVRpbWVGb3JtYXRcIiBwcm94eS5cblxuICBmdW5jdGlvbiBUaURhdGVUaW1lRm9ybWF0KCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYWtlVGlGb3JtYXRDcmVhdGlvblByb3BlcnRpZXNGcm9tKGFyZ3VtZW50cywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyk7XG4gICAgcmV0dXJuIG5ldyBUaS5Mb2NhbGUuRGF0ZVRpbWVGb3JtYXQocHJvcGVydGllcyk7XG4gIH1cblxuICBUaURhdGVUaW1lRm9ybWF0Ll9tYWtlVGlDcmVhdGlvblByb3BlcnRpZXNGcm9tID0gYXJncyA9PiB7XG4gICAgcmV0dXJuIG1ha2VUaUZvcm1hdENyZWF0aW9uUHJvcGVydGllc0Zyb20oYXJncywgVGkuTG9jYWxlLmdldFN1cHBvcnRlZERhdGVUaW1lRm9ybWF0TG9jYWxlcyk7XG4gIH07XG5cbiAgVGlEYXRlVGltZUZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YgPSBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkRGF0ZVRpbWVGb3JtYXRMb2NhbGVzOyAvLyBTZXQgdXAgYW4gXCJJbnRsLk51bWJlckZvcm1hdFwiIHR5cGUgd2hpY2ggd3JhcHMgb3VyIHVuZG9jdW1lbnRlZCBcIlRpLkxvY2FsZS5OdW1iZXJGb3JtYXRcIiBwcm94eS5cblxuICBmdW5jdGlvbiBUaU51bWJlckZvcm1hdCgpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gbWFrZVRpRm9ybWF0Q3JlYXRpb25Qcm9wZXJ0aWVzRnJvbShhcmd1bWVudHMsIFRpLkxvY2FsZS5nZXRTdXBwb3J0ZWROdW1iZXJGb3JtYXRMb2NhbGVzKTtcbiAgICByZXR1cm4gbmV3IFRpLkxvY2FsZS5OdW1iZXJGb3JtYXQocHJvcGVydGllcyk7XG4gIH1cblxuICBUaU51bWJlckZvcm1hdC5zdXBwb3J0ZWRMb2NhbGVzT2YgPSBUaS5Mb2NhbGUuZ2V0U3VwcG9ydGVkTnVtYmVyRm9ybWF0TG9jYWxlczsgLy8gTWFrZSBvdXIgY3VzdG9tIFwiSW50bFwiIG1vZHVsZSBhdmFpbGFibGUgZ2xvYmFsbHkuXG5cbiAgY29tbW9uanNHbG9iYWwuSW50bCA9IHtcbiAgICBDb2xsYXRvcjogVGlDb2xsYXRvcixcbiAgICBEYXRlVGltZUZvcm1hdDogVGlEYXRlVGltZUZvcm1hdCxcbiAgICBOdW1iZXJGb3JtYXQ6IFRpTnVtYmVyRm9ybWF0LFxuICAgIGdldENhbm9uaWNhbExvY2FsZXM6IFRpLkxvY2FsZS5nZXRDYW5vbmljYWxMb2NhbGVzXG4gIH07XG59XG5cbi8qKlxuICogQXBwY2VsZXJhdG9yIFRpdGFuaXVtIE1vYmlsZVxuICogQ29weXJpZ2h0IChjKSAyMDIwIGJ5IEF4d2F5LCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSBQdWJsaWMgTGljZW5zZVxuICogUGxlYXNlIHNlZSB0aGUgTElDRU5TRSBpbmNsdWRlZCB3aXRoIHRoaXMgZGlzdHJpYnV0aW9uIGZvciBkZXRhaWxzLlxuICovXG5cbi8qIGdsb2JhbHMgT1NfQU5EUk9JRCAqL1xue1xuICBOdW1iZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCguLi5hcmd1bWVudHMpO1xuICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KHRoaXMudmFsdWVPZigpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjAgYnkgQXh3YXksIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgQXBhY2hlIFB1YmxpYyBMaWNlbnNlXG4gKiBQbGVhc2Ugc2VlIHRoZSBMSUNFTlNFIGluY2x1ZGVkIHdpdGggdGhpcyBkaXN0cmlidXRpb24gZm9yIGRldGFpbHMuXG4gKi9cblxuLyogZ2xvYmFscyBPU19BTkRST0lEICovXG57XG4gIFN0cmluZy5wcm90b3R5cGUubG9jYWxlQ29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlU3RyaW5nLCBsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcihsb2NhbGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY29sbGF0b3IuY29tcGFyZSh0aGlzLCBjb21wYXJlU3RyaW5nKTtcbiAgfTtcblxuICBTdHJpbmcucHJvdG90eXBlLnRvTG9jYWxlTG93ZXJDYXNlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgIHJldHVybiBUaS5Mb2NhbGUubWFrZUxvd2VyQ2FzZSh0aGlzLCBsb2NhbGUpO1xuICB9O1xuXG4gIFN0cmluZy5wcm90b3R5cGUudG9Mb2NhbGVVcHBlckNhc2UgPSBmdW5jdGlvbiAobG9jYWxlKSB7XG4gICAgcmV0dXJuIFRpLkxvY2FsZS5tYWtlVXBwZXJDYXNlKHRoaXMsIGxvY2FsZSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgdG8gaGlqYWNrIHRoZSBzdGFuZGFyZCByZXF1aXJlIHRvIGFsbG93IGZvciBKU1xuICogaW1wbGVtZW50YXRpb25zIG9mIFwiY29yZVwiIG1vZHVsZXMuXG4gKlxuICogWW91IGFkZCBhIGJpbmRpbmcgZnJvbSB0aGUgXCJjb3JlXCIgbW9kdWxlIGlkIHRvIHRoZSB1bmRlciB0aGUgaG9vZCBKU1xuICogaW1wbGVtZW50YXRpb24uIFdlIHRoZW4gaW50ZXJjZXB0IHJlcXVpcmUgY2FsbHMgdG8gaGFuZGxlIHJlcXVlc3RzIGZvciB0aGVzZSBtb2R1bGVzXG4gKiBhbmQgbGF6aWx5IGxvYWQgdGhlIGZpbGUuXG4gKi9cblxuLyoqXG4gKiBVc2VkIGJ5IEBmdW5jdGlvbiBiaW5kT2JqZWN0VG9Db3JlTW9kdWxlSWRcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5jb25zdCBiaW5kaW5ncyA9IG5ldyBNYXAoKTtcbi8qKlxuICogVXNlZCBieSBAZnVuY3Rpb24gcmVkaXJlY3RDb3JlTW9kdWxlSWRUb1BhdGhcbiAqIEB0eXBlIHttYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5cbmNvbnN0IHJlZGlyZWN0cyA9IG5ldyBNYXAoKTtcbi8qKlxuICogRG9lcyB0aGUgcmVxdWVzdCBsb29rIGxpa2UgYSB0eXBpY2FsIGNvcmUgbW9kdWxlPyAobm8gJy4nIG9yICcvJyBjaGFyYWN0ZXJzKVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggb3JpZ2luYWwgcmVxdWlyZSBwYXRoL2lkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuXG5mdW5jdGlvbiBpc0hpamFja2FibGVNb2R1bGVJZChwYXRoKSB7XG4gIGlmICghcGF0aCB8fCBwYXRoLmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBmaXJzdENoYXIgPSBwYXRoLmNoYXJBdCgwKTtcbiAgcmV0dXJuIGZpcnN0Q2hhciAhPT0gJy4nICYmIGZpcnN0Q2hhciAhPT0gJy8nO1xufSAvLyBIYWNrIHJlcXVpcmUgdG8gcG9pbnQgdG8gdGhpcyBhcyBhIGNvcmUgbW9kdWxlIFwiYmluZGluZ1wiXG5cblxuY29uc3Qgb3JpZ2luYWxSZXF1aXJlID0gZ2xvYmFsLnJlcXVpcmU7IC8vIFRoaXMgd29ya3MgZm9yIGlPUyBhcy1pcywgYW5kIGFsc28gaW50ZXJjZXB0cyB0aGUgY2FsbCBvbiBBbmRyb2lkIGZvciB0aS5tYWluLmpzICh0aGUgZmlyc3QgZmlsZSBleGVjdXRlZClcblxuZ2xvYmFsLnJlcXVpcmUgPSBmdW5jdGlvbiAobW9kdWxlSWQpIHtcbiAgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICByZXR1cm4gYmluZGluZ3MuZ2V0KG1vZHVsZUlkKTtcbiAgfVxuXG4gIGlmIChyZWRpcmVjdHMuaGFzKG1vZHVsZUlkKSkge1xuICAgIG1vZHVsZUlkID0gcmVkaXJlY3RzLmdldChtb2R1bGVJZCk7XG4gIH1cblxuICByZXR1cm4gb3JpZ2luYWxSZXF1aXJlKG1vZHVsZUlkKTtcbn07XG5cbntcbiAgLy8gLi4uIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvIGhhY2sgaXQgd2hlbiByZXF1aXJpbmcgZnJvbSBvdGhlciBmaWxlcyBmb3IgQW5kcm9pZFxuICBjb25zdCBvcmlnaW5hbE1vZHVsZVJlcXVpcmUgPSBnbG9iYWwuTW9kdWxlLnByb3RvdHlwZS5yZXF1aXJlO1xuXG4gIGdsb2JhbC5Nb2R1bGUucHJvdG90eXBlLnJlcXVpcmUgPSBmdW5jdGlvbiAocGF0aCwgY29udGV4dCkge1xuICAgIGlmIChiaW5kaW5ncy5oYXMocGF0aCkpIHtcbiAgICAgIHJldHVybiBiaW5kaW5ncy5nZXQocGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKHJlZGlyZWN0cy5oYXMocGF0aCkpIHtcbiAgICAgIHBhdGggPSByZWRpcmVjdHMuZ2V0KHBhdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBvcmlnaW5hbE1vZHVsZVJlcXVpcmUuY2FsbCh0aGlzLCBwYXRoLCBjb250ZXh0KTtcbiAgfTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIGFuIGFscmVhZHkgbG9hZGVkL2NvbnN0cnVjdGVkIG9iamVjdC92YWx1ZSB0byBleHBvcnQgZm9yIHRoYXQgY29yZSBtb2R1bGUgaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlSWQgdGhlIG1vZHVsZSBpZCB0byBcImhpamFja1wiXG4gKiBAcGFyYW0geyp9IGJpbmRpbmcgYW4gYWxyZWFkeSBjb25zdHJ1Y3R1cmVkIHZhbHVlL29iamVjdCB0byByZXR1cm5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKG1vZHVsZUlkLCBiaW5kaW5nKSB7XG4gIGlmICghaXNIaWphY2thYmxlTW9kdWxlSWQobW9kdWxlSWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVnaXN0ZXIgZm9yIHJlbGF0aXZlL2Fic29sdXRlIGZpbGUgcGF0aHM7IG5vIGxlYWRpbmcgJy4nIG9yICcvJyBhbGxvd2VkICh3YXMgZ2l2ZW4gJHttb2R1bGVJZH0pYCk7XG4gIH1cblxuICBpZiAocmVkaXJlY3RzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICAgIHJlZGlyZWN0cy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKGJpbmRpbmdzLmhhcyhtb2R1bGVJZCkpIHtcbiAgICBUaS5BUEkud2FybihgQW5vdGhlciBiaW5kaW5nIGhhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgZm9yIG1vZHVsZSBpZDogJyR7bW9kdWxlSWR9JywgaXQgd2lsbCBiZSBvdmVyd3JpdHRlbi4uLmApO1xuICB9XG5cbiAgYmluZGluZ3Muc2V0KG1vZHVsZUlkLCBiaW5kaW5nKTtcbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgYmluZGluZyBmcm9tIGEgc2hvcnQgbW9kdWxlIGlkIHRvIHRoZSBmdWxsIHVuZGVyIHRoZSBob29kIGZpbGVwYXRoIGlmIGdpdmVuIGEgc3RyaW5nLlxuICogVGhpcyBhbGxvd3MgZm9yIGxhenkgaW5zdGFudGlhdGlvbiBvZiB0aGUgbW9kdWxlIG9uLWRlbWFuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVJZCB0aGUgbW9kdWxlIGlkIHRvIFwiaGlqYWNrXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCB0aGUgZnVsbCBmaWxlcGF0aCB0byByZXF1aXJlIHVuZGVyIHRoZSBob29kLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIHNob3VsZCBiZSBhbiBhbHJlYWR5IHJlc29sdmVkIGFic29sdXRlIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIG90aGVyd2lzZSB0aGUgY29udGV4dCBvZiB0aGUgY2FsbCBjb3VsZCBjaGFuZ2Ugd2hhdCBnZXRzIGxvYWRlZCFcbiAqL1xuXG5mdW5jdGlvbiByZWRpcmVjdChtb2R1bGVJZCwgZmlsZXBhdGgpIHtcbiAgaWYgKCFpc0hpamFja2FibGVNb2R1bGVJZChtb2R1bGVJZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZWdpc3RlciBmb3IgcmVsYXRpdmUvYWJzb2x1dGUgZmlsZSBwYXRoczsgbm8gbGVhZGluZyAnLicgb3IgJy8nIGFsbG93ZWQgKHdhcyBnaXZlbiAke21vZHVsZUlkfSlgKTtcbiAgfVxuXG4gIGlmIChiaW5kaW5ncy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgICBiaW5kaW5ncy5kZWxldGUobW9kdWxlSWQpO1xuICB9IGVsc2UgaWYgKHJlZGlyZWN0cy5oYXMobW9kdWxlSWQpKSB7XG4gICAgVGkuQVBJLndhcm4oYEFub3RoZXIgYmluZGluZyBoYXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBtb2R1bGUgaWQ6ICcke21vZHVsZUlkfScsIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uLi5gKTtcbiAgfVxuXG4gIHJlZGlyZWN0cy5zZXQobW9kdWxlSWQsIGZpbGVwYXRoKTtcbn1cbmNvbnN0IGJpbmRpbmcgPSB7XG4gIHJlZ2lzdGVyLFxuICByZWRpcmVjdFxufTtcbmdsb2JhbC5iaW5kaW5nID0gYmluZGluZztcblxuLy8gTG9hZCBhbGwgSmF2YVNjcmlwdCBleHRlbnNpb25zL3BvbHlmaWxsc1xucmVnaXN0ZXIoJ2NvbnNvbGUnLCBnbG9iYWxDb25zb2xlKTtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTktUHJlc2VudCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuXG4vKiBnbG9iYWxzIE9TX0lPUywgT1NfVkVSU0lPTl9NQUpPUiAqL1xuY29uc3QgYnVmZmVyID0gVGkuY3JlYXRlQnVmZmVyKHtcbiAgdmFsdWU6ICcnXG59KTtcbmNvbnN0IGJsb2IgPSBidWZmZXIudG9CbG9iKCk7XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQmxvYi9hcnJheUJ1ZmZlclxuXG5cbmJsb2IuY29uc3RydWN0b3IucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBidWY7XG5cbiAgICB0cnkge1xuICAgICAgYnVmID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmVzb2x2ZShidWYpO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGhpcyBzY3JpcHQgaXMgdXNlZCBhdCBydW50aW1lIGZvciBUaS5VSS5mZXRjaFNlbWFudGljQ29sb3IgLSBhcyB3ZWxsIGFzIGF0IGJ1aWxkIHRpbWUgYnkgYm90aCBpT1MvQW5kcm9pZC5cbiAqIEl0IHByb3ZpZGVzIGEgY29tbW9uIGludGVyZmFjZSBmb3IgaGFuZGxpbmcgY29sb3JzIGFuZCBjb252ZXJ0aW5nIHRvIG5lY2Vzc2FyeSBzdHJpbmcgZm9ybXMuXG4gKi9cblxuY29uc3QgSEVYXzNfUkVHRVggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pOyAvLyBpLmUuICMwRjNcblxuY29uc3QgSEVYXzRfUkVHRVggPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTsgLy8gaS5lLiAjMEYzOFxuXG5jb25zdCBIRVhfNl9SRUdFWCA9IC9eIz8oW2EtZlxcZF0pezZ9JC9pOyAvLyBpLmUuICMwMEZGMzNcblxuY29uc3QgSEVYXzhfUkVHRVggPSAvXiM/KFthLWZcXGRdKXs4fSQvaTsgLy8gaS5lLiAjMDBGRjMzODhcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZWdlciBpbiByYW5nZSBvZiAwLTI1NVxuICogQHJldHVybnMge3N0cmluZ30gMi1jaGFyYWN0ZXIgaGV4IHN0cmluZyB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHBhZGRlZEhleChpbnRlZ2VyKSB7XG4gIGNvbnN0IHN0ciA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuXG4gIGlmIChzdHIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGAwJHtzdHJ9YDtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbmNsYXNzIENvbG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByIHJlZCB2YWx1ZSBpbiByYW5nZSAwLTI1NVxuICAgKiBAcGFyYW0ge251bWJlcn0gZyBncmVlbiB2YWx1ZSBpbiByYW5nZSAwLTI1NVxuICAgKiBAcGFyYW0ge251bWJlcn0gYiBibHVlIHZhbHVlIGluIHJhbmdlIDAtMjU1XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYT0xLjBdIGFscGhhIHZhbHVlIGluIHJhbmdlIDAuMC0xLjBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHIsIGcsIGIsIGEgPSAxLjApIHtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmFscGhhID0gYTtcbiAgfVxuICAvKipcbiAgICogaW5kaWNhdGVzIGlmIHRoaXMgaXMgYSBmdWxseSBvcGFxdWUgY29sb3IgKGFscGhhIGlzIDEuMCBvciB3YXMgdW5kZWZpbmVkKVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBpc09wYXF1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYSA9PT0gMS4wO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgYWxwaGEgdmFsdWUgaW50byBlcXVpdmFsZW50IGhleCBzdHJpbmcgdmFsdWUgcHJvcGVybHkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgYWxwaGFIZXgoKSB7XG4gICAgLy8gbmVlZCB0byByb3VuZCB0byBhdm9pZCBub25zZW5zaWNhbCB2YWx1ZXMgbGlrZSAnN2YuOCcgZm9yIGEgMC41IGFscGhhXG4gICAgcmV0dXJuIHBhZGRlZEhleChNYXRoLnJvdW5kKHRoaXMuYWxwaGEgKiAyNTUuMCkpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjYXJkcyBhbnkgYWxwaGEgdmFsdWUuIFRvIGJlIHVzZWQgaW50ZXJuYWxseSwgbm90IGV4dGVybmFsIGFwaS4gRG9lcyBub3QgcHJvdmlkZSBsZWFkaW5nICcjJyBzeW1ib2wuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX3RvUkdCSGV4U3RyaW5nKCkge1xuICAgIHJldHVybiBgJHtwYWRkZWRIZXgodGhpcy5yKX0ke3BhZGRlZEhleCh0aGlzLmcpfSR7cGFkZGVkSGV4KHRoaXMuYil9YDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBDU1MuXG4gICAqIENvbnZlcnRzIHRoaXMgY29sb3IgdG8gYSBoZXggc3RyaW5nIHdpdGggbGVhZGluZyAnIycgc3ltYm9sIGFuZCA2LSBvciA4LVxuICAgKiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzIChkZXBlbmRpbmcgb24gaWYgYWxwaGEgaXMgMS4wKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRvUkdCQUhleFN0cmluZygpIHtcbiAgICBpZiAodGhpcy5pc09wYXF1ZSgpKSB7XG4gICAgICByZXR1cm4gYCMke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCMke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9JHt0aGlzLmFscGhhSGV4KCl9YDtcbiAgfVxuICAvKipcbiAgICogVXNlZCBieSBBbmRyb2lkL2lPU1xuICAgKiBDb252ZXJ0cyB0aGlzIGNvbG9yIHRvIGEgaGV4IHN0cmluZyB3aXRoIGxlYWRpbmcgJyMnIHN5bWJvbCBhbmQgNi0gb3IgOC1cbiAgICogaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoZGVwZW5kaW5nIG9uIGlmIGFscGhhIGlzIDEuMCkuIEFscGhhIGlzIHRoZSBmaXJzdCBlbnRyeSAoaWYgdGhlcmUgaXMgYWxwaGEuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRvQVJHQkhleFN0cmluZygpIHtcbiAgICBpZiAodGhpcy5pc09wYXF1ZSgpKSB7XG4gICAgICByZXR1cm4gYCMke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gYCMke3RoaXMuYWxwaGFIZXgoKX0ke3RoaXMuX3RvUkdCSGV4U3RyaW5nKCl9YDtcbiAgfVxuICAvKipcbiAgICogRm9yIGNvbW1vbmFsaXR5IHdpdGggbmF0aXZlIGlPUyBUaUNvbG9yIHByb3h5LiBQcm9kdWNlcyBhbiBBQVJSR0dCQiAob3IgUlJHR0JCIGlmIGZ1bGwgYWxwaGEpIGhleCBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cblxuICB0b0hleCgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FSR0JIZXhTdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBjb2xvciB0byBhbiByZ2JhIGV4cHJlc3Npb24uIFRoaXMgZXhwcmVzc2lvbiBpcyBtb3JlIGNvbnNpc3RlbnQgYWNyb3NzIHBsYXRmb3Jtcy5cbiAgICogKHdoZXJlYXMgaU9TL0FuZHJvaWQgZGlmZmVyIGluIGV4cGVjdHRhaW9zbiBmb3IgaGV4IHN0cmluZ3MuKVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuXG4gIHRvUkdCQVN0cmluZygpIHtcbiAgICByZXR1cm4gYHJnYmEoJHt0aGlzLnJ9LCAke3RoaXMuZ30sICR7dGhpcy5ifSwgJHt0aGlzLmFscGhhLnRvRml4ZWQoMyl9KWA7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtDb2xvcn1cbiAgICovXG5cblxuICBzdGF0aWMgZmFsbGJhY2soKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwKTsgLy8gcmV0dXJuIGJsYWNrIHRvIG1hdGNoIG5hdGl2ZSBpbXBsIGluIGlPU1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3VwcGxpZWQgaGV4IHN0cmluZyBNVVNUIGJlIGluIGZvcm0gJyMwMDAwMDAnIChpLmUuIGxlYWRpbmcgcG91bmQgc3ltYm9sLCA2IGhleCBjaGFyYWN0ZXJzIGFmdGVyKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4IGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhXSBhbHBoYSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21IZXg2U3RyaW5nKGhleCwgYWxwaGEpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaGV4LnN0YXJ0c1dpdGgoJyMnKSA/IDEgOiAwO1xuICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXgsIDIpLCAxNik7XG4gICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDIsIDIpLCAxNik7XG4gICAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zdWJzdHIoc3RhcnRJbmRleCArIDQsIDIpLCAxNik7XG4gICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhbHBoYSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdXBwbGllZCBoZXggc3RyaW5nIE1VU1QgYmUgaW4gZm9ybSAnIzAwMDAwMDAwJyAoaS5lLiBsZWFkaW5nIHBvdW5kIHN5bWJvbCwgOCBoZXggY2hhcmFjdGVycyBhZnRlcilcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhleCBoZXhhZGVjaW1hbCBjb2xvciBzdHJpbmdcbiAgICogQHJldHVybnMge0NvbG9yfVxuICAgKi9cblxuXG4gIHN0YXRpYyBmcm9tSGV4OFN0cmluZyhoZXgpIHtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaGV4LnN0YXJ0c1dpdGgoJyMnKSA/IDEgOiAwO1xuICAgIGNvbnN0IGFscGhhID0gcGFyc2VJbnQoaGV4LnN1YnN0cihzdGFydEluZGV4LCAyKSwgMTYpOyAvLyBhbHBoYSBpcyBub3cgMC0yNTVcblxuICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyAyLCAyKSwgMTYpO1xuICAgIGNvbnN0IGcgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA0LCAyKSwgMTYpO1xuICAgIGNvbnN0IGIgPSBwYXJzZUludChoZXguc3Vic3RyKHN0YXJ0SW5kZXggKyA2LCAyKSwgMTYpO1xuICAgIHJldHVybiBuZXcgQ29sb3IociwgZywgYiwgYWxwaGEgLyAyNTUuMCk7IC8vIGNvbnZlcnQgdG8gMC4wLTEuMCAocGVyY2VudClcbiAgfVxuICAvKipcbiAgICogTm90ZSB0aGF0IHRoZSBoZXggdmFsdWUgY2FuIGNvbnRhaW4gYWxwaGEsIGJ1dCBtdXN0IGZvbGxvdyB0aGUgQ1NTIHN0YW5kYXJkIG9mICNSUkdHQkJBQSAoTk9UIHRoZSBBbmRyb2lkIHN0YW5kYXJkIG9mICNBQVJSR0dCQilcbiAgICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBlbnRyeSBwb3NzaWJsZSBoZXggc3RyaW5nIG9yIGFuIG9iamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtoZXguYWxwaGFdIGFscGhhIHZhbHVlIGluIHBlcmNlbnQgKDAuMC0xMDAuMCkgd2hlbiBoZXggaXMgYW4gb2JqZWN0XG4gIFx0ICogQHBhcmFtIHtzdHJpbmd9IFtoZXguY29sb3JdIGhleCBzdHJpbmcgZm9yIHRoZSBiYXNlIGNvbG9yIHdoZW4gaGV4IGlzIGFuIG9iamVjdFxuICAgKiBAcmV0dXJucyB7Q29sb3J9XG4gICAqIEB0aHJvd3MgaWYgZW50cnkgaGFzIGJvdGggYW4gZXhwbGljaXQgYWxwaGEgdmFsdWUgQU5EIGEgaGV4IHN0cmluZyBjb250YWluaW5nIGFuIGFscGhhIHZhbHVlXG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb21TZW1hbnRpY0NvbG9yc0VudHJ5KGVudHJ5KSB7XG4gICAgbGV0IGNvbG9yID0gZW50cnk7XG4gICAgbGV0IGFscGhhID0gMS4wO1xuICAgIGxldCBoYWRBbHBoYSA9IGZhbHNlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnRyeSwgJ2FscGhhJykpIHtcbiAgICAgIGFscGhhID0gcGFyc2VGbG9hdChlbnRyeS5hbHBoYSkgLyAxMDAuMDsgLy8gY29udmVydCBmcm9tIDAtMTAwIHJhbmdlIHRvIDAtMSByYW5nZVxuXG4gICAgICBoYWRBbHBoYSA9IHRydWU7XG4gICAgICBjb2xvciA9IGVudHJ5LmNvbG9yOyAvLyBpZiBpdCBoYXMgYW4gYWxwaGEgcHJvcGVydHkgYXNzdW1lIGl0IGhhcyBhIGNvbG9yIHByb3BlcnR5IHRvbyFcbiAgICB9IC8vIGV4cGFuZCB0aGUgc2hvcnRlciBoZXggc3RyaW5nIGZvcm1zIHRvIDYgb3IgOCBkaWdpdHNcblxuXG4gICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gMykge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGXCIpIHRvIGZ1bGwgZm9ybSAoZS5nLiBcIjAwMzNGRlwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF8zX1JFR0VYLCAobSwgciwgZywgYikgPT4gciArIHIgKyBnICsgZyArIGIgKyBiKTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgLy8gRXhwYW5kIHNob3J0aGFuZCBmb3JtIChlLmcuIFwiMDNGOFwiKSB0byBmdWxsIGZvcm0gKGUuZy4gXCIwMDMzRkY4OFwiKVxuICAgICAgY29sb3IgPSBjb2xvci5yZXBsYWNlKEhFWF80X1JFR0VYLCAobSwgYSwgciwgZywgYikgPT4gYSArIGEgKyByICsgciArIGcgKyBnICsgYiArIGIpO1xuICAgIH1cblxuICAgIGlmIChIRVhfNl9SRUdFWC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXg2U3RyaW5nKGNvbG9yLCBhbHBoYSk7XG4gICAgfVxuXG4gICAgaWYgKEhFWF84X1JFR0VYLmV4ZWMoY29sb3IpKSB7XG4gICAgICBpZiAoaGFkQWxwaGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2xvciAke2VudHJ5fSBoYWQgYW4gZXhwbGljaXQgYWxwaGEgdmFsdWUgQU5EIGEgaGV4IHZhbHVlIGNvbnRhaW5pbmcgYWxwaGEuIFVzZSBvbmUgb3IgdGhlIG90aGVyLmApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29sb3IuZnJvbUhleDhTdHJpbmcoY29sb3IpO1xuICAgIH0gLy8gdWgtb2gsIHNvbWV0aGluZyBpcyB1cCFcblxuXG4gICAgcmV0dXJuIENvbG9yLmZhbGxiYWNrKCk7XG4gIH1cblxufVxuXG52YXIgY29sb3IgPSBDb2xvcjtcblxuLyoqXG4gKiBBcHBjZWxlcmF0b3IgVGl0YW5pdW0gTW9iaWxlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTktMjAyMCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuLy8gVGkuVUkgd2l0aGluIHRoaXMgZmlsZSwgd2UgbXVzdCBjYWxsIGtyb2xsLmJpbmRpbmcgdG8gZ2V0IHRoZSBUaXRhbml1bVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgcGFzc2VkIGluIHdpdGggcmVxdWlyZSBhbmQgdGhhdCBkZWFsIHdpdGggdGhlIC5VSVxuLy8gbmFtZXNwYWNlIHRoYXQgaXMgb24gdGhhdCBkaXJlY3RseS5cblxuY29uc3QgVUkgPSAga3JvbGwuYmluZGluZygnVGl0YW5pdW0nKS5UaXRhbml1bS5VSSA7IC8vIE1ha2Ugb3VyIHJlYWQtb25seSBjb25zdGFudHNcbi8vIFRPRE86IFJlbW92ZSBpbiBTREsgMTAsIERFUFJFQ0FURUQgaW4gOS4xLjBcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFVJLCAnU0VNQU5USUNfQ09MT1JfVFlQRV9MSUdIVCcsIHtcbiAgdmFsdWU6ICdsaWdodCcsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVUksICdTRU1BTlRJQ19DT0xPUl9UWVBFX0RBUksnLCB7XG4gIHZhbHVlOiAnZGFyaycsXG4gIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVUksICdzZW1hbnRpY0NvbG9yVHlwZScsIHtcbiAgZ2V0OiAoKSA9PiB7XG4gICAgLy8gVE9ETzogR3VhcmQgYWdhaW5zdCBpb3MgPCAxMyBhbmQgQW5kcm9pZCBhcGkgPCAyOT9cbiAgICAvLyBBc3N1bWUgXCJsaWdodFwiIG1vZGUgdW5sZXNzIHdlIGV4cGxpY2l0bHkga25vdyBpdCdzIGRhcmtcbiAgICBpZiAoVGkuVUkudXNlckludGVyZmFjZVN0eWxlID09PSBUaS5VSS5VU0VSX0lOVEVSRkFDRV9TVFlMRV9EQVJLKSB7XG4gICAgICByZXR1cm4gVUkuU0VNQU5USUNfQ09MT1JfVFlQRV9EQVJLO1xuICAgIH1cblxuICAgIHJldHVybiBVSS5TRU1BTlRJQ19DT0xPUl9UWVBFX0xJR0hUO1xuICB9XG59KTsgLy8gb24gQW5kcm9pZC9pT1MgPCAxMywgd2UgbmVlZCB0byByb2xsIG91ciBvd24gZmV0Y2hTZW1hbnRpY0NvbG9yIGltcGxcbi8vIG9uIGlPUyAxMyssIHdlIGhhdmUgYSBuYXRpdmUgdmVyc2lvblxuXG57XG5cbiAgbGV0IGNvbG9yc2V0O1xuXG4gIFVJLmZldGNoU2VtYW50aWNDb2xvciA9IGZ1bmN0aW9uIGZldGNoU2VtYW50aWNDb2xvcihjb2xvck5hbWUpIHtcbiAgICBpZiAoIWNvbG9yc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb2xvcnNldEZpbGUgPSBUaS5GaWxlc3lzdGVtLmdldEZpbGUoVGkuRmlsZXN5c3RlbS5yZXNvdXJjZXNEaXJlY3RvcnksICdzZW1hbnRpYy5jb2xvcnMuanNvbicpO1xuXG4gICAgICAgIGlmIChjb2xvcnNldEZpbGUuZXhpc3RzKCkpIHtcbiAgICAgICAgICBjb2xvcnNldCA9IEpTT04ucGFyc2UoY29sb3JzZXRGaWxlLnJlYWQoKS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IHRocm93IGFuIEVycm9yIGhlcmUgKG9yIHJldHVybiBhIGZhbGxiYWNrIGNvbG9yISlcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgY29sb3JzIGZpbGUgXFwnc2VtYW50aWMuY29sb3JzLmpzb25cXCcnKTtcbiAgICAgICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKCFjb2xvcnNldFtjb2xvck5hbWVdKSB7XG4gICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBub3QgaW4gdGhlIHNlbWFudGljIGNvbG9ycyBhbmQgd2UncmUgb24gQW5kcm9pZCwgaXQgbWF5IGJlIGEgVGkuQW5kcm9pZC5SLmNvbG9yIHZhbHVlXG4gICAgICAgICAgY29uc3Qgc3lzdGVtQ29sb3JJZCA9IFRpLkFuZHJvaWQuUi5jb2xvcltjb2xvck5hbWVdO1xuXG4gICAgICAgICAgaWYgKHN5c3RlbUNvbG9ySWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlQ29sb3IgPSBUaS5VSS5BbmRyb2lkLmdldENvbG9yUmVzb3VyY2Uoc3lzdGVtQ29sb3JJZCk7XG5cbiAgICAgICAgICAgIGlmIChyZXNvdXJjZUNvbG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZUNvbG9yLnRvSGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yLmZhbGxiYWNrKCkudG9IZXgoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW50cnkgPSBjb2xvcnNldFtjb2xvck5hbWVdW1VJLnNlbWFudGljQ29sb3JUeXBlXTtcbiAgICAgIGNvbnN0IGNvbG9yT2JqID0gY29sb3IuZnJvbVNlbWFudGljQ29sb3JzRW50cnkoZW50cnkpOyAvLyBGb3Igbm93LCByZXR1cm4gYSBzdHJpbmcgb24gaU9TIDwgMTMsIEFuZHJvaWQgc28gd2UgY2FuIHBhc3MgdGhlIHJlc3VsdCBkaXJlY3RseSB0byB0aGUgVUkgcHJvcGVydHkgd2Ugd2FudCB0byBzZXRcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIG1vZGlmeSB0aGUgQW5kcm9pZCBBUElzIHRvIGFjY2VwdCBmYWtlL3JlYWwgVGkuVUkuQ29sb3IgaW5zdGFuY2VzIGFuZCBjb252ZXJ0IGl0IHRvIGl0J3Mgb3duIGludGVybmFsXG4gICAgICAvLyBDb2xvciByZXByZXNlbnRhdGlvblxuXG4gICAgICByZXR1cm4gY29sb3JPYmoudG9SR0JBU3RyaW5nKCk7IC8vIElmIHRoZXJlJ3MgYW4gZW50cnksIHVzZSB0aGUgbW9yZSBleGFjdCByZ2JhIGZ1bmN0aW9uIG92ZXIgOC1jaGFyIEFSR0IgaGV4LiBIYXJkIHRvIGNvbnZlcnQgdGhpbmdzIGxpa2UgNzUlIGFscGhhIHByb3Blcmx5LlxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9va3VwIGNvbG9yIGZvciAke2NvbG9yTmFtZX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29sb3IuZmFsbGJhY2soKS50b0hleCgpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIHRoZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdG8gdXNlIHRvIHJlZ2lzdGVyIGZvciBpdCdzIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgZm9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2svZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGV2ZW50IGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJlcGVuZCB3aGV0aGVyIHRvIHByZXBlbmQgb3IgYXBwZW5kIHRoZSBsaXN0ZW5lclxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqL1xuZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgIGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307IC8vIGluaXRpYWxpemUgaXRcbiAgfSAvLyBpZiB0aGVyZSdzIHNvbWVvbmUgbGlzdGVuaW5nIHRvICduZXdMaXN0ZW5lcicgZXZlbnRzLCBlbWl0IHRoYXQgKipiZWZvcmUqKiB3ZSBhZGQgdGhlIGxpc3RlbmVyICh0byBhdm9pZCBpbmZpbml0ZSByZWN1cnNpb24pXG5cblxuICBpZiAoZW1pdHRlci5fZXZlbnRzVG9MaXN0ZW5lcnMubmV3TGlzdGVuZXIpIHtcbiAgICBlbWl0dGVyLmVtaXQoJ25ld0xpc3RlbmVyJywgZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cblxuICBjb25zdCBldmVudExpc3RlbmVycyA9IGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gfHwgW107XG5cbiAgaWYgKHByZXBlbmQpIHtcbiAgICBldmVudExpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBldmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVtaXR0ZXIuX2V2ZW50c1RvTGlzdGVuZXJzW2V2ZW50TmFtZV0gPSBldmVudExpc3RlbmVyczsgLy8gQ2hlY2sgbWF4IGxpc3RlbmVycyBhbmQgc3BpdCBvdXQgd2FybmluZyBpZiA+XG5cbiAgY29uc3QgbWF4ID0gZW1pdHRlci5nZXRNYXhMaXN0ZW5lcnMoKTtcbiAgY29uc3QgbGVuZ3RoID0gZXZlbnRMaXN0ZW5lcnMubGVuZ3RoO1xuXG4gIGlmIChtYXggPiAwICYmIGxlbmd0aCA+IG1heCkge1xuICAgIGNvbnN0IHcgPSBuZXcgRXJyb3IoYFBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJHtsZW5ndGh9ICR7ZXZlbnROYW1lfSBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0YCk7XG4gICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgdy5lbWl0dGVyID0gZW1pdHRlcjtcbiAgICB3LnR5cGUgPSBldmVudE5hbWU7XG4gICAgdy5jb3VudCA9IGxlbmd0aDtcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHcpO1xuICB9XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbmZ1bmN0aW9uIG9uY2VXcmFwKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgZnVuY3Rpb24gd3JhcHBlciguLi5hcmdzKSB7XG4gICAgdGhpcy5lbWl0dGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLndyYXBwZWRGdW5jKTsgLy8gcmVtb3ZlIG91cnNlbHZlc1xuXG4gICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLmVtaXR0ZXIsIGFyZ3MpOyAvLyB0aGVuIGZvcndhcmQgdGhlIGV2ZW50IGNhbGxiYWNrXG4gIH0gLy8gd2UgaGF2ZSB0byB1c2UgYmluZCB3aXRoIGEgY3VzdG9tICd0aGlzJywgYmVjYXVzZSBldmVudHMgZmlyZSB3aXRoICd0aGlzJyBwb2ludGluZyBhdCB0aGUgZW1pdHRlclxuXG5cbiAgY29uc3Qgd3JhcHBlclRoaXMgPSB7XG4gICAgZW1pdHRlcixcbiAgICBldmVudE5hbWUsXG4gICAgbGlzdGVuZXJcbiAgfTtcbiAgY29uc3QgYm91bmQgPSB3cmFwcGVyLmJpbmQod3JhcHBlclRoaXMpOyAvLyBiaW5kIHRvIGZvcmNlIFwidGhpc1wiIHRvIHJlZmVyIHRvIG91ciBjdXN0b20gb2JqZWN0IHRyYWNraW5nIHRoZSB3cmFwcGVyL2VtaXR0ZXIvbGlzdGVuZXJcblxuICBib3VuZC5saXN0ZW5lciA9IGxpc3RlbmVyOyAvLyBoYXZlIHRvIGFkZCBsaXN0ZW5lciBwcm9wZXJ0eSBmb3IgXCJ1bndyYXBwaW5nXCJcblxuICB3cmFwcGVyVGhpcy53cmFwcGVkRnVuYyA9IGJvdW5kO1xuICByZXR1cm4gYm91bmQ7XG59IC8vIG1hbnkgY29uc3VtZXJzIG1ha2UgdXNlIG9mIHRoaXMgdmlhIHV0aWwuaW5oZXJpdHMsIHdoaWNoIGRvZXMgbm90IGNoYWluIGNvbnN0cnVjdG9yIGNhbGxzIVxuLy8gc28gd2UgbmVlZCB0byBiZSBhd2FyZSB0aGF0IF9ldmVudHNUb0xpc3RlbmVycyBtYXllIGJlIG51bGwvdW5kZWZpbmVkIG9uIGluc3RhbmNlcywgYW5kIGNoZWNrIGluIG1ldGhvZHMgYmVmb3JlIGFjY2Vzc2luZyBpdFxuXG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICB9XG5cbiAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICB9XG5cbiAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5vbihldmVudE5hbWUsIG9uY2VXcmFwKHRoaXMsIGV2ZW50TmFtZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgb25jZVdyYXAodGhpcywgZXZlbnROYW1lLCBsaXN0ZW5lcikpO1xuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGV2ZW50TGlzdGVuZXJzLmxlbmd0aDtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xO1xuICAgIGxldCB1bndyYXBwZWRMaXN0ZW5lcjsgLy8gTmVlZCB0byBzZWFyY2ggTElGTywgYW5kIG5lZWQgdG8gaGFuZGxlIHdyYXBwZWQgZnVuY3Rpb25zIChvbmNlIHdyYXBwZXJzKVxuXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoZXZlbnRMaXN0ZW5lcnNbaV0gPT09IGxpc3RlbmVyIHx8IGV2ZW50TGlzdGVuZXJzW2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBmb3VuZEluZGV4ID0gaTtcbiAgICAgICAgdW53cmFwcGVkTGlzdGVuZXIgPSBldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIGxlbmd0aCB3YXMgMSBhbmQgd2Ugd2FudCB0byByZW1vdmUgbGFzdCBlbnRyeSwgc28gZGVsZXRlIHRoZSBldmVudCB0eXBlIGZyb20gb3VyIGxpc3RlbmVyIG1hcHBpbmcgbm93IVxuICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGhhZCAyKyBsaXN0ZW5lcnMsIHNvIHN0b3JlIGFycmF5IHdpdGhvdXQgdGhpcyBnaXZlbiBsaXN0ZW5lclxuICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoZm91bmRJbmRleCwgMSk7IC8vIG1vZGlmaWVzIGluIHBsYWNlLCBubyBuZWVkIHRvIGFzc2lnbiB0byB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdXG4gICAgICB9IC8vIERvbid0IGVtaXQgaWYgdGhlcmUncyBubyBsaXN0ZW5lcnMgZm9yICdyZW1vdmVMaXN0ZW5lcicgdHlwZSFcblxuXG4gICAgICBpZiAodGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIGV2ZW50TmFtZSwgdW53cmFwcGVkTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuXG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBldmVudExpc3RlbmVycy5zbGljZSgpKSB7XG4gICAgICAvLyBtdXN0IG9wZXJhdGUgb24gY29weSBiZWNhdXNlIGxpc3RlbmVycyAsYXkgZ2V0IHJlbW92ZSBhcyBzaWRlLWVmZmVjdCBvZiBjYWxsaW5nXG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGggIT09IDA7XG4gIH1cblxuICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHJldHVybiBldmVudExpc3RlbmVycy5sZW5ndGg7XG4gIH1cblxuICBldmVudE5hbWVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9ldmVudHNUb0xpc3RlbmVycyB8fCB7fSk7XG4gIH1cblxuICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNUb0xpc3RlbmVycykge1xuICAgICAgLy8gbm8gZXZlbnRzL2xpc3RlbmVycyByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gW107XG4gICAgfSAvLyBOZWVkIHRvIFwidW53cmFwXCIgb25jZSB3cmFwcGVycyFcblxuXG4gICAgY29uc3QgcmF3ID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcbiAgICByZXR1cm4gcmF3Lm1hcChsID0+IGwubGlzdGVuZXIgfHwgbCk7IC8vIGhlcmUgd2UgdW53cmFwIHRoZSBvbmNlIHdyYXBwZXIgaWYgdGhlcmUgaXMgb25lIG9yIGZhbGwgYmFjayB0byBsaXN0ZW5lciBmdW5jdGlvblxuICB9XG5cbiAgcmF3TGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXSkuc2xpY2UoMCk7IC8vIHJldHVybiBhIGNvcHlcbiAgfVxuXG4gIGdldE1heExpc3RlbmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9XG5cbiAgc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuOyAvLyBUT0RPOiBUeXBlIGNoZWNrIG4sIG1ha2Ugc3VyZSA+PSAwIChvIGVxdWFscyBubyBsaW1pdClcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMpIHtcbiAgICAgIC8vIG5vIGV2ZW50cy9saXN0ZW5lcnMgcmVnaXN0ZXJlZFxuICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTsgLy8gaW5pdGlhbGl6ZSBpdFxuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgIC8vIG5vIG5lZWQgdG8gZW1pdCEgd2UgY2FuIGp1c3Qgd2lwZSFcbiAgICAgIGlmIChldmVudE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZW1vdmUgZXZlcnkgdHlwZSFcbiAgICAgICAgdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnMgPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBzcGVjaWZpYyB0eXBlXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNUb0xpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IC8vIHl1Y2ssIHdlJ2xsIGhhdmUgdG8gZW1pdCAncmVtb3ZlTGlzdGVuZXInIGV2ZW50cyBhcyB3ZSBnb1xuXG5cbiAgICBpZiAoZXZlbnROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFJlbW92ZSBhbGwgdHlwZXMgKGJ1dCBkbyAncmVtb3ZlTGlzdGVuZXInIGxhc3QhKVxuICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9ldmVudHNUb0xpc3RlbmVycykuZmlsdGVyKG5hbWUgPT4gbmFtZSAhPT0gJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMobmFtZSkpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICB0aGlzLl9ldmVudHNUb0xpc3RlbmVycyA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJzIGZvciBvbmUgdHlwZSwgYmFjayB0byBmcm9udCAoTGFzdC1pbiwgZmlyc3Qtb3V0LCBleGNlcHQgd2hlcmUgcHJlcGVuZCBmLWVkIGl0IHVwKVxuICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzVG9MaXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG59XG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCBldmVudE5hbWUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLyoqXG4gKiBAcGFyYW0gIHsqfSBhcmcgcGFzc2VkIGluIGFyZ3VtZW50IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgYXJndW1lbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZW5hbWUgaS5lLiAnc3RyaW5nJywgJ0Z1bmN0aW9uJyAodmFsdWUgaXMgY29tcGFyZWQgdG8gdHlwZW9mIGFmdGVyIGxvd2VyY2FzaW5nKVxuICogQHJldHVybiB7dm9pZH1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0QXJndW1lbnRUeXBlKGFyZywgbmFtZSwgdHlwZW5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG5cbiAgaWYgKHR5cGUgIT09IHR5cGVuYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlICR7dHlwZW5hbWV9LiBSZWNlaXZlZCB0eXBlICR7dHlwZX1gKTtcbiAgfVxufVxuXG5jb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uICdzdGFuZGFyZGl6ZXMnIHRoZSByZXBvcnRlZCBhcmNoaXRlY3R1cmVzIHRvIHRoZSBlcXVpdmFsZW50cyByZXBvcnRlZCBieSBOb2RlLmpzXG4gKiBub2RlIHZhbHVlczogJ2FybScsICdhcm02NCcsICdpYTMyJywgJ21pcHMnLCAnbWlwc2VsJywgJ3BwYycsICdwcGM2NCcsICdzMzkwJywgJ3MzOTB4JywgJ3gzMicsIGFuZCAneDY0Jy5cbiAqIGlPUyB2YWx1ZXM6IFwiYXJtNjRcIiwgXCJhcm12N1wiLCBcIng4Nl82NFwiLCBcImkzODZcIiwgXCJVbmtub3duXCJcbiAqIEFuZHJvaWQgdmFsdWVzOiBcImFybWVhYmlcIiwgXCJhcm1lYWJpLXY3YVwiLCBcImFybTY0LXY4YVwiLCBcIng4NlwiLCBcIng4Nl82NFwiLCBcIm1pcHNcIiwgXCJtaXBzNjRcIiwgXCJ1bmtub3duXCJcbiAqIFdpbmRvd3MgdmFsdWVzOiBcIng2NFwiLCBcImlhNjRcIiwgXCJBUk1cIiwgXCJ4ODZcIiwgXCJ1bmtub3duXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW5hbCBvcmlnaW5hbCBhcmNoaXRlY3R1cmUgcmVwb3J0ZWQgYnkgVGkuUGxhdGZvcm1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gc3RhbmRhcmRpemVBcmNoKG9yaWdpbmFsKSB7XG4gIHN3aXRjaCAob3JpZ2luYWwpIHtcbiAgICAvLyBjb2VyY2UgJ2FybXY3JywgJ2FybWVhYmknLCAnYXJtZWFiaS12N2EnLCAnQVJNJyAtPiAnYXJtJ1xuICAgIC8vICdhcm1lYWJpJyBpcyBhIGRlYWQgQUJJIGZvciBBbmRyb2lkLCByZW1vdmVkIGluIE5ESyByMTdcbiAgICBjYXNlICdhcm12Nyc6XG4gICAgY2FzZSAnYXJtZWFiaSc6XG4gICAgY2FzZSAnYXJtZWFiaS12N2EnOlxuICAgIGNhc2UgJ0FSTSc6XG4gICAgICByZXR1cm4gJ2FybSc7XG4gICAgLy8gY29lcmNlICdhcm02NC12OGEnIC0+ICdhcm02NCdcblxuICAgIGNhc2UgJ2FybTY0LXY4YSc6XG4gICAgICByZXR1cm4gJ2FybTY0JztcbiAgICAvLyBjb2VyY2UgJ2kzODYnLCAneDg2JyAtPiAnaWEzMidcblxuICAgIGNhc2UgJ2kzODYnOlxuICAgIGNhc2UgJ3g4Nic6XG4gICAgICByZXR1cm4gJ2lhMzInO1xuICAgIC8vIGNvZXJjZSAneDg2XzY0JywgJ2lhNjQnLCAneDY0JyAtPiAneDY0J1xuXG4gICAgY2FzZSAneDg2XzY0JzpcbiAgICBjYXNlICdpYTY0JzpcbiAgICAgIHJldHVybiAneDY0JztcbiAgICAvLyBjb2VyY2UgJ21pcHM2NCcgLT4gJ21pcHMnIC8vICdtaXBzJyBhbmQgJ21pcHM2NCcgYXJlIGRlYWQgQUJJcyBmb3IgQW5kcm9pZCwgcmVtb3ZlZCBpbiBOREsgcjE3XG5cbiAgICBjYXNlICdtaXBzNjQnOlxuICAgICAgcmV0dXJuICdtaXBzJztcbiAgICAvLyBjb2VyY2UgJ1Vua25vd24nIC0+ICd1bmtub3duJ1xuXG4gICAgY2FzZSAnVW5rbm93bic6XG4gICAgICByZXR1cm4gJ3Vua25vd24nO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgfVxufVxuXG5jb25zdCBwcm9jZXNzJDEgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbnByb2Nlc3MkMS5hYm9ydCA9ICgpID0+IHt9OyAvLyBUT0RPOiBEbyB3ZSBoYXZlIGVxdWl2YWxlbnQgb2YgZm9yY2libHkga2lsbGluZyB0aGUgcHJvY2Vzcz8gV2UgaGF2ZSByZXN0YXJ0LCBidXQgSSB0aGluayB3ZSBqdXN0IHdhbnQgYSBuby1vcCBzdHViIGhlcmVcblxuXG5wcm9jZXNzJDEuYXJjaCA9IHN0YW5kYXJkaXplQXJjaChUaS5QbGF0Zm9ybS5hcmNoaXRlY3R1cmUpO1xucHJvY2VzcyQxLmFyZ3YgPSBbXTsgLy8gVE9ETzogV2hhdCBtYWtlcyBzZW5zZSBoZXJlPyBwYXRoIHRvIHRpdGFuaXVtIGNsaSBmb3IgZmlyc3QgYXJnPyBwYXRoIHRvIHRpLm1haW4vYXBwLmpzIGZvciBzZWNvbmQ/XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDEsICdhcmd2MCcsIHtcbiAgdmFsdWU6ICcnLFxuICAvLyBUT0RPOiBQYXRoIHRvIC5hcHAgb24gaU9TP1xuICB3cml0YWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn0pO1xuXG5wcm9jZXNzJDEuYmluZGluZyA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgdW5zdXBwb3J0ZWQgYW5kIG5vdCB1c2VyLWZhY2luZyBBUEknKTtcbn07XG5cbnByb2Nlc3MkMS5jaGFubmVsID0gdW5kZWZpbmVkO1xuXG5wcm9jZXNzJDEuY2hkaXIgPSAoKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyB1bnN1cHBvcnRlZCcpO1xufTtcblxucHJvY2VzcyQxLmNvbmZpZyA9IHt9O1xucHJvY2VzcyQxLmNvbm5lY3RlZCA9IGZhbHNlO1xuXG5wcm9jZXNzJDEuY3B1VXNhZ2UgPSAoKSA9PiB7XG4gIC8vIEZJWE1FOiBDYW4gd2UgbG9vayBhdCBPUy5jcHVzIHRvIGdldCB0aGlzIGRhdGE/XG4gIHJldHVybiB7XG4gICAgdXNlcjogMCxcbiAgICBzeXN0ZW06IDBcbiAgfTtcbn07XG5cbnByb2Nlc3MkMS5jd2QgPSAoKSA9PiBfX2Rpcm5hbWU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9jZXNzJDEsICdkZWJ1Z1BvcnQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGxldCB2YWx1ZSA9IDA7IC8vIGRlZmF1bHQgdG8gMFxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChcImFuZHJvaWRcIiA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IGtyb2xsLmJpbmRpbmcoJ2Fzc2V0cycpO1xuICAgICAgICBjb25zdCBqc29uID0gYXNzZXRzLnJlYWRBc3NldCgnZGVwbG95Lmpzb24nKTtcblxuICAgICAgICBpZiAoanNvbikge1xuICAgICAgICAgIGNvbnN0IGRlcGxveURhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXG4gICAgICAgICAgaWYgKGRlcGxveURhdGEuZGVidWdnZXJQb3J0ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gLTEgbWVhbnMgbm90IHNldCAobm90IGluIGRlYnVnIG1vZGUpXG4gICAgICAgICAgICB2YWx1ZSA9IGRlcGxveURhdGEuZGVidWdnZXJQb3J0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBpZ25vcmVcbiAgICAvLyBvdmVyd3JpdGUgdGhpcyBnZXR0ZXIgd2l0aCBzdGF0aWMgdmFsdWVcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdkZWJ1Z1BvcnQnLCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZVxufSk7XG5cbnByb2Nlc3MkMS5kaXNjb25uZWN0ID0gKCkgPT4ge307IC8vIG5vLW9wXG5cblxucHJvY2VzcyQxLmRsb3BlbiA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmRsb3BlbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzJDEuZW1pdFdhcm5pbmcgPSBmdW5jdGlvbiAod2FybmluZywgb3B0aW9ucywgY29kZSwgY3Rvcikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGxldCB0eXBlO1xuICBsZXQgZGV0YWlsO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICB0eXBlID0gb3B0aW9ucztcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gb3B0aW9ucy50eXBlO1xuICAgIGNvZGUgPSBvcHRpb25zLmNvZGU7XG4gICAgZGV0YWlsID0gb3B0aW9ucy5kZXRhaWw7XG4gIH1cblxuICBpZiAodHlwZW9mIHdhcm5pbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVE9ETzogbWFrZSB1c2Ugb2YgYGN0b3JgIGFyZyBmb3IgbGltaXRpbmcgc3RhY2sgdHJhY2VzPyBDYW4gb25seSByZWFsbHkgYmUgdXNlZCBvbiBWOFxuICAgIC8vIHNldCBzdGFjayB0cmFjZSBsaW1pdCB0byAwLCB0aGVuIGNhbGwgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Uod2FybmluZywgY3Rvcik7XG4gICAgd2FybmluZyA9IG5ldyBFcnJvcih3YXJuaW5nKTtcbiAgICB3YXJuaW5nLm5hbWUgPSB0eXBlIHx8ICdXYXJuaW5nJztcblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdhcm5pbmcuY29kZSA9IGNvZGU7XG4gICAgfVxuXG4gICAgaWYgKGRldGFpbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuaW5nLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG4gIH0gLy8gVE9ETzogVGhyb3cgVHlwZUVycm9yIGlmIG5vdCBhbiBpbnN0YW5jZW9mIEVycm9yIGF0IHRoaXMgcG9pbnQhXG5cblxuICBjb25zdCBpc0RlcHJlY2F0aW9uID0gd2FybmluZy5uYW1lID09PSAnRGVwcmVjYXRpb25XYXJuaW5nJztcblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDEubm9EZXByZWNhdGlvbikge1xuICAgIHJldHVybjsgLy8gaWdub3JlXG4gIH1cblxuICBpZiAoaXNEZXByZWNhdGlvbiAmJiBwcm9jZXNzJDEudGhyb3dEZXByZWNhdGlvbikge1xuICAgIHRocm93IHdhcm5pbmc7XG4gIH1cblxuICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCB3YXJuaW5nKTtcbn07XG5cbmZ1bmN0aW9uIGxvYWRFbnZKc29uKCkge1xuICB0cnkge1xuICAgIGNvbnN0IGpzb25GaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCAnX2Vudl8uanNvbicpO1xuXG4gICAgaWYgKGpzb25GaWxlLmV4aXN0cygpKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uRmlsZS5yZWFkKCkudGV4dCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFRpLkFQSS5lcnJvcihgRmFpbGVkIHRvIHJlYWQgXCJfZW52Xy5qc29uXCIuIFJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvY2VzcyQxLCAnZW52Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBkZWxldGUgdGhpcy5lbnY7XG4gICAgcmV0dXJuIHRoaXMuZW52ID0gbG9hZEVudkpzb24oKTtcbiAgfSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlXG59KTtcbnByb2Nlc3MkMS5leGVjQXJndiA9IFtdO1xucHJvY2VzcyQxLmV4ZWNQYXRoID0gJyc7IC8vIEZJWE1FOiBXaGF0IG1ha2VzIHNlbnNlIGhlcmU/IFBhdGggdG8gdGl0YW5pdW0gQ0xJIGhlcmU/XG5cbnByb2Nlc3MkMS5leGl0ID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuZXhpdCBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzJDEuZXhpdENvZGUgPSB1bmRlZmluZWQ7XG5wcm9jZXNzJDEubm9EZXByZWNhdGlvbiA9IGZhbHNlO1xucHJvY2VzcyQxLnBpZCA9IDA7IC8vIEZJWE1FOiBTaG91bGQgd2UgdHJ5IGFuZCBhZG9wdCAnaXBhZCcvJ2lwaG9uZScgdG8gJ2Rhcndpbic/IG9yICdpb3MnP1xuXG5wcm9jZXNzJDEucGxhdGZvcm0gPSBcImFuZHJvaWRcIjtcbnByb2Nlc3MkMS5wcGlkID0gMDsgLy8gVE9ETzogQWRkIHJlbGVhc2UgcHJvcGVydHkgKE9iamVjdClcbi8vIFRPRE86IENhbiB3ZSBleHBvc2Ugc3Rkb3V0L3N0ZGVyci9zdGRpbiBuYXRpdmVseT9cbi8vIERvbid0IHdyYXAgY29uc29sZS5sb2cvZXJyb3IgYmVjYXVzZSB0ZWNobmljYWxseSBnbG9iYWwgY29uc29sZSB3cmFwcyBwcm9jZXNzLnN0ZG91dC9zdGRlcnIgKG9yIHNob3VsZClcblxucHJvY2VzcyQxLnN0ZGVyciA9IHtcbiAgaXNUVFk6IGZhbHNlLFxuICB3cml0YWJsZTogdHJ1ZSxcbiAgd3JpdGU6IChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSA9PiB7XG4gICAgVGkuQVBJLmVycm9yKGNodW5rKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnByb2Nlc3MkMS5zdGRvdXQgPSB7XG4gIGlzVFRZOiBmYWxzZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgIFRpLkFQSS5pbmZvKGNodW5rKTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnByb2Nlc3MkMS50aXRsZSA9IFRpLkFwcC5uYW1lO1xucHJvY2VzcyQxLnRocm93RGVwcmVjYXRpb24gPSBmYWxzZTtcbnByb2Nlc3MkMS50cmFjZURlcHJlY2F0aW9uID0gZmFsc2U7XG5cbnByb2Nlc3MkMS51bWFzayA9ICgpID0+IDA7IC8vIGp1c3QgYWx3YXlzIHJldHVybiAwXG5cblxucHJvY2VzcyQxLnVwdGltZSA9ICgpID0+IHtcbiAgY29uc3QgZGlmZk1zID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgcmV0dXJuIGRpZmZNcyAvIDEwMDAuMDsgLy8gY29udmVydCB0byBcInNlY29uZHNcIiB3aXRoIGZyYWN0aW9uc1xufTtcblxucHJvY2VzcyQxLnZlcnNpb24gPSBcIjkuMi4xXCI7XG5wcm9jZXNzJDEudmVyc2lvbnMgPSB7XG4gIG1vZHVsZXM6ICcnLFxuICAvLyBUT0RPOiBSZXBvcnQgbW9kdWxlIGFwaSB2ZXJzaW9uIChmb3IgY3VycmVudCBwbGF0Zm9ybSEpXG4gIHY4OiAnJyxcbiAgLy8gVE9ETzogcmVwb3J0IGFuZHJvaWQncyB2OCB2ZXJzaW9uIChpZiBvbiBBbmRyb2lkISlcbiAganNjOiAnJyAvLyBUT0RPOiByZXBvcnQgamF2YXNjcmlwdGNvcmUgdmVyc2lvbiBmb3IgaU9TL1dJbmRvd3M/XG4gIC8vIFRPRE86IFJlcG9ydCBpb3MvQW5kcm9pZC9XaW5kb3dzIHBsYXRmb3JtIHZlcnNpb25zP1xuXG59O1xucHJvY2VzcyQxW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAncHJvY2Vzcyc7XG5nbG9iYWwucHJvY2VzcyA9IHByb2Nlc3MkMTsgLy8gaGFuZGxlIHNwaXR0aW5nIG91dCB3YXJuaW5nc1xuXG5jb25zdCBXQVJOSU5HX1BSRUZJWCA9IGAodGl0YW5pdW06JHtwcm9jZXNzJDEucGlkfSkgYDtcbnByb2Nlc3MkMS5vbignd2FybmluZycsIHdhcm5pbmcgPT4ge1xuICBjb25zdCBpc0RlcHJlY2F0aW9uID0gd2FybmluZy5uYW1lID09PSAnRGVwcmVjYXRpb25XYXJuaW5nJzsgLy8gaWYgd2UncmUgbm90IGRvaW5nIGRlcHJlY2F0aW9ucywgaWdub3JlIVxuXG4gIGlmIChpc0RlcHJlY2F0aW9uICYmIHByb2Nlc3MkMS5ub0RlcHJlY2F0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRPRE86IENoZWNrIHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbiBhbmQgaWYgc2V0LCBpbmNsdWRlIHN0YWNrIHRyYWNlIGluIG1lc3NhZ2UhXG5cblxuICBsZXQgbXNnID0gV0FSTklOR19QUkVGSVg7XG5cbiAgaWYgKHdhcm5pbmcuY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbXNnICs9IGBbJHt3YXJuaW5nLmNvZGV9XSBgO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcudG9TdHJpbmcpIHtcbiAgICBtc2cgKz0gd2FybmluZy50b1N0cmluZygpO1xuICB9XG5cbiAgaWYgKHdhcm5pbmcuZGV0YWlsKSB7XG4gICAgbXNnICs9IGBcXG4ke3dhcm5pbmcuZGV0YWlsfWA7XG4gIH1cblxuICBjb25zb2xlLmVycm9yKG1zZyk7XG59KTtcbmxldCB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrID0gbnVsbDtcblxucHJvY2VzcyQxLmhhc1VuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrID0gKCkgPT4gdW5jYXVnaHRFeGNlcHRpb25DYWxsYmFjayAhPT0gbnVsbDtcblxucHJvY2VzcyQxLnNldFVuY2F1Z2h0RXhjZXB0aW9uQ2FwdHVyZUNhbGxiYWNrID0gZm4gPT4ge1xuICBpZiAoZm4gPT09IG51bGwpIHtcbiAgICB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cblxuICBhc3NlcnRBcmd1bWVudFR5cGUoZm4sICdmbicsICdmdW5jdGlvbicpO1xuXG4gIGlmICh1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgcHJvY2Vzcy5zZXRVbmNhdWdodEV4Y2VwdGlvbkNhcHR1cmVDYWxsYmFjaygpYCB3YXMgY2FsbGVkIHdoaWxlIGEgY2FwdHVyZSBjYWxsYmFjayB3YXMgYWxyZWFkeSBhY3RpdmUnKTtcbiAgfVxuXG4gIHVuY2F1Z2h0RXhjZXB0aW9uQ2FsbGJhY2sgPSBmbjtcbn07XG5cblRpLkFwcC5hZGRFdmVudExpc3RlbmVyKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChldmVudCkge1xuICAvLyBDcmVhdGUgYW4gRXJyb3IgaW5zdGFuY2UgdGhhdCB3cmFwcyB0aGUgZGF0YSBmcm9tIHRoZSBldmVudFxuICAvLyBpZGVhbGx5IHdlJ2QganVzdCBmb3J3YXJkIGFsb25nIHRoZSBvcmlnaW5hbCBFcnJvciFcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXZlbnQubWVzc2FnZSk7XG4gIGVycm9yLnN0YWNrID0gZXZlbnQuYmFja3RyYWNlO1xuICBlcnJvci5maWxlTmFtZSA9IGV2ZW50LnNvdXJjZU5hbWU7XG4gIGVycm9yLmxpbmVOdW1iZXIgPSBldmVudC5saW5lO1xuICBlcnJvci5jb2x1bW5OdW1iZXIgPSBldmVudC5saW5lT2Zmc2V0O1xuXG4gIGlmIChwcm9jZXNzJDEuaGFzVW5jYXVnaHRFeGNlcHRpb25DYXB0dXJlQ2FsbGJhY2soKSkge1xuICAgIHJldHVybiB1bmNhdWdodEV4Y2VwdGlvbkNhbGxiYWNrKGVycm9yKTtcbiAgfSAvLyBvdGhlcndpc2UgZm9yd2FyZCB0aGUgZXZlbnQhXG5cblxuICBwcm9jZXNzJDEuZW1pdCgndW5jYXVnaHRFeGNlcHRpb24nLCBlcnJvcik7XG59KTtcbi8vIEpTIGVuZ2luZSBzaG91bGQgYmUgYWJsZSB0byBvcHRpbWl6ZSBlYXNpZXJcblxuY2xhc3MgQ2FsbGJhY2tXaXRoQXJncyB7XG4gIGNvbnN0cnVjdG9yKGZ1bmMsIGFyZ3MpIHtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBydW4oKSB7XG4gICAgaWYgKHRoaXMuYXJncykge1xuICAgICAgdGhpcy5mdW5jLmFwcGx5KG51bGwsIHRoaXMuYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnVuKCk7XG4gICAgfVxuICB9XG5cbn0gLy8gbmV4dFRpY2sgdnMgc2V0SW1tZWRpYXRlIHNob3VsZCBiZSBoYW5kbGVkIGluIGEgc2VtaS1zbWFydCB3YXlcbi8vIEJhc2ljYWxseSBuZXh0VGljayBuZWVkcyB0byBkcmFpbiB0aGUgZnVsbCBxdWV1ZSAoYW5kIGNhbiBjYXVzZSBpbmZpbml0ZSBsb29wcyBpZiBuZXh0VGljayBjYWxsYmFjayBjYWxscyBuZXh0VGljayEpXG4vLyBUaGVuIHdlIHNob3VsZCBnbyB0aHJvdWdoIHRoZSBcImltbWVkaWF0ZVwiIHF1ZXVlXG4vLyBodHRwOi8vcGxhZmVyLmdpdGh1Yi5pby8yMDE1LzA5LzA4L25leHRUaWNrLXZzLXNldEltbWVkaWF0ZS9cblxuXG5jb25zdCB0aWNrUXVldWUgPSBbXTtcbmNvbnN0IGltbWVkaWF0ZVF1ZXVlID0gW107XG5sZXQgZHJhaW5pbmdUaWNrUXVldWUgPSBmYWxzZTtcbmxldCBkcmFpblF1ZXVlc1RpbWVvdXQgPSBudWxsO1xuLyoqXG4gKiBJdGVyYXRpdmVseSBydW5zIGFsbCBcInRpY2tzXCIgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUuXG4gKiBUaGlzIGNhbiBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24gaWYgYSB0aWNrIHNjaGVkdWxlcyBhbm90aGVyIGZvcmV2ZXIuXG4gKi9cblxuZnVuY3Rpb24gZHJhaW5UaWNrUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZ1RpY2tRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRyYWluaW5nVGlja1F1ZXVlID0gdHJ1ZTtcblxuICB3aGlsZSAodGlja1F1ZXVlLmxlbmd0aCkge1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrUXVldWUuc2hpZnQoKTtcbiAgICB0aWNrLnJ1bigpO1xuICB9XG5cbiAgZHJhaW5pbmdUaWNrUXVldWUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZXMoKSB7XG4gIC8vIGRyYWluIHRoZSBmdWxsIHRpY2sgcXVldWUgZmlyc3QuLi5cbiAgZHJhaW5UaWNrUXVldWUoKTsgLy8gdGljayBxdWV1ZSBzaG91bGQgYmUgZW1wdHkhXG5cbiAgY29uc3QgaW1tZWRpYXRlc1JlbWFpbmluZyA9IHByb2Nlc3NJbW1lZGlhdGVRdWV1ZSgpO1xuXG4gIGlmIChpbW1lZGlhdGVzUmVtYWluaW5nICE9PSAwKSB7XG4gICAgLy8gcmUtc2NoZWR1bGUgZHJhaW5pbmcgb3VyIHF1ZXVlcywgYXMgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgbW9yZSBcImltbWVkaWF0ZVwiIHRvIGhhbmRsZVxuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9IGVsc2Uge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IG51bGw7XG4gIH1cbn1cbi8qKlxuICogQXR0ZW1wdHMgdG8gcHJvY2VzcyBcImltbWVkaWF0ZXNcIiAoaW4gYSBtdWNoIG1vcmUgbGVpc3VyZWx5IHdheSB0aGFuIHRpY2tzKVxuICogV2UgZ2l2ZSBhIDEwMG1zIHdpbmRvdyB0byBydW4gdGhlbSBpbiBiZWZvcmUgcmUtc2NoZWR1bGluZyB0aGUgdGltZW91dCB0byBwcm9jZXNzIHRoZW0gYWdhaW4uXG4gKiBJZiBhbnkgdGlja3MgYXJlIGFkZGVkIGR1cmluZyBpbnZvY2F0aW9uIG9mIGltbWVkaWF0ZSwgd2UgZHJhaW4gdGhlIHRpY2sgcXVldWUgZnVsbHkgYmVmb3JlXG4gKiBwcm9jZWVkaW5nIHRvIG5leHQgaW1tZWRpYXRlIChpZiB3ZSBzdGlsbCBoYXZlIHRpbWUgaW4gb3VyIHdpbmRvdykuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBudW1iZXIgb2YgcmVtYWluaW5nIGltbWVkaWF0ZXMgdG8gYmUgcHJvY2Vzc2VkXG4gKi9cblxuXG5mdW5jdGlvbiBwcm9jZXNzSW1tZWRpYXRlUXVldWUoKSB7XG4gIGNvbnN0IGltbWVkaWF0ZURlYWRsaW5lID0gRGF0ZS5ub3coKSArIDEwMDsgLy8gZ2l2ZSB1cyB1cCB0byAxMDBtcyB0byBwcm9jZXNzIGltbWVkaWF0ZXNcblxuICB3aGlsZSAoaW1tZWRpYXRlUXVldWUubGVuZ3RoICYmIERhdGUubm93KCkgPCBpbW1lZGlhdGVEZWFkbGluZSkge1xuICAgIGNvbnN0IGltbWVkaWF0ZSA9IGltbWVkaWF0ZVF1ZXVlLnNoaWZ0KCk7XG4gICAgaW1tZWRpYXRlLnJ1bigpO1xuXG4gICAgaWYgKHRpY2tRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyB0aGV5IGFkZGVkIGEgdGljayEgZHJhaW4gdGhlIHRpY2sgcXVldWUgYmVmb3JlIHdlIGRvIGFueXRoaW5nIGVsc2UgKHRoaXMgKm1heSogZWF0IHVwIG91ciBkZWFkbGluZS93aW5kb3cgdG8gcHJvY2VzcyBhbnkgbW9yZSBpbW1lZGlhdGVzKVxuICAgICAgZHJhaW5UaWNrUXVldWUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW1tZWRpYXRlUXVldWUubGVuZ3RoO1xufVxuXG5wcm9jZXNzJDEubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIC4uLmFyZ3MpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGNhbGxiYWNrLCAnY2FsbGJhY2snLCAnZnVuY3Rpb24nKTtcbiAgdGlja1F1ZXVlLnB1c2gobmV3IENhbGxiYWNrV2l0aEFyZ3MoY2FsbGJhY2ssIGFyZ3MpKTtcblxuICBpZiAoIWRyYWluUXVldWVzVGltZW91dCkge1xuICAgIGRyYWluUXVldWVzVGltZW91dCA9IHNldFRpbWVvdXQoZHJhaW5RdWV1ZXMsIDApO1xuICB9XG59O1xuXG5nbG9iYWwuc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrLCAuLi5hcmdzKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShjYWxsYmFjaywgJ2NhbGxiYWNrJywgJ2Z1bmN0aW9uJyk7XG4gIGNvbnN0IGltbWVkaWF0ZSA9IG5ldyBDYWxsYmFja1dpdGhBcmdzKGNhbGxiYWNrLCBhcmdzKTtcbiAgaW1tZWRpYXRlUXVldWUucHVzaChpbW1lZGlhdGUpO1xuXG4gIGlmICghZHJhaW5RdWV1ZXNUaW1lb3V0KSB7XG4gICAgZHJhaW5RdWV1ZXNUaW1lb3V0ID0gc2V0VGltZW91dChkcmFpblF1ZXVlcywgMCk7XG4gIH1cblxuICByZXR1cm4gaW1tZWRpYXRlO1xufTtcblxuZ2xvYmFsLmNsZWFySW1tZWRpYXRlID0gZnVuY3Rpb24gKGltbWVkaWF0ZSkge1xuICBjb25zdCBpbmRleCA9IGltbWVkaWF0ZVF1ZXVlLmluZGV4T2YoaW1tZWRpYXRlKTtcblxuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgaW1tZWRpYXRlUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuY29uc3QgRk9SV0FSRF9TTEFTSCA9IDQ3OyAvLyAnLydcblxuY29uc3QgQkFDS1dBUkRfU0xBU0ggPSA5MjsgLy8gJ1xcXFwnXG5cbi8qKlxuICogSXMgdGhpcyBbYS16QS1aXT9cbiAqIEBwYXJhbSAge251bWJlcn0gIGNoYXJDb2RlIHZhbHVlIGZyb20gU3RyaW5nLmNoYXJDb2RlQXQoKVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cbmZ1bmN0aW9uIGlzV2luZG93c0RldmljZU5hbWUoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDkwIHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEyMjtcbn1cbi8qKlxuICogW2lzQWJzb2x1dGUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtib29sZWFufSBpc1Bvc2l4IHdoZXRoZXIgdGhpcyBpbXBsIGlzIGZvciBQT1NJWCBvciBub3RcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzQWJzb2x1dGUoaXNQb3NpeCwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoOyAvLyBlbXB0eSBzdHJpbmcgc3BlY2lhbCBjYXNlXG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gRk9SV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHdlIGFscmVhZHkgZGlkIG91ciBjaGVja3MgZm9yIHBvc2l4XG5cblxuICBpZiAoaXNQb3NpeCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyB3aW4zMiBmcm9tIGhlcmUgb24gb3V0XG5cblxuICBpZiAoZmlyc3RDaGFyID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDIgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXIpICYmIGZpbGVwYXRoLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgY29uc3QgdGhpcmRDaGFyID0gZmlsZXBhdGguY2hhckF0KDIpO1xuICAgIHJldHVybiB0aGlyZENoYXIgPT09ICcvJyB8fCB0aGlyZENoYXIgPT09ICdcXFxcJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogW2Rpcm5hbWUgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciAgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ30gZmlsZXBhdGggICBpbnB1dCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge3N0cmluZ30gICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cblxuXG5mdW5jdGlvbiBkaXJuYW1lKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgbGVuZ3RoID0gZmlsZXBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJy4nO1xuICB9IC8vIGlnbm9yZSB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gIGxldCBmcm9tSW5kZXggPSBsZW5ndGggLSAxO1xuICBjb25zdCBoYWRUcmFpbGluZyA9IGZpbGVwYXRoLmVuZHNXaXRoKHNlcGFyYXRvcik7XG5cbiAgaWYgKGhhZFRyYWlsaW5nKSB7XG4gICAgZnJvbUluZGV4LS07XG4gIH1cblxuICBjb25zdCBmb3VuZEluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2Yoc2VwYXJhdG9yLCBmcm9tSW5kZXgpOyAvLyBubyBzZXBhcmF0b3JzXG5cbiAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSB7XG4gICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiByb290IHdpbmRvd3MgcGF0aHNcbiAgICBpZiAobGVuZ3RoID49IDIgJiYgc2VwYXJhdG9yID09PSAnXFxcXCcgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hhciA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7XG5cbiAgICAgIGlmIChpc1dpbmRvd3NEZXZpY2VOYW1lKGZpcnN0Q2hhcikpIHtcbiAgICAgICAgcmV0dXJuIGZpbGVwYXRoOyAvLyBpdCdzIGEgcm9vdCB3aW5kb3dzIHBhdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJy4nO1xuICB9IC8vIG9ubHkgZm91bmQgcm9vdCBzZXBhcmF0b3JcblxuXG4gIGlmIChmb3VuZEluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuIHNlcGFyYXRvcjsgLy8gaWYgaXQgd2FzICcvJywgcmV0dXJuIHRoYXRcbiAgfSAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIG9mICcvL3NvbWV0aGluZydcblxuXG4gIGlmIChmb3VuZEluZGV4ID09PSAxICYmIHNlcGFyYXRvciA9PT0gJy8nICYmIGZpbGVwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuICcvLyc7XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoMCwgZm91bmRJbmRleCk7XG59XG4vKipcbiAqIFtleHRuYW1lIGRlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoICAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gZXh0bmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG4gIGNvbnN0IGluZGV4ID0gZmlsZXBhdGgubGFzdEluZGV4T2YoJy4nKTtcblxuICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IC8vIGlnbm9yZSB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gIGxldCBlbmRJbmRleCA9IGZpbGVwYXRoLmxlbmd0aDtcblxuICBpZiAoZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKSkge1xuICAgIGVuZEluZGV4LS07XG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGguc2xpY2UoaW5kZXgsIGVuZEluZGV4KTtcbn1cblxuZnVuY3Rpb24gbGFzdEluZGV4V2luMzJTZXBhcmF0b3IoZmlsZXBhdGgsIGluZGV4KSB7XG4gIGZvciAobGV0IGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBjaGFyID0gZmlsZXBhdGguY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChjaGFyID09PSBCQUNLV0FSRF9TTEFTSCB8fCBjaGFyID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG4vKipcbiAqIFtiYXNlbmFtZSBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgIGlucHV0IGZpbGUgcGF0aFxuICogQHBhcmFtICB7c3RyaW5nfSBbZXh0XSAgICAgIGZpbGUgZXh0ZW5zaW9uIHRvIGRyb3AgaWYgaXQgZXhpc3RzXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gYmFzZW5hbWUoc2VwYXJhdG9yLCBmaWxlcGF0aCwgZXh0KSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXNzZXJ0QXJndW1lbnRUeXBlKGV4dCwgJ2V4dCcsICdzdHJpbmcnKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGZpbGVwYXRoLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nO1xuICBsZXQgZW5kSW5kZXggPSBsZW5ndGg7IC8vIGRyb3AgdHJhaWxpbmcgc2VwYXJhdG9yIChpZiB0aGVyZSBpcyBvbmUpXG5cbiAgY29uc3QgbGFzdENoYXJDb2RlID0gZmlsZXBhdGguY2hhckNvZGVBdChsZW5ndGggLSAxKTtcblxuICBpZiAobGFzdENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIIHx8ICFpc1Bvc2l4ICYmIGxhc3RDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICBlbmRJbmRleC0tO1xuICB9IC8vIEZpbmQgbGFzdCBvY2N1cmVuY2Ugb2Ygc2VwYXJhdG9yXG5cblxuICBsZXQgbGFzdEluZGV4ID0gLTE7XG5cbiAgaWYgKGlzUG9zaXgpIHtcbiAgICBsYXN0SW5kZXggPSBmaWxlcGF0aC5sYXN0SW5kZXhPZihzZXBhcmF0b3IsIGVuZEluZGV4IC0gMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT24gd2luMzIsIGhhbmRsZSAqZWl0aGVyKiBzZXBhcmF0b3IhXG4gICAgbGFzdEluZGV4ID0gbGFzdEluZGV4V2luMzJTZXBhcmF0b3IoZmlsZXBhdGgsIGVuZEluZGV4IC0gMSk7IC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2Ygcm9vdCBwYXRoIGxpa2UgJ0M6JyBvciAnQzpcXFxcJ1xuXG4gICAgaWYgKChsYXN0SW5kZXggPT09IDIgfHwgbGFzdEluZGV4ID09PSAtMSkgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnOicgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaWxlcGF0aC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSAvLyBUYWtlIGZyb20gbGFzdCBvY2N1cnJlbmNlIG9mIHNlcGFyYXRvciB0byBlbmQgb2Ygc3RyaW5nIChvciBiZWdpbm5pbmcgdG8gZW5kIGlmIG5vdCBmb3VuZClcblxuXG4gIGNvbnN0IGJhc2UgPSBmaWxlcGF0aC5zbGljZShsYXN0SW5kZXggKyAxLCBlbmRJbmRleCk7IC8vIGRyb3AgdHJhaWxpbmcgZXh0ZW5zaW9uIChpZiBzcGVjaWZpZWQpXG5cbiAgaWYgKGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICByZXR1cm4gYmFzZS5lbmRzV2l0aChleHQpID8gYmFzZS5zbGljZSgwLCBiYXNlLmxlbmd0aCAtIGV4dC5sZW5ndGgpIDogYmFzZTtcbn1cbi8qKlxuICogVGhlIGBwYXRoLm5vcm1hbGl6ZSgpYCBtZXRob2Qgbm9ybWFsaXplcyB0aGUgZ2l2ZW4gcGF0aCwgcmVzb2x2aW5nICcuLicgYW5kICcuJyBzZWdtZW50cy5cbiAqXG4gKiBXaGVuIG11bHRpcGxlLCBzZXF1ZW50aWFsIHBhdGggc2VnbWVudCBzZXBhcmF0aW9uIGNoYXJhY3RlcnMgYXJlIGZvdW5kIChlLmcuXG4gKiAvIG9uIFBPU0lYIGFuZCBlaXRoZXIgXFwgb3IgLyBvbiBXaW5kb3dzKSwgdGhleSBhcmUgcmVwbGFjZWQgYnkgYSBzaW5nbGVcbiAqIGluc3RhbmNlIG9mIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBwYXRoIHNlZ21lbnQgc2VwYXJhdG9yICgvIG9uIFBPU0lYIGFuZCBcXFxuICogb24gV2luZG93cykuIFRyYWlsaW5nIHNlcGFyYXRvcnMgYXJlIHByZXNlcnZlZC5cbiAqXG4gKiBJZiB0aGUgcGF0aCBpcyBhIHplcm8tbGVuZ3RoIHN0cmluZywgJy4nIGlzIHJldHVybmVkLCByZXByZXNlbnRpbmcgdGhlXG4gKiBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yICBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCAgaW5wdXQgZmlsZSBwYXRoXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZShzZXBhcmF0b3IsIGZpbGVwYXRoKSB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShmaWxlcGF0aCwgJ3BhdGgnLCAnc3RyaW5nJyk7XG5cbiAgaWYgKGZpbGVwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnLic7XG4gIH0gLy8gV2luZG93cyBjYW4gaGFuZGxlICcvJyBvciAnXFxcXCcgYW5kIGJvdGggc2hvdWxkIGJlIHR1cm5lZCBpbnRvIHNlcGFyYXRvclxuXG5cbiAgY29uc3QgaXNXaW5kb3dzID0gc2VwYXJhdG9yID09PSAnXFxcXCc7XG5cbiAgaWYgKGlzV2luZG93cykge1xuICAgIGZpbGVwYXRoID0gZmlsZXBhdGgucmVwbGFjZSgvXFwvL2csIHNlcGFyYXRvcik7XG4gIH1cblxuICBjb25zdCBoYWRMZWFkaW5nID0gZmlsZXBhdGguc3RhcnRzV2l0aChzZXBhcmF0b3IpOyAvLyBPbiBXaW5kb3dzLCBuZWVkIHRvIGhhbmRsZSBVTkMgcGF0aHMgKFxcXFxob3N0LW5hbWVcXFxccmVzb3VyY2VcXFxcZGlyKSBzcGVjaWFsIHRvIHJldGFpbiBsZWFkaW5nIGRvdWJsZSBiYWNrc2xhc2hcblxuICBjb25zdCBpc1VOQyA9IGhhZExlYWRpbmcgJiYgaXNXaW5kb3dzICYmIGZpbGVwYXRoLmxlbmd0aCA+IDIgJiYgZmlsZXBhdGguY2hhckF0KDEpID09PSAnXFxcXCc7XG4gIGNvbnN0IGhhZFRyYWlsaW5nID0gZmlsZXBhdGguZW5kc1dpdGgoc2VwYXJhdG9yKTtcbiAgY29uc3QgcGFydHMgPSBmaWxlcGF0aC5zcGxpdChzZXBhcmF0b3IpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGFydHMpIHtcbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDAgJiYgc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgICByZXN1bHQucG9wKCk7IC8vIEZJWE1FOiBXaGF0IGlmIHRoaXMgZ29lcyBhYm92ZSByb290PyBTaG91bGQgd2UgdGhyb3cgYW4gZXJyb3I/XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgbm9ybWFsaXplZCA9IGhhZExlYWRpbmcgPyBzZXBhcmF0b3IgOiAnJztcbiAgbm9ybWFsaXplZCArPSByZXN1bHQuam9pbihzZXBhcmF0b3IpO1xuXG4gIGlmIChoYWRUcmFpbGluZykge1xuICAgIG5vcm1hbGl6ZWQgKz0gc2VwYXJhdG9yO1xuICB9XG5cbiAgaWYgKGlzVU5DKSB7XG4gICAgbm9ybWFsaXplZCA9ICdcXFxcJyArIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxuICogW2Fzc2VydFNlZ21lbnQgZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHsqfSBzZWdtZW50IFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge3ZvaWR9ICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0U2VnbWVudChzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICR7c2VnbWVudH1gKTtcbiAgfVxufVxuLyoqXG4gKiBUaGUgYHBhdGguam9pbigpYCBtZXRob2Qgam9pbnMgYWxsIGdpdmVuIHBhdGggc2VnbWVudHMgdG9nZXRoZXIgdXNpbmcgdGhlXG4gKiBwbGF0Zm9ybS1zcGVjaWZpYyBzZXBhcmF0b3IgYXMgYSBkZWxpbWl0ZXIsIHRoZW4gbm9ybWFsaXplcyB0aGUgcmVzdWx0aW5nIHBhdGguXG4gKiBaZXJvLWxlbmd0aCBwYXRoIHNlZ21lbnRzIGFyZSBpZ25vcmVkLiBJZiB0aGUgam9pbmVkIHBhdGggc3RyaW5nIGlzIGEgemVyby1cbiAqIGxlbmd0aCBzdHJpbmcgdGhlbiAnLicgd2lsbCBiZSByZXR1cm5lZCwgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5LlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFRoZSBqb2luZWQgZmlsZXBhdGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGpvaW4kMShzZXBhcmF0b3IsIHBhdGhzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdOyAvLyBuYWl2ZSBpbXBsOiBqdXN0IGpvaW4gYWxsIHRoZSBwYXRocyB3aXRoIHNlcGFyYXRvclxuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBwYXRocykge1xuICAgIGFzc2VydFNlZ21lbnQoc2VnbWVudCk7XG5cbiAgICBpZiAoc2VnbWVudC5sZW5ndGggIT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc2VwYXJhdG9yLCByZXN1bHQuam9pbihzZXBhcmF0b3IpKTtcbn1cbi8qKlxuICogVGhlIGBwYXRoLnJlc29sdmUoKWAgbWV0aG9kIHJlc29sdmVzIGEgc2VxdWVuY2Ugb2YgcGF0aHMgb3IgcGF0aCBzZWdtZW50cyBpbnRvIGFuIGFic29sdXRlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzZXBhcmF0b3IgcGxhdGZvcm0tc3BlY2lmaWMgZmlsZSBzZXBhcmF0b3JcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBwYXRocyBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlc29sdmUoc2VwYXJhdG9yLCBwYXRocykge1xuICBsZXQgcmVzb2x2ZWQgPSAnJztcbiAgbGV0IGhpdFJvb3QgPSBmYWxzZTtcbiAgY29uc3QgaXNQb3NpeCA9IHNlcGFyYXRvciA9PT0gJy8nOyAvLyBnbyBmcm9tIHJpZ2h0IHRvIGxlZnQgdW50aWwgd2UgaGl0IGFic29sdXRlIHBhdGgvcm9vdFxuXG4gIGZvciAobGV0IGkgPSBwYXRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBwYXRoc1tpXTtcbiAgICBhc3NlcnRTZWdtZW50KHNlZ21lbnQpO1xuXG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTsgLy8gc2tpcCBlbXB0eVxuICAgIH1cblxuICAgIHJlc29sdmVkID0gc2VnbWVudCArIHNlcGFyYXRvciArIHJlc29sdmVkOyAvLyBwcmVwZW5kIG5ldyBzZWdtZW50XG5cbiAgICBpZiAoaXNBYnNvbHV0ZShpc1Bvc2l4LCBzZWdtZW50KSkge1xuICAgICAgLy8gaGF2ZSB3ZSBiYWNrZWQgaW50byBhbiBhYnNvbHV0ZSBwYXRoP1xuICAgICAgaGl0Um9vdCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gaWYgd2UgZGlkbid0IGhpdCByb290LCBwcmVwZW5kIGN3ZFxuXG5cbiAgaWYgKCFoaXRSb290KSB7XG4gICAgcmVzb2x2ZWQgPSBwcm9jZXNzLmN3ZCgpICsgc2VwYXJhdG9yICsgcmVzb2x2ZWQ7XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplKHNlcGFyYXRvciwgcmVzb2x2ZWQpO1xuXG4gIGlmIChub3JtYWxpemVkLmNoYXJBdChub3JtYWxpemVkLmxlbmd0aCAtIDEpID09PSBzZXBhcmF0b3IpIHtcbiAgICAvLyBGSVhNRTogSGFuZGxlIFVOQyBwYXRocyBvbiBXaW5kb3dzIGFzIHdlbGwsIHNvIHdlIGRvbid0IHRyaW0gdHJhaWxpbmcgc2VwYXJhdG9yIG9uIHNvbWV0aGluZyBsaWtlICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFwnXG4gICAgLy8gRG9uJ3QgcmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvciBpZiB0aGlzIGlzIHJvb3QgcGF0aCBvbiB3aW5kb3dzIVxuICAgIGlmICghaXNQb3NpeCAmJiBub3JtYWxpemVkLmxlbmd0aCA9PT0gMyAmJiBub3JtYWxpemVkLmNoYXJBdCgxKSA9PT0gJzonICYmIGlzV2luZG93c0RldmljZU5hbWUobm9ybWFsaXplZC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfSAvLyBvdGhlcndpc2UgdHJpbSB0cmFpbGluZyBzZXBhcmF0b3JcblxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQuc2xpY2UoMCwgbm9ybWFsaXplZC5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuLyoqXG4gKiBUaGUgYHBhdGgucmVsYXRpdmUoKWAgbWV0aG9kIHJldHVybnMgdGhlIHJlbGF0aXZlIHBhdGggYGZyb21gIGZyb20gdG8gYHRvYCBiYXNlZFxuICogb24gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuIElmIGZyb20gYW5kIHRvIGVhY2ggcmVzb2x2ZSB0byB0aGUgc2FtZVxuICogcGF0aCAoYWZ0ZXIgY2FsbGluZyBgcGF0aC5yZXNvbHZlKClgIG9uIGVhY2gpLCBhIHplcm8tbGVuZ3RoIHN0cmluZyBpcyByZXR1cm5lZC5cbiAqXG4gKiBJZiBhIHplcm8tbGVuZ3RoIHN0cmluZyBpcyBwYXNzZWQgYXMgYGZyb21gIG9yIGB0b2AsIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gKiB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgemVyby1sZW5ndGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7c3RyaW5nfSBmcm9tIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge3N0cmluZ30gdG8gICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5cblxuZnVuY3Rpb24gcmVsYXRpdmUoc2VwYXJhdG9yLCBmcm9tLCB0bykge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoZnJvbSwgJ2Zyb20nLCAnc3RyaW5nJyk7XG4gIGFzc2VydEFyZ3VtZW50VHlwZSh0bywgJ3RvJywgJ3N0cmluZycpO1xuXG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZyb20gPSByZXNvbHZlKHNlcGFyYXRvciwgW2Zyb21dKTtcbiAgdG8gPSByZXNvbHZlKHNlcGFyYXRvciwgW3RvXSk7XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IC8vIHdlIG5vdyBoYXZlIHR3byBhYnNvbHV0ZSBwYXRocyxcbiAgLy8gbGV0cyBcImdvIHVwXCIgZnJvbSBgZnJvbWAgdW50aWwgd2UgcmVhY2ggY29tbW9uIGJhc2UgZGlyIG9mIGB0b2BcbiAgLy8gY29uc3Qgb3JpZ2luYWxGcm9tID0gZnJvbTtcblxuXG4gIGxldCB1cENvdW50ID0gMDtcbiAgbGV0IHJlbWFpbmluZ1BhdGggPSAnJztcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICh0by5zdGFydHNXaXRoKGZyb20pKSB7XG4gICAgICAvLyBtYXRjaCEgcmVjb3JkIHJlc3QuLi4/XG4gICAgICByZW1haW5pbmdQYXRoID0gdG8uc2xpY2UoZnJvbS5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBGSVhNRTogQnJlYWsvdGhyb3cgaWYgd2UgaGl0IGJhZCBlZGdlIGNhc2Ugb2Ygbm8gY29tbW9uIHJvb3QhXG5cblxuICAgIGZyb20gPSBkaXJuYW1lKHNlcGFyYXRvciwgZnJvbSk7XG4gICAgdXBDb3VudCsrO1xuICB9IC8vIHJlbW92ZSBsZWFkaW5nIHNlcGFyYXRvciBmcm9tIHJlbWFpbmluZ1BhdGggaWYgdGhlcmUgaXMgYW55XG5cblxuICBpZiAocmVtYWluaW5nUGF0aC5sZW5ndGggPiAwKSB7XG4gICAgcmVtYWluaW5nUGF0aCA9IHJlbWFpbmluZ1BhdGguc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gKCcuLicgKyBzZXBhcmF0b3IpLnJlcGVhdCh1cENvdW50KSArIHJlbWFpbmluZ1BhdGg7XG59XG4vKipcbiAqIFRoZSBgcGF0aC5wYXJzZSgpYCBtZXRob2QgcmV0dXJucyBhbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyByZXByZXNlbnRcbiAqIHNpZ25pZmljYW50IGVsZW1lbnRzIG9mIHRoZSBwYXRoLiBUcmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycyBhcmUgaWdub3JlZCxcbiAqIHNlZSBgcGF0aC5zZXBgLlxuICpcbiAqIFRoZSByZXR1cm5lZCBvYmplY3Qgd2lsbCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAtIGRpciA8c3RyaW5nPlxuICogLSByb290IDxzdHJpbmc+XG4gKiAtIGJhc2UgPHN0cmluZz5cbiAqIC0gbmFtZSA8c3RyaW5nPlxuICogLSBleHQgPHN0cmluZz5cbiAqIEBwYXJhbSAge3N0cmluZ30gc2VwYXJhdG9yIHBsYXRmb3JtLXNwZWNpZmljIGZpbGUgc2VwYXJhdG9yXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGVwYXRoIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIHBhcnNlKHNlcGFyYXRvciwgZmlsZXBhdGgpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZpbGVwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJvb3Q6ICcnLFxuICAgIGRpcjogJycsXG4gICAgYmFzZTogJycsXG4gICAgZXh0OiAnJyxcbiAgICBuYW1lOiAnJ1xuICB9O1xuICBjb25zdCBsZW5ndGggPSBmaWxlcGF0aC5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gQ2hlYXQgYW5kIGp1c3QgY2FsbCBvdXIgb3RoZXIgbWV0aG9kcyBmb3IgZGlybmFtZS9iYXNlbmFtZS9leHRuYW1lP1xuXG5cbiAgcmVzdWx0LmJhc2UgPSBiYXNlbmFtZShzZXBhcmF0b3IsIGZpbGVwYXRoKTtcbiAgcmVzdWx0LmV4dCA9IGV4dG5hbWUoc2VwYXJhdG9yLCByZXN1bHQuYmFzZSk7XG4gIGNvbnN0IGJhc2VMZW5ndGggPSByZXN1bHQuYmFzZS5sZW5ndGg7XG4gIHJlc3VsdC5uYW1lID0gcmVzdWx0LmJhc2Uuc2xpY2UoMCwgYmFzZUxlbmd0aCAtIHJlc3VsdC5leHQubGVuZ3RoKTtcbiAgY29uc3QgdG9TdWJ0cmFjdCA9IGJhc2VMZW5ndGggPT09IDAgPyAwIDogYmFzZUxlbmd0aCArIDE7XG4gIHJlc3VsdC5kaXIgPSBmaWxlcGF0aC5zbGljZSgwLCBmaWxlcGF0aC5sZW5ndGggLSB0b1N1YnRyYWN0KTsgLy8gZHJvcCB0cmFpbGluZyBzZXBhcmF0b3IhXG5cbiAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IGZpbGVwYXRoLmNoYXJDb2RlQXQoMCk7IC8vIGJvdGggd2luMzIgYW5kIFBPU0lYIHJldHVybiAnLycgcm9vdFxuXG4gIGlmIChmaXJzdENoYXJDb2RlID09PSBGT1JXQVJEX1NMQVNIKSB7XG4gICAgcmVzdWx0LnJvb3QgPSAnLyc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyB3ZSdyZSBkb25lIHdpdGggUE9TSVguLi5cblxuXG4gIGlmIChzZXBhcmF0b3IgPT09ICcvJykge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gZm9yIHdpbjMyLi4uXG5cblxuICBpZiAoZmlyc3RDaGFyQ29kZSA9PT0gQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAvLyBGSVhNRTogSGFuZGxlIFVOQyBwYXRocyBsaWtlICdcXFxcXFxcXGhvc3QtbmFtZVxcXFxyZXNvdXJjZVxcXFxmaWxlX3BhdGgnXG4gICAgLy8gbmVlZCB0byByZXRhaW4gJ1xcXFxcXFxcaG9zdC1uYW1lXFxcXHJlc291cmNlXFxcXCcgYXMgcm9vdCBpbiB0aGF0IGNhc2UhXG4gICAgcmVzdWx0LnJvb3QgPSAnXFxcXCc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBjaGVjayBmb3IgQzogc3R5bGUgcm9vdFxuXG5cbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiBmaWxlcGF0aC5jaGFyQXQoMSkgPT09ICc6Jykge1xuICAgIGlmIChsZW5ndGggPiAyKSB7XG4gICAgICAvLyBpcyBpdCBsaWtlIEM6XFxcXD9cbiAgICAgIGNvbnN0IHRoaXJkQ2hhckNvZGUgPSBmaWxlcGF0aC5jaGFyQ29kZUF0KDIpO1xuXG4gICAgICBpZiAodGhpcmRDaGFyQ29kZSA9PT0gRk9SV0FSRF9TTEFTSCB8fCB0aGlyZENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICByZXN1bHQucm9vdCA9IGZpbGVwYXRoLnNsaWNlKDAsIDMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH0gLy8gbm9wZSwganVzdCBDOiwgbm8gdHJhaWxpbmcgc2VwYXJhdG9yXG5cblxuICAgIHJlc3VsdC5yb290ID0gZmlsZXBhdGguc2xpY2UoMCwgMik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBUaGUgYHBhdGguZm9ybWF0KClgIG1ldGhvZCByZXR1cm5zIGEgcGF0aCBzdHJpbmcgZnJvbSBhbiBvYmplY3QuIFRoaXMgaXMgdGhlXG4gKiBvcHBvc2l0ZSBvZiBgcGF0aC5wYXJzZSgpYC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHNlcGFyYXRvciBwbGF0Zm9ybS1zcGVjaWZpYyBmaWxlIHNlcGFyYXRvclxuICogQHBhcmFtICB7b2JqZWN0fSBwYXRoT2JqZWN0IG9iamVjdCBvZiBmb3JtYXQgcmV0dXJuZWQgYnkgYHBhdGgucGFyc2UoKWBcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5kaXIgZGlyZWN0b3J5IG5hbWVcbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aE9iamVjdC5yb290IGZpbGUgcm9vdCBkaXIsIGlnbm9yZWQgaWYgYHBhdGhPYmplY3QuZGlyYCBpcyBwcm92aWRlZFxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmJhc2UgZmlsZSBiYXNlbmFtZVxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0Lm5hbWUgYmFzZW5hbWUgbWludXMgZXh0ZW5zaW9uLCBpZ25vcmVkIGlmIGBwYXRoT2JqZWN0LmJhc2VgIGV4aXN0c1xuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoT2JqZWN0LmV4dCBmaWxlIGV4dGVuc2lvbiwgaWdub3JlZCBpZiBgcGF0aE9iamVjdC5iYXNlYCBleGlzdHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdCQxKHNlcGFyYXRvciwgcGF0aE9iamVjdCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocGF0aE9iamVjdCwgJ3BhdGhPYmplY3QnLCAnb2JqZWN0Jyk7XG4gIGNvbnN0IGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgYCR7cGF0aE9iamVjdC5uYW1lIHx8ICcnfSR7cGF0aE9iamVjdC5leHQgfHwgJyd9YDsgLy8gYXBwZW5kIGJhc2UgdG8gcm9vdCBpZiBgZGlyYCB3YXNuJ3Qgc3BlY2lmaWVkLCBvciBpZlxuICAvLyBkaXIgaXMgdGhlIHJvb3RcblxuICBpZiAoIXBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3QuZGlyID09PSBwYXRoT2JqZWN0LnJvb3QpIHtcbiAgICByZXR1cm4gYCR7cGF0aE9iamVjdC5yb290IHx8ICcnfSR7YmFzZX1gO1xuICB9IC8vIGNvbWJpbmUgZGlyICsgLyArIGJhc2VcblxuXG4gIHJldHVybiBgJHtwYXRoT2JqZWN0LmRpcn0ke3NlcGFyYXRvcn0ke2Jhc2V9YDtcbn1cbi8qKlxuICogT24gV2luZG93cyBzeXN0ZW1zIG9ubHksIHJldHVybnMgYW4gZXF1aXZhbGVudCBuYW1lc3BhY2UtcHJlZml4ZWQgcGF0aCBmb3JcbiAqIHRoZSBnaXZlbiBwYXRoLiBJZiBwYXRoIGlzIG5vdCBhIHN0cmluZywgcGF0aCB3aWxsIGJlIHJldHVybmVkIHdpdGhvdXQgbW9kaWZpY2F0aW9ucy5cbiAqIFNlZSBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy93aW5kb3dzL2Rlc2t0b3AvRmlsZUlPL25hbWluZy1hLWZpbGUjbmFtZXNwYWNlc1xuICogQHBhcmFtICB7c3RyaW5nfSBmaWxlcGF0aCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuXG5cbmZ1bmN0aW9uIHRvTmFtZXNwYWNlZFBhdGgoZmlsZXBhdGgpIHtcbiAgaWYgKHR5cGVvZiBmaWxlcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cblxuICBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gcmVzb2x2ZSgnXFxcXCcsIFtmaWxlcGF0aF0pO1xuICBjb25zdCBsZW5ndGggPSByZXNvbHZlZFBhdGgubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPCAyKSB7XG4gICAgLy8gbmVlZCAnXFxcXFxcXFwnIG9yICdDOicgbWluaW11bVxuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKTsgLy8gaWYgc3RhcnQgd2l0aCAnXFxcXFxcXFwnLCBwcmVmaXggd2l0aCBVTkMgcm9vdCwgZHJvcCB0aGUgc2xhc2hlc1xuXG4gIGlmIChmaXJzdENoYXJDb2RlID09PSBCQUNLV0FSRF9TTEFTSCAmJiByZXNvbHZlZFBhdGguY2hhckF0KDEpID09PSAnXFxcXCcpIHtcbiAgICAvLyByZXR1cm4gYXMtaXMgaWYgaXQncyBhbiBhcmVhZHkgbG9uZyBwYXRoICgnXFxcXFxcXFw/XFxcXCcgb3IgJ1xcXFxcXFxcLlxcXFwnIHByZWZpeClcbiAgICBpZiAobGVuZ3RoID49IDMpIHtcbiAgICAgIGNvbnN0IHRoaXJkQ2hhciA9IHJlc29sdmVkUGF0aC5jaGFyQXQoMik7XG5cbiAgICAgIGlmICh0aGlyZENoYXIgPT09ICc/JyB8fCB0aGlyZENoYXIgPT09ICcuJykge1xuICAgICAgICByZXR1cm4gZmlsZXBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICdcXFxcXFxcXD9cXFxcVU5DXFxcXCcgKyByZXNvbHZlZFBhdGguc2xpY2UoMik7XG4gIH0gZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlTmFtZShmaXJzdENoYXJDb2RlKSAmJiByZXNvbHZlZFBhdGguY2hhckF0KDEpID09PSAnOicpIHtcbiAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFwnICsgcmVzb2x2ZWRQYXRoO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVwYXRoO1xufVxuXG5jb25zdCBXaW4zMlBhdGggPSB7XG4gIHNlcDogJ1xcXFwnLFxuICBkZWxpbWl0ZXI6ICc7JyxcbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCwgZXh0KSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCwgZXh0KTtcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uICguLi5wYXRocykge1xuICAgIHJldHVybiBqb2luJDEodGhpcy5zZXAsIHBhdGhzKTtcbiAgfSxcbiAgZXh0bmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGV4dG5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgZGlybmFtZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGRpcm5hbWUodGhpcy5zZXAsIGZpbGVwYXRoKTtcbiAgfSxcbiAgaXNBYnNvbHV0ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIGlzQWJzb2x1dGUoZmFsc2UsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0JDEodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiB0b05hbWVzcGFjZWRQYXRoXG59O1xuY29uc3QgUG9zaXhQYXRoID0ge1xuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiAoZmlsZXBhdGgsIGV4dCkge1xuICAgIHJldHVybiBiYXNlbmFtZSh0aGlzLnNlcCwgZmlsZXBhdGgsIGV4dCk7XG4gIH0sXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZSh0aGlzLnNlcCwgZmlsZXBhdGgpO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gam9pbiQxKHRoaXMuc2VwLCBwYXRocyk7XG4gIH0sXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBleHRuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGRpcm5hbWU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBkaXJuYW1lKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGlzQWJzb2x1dGU6IGZ1bmN0aW9uIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBpc0Fic29sdXRlKHRydWUsIGZpbGVwYXRoKTtcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHJldHVybiByZWxhdGl2ZSh0aGlzLnNlcCwgZnJvbSwgdG8pO1xuICB9LFxuICByZXNvbHZlOiBmdW5jdGlvbiAoLi4ucGF0aHMpIHtcbiAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLnNlcCwgcGF0aHMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMuc2VwLCBmaWxlcGF0aCk7XG4gIH0sXG4gIGZvcm1hdDogZnVuY3Rpb24gKHBhdGhPYmplY3QpIHtcbiAgICByZXR1cm4gZm9ybWF0JDEodGhpcy5zZXAsIHBhdGhPYmplY3QpO1xuICB9LFxuICB0b05hbWVzcGFjZWRQYXRoOiBmdW5jdGlvbiAoZmlsZXBhdGgpIHtcbiAgICByZXR1cm4gZmlsZXBhdGg7IC8vIG5vLW9wXG4gIH1cbn07XG5jb25zdCBwYXRoID0gUG9zaXhQYXRoO1xucGF0aC53aW4zMiA9IFdpbjMyUGF0aDtcbnBhdGgucG9zaXggPSBQb3NpeFBhdGg7XG5cbmNvbnN0IFBvc2l4Q29uc3RhbnRzID0ge1xuICBVVl9VRFBfUkVVU0VBRERSOiA0LFxuICBkbG9wZW46IHt9LFxuICBlcnJubzoge1xuICAgIEUyQklHOiA3LFxuICAgIEVBQ0NFUzogMTMsXG4gICAgRUFERFJJTlVTRTogNDgsXG4gICAgRUFERFJOT1RBVkFJTDogNDksXG4gICAgRUFGTk9TVVBQT1JUOiA0NyxcbiAgICBFQUdBSU46IDM1LFxuICAgIEVBTFJFQURZOiAzNyxcbiAgICBFQkFERjogOSxcbiAgICBFQkFETVNHOiA5NCxcbiAgICBFQlVTWTogMTYsXG4gICAgRUNBTkNFTEVEOiA4OSxcbiAgICBFQ0hJTEQ6IDEwLFxuICAgIEVDT05OQUJPUlRFRDogNTMsXG4gICAgRUNPTk5SRUZVU0VEOiA2MSxcbiAgICBFQ09OTlJFU0VUOiA1NCxcbiAgICBFREVBRExLOiAxMSxcbiAgICBFREVTVEFERFJSRVE6IDM5LFxuICAgIEVET006IDMzLFxuICAgIEVEUVVPVDogNjksXG4gICAgRUVYSVNUOiAxNyxcbiAgICBFRkFVTFQ6IDE0LFxuICAgIEVGQklHOiAyNyxcbiAgICBFSE9TVFVOUkVBQ0g6IDY1LFxuICAgIEVJRFJNOiA5MCxcbiAgICBFSUxTRVE6IDkyLFxuICAgIEVJTlBST0dSRVNTOiAzNixcbiAgICBFSU5UUjogNCxcbiAgICBFSU5WQUw6IDIyLFxuICAgIEVJTzogNSxcbiAgICBFSVNDT05OOiA1NixcbiAgICBFSVNESVI6IDIxLFxuICAgIEVMT09QOiA2MixcbiAgICBFTUZJTEU6IDI0LFxuICAgIEVNTElOSzogMzEsXG4gICAgRU1TR1NJWkU6IDQwLFxuICAgIEVNVUxUSUhPUDogOTUsXG4gICAgRU5BTUVUT09MT05HOiA2MyxcbiAgICBFTkVURE9XTjogNTAsXG4gICAgRU5FVFJFU0VUOiA1MixcbiAgICBFTkVUVU5SRUFDSDogNTEsXG4gICAgRU5GSUxFOiAyMyxcbiAgICBFTk9CVUZTOiA1NSxcbiAgICBFTk9EQVRBOiA5NixcbiAgICBFTk9ERVY6IDE5LFxuICAgIEVOT0VOVDogMixcbiAgICBFTk9FWEVDOiA4LFxuICAgIEVOT0xDSzogNzcsXG4gICAgRU5PTElOSzogOTcsXG4gICAgRU5PTUVNOiAxMixcbiAgICBFTk9NU0c6IDkxLFxuICAgIEVOT1BST1RPT1BUOiA0MixcbiAgICBFTk9TUEM6IDI4LFxuICAgIEVOT1NSOiA5OCxcbiAgICBFTk9TVFI6IDk5LFxuICAgIEVOT1NZUzogNzgsXG4gICAgRU5PVENPTk46IDU3LFxuICAgIEVOT1RESVI6IDIwLFxuICAgIEVOT1RFTVBUWTogNjYsXG4gICAgRU5PVFNPQ0s6IDM4LFxuICAgIEVOT1RTVVA6IDQ1LFxuICAgIEVOT1RUWTogMjUsXG4gICAgRU5YSU86IDYsXG4gICAgRU9QTk9UU1VQUDogMTAyLFxuICAgIEVPVkVSRkxPVzogODQsXG4gICAgRVBFUk06IDEsXG4gICAgRVBJUEU6IDMyLFxuICAgIEVQUk9UTzogMTAwLFxuICAgIEVQUk9UT05PU1VQUE9SVDogNDMsXG4gICAgRVBST1RPVFlQRTogNDEsXG4gICAgRVJBTkdFOiAzNCxcbiAgICBFUk9GUzogMzAsXG4gICAgRVNQSVBFOiAyOSxcbiAgICBFU1JDSDogMyxcbiAgICBFU1RBTEU6IDcwLFxuICAgIEVUSU1FOiAxMDEsXG4gICAgRVRJTUVET1VUOiA2MCxcbiAgICBFVFhUQlNZOiAyNixcbiAgICBFV09VTERCTE9DSzogMzUsXG4gICAgRVhERVY6IDE4XG4gIH0sXG4gIHNpZ25hbHM6IHtcbiAgICBTSUdIVVA6IDEsXG4gICAgU0lHSU5UOiAyLFxuICAgIFNJR1FVSVQ6IDMsXG4gICAgU0lHSUxMOiA0LFxuICAgIFNJR1RSQVA6IDUsXG4gICAgU0lHQUJSVDogNixcbiAgICBTSUdJT1Q6IDYsXG4gICAgU0lHQlVTOiAxMCxcbiAgICBTSUdGUEU6IDgsXG4gICAgU0lHS0lMTDogOSxcbiAgICBTSUdVU1IxOiAzMCxcbiAgICBTSUdTRUdWOiAxMSxcbiAgICBTSUdVU1IyOiAzMSxcbiAgICBTSUdQSVBFOiAxMyxcbiAgICBTSUdBTFJNOiAxNCxcbiAgICBTSUdURVJNOiAxNSxcbiAgICBTSUdDSExEOiAyMCxcbiAgICBTSUdDT05UOiAxOSxcbiAgICBTSUdTVE9QOiAxNyxcbiAgICBTSUdUU1RQOiAxOCxcbiAgICBTSUdUVElOOiAyMSxcbiAgICBTSUdUVE9VOiAyMixcbiAgICBTSUdVUkc6IDE2LFxuICAgIFNJR1hDUFU6IDI0LFxuICAgIFNJR1hGU1o6IDI1LFxuICAgIFNJR1ZUQUxSTTogMjYsXG4gICAgU0lHUFJPRjogMjcsXG4gICAgU0lHV0lOQ0g6IDI4LFxuICAgIFNJR0lPOiAyMyxcbiAgICBTSUdJTkZPOiAyOSxcbiAgICBTSUdTWVM6IDEyXG4gIH0sXG4gIHByaW9yaXR5OiB7XG4gICAgUFJJT1JJVFlfTE9XOiAxOSxcbiAgICBQUklPUklUWV9CRUxPV19OT1JNQUw6IDEwLFxuICAgIFBSSU9SSVRZX05PUk1BTDogMCxcbiAgICBQUklPUklUWV9BQk9WRV9OT1JNQUw6IC03LFxuICAgIFBSSU9SSVRZX0hJR0g6IC0xNCxcbiAgICBQUklPUklUWV9ISUdIRVNUOiAtMjBcbiAgfVxufTsgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvbnNcblxuY29uc3QgT1MgPSB7XG4gIEVPTDogJ1xcbicsXG4gIGFyY2g6ICgpID0+IHByb2Nlc3MuYXJjaCxcbiAgY29uc3RhbnRzOiBQb3NpeENvbnN0YW50cyxcbiAgY3B1czogKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gVGkuUGxhdGZvcm0ucHJvY2Vzc29yQ291bnQ7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgIG1vZGVsOiAndW5rbm93bicsXG4gICAgICAgIHNwZWVkOiAwLFxuICAgICAgICB0aW1lczoge1xuICAgICAgICAgIHVzZXI6IDAsXG4gICAgICAgICAgbmljZTogMCxcbiAgICAgICAgICBzeXM6IDAsXG4gICAgICAgICAgaWRsZTogMCxcbiAgICAgICAgICBpcnE6IDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9LFxuICBlbmRpYW5uZXNzOiAoKSA9PiB7XG4gICAgLy8gVE9ETzogQ2FjaGUgdGhlIHZhbHVlIVxuICAgIGNvbnN0IHJlc3VsdCA9IFRpLkNvZGVjLmdldE5hdGl2ZUJ5dGVPcmRlcigpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gVGkuQ29kZWMuTElUVExFX0VORElBTikge1xuICAgICAgcmV0dXJuICdMRSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdCRSc7XG4gIH0sXG4gIGZyZWVtZW06ICgpID0+IFRpLlBsYXRmb3JtLmF2YWlsYWJsZU1lbW9yeSxcbiAgZ2V0UHJpb3JpdHk6ICgpID0+IDAsXG4gIC8vIGZha2UgaXRcbiAgaG9tZWRpcjogKCkgPT4gVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gIC8vIGZha2UgaXRcbiAgaG9zdG5hbWU6ICgpID0+IFRpLlBsYXRmb3JtLmFkZHJlc3MsXG4gIC8vIGZha2UgaXRcbiAgbG9hZGF2ZzogKCkgPT4gWzAsIDAsIDBdLFxuICAvLyBmYWtlIGl0XG4gIG5ldHdvcmtJbnRlcmZhY2VzOiAoKSA9PiB7fSxcbiAgLy8gRklYTUU6IFdoYXQgZG8gd2UgZG8gaGVyZT8gV2UgbWlnaHQgYmUgYWJsZSB0byBwaWVjZSBzb21lIG9mIHRoaXMgdG9nZXRoZXIgdXNpbmcgVGkuUGxhdGZvcm0ubmV0bWFzaywgVGkuUGxhdGZvcm0uYWRkcmVzc1xuICBwbGF0Zm9ybTogKCkgPT4gcHJvY2Vzcy5wbGF0Zm9ybSxcbiAgcmVsZWFzZTogKCkgPT4gVGkuUGxhdGZvcm0udmVyc2lvbixcbiAgc2V0UHJpb3JpdHk6ICgpID0+IHt9LFxuICAvLyBuby1vcCwgZmFrZSBpdFxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnRtcGRpcigpYCBtZXRob2QgcmV0dXJucyBhIHN0cmluZyBzcGVjaWZ5aW5nIHRoZSBvcGVyYXRpbmcgc3lzdGVtJ3MgZGVmYXVsdCBkaXJlY3RvcnkgZm9yIHRlbXBvcmFyeSBmaWxlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICB0bXBkaXI6ICgpID0+IFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSxcblxuICAvKipcbiAgICogVGhlIGBvcy50b3RhbG1lbSgpYCBtZXRob2QgcmV0dXJucyB0aGUgdG90YWwgYW1vdW50IG9mIHN5c3RlbSBtZW1vcnkgaW4gYnl0ZXMgYXMgYW4gaW50ZWdlci5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdG90YWxtZW06ICgpID0+IFRpLlBsYXRmb3JtLnRvdGFsTWVtb3J5LFxuICB0eXBlOiAoKSA9PiAnVW5rbm93bicsXG4gIC8vIG92ZXJyaWRkZW4gcGVyLXBsYXRmb3JtIGF0IGJvdHRvbVxuXG4gIC8qKlxuICAgKiBUaGUgYG9zLnVwdGltZSgpYCBtZXRob2QgcmV0dXJucyB0aGUgc3lzdGVtIHVwdGltZSBpbiBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICogQHJldHVybiB7aW50ZWdlcn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgdXB0aW1lOiAoKSA9PiBUaS5QbGF0Zm9ybS51cHRpbWUsXG4gIHVzZXJJbmZvOiAoKSA9PiB7XG4gICAgLy8gZmFrZSBpdCFcbiAgICByZXR1cm4ge1xuICAgICAgdWlkOiAtMSxcbiAgICAgIGd1aWQ6IC0xLFxuICAgICAgdXNlcm5hbWU6IFRpLlBsYXRmb3JtLnVzZXJuYW1lLFxuICAgICAgaG9tZWRpcjogVGkuRmlsZXN5c3RlbS5hcHBsaWNhdGlvbkRhdGFEaXJlY3RvcnksXG4gICAgICBzaGVsbDogbnVsbFxuICAgIH07XG4gIH1cbn07IC8vIE9uIHNwZWNpZmljIHBsYXRmb3Jtcywgb3ZlcnJpZGUgaW1wbGVtZW50YXRpb25zIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGVtXG4vLyB5ZXQgYW5kIG5lZWQgdG8gZmFrZSBpdCwgb3IgdG8gaGFjayB0aGVtXG4vLyBJJ20gYWxzbyBkb2luZyB0aGlzIGluIGJsb2NrcyB0byBhc3NpZ24gaW1wbGVtZW50YXRpb25zIHRoYXQgZG9uJ3QgbmVlZCB0byBjb25zdWx0IHBsYXRmb3JtXG4vLyB0eXBlIGF0IHJ1bnRpbWUgKGhvcGVmdWxseSBzcGVlZGluZyB1cCBleGVjdXRpb24gYXQgcnVudGltZSlcblxue1xuICBPUy5jcHVzID0gKCkgPT4gVGkuUGxhdGZvcm0uY3B1cygpO1xuXG4gIE9TLnR5cGUgPSAoKSA9PiAnTGludXgnO1xufVxuXG5jb25zdCB0dHkgPSB7XG4gIGlzYXR0eTogKCkgPT4gZmFsc2UsXG4gIFJlYWRTdHJlYW06ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3R0eS5SZWFkU3RyZWFtIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9LFxuICBXcml0ZVN0cmVhbTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcigndHR5LldyaXRlU3RyZWFtIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xuICB9XG59O1xuXG5jb25zdCBNT05USFMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5jb25zdCB1dGlsID0ge1xuICBmb3JtYXQsXG4gIGZvcm1hdFdpdGhPcHRpb25zLFxuICBpbnNwZWN0LFxuICBpc0FycmF5OiBBcnJheS5pc0FycmF5LFxuICBpc0Jvb2xlYW46IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nLFxuICBpc0J1ZmZlcjogQnVmZmVyTW9kdWxlLkJ1ZmZlci5pc0J1ZmZlcixcbiAgaXNGdW5jdGlvbjogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nLFxuICBpc051bGw6IHZhbHVlID0+IHZhbHVlID09PSBudWxsLFxuICBpc051bGxPclVuZGVmaW5lZDogdmFsdWUgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCxcbiAgaXNOdW1iZXI6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gIGlzT2JqZWN0OiB2YWx1ZSA9PiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnLFxuICBpc1ByaW1pdGl2ZTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGwsXG4gIGlzU3RyaW5nOiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICBpc1N5bWJvbDogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyxcbiAgaXNVbmRlZmluZWQ6IHZhbHVlID0+IHZhbHVlID09PSB1bmRlZmluZWQsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRXJyb3I6IGUgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcixcbiAgbG9nOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWUgPSBgJHtkYXRlLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCAnMCcpfToke2RhdGUuZ2V0TWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKX06JHtkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJyl9YDsgLy8gUHJvZHVjZXMgb3V0cHV0IGxpa2U6IFwiMjEgRmViIDEwOjA0OjIzIC0gbWVzc2FnZVwiXG5cbiAgICBjb25zb2xlLmxvZyhgJHtkYXRlLmdldERhdGUoKX0gJHtNT05USFNbZGF0ZS5nZXRNb250aCgpXX0gJHt0aW1lfSAtICR7c3RyaW5nfWApO1xuICB9LFxuICBwcmludDogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignJykpLFxuICAvLyBGSVhNRTogU2hvdWxkbid0IGFkZCB0cmFpbGluZyBuZXdsaW5lIGxpa2UgY29uc29sZS5sb2cgZG9lcyFcbiAgcHV0czogKC4uLmFyZ3MpID0+IGNvbnNvbGUubG9nKGFyZ3Muam9pbignXFxuJykpLFxuICBlcnJvcjogKC4uLmFyZ3MpID0+IGNvbnNvbGUuZXJyb3IoYXJncy5qb2luKCdcXG4nKSksXG4gIGRlYnVnOiBzdHJpbmcgPT4gY29uc29sZS5lcnJvcihgREVCVUc6ICR7c3RyaW5nfWApLFxuICB0eXBlc1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3Igc3ViY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3IgYmFzZSBjbGFzc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxudXRpbC5pbmhlcml0cyA9IGZ1bmN0aW9uIChjb25zdHJ1Y3Rvciwgc3VwZXJDb25zdHJ1Y3Rvcikge1xuICBhc3NlcnRBcmd1bWVudFR5cGUoY29uc3RydWN0b3IsICdjb25zdHJ1Y3RvcicsICdGdW5jdGlvbicpO1xuICBhc3NlcnRBcmd1bWVudFR5cGUoc3VwZXJDb25zdHJ1Y3RvciwgJ3N1cGVyQ29uc3RydWN0b3InLCAnRnVuY3Rpb24nKTtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKHN1cGVyQ29uc3RydWN0b3IucHJvdG90eXBlLCAnc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUnLCAnT2JqZWN0Jyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb25zdHJ1Y3RvciwgJ3N1cGVyXycsIHtcbiAgICB2YWx1ZTogc3VwZXJDb25zdHJ1Y3RvclxuICB9KTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwgc3VwZXJDb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gd3JhcCB3aGljaCBpcyBleHBlY3RlZCB0byBoYXZlIGEgZmluYWwgY2FsbGJhY2sgYXJndW1lbnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZVxuICovXG5cblxudXRpbC5wcm9taXNpZnkgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKG9yaWdpbmFsLCAnb3JpZ2luYWwnLCAnRnVuY3Rpb24nKTtcblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgb3JpZ2luYWwuY2FsbCh0aGlzLCAuLi5hcmdzLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDb3B5IHByb3BlcnRpZXMgZnJvbSBvcmlnaW5hbCB0byB3cmFwcGVkXG4gIC8vIFRPRE86IGhvb2sgcHJvdG90eXBlIGNoYWluIHVwIGZyb20gd3JhcHBlZCB0byBvcmlnaW5hbFxuICAvLyBUT0RPOiBTdXBwb3J0IGN1c3RvbSBwcm9taXNpZnkgaG9va3NcblxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3JpZ2luYWwgb3JpZ2luYWwgZnVuY3Rpb24gdG8gY29udmVydCBmcm9tIGFzeW5jL1Byb21pc2UgcmV0dXJuIHZhbHVlIHRvIGEgY2FsbGJhY2sgc3R5bGVcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICovXG5cblxudXRpbC5jYWxsYmFja2lmeSA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICBhc3NlcnRBcmd1bWVudFR5cGUob3JpZ2luYWwsICdvcmlnaW5hbCcsICdGdW5jdGlvbicpO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoLi4uYXJncykge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgcHJvbWlzZS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByb21pc2UvYWx3YXlzLXJldHVyblxuICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZEVycm9yID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGZhbHN5IHZhbHVlJyk7XG4gICAgICAgIHdyYXBwZWRFcnJvci5yZWFzb24gPSBlcnI7XG4gICAgICAgIGVyciA9IHdyYXBwZWRFcnJvcjtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2soZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcm9taXNlL25vLWNhbGxiYWNrLWluLXByb21pc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVkO1xufTtcbi8qKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBmdW5jdGlvbiB0byBkZXByZWNhdGUvd3JhcFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBtZXNzYWdlIHRvIGdpdmUgd2hlbiBkZXByZWNhdGlvbiB3YXJuaW5nIGlzIGVtaXR0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlIGRlcHJlY2F0aW9uIGNvZGUgdG8gdXNlIHRvIGdyb3VwIHdhcm5pbmdzXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IHdyYXBwZWQgZnVuY3Rpb25cbiAqL1xuXG5cbnV0aWwuZGVwcmVjYXRlID0gZnVuY3Rpb24gKGZ1bmMsIHN0cmluZywgY29kZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24pIHtcbiAgICByZXR1cm4gZnVuYzsgLy8gc2tpcCB0aGUgd3JhcHBpbmchXG4gIH0gLy8gVE9ETzogU3VwcG9ydCBgY29kZWAgYXJndW1lbnQgYnkgdHJhY2tpbmcgYSBtYXAgb2YgY29kZXMgd2UndmUgd2FybmVkIGFib3V0XG5cblxuICBmdW5jdGlvbiB3cmFwcGVkKC4uLmFyZ3MpIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG5cbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhzdHJpbmcsICdEZXByZWNhdGlvbldhcm5pbmcnKTtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gd3JhcHBlZDtcbn07IC8vIFRPRE86IFN1cHBvcnQgZGVidWdsb2c/IFdoYXQgaXMgb3VyIGVxdWl2YWxlbnQgb2YgcHJvY2Vzcy5lbnYoJ05PREVfREVCVUcnKT9cblxuXG5jb25zdCBub29wJDEgPSAoKSA9PiB7fTtcblxudXRpbC5kZWJ1Z2xvZyA9ICgpID0+IHtcbiAgcmV0dXJuIG5vb3AkMTtcbn07XG5cbmNvbnN0IERFRkFVTFRfTUVTU0FHRVMgPSB7XG4gIGRlZXBTdHJpY3RFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsOicsXG4gIHN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgdmFsdWVzIHRvIGJlIHN0cmljdGx5IGVxdWFsOicsXG4gIGRlZXBFcXVhbDogJ0V4cGVjdGVkIHZhbHVlcyB0byBiZSBsb29zZWx5IGRlZXAtZXF1YWw6JyxcbiAgZXF1YWw6ICdFeHBlY3RlZCB2YWx1ZXMgdG8gYmUgbG9vc2VseSBlcXVhbDonLFxuICBub3REZWVwU3RyaWN0RXF1YWw6ICdFeHBlY3RlZCBcImFjdHVhbFwiIG5vdCB0byBiZSBzdHJpY3RseSBkZWVwLWVxdWFsIHRvOicsXG4gIG5vdFN0cmljdEVxdWFsOiAnRXhwZWN0ZWQgXCJhY3R1YWxcIiB0byBiZSBzdHJpY3RseSB1bmVxdWFsIHRvOicsXG4gIG5vdERlZXBFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgbm90IHRvIGJlIGxvb3NlbHkgZGVlcC1lcXVhbCB0bzonLFxuICBub3RFcXVhbDogJ0V4cGVjdGVkIFwiYWN0dWFsXCIgdG8gYmUgbG9vc2VseSB1bmVxdWFsIHRvOidcbn07IC8vIEZha2UgZW51bXMgdG8gdXNlIGludGVybmFsbHlcblxuY29uc3QgQ09NUEFSRV9UWVBFID0ge1xuICBPYmplY3Q6IDAsXG4gIE1hcDogMSxcbiAgU2V0OiAyXG59O1xuY29uc3QgU1RSSUNUTkVTUyA9IHtcbiAgU3RyaWN0OiAwLFxuICBMb29zZTogMVxufTtcblxuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBsZXQge1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3JcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgLy8gRklYTUU6IEdlbmVyYXRlIHRoZSByZXN0IG9mIHRoZSBtZXNzYWdlIHdpdGggZGlmZiBvZiBhY3R1YWwvZXhwZWN0ZWQhXG4gICAgICBtZXNzYWdlID0gYCR7REVGQVVMVF9NRVNTQUdFU1tvcGVyYXRvcl19XFxuXFxuYDtcbiAgICB9XG5cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmFjdHVhbCA9IGFjdHVhbDtcbiAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9ICFtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvciBbRVJSX0FTU0VSVElPTl0nO1xuICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgfVxuXG59IC8vIFRPRE86IENhbiB3ZSBkZWZpbmUgQXNzZXJ0U3RyaWN0IGFuZCBBc3NlcnRMb29zZSBhcyBzdWJjbGFzc2VzIG9mIGEgYmFzZSBBc3NlcnQgY2xhc3Ncbi8vIHRoYXQgY2xhc3MgaG9sZHMgaW1wbHMgZm9yIHNoYXJlZCBtZXRob2RzLCBzdWJjbGFzc2VzIG92ZXJyaWRlIHNwZWNpZmljXG4vLyBjb21wYXJpc29ucyB1c2VkIChPYmplY3QuaXMgdnMgPT09KT9cblxuXG5jb25zdCBhc3NlcnQkMSA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0JDEub2sodmFsdWUsIG1lc3NhZ2UpO1xuXG5hc3NlcnQkMS5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuXG5hc3NlcnQkMS5vayA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gYXJnc1swXTtcblxuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgbWVzc2FnZSA9IGFyZ3NbMV07XG4gIGxldCBnZW5lcmF0ZWRNZXNzYWdlID0gZmFsc2U7IC8vIENoZWNrIGlmIHZhbHVlICgxc3QgYXJnKSB3YXMgbm90IHN1cHBsaWVkIVxuICAvLyBIYXZlIHRvIHVzZSB1Z2x5IGhhY2sgb24gYXJncyBkZWZpbml0aW9uIHRvIGRvIHNvXG5cbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgbWVzc2FnZSA9ICdObyB2YWx1ZSBhcmd1bWVudCBwYXNzZWQgdG8gYGFzc2VydC5vaygpYCc7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgIC8vIFRPRE86IGdlbmVyYXRlIHJlc3Qgb2YgdGhlIG1lc3NhZ2UuIE5vZGUgYWN0dWFsbHkgcmVhZHMgdGhlIGlucHV0IGZpbGUhIFRoZSBoYWNrZWQgYnJvd3NlcmlmeSBkb2VzIG5vdCBkbyB0aGlzXG4gICAgLy8gSXQgdHJlYXRlcyBvayBmYWlsaW5nIGxpa2UgYHZhbHVlID09IHRydWVgIGZhaWxpbmdcbiAgICBtZXNzYWdlID0gJ1RoZSBleHByZXNzaW9uIGV2YWx1YXRlZCB0byBhIGZhbHN5IHZhbHVlOlxcblxcbic7XG4gICAgZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgbWVzc2FnZTtcbiAgfVxuXG4gIGNvbnN0IGVyciA9IG5ldyBBc3NlcnRpb25FcnJvcih7XG4gICAgYWN0dWFsOiB2YWx1ZSxcbiAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnPT0nXG4gIH0pO1xuICBlcnIuZ2VuZXJhdGVkTWVzc2FnZSA9IGdlbmVyYXRlZE1lc3NhZ2U7XG4gIHRocm93IGVycjtcbn07XG5cbmZ1bmN0aW9uIHRocm93RXJyb3Iob2JqKSB7XG4gIC8vIElmIG1lc3NhZ2UgaXMgYW4gRXJyb3Igb2JqZWN0LCB0aHJvdyB0aGF0IGluc3RlYWQhXG4gIGlmIChvYmoubWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgdGhyb3cgb2JqLm1lc3NhZ2U7XG4gIH1cblxuICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3Iob2JqKTtcbn1cblxuYXNzZXJ0JDEuZXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsID09IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ2VxdWFsJ1xuICB9KTtcbn07XG5cbmFzc2VydCQxLnN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKE9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIC8vIHByb3ZpZGVzIFNhbWVWYWx1ZSBjb21wYXJpc29uIGZvciB1c1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbCxcbiAgICBleHBlY3RlZCxcbiAgICBtZXNzYWdlLFxuICAgIG9wZXJhdG9yOiAnc3RyaWN0RXF1YWwnXG4gIH0pO1xufTtcblxuYXNzZXJ0JDEubm90RXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdEVxdWFsJ1xuICB9KTtcbn07XG5cbmFzc2VydCQxLm5vdFN0cmljdEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFPYmplY3QuaXMoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICAvLyBwcm92aWRlcyBTYW1lVmFsdWUgY29tcGFyaXNvbiBmb3IgdXNcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvd0Vycm9yKHtcbiAgICBhY3R1YWwsXG4gICAgZXhwZWN0ZWQsXG4gICAgbWVzc2FnZSxcbiAgICBvcGVyYXRvcjogJ25vdFN0cmljdEVxdWFsJ1xuICB9KTtcbn07XG5cbmNvbnN0IGlzUHJpbWl0aXZlID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgfHwgdmFsdWUgPT09IG51bGw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge01hcH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge01hcH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge1NUUklDVE5FU1MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlTWFwcyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIGNvbnN0IGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIG9iamVjdHMgd2UgbmVlZCB0byB0ZXN0IG1vcmUgZXh0ZW5zaXZlbHkgdGhhbiB1c2luZyAjZ2V0KCkvI2hhcygpXG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYWN0dWFsKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIGtleSAhPT0gbnVsbCkge1xuICAgICAgLy8gbm9uLW51bGwgb2JqZWN0LiBXZSBuZWVkIHRvIGRvIG91ciBvd24gY2hlY2tpbmcsIG5vdCB1c2UgZ2V0KCkvaGFzKClcbiAgICAgIGxvb3NlQ2hlY2tzLmFkZChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgXCJwcmltaXRpdmVzXCJcbiAgICAgIGlmIChleHBlY3RlZC5oYXMoa2V5KSAmJiBkZWVwRXF1YWwodmFsdWUsIGV4cGVjdGVkLmdldChrZXkpLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSkge1xuICAgICAgICAvLyB5YXkhIGEgbmljZSBlYXN5IG1hdGNoIC0gYm90aCBrZXkgYW5kIHZhbHVlIG1hdGNoZWQgZXhhY3RseSAtIG1vdmUgb25cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgbWF0Y2gga2V5L3ZhbHVlIHBlcmZlY3RseSBpbiBzdHJpY3QgbW9kZSwgZmFpbCByaWdodCBhd2F5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gb2ssIHNvIGl0IGRpZG4ndCBtYXRjaCBrZXkvdmFsdWUgcGVyZmVjdGx5IC0gYnV0IHdlJ3JlIGluIGxvb3NlIG1vZGUsIHNvIGZhbGwgYmFjayB0byB0cnkgYWdhaW5cblxuXG4gICAgICBsb29zZUNoZWNrcy5hZGQoa2V5KTtcbiAgICB9XG4gIH1cblxuICBpZiAobG9vc2VDaGVja3Muc2l6ZSA9PT0gMCkge1xuICAgIC8vIG5vIGxvb3NlIGVuZHMgdG8gdGllIHVwLCBldmVyeXRoaW5nIG1hdGNoZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBvbmx5IGdvIHRocm91Z2ggdGhlIHNlY29uZCBNYXAgb25jZSFcblxuXG4gIGZvciAoY29uc3QgW2V4cGVjdGVkS2V5LCBleHBlY3RlZFZhbHVlXSBvZiBleHBlY3RlZCkge1xuICAgIC8vIGlmIGl0J3Mgbm90IGEgbm9uLW51bGwgb2JqZWN0IGluIHN0cmljdCBtb2RlLCBmYWlsIVxuICAgIC8vIChpLmUuIGlmIGl0J3MgYSBwcmltaXRpdmUgdGhhdCBmYWlsZWQgYSBtYXRjaCwgZG9uJ3QgZmFsbCBiYWNrIHRvIG1vcmUgbG9vc2VseSBtYXRjaCBpdClcbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBzaG91bGRuJ3QgZXZlciBoYXBwZW4gc2luY2Ugd2Ugc2hvdWxkIGJlIHJldHVybmluZyBmYWxzZSBpbW1lZGlhdGVseSBhYm92ZVxuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCAmJiAhKHR5cGVvZiBleHBlY3RlZEtleSA9PT0gJ29iamVjdCcgJiYgZXhwZWN0ZWRLZXkgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvdGhlcndpc2UsIHRlc3QgaXQgLy8gVE9ETzogV2lzaCB3ZSBjb3VsZCB1c2UgI2ZpbmQoKSBsaWtlIG9uIGFuIEFycmF5LCBidXQgU2V0IGRvZXNuJ3QgaGF2ZSBpdCFcblxuXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBsb29zZUNoZWNrcykge1xuICAgICAgLy8gaWYgYm90aCBrZXkgYW5kIHZhbHVlIG1hdGNoZXNcbiAgICAgIGlmIChkZWVwRXF1YWwoa2V5LCBleHBlY3RlZEtleSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykgJiYgZGVlcEVxdWFsKGFjdHVhbC5nZXQoa2V5KSwgZXhwZWN0ZWRWYWx1ZSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBsb29zZUNoZWNrcy5kZWxldGUoa2V5KTsgLy8gcmVtb3ZlIGZyb20gb3VyIGxvb3NlQ2hlY2tzIFNldCBzaW5jZSB3ZSBhbHJlYWR5IG1hdGNoZWQgaXRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIGlmIG5vdCBmb3VuZCwgd2UgZmFpbGVkIHRvIG1hdGNoXG5cblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gZGlkIHdlIGxlYXZlIHVuLW1hdGNoZWQga2V5cz8gaWYgc28sIGZhaWxcblxuXG4gIHJldHVybiBsb29zZUNoZWNrcy5zaXplID09PSAwO1xufVxuLyoqXG4gKiBAcGFyYW0ge1NldH0gYWN0dWFsIG1hcCB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0ge1NldH0gZXhwZWN0ZWQgbWFwIHdlJ3JlIGNvbXBhcmluZyBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmljdG5lc3MuTG9vc2V8c3RyaWN0bmVzcy5TdHJpY3R9IHN0cmljdG5lc3MgaG93IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VzIG1lbW9pemVkIHJlZmVyZW5jZXMgdG8gb2JqZWN0cyBpbiB0aGUgZGVlcEVxdWFsIGhpZXJhcmNoeVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBjb21wYXJlU2V0cyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKSB7XG4gIGNvbnN0IGxvb3NlQ2hlY2tzID0gbmV3IFNldCgpOyAvLyBrZWVwIHRyYWNrIG9mIHZhbHVlcyB3ZSBuZWVkIHRvIHRlc3QgbW9yZSBleHRlbnNpdmVseSB0aGFuIHVzaW5nICNoYXMoKVxuXG4gIGZvciAoY29uc3QgdmFsdWUgb2YgYWN0dWFsKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIC8vIG5vbi1udWxsIG9iamVjdC4gV2UgbmVlZCB0byBkbyBvdXIgb3duIGNoZWNraW5nLCBub3QgdXNlIGhhcygpXG4gICAgICBsb29zZUNoZWNrcy5hZGQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoIWV4cGVjdGVkLmhhcyh2YWx1ZSkpIHtcbiAgICAgIC8vIEZJWE1FOiBoYXMgZG9lcyBcInNhbWUtdmFsdWUtemVyb1wiIGNoZWNrLCB3aGljaCBpcyBsaWtlIE9iamVjdC5pcyBleGNlcHQgZm9yIC0wLyswIGJlaW5nIGNvbnNpZGVyZWQgZXF1YWxcbiAgICAgIC8vIHNvIG1heSBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGF0IGhlcmUsIHRoYXQnZCBoYXZlIHRvIGJlIGluIGFuIGVsc2UgYmVsb3cgKHNpbmNlIGhhcyB3aWxsIHJldHVybiB0cnVlIGhlcmUpXG4gICAgICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICAgICAgLy8gZmFpbGVkIFwic2FtZS12YWx1ZVwiIG1hdGNoIGZvciBwcmltaXRpdmUgaW4gc3RyaWN0IG1vZGUsIHNvIGZhaWwgcmlnaHQgYXdheVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIFdoZW4gZG9pbmcgbG9vc2UgY2hlY2ssIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGxvb3NlciBjaGVjayB0aGFuICNoYXMoKSwgc28gd2UgY2FuJ3QganVzdCByZXR1cm4gZmFsc2UgaW1tZWRpYXRlbHkgaGVyZVxuICAgICAgLy8gYWRkIHRvIHNldCBvZiB2YWx1ZXMgdG8gY2hlY2sgbW9yZSB0aG9yb3VnaGx5XG5cblxuICAgICAgbG9vc2VDaGVja3MuYWRkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAobG9vc2VDaGVja3Muc2l6ZSA9PT0gMCkge1xuICAgIC8vIG5vIGxvb3NlIGVuZHMgdG8gdGllIHVwLCBldmVyeXRoaW5nIG1hdGNoZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUcnkgdG8gd2hpdHRsZSBkb3duIHRoZSBsb29zZSBjaGVja3Mgc2V0IHRvIGJlIGVtcHR5Li4uXG4gIC8vIG9ubHkgZ28gdGhyb3VnaCB0aGUgc2Vjb25kIFNldCBvbmNlIVxuXG5cbiAgZm9yIChjb25zdCBleHBlY3RlZFZhbHVlIG9mIGV4cGVjdGVkKSB7XG4gICAgLy8gaWYgaXQncyBub3QgYSBub24tbnVsbCBvYmplY3QgaW4gc3RyaWN0IG1vZGUsIGZhaWwhXG4gICAgLy8gKGkuZS4gaWYgaXQncyBhIHByaW1pdGl2ZSB0aGF0IGZhaWxlZCBhIG1hdGNoLCBkb24ndCBmYWxsIGJhY2sgdG8gbW9yZSBsb29zZWx5IG1hdGNoIGl0KVxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiBzaW5jZSB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGZhbHNlIGltbWVkaWF0ZWx5IGFib3ZlXG4gICAgaWYgKHN0cmljdG5lc3MgPT09IFNUUklDVE5FU1MuU3RyaWN0ICYmICEodHlwZW9mIGV4cGVjdGVkVmFsdWUgPT09ICdvYmplY3QnICYmIGV4cGVjdGVkVmFsdWUgIT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBsb29zZUNoZWNrcykge1xuICAgICAgaWYgKGRlZXBFcXVhbChvYmplY3QsIGV4cGVjdGVkVmFsdWUsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgLy8gZm91bmQgYSBtYXRjaCFcblxuICAgICAgICBsb29zZUNoZWNrcy5kZWxldGUob2JqZWN0KTsgLy8gcmVtb3ZlIGZyb20gb3VyIGxvb3NlQ2hlY2tzIFNldCBzaW5jZSB3ZSBtYXRjaGVkIGl0XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSAvLyBpZiBub3QgZm91bmQsIHdlIGZhaWxlZCB0byBtYXRjaFxuXG5cbiAgICBpZiAoIWZvdW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIGRpZCB3ZSBsZWF2ZSB1bi1tYXRjaGVkIHZhbHVlcz8gaWYgc28sIGZhaWxcblxuXG4gIHJldHVybiBsb29zZUNoZWNrcy5zaXplID09PSAwO1xufVxuLyoqXG4gKiBAcGFyYW0geyp9IGFjdHVhbCB2YWx1ZSB3ZSBhcmUgY29tcGFyaW5nXG4gKiBAcGFyYW0geyp9IGV4cGVjdGVkIHZhbHVlcyB3ZSdyZSBjb21wYXJpbmcgYWdhaW5zdFxuICogQHBhcmFtIHtTVFJJQ1RORVNTLlN0cmljdHxTVFJJQ1RORVNTLkxvb3NlfSBzdHJpY3RuZXNzIGhvdyBzdHJpY3QgYSBjb21wYXJpc29uIHRvIGRvXG4gKiBAcGFyYW0ge29iamVjdH0gW3JlZmVyZW5jZXNdIG9wdGlvbmFsIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGNpcmN1bGFyIHJlZmVyZW5jZXMgaW4gdGhlIGhpZXJhcmNoeVxuICogQHBhcmFtIHtNYXA8b2JqZWN0LG51bWJlcj59IFtyZWZlcmVuY2VzLmFjdHVhbF0gbWFwcGluZyBmcm9tIG9iamVjdHMgdmlzaXRlZCAob24gYGFjdHVhbGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge01hcDxvYmplY3QsbnVtYmVyPn0gW3JlZmVyZW5jZXMuZXhwZWN0ZWRdIG1hcHBpbmcgZnJvbSBvYmplY3RzIHZpc2l0ZWQgKG9uIGBleHBlY3RlZGApIHRvIHRoZWlyIGRlcHRoXG4gKiBAcGFyYW0ge251bWJlcn0gW3JlZmVyZW5jZXMuZGVwdGhdIFRoZSBjdXJyZW50IGRlcHRoIG9mIHRoZSBoaWVyYXJjaHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIHN0cmljdG5lc3MsIHJlZmVyZW5jZXMpIHtcbiAgLy8gaWYgcHJpbWl0aXZlcywgY29tcGFyZSB1c2luZyBPYmplY3QuaXNcbiAgLy8gVGhpcyBoYW5kbGVzOiBudWxsLCB1bmRlZmluZWQsIG51bWJlciwgc3RyaW5nLCBib29sZWFuXG4gIGlmIChpc1ByaW1pdGl2ZShhY3R1YWwpICYmIGlzUHJpbWl0aXZlKGV4cGVjdGVkKSkge1xuICAgIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5pcyhhY3R1YWwsIGV4cGVjdGVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFjdHVhbCA9PSBleHBlY3RlZDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICB9XG4gIH0gLy8gTm93IHdlIGhhdmUgdmFyaW91cyBvYmplY3RzL2Z1bmN0aW9uczpcbiAgLy8gRGF0ZSwgRXJyb3IsIFJlZ0V4cCwgQXJyYXksIE1hcCwgU2V0LCBPYmplY3QsIEZ1bmN0aW9uLCBBcnJvdyBmdW5jdGlvbnMsIFdlYWtNYXAsIERhdGFWaWV3LCBBcnJheUJ1ZmZlciwgV2Vha1NldCwgdHlwZWQgYXJyYXlzXG4gIC8vIG5vdGFibHksIHRoaXMgaW5jbHVkZXMgXCJib3hlZFwiIHByaW1pdGl2ZXMgY3JlYXRlZCBieSBuZXcgQm9vbGVhbihmYWxzZSksIG5ldyBTdHJpbmcoJ3ZhbHVlJyksIFN5bWJvbCgnd2hhdGV2ZXInKSwgZXRjXG4gIC8vIFR5cGUgdGFncyBvZiBvYmplY3RzIHNob3VsZCBiZSB0aGUgc2FtZVxuXG5cbiAgY29uc3QgYWN0dWFsVGFnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFjdHVhbCk7XG4gIGNvbnN0IGV4cGVjdGVkVGFnID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKTtcblxuICBpZiAoYWN0dWFsVGFnICE9PSBleHBlY3RlZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBbW1Byb3RvdHlwZV1dIG9mIG9iamVjdHMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZSBTdHJpY3QgRXF1YWxpdHkgQ29tcGFyaXNvbi5cblxuXG4gIGlmIChzdHJpY3RuZXNzID09PSBTVFJJQ1RORVNTLlN0cmljdCkge1xuICAgIC8vIGRvbid0IGNoZWNrIHByb3RvdHlwZSB3aGVuIGRvaW5nIFwibG9vc2VcIlxuICAgIGNvbnN0IGFjdHVhbFByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihhY3R1YWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGV4cGVjdGVkKTtcblxuICAgIGlmIChhY3R1YWxQcm90b3R5cGUgIT09IGV4cGVjdGVkUHJvdG90eXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgbGV0IGNvbXBhcmlzb24gPSBDT01QQVJFX1RZUEUuT2JqZWN0O1xuXG4gIGlmICh1dGlsLnR5cGVzLmlzUmVnRXhwKGFjdHVhbCkpIHtcbiAgICAvLyBSZWdFeHAgc291cmNlIGFuZCBmbGFncyBzaG91bGQgbWF0Y2hcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNSZWdFeHAoZXhwZWN0ZWQpIHx8IGFjdHVhbC5mbGFncyAhPT0gZXhwZWN0ZWQuZmxhZ3MgfHwgYWN0dWFsLnNvdXJjZSAhPT0gZXhwZWN0ZWQuc291cmNlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjb250aW51ZSBvbiB0byBjaGVjayBwcm9wZXJ0aWVzLi4uXG5cbiAgfSBlbHNlIGlmICh1dGlsLnR5cGVzLmlzRGF0ZShhY3R1YWwpKSB7XG4gICAgLy8gRGF0ZSdzIHVuZGVybHlpbmcgdGltZSBzaG91bGQgbWF0Y2hcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNEYXRlKGV4cGVjdGVkKSB8fCBhY3R1YWwuZ2V0VGltZSgpICE9PSBleHBlY3RlZC5nZXRUaW1lKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgLy8gRXJyb3IncyBuYW1lIGFuZCBtZXNzYWdlIG11c3QgbWF0Y2hcbiAgICBpZiAoIShleHBlY3RlZCBpbnN0YW5jZW9mIEVycm9yKSB8fCBhY3R1YWwubmFtZSAhPT0gZXhwZWN0ZWQubmFtZSB8fCBhY3R1YWwubWVzc2FnZSAhPT0gZXhwZWN0ZWQubWVzc2FnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhY3R1YWwpKSB7XG4gICAgLy8gaWYgYXJyYXkgbGVuZ3RocyBkaWZmZXIsIHF1aWNrIGZhaWxcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWQpIHx8IGFjdHVhbC5sZW5ndGggIT09IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuXG4gIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0JveGVkUHJpbWl0aXZlKGFjdHVhbCkpIHtcbiAgICBpZiAoIXV0aWwudHlwZXMuaXNCb3hlZFByaW1pdGl2ZShleHBlY3RlZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNoZWNrIHRoYXQgdGhleSdyZSB0aGUgc2FtZSB0eXBlIG9mIHdyYXBwZWQgcHJpbWl0aXZlIGFuZCB0aGVuIGNhbGwgdGhlIHJlbGV2YW50IHZhbHVlT2YoKSBmb3IgdGhhdCB0eXBlIHRvIGNvbXBhcmUgdGhlbSFcblxuXG4gICAgaWYgKHV0aWwudHlwZXMuaXNOdW1iZXJPYmplY3QoYWN0dWFsKSAmJiAoIXV0aWwudHlwZXMuaXNOdW1iZXJPYmplY3QoZXhwZWN0ZWQpIHx8ICFPYmplY3QuaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoYWN0dWFsKSwgTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZXhwZWN0ZWQpKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTdHJpbmdPYmplY3QoYWN0dWFsKSAmJiAoIXV0aWwudHlwZXMuaXNTdHJpbmdPYmplY3QoZXhwZWN0ZWQpIHx8IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCkgIT09IFN0cmluZy5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNCb29sZWFuT2JqZWN0KGFjdHVhbCkgJiYgKCF1dGlsLnR5cGVzLmlzQm9vbGVhbk9iamVjdChleHBlY3RlZCkgfHwgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCkgIT09IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIEZJWE1FOiBVbmNvbW1lbnQgd2hlbiB3ZSBzdXBwb3J0IEJpZ0ludCBjcm9zcy1wbGF0Zm9ybSFcbiAgICAgIC8vIH0gZWxzZSBpZiAodXRpbC50eXBlcy5pc0JpZ0ludE9iamVjdChhY3R1YWwpXG4gICAgICAvLyBcdCYmICghdXRpbC50eXBlcy5pc0JpZ0ludE9iamVjdChleHBlY3RlZClcbiAgICAgIC8vIFx0XHR8fCBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbChhY3R1YWwpICE9PSBCaWdJbnQucHJvdG90eXBlLnZhbHVlT2YuY2FsbChleHBlY3RlZCkpKSB7XG4gICAgICAvLyBcdHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTeW1ib2xPYmplY3QoYWN0dWFsKSAmJiAoIXV0aWwudHlwZXMuaXNTeW1ib2xPYmplY3QoZXhwZWN0ZWQpIHx8IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGFjdHVhbCkgIT09IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZi5jYWxsKGV4cGVjdGVkKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNvbnRpbnVlIG9uIHRvIGNoZWNrIHByb3BlcnRpZXMuLi5cblxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNTZXQoYWN0dWFsKSkge1xuICAgIGlmICghdXRpbC50eXBlcy5pc1NldChleHBlY3RlZCkgfHwgYWN0dWFsLnNpemUgIT09IGV4cGVjdGVkLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLlNldDsgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IGVsc2UgaWYgKHV0aWwudHlwZXMuaXNNYXAoYWN0dWFsKSkge1xuICAgIGlmICghdXRpbC50eXBlcy5pc01hcChleHBlY3RlZCkgfHwgYWN0dWFsLnNpemUgIT09IGV4cGVjdGVkLnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb21wYXJpc29uID0gQ09NUEFSRV9UWVBFLk1hcDsgLy8gY29udGludWUgb24gdG8gY2hlY2sgcHJvcGVydGllcy4uLlxuICB9IC8vIE5vdyBpdGVyYXRlIG92ZXIgcHJvcGVydGllcyBhbmQgY29tcGFyZSB0aGVtIVxuXG5cbiAgY29uc3QgYWN0dWFsS2V5cyA9IE9iamVjdC5rZXlzKGFjdHVhbCk7IC8vIGZvciBhbiBhcnJheSwgdGhpcyB3aWxsIHJldHVybiB0aGUgaW5kaWNlcyB0aGF0IGhhdmUgdmFsdWVzXG5cbiAgY29uc3QgZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpOyAvLyBhbmQgaXQganVzdCBtYWdpY2FsbHkgd29ya3NcbiAgLy8gTXVzdCBoYXZlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcblxuICBpZiAoYWN0dWFsS2V5cy5sZW5ndGggIT09IGV4cGVjdGVkS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQXJlIHRoZXkgdGhlIHNhbWUga2V5cz8gSWYgb25lIGlzIG1pc3NpbmcsIHRoZW4gbm8sIGZhaWwgcmlnaHQgYXdheVxuXG5cbiAgaWYgKCFhY3R1YWxLZXlzLmV2ZXJ5KGtleSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwZWN0ZWQsIGtleSkpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIERvbid0IGNoZWNrIG93biBzeW1ib2xzIHdoZW4gZG9pbmcgXCJsb29zZVwiXG5cblxuICBpZiAoc3RyaWN0bmVzcyA9PT0gU1RSSUNUTkVTUy5TdHJpY3QpIHtcbiAgICBjb25zdCBhY3R1YWxTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhhY3R1YWwpO1xuICAgIGNvbnN0IGV4cGVjdGVkU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXhwZWN0ZWQpOyAvLyBNdXN0IGhhdmUgc2FtZSBudW1iZXIgb2Ygc3ltYm9sc1xuXG4gICAgaWYgKGFjdHVhbFN5bWJvbHMubGVuZ3RoICE9PSBleHBlY3RlZFN5bWJvbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbFN5bWJvbHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSGF2ZSB0byBmaWx0ZXIgdGhlbSBkb3duIHRvIGVudW1lcmFibGUgc3ltYm9scyFcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGFjdHVhbFN5bWJvbHMpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGFjdHVhbCwga2V5KTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZXhwZWN0ZWQsIGtleSk7XG5cbiAgICAgICAgaWYgKGFjdHVhbElzRW51bWVyYWJsZSAhPT0gZXhwZWN0ZWRJc0VudW1lcmFibGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHRoZXkgZGlmZmVyIG9uIHdoZXRlaHIgc3ltYm9sIGlzIGVudW1lcmFibGUsIGZhaWwhXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0dWFsSXNFbnVtZXJhYmxlKSB7XG4gICAgICAgICAgLy8gaXQncyBlbnVtZXJhYmxlLCBhZGQgdG8ga2V5cyB0byBjaGVja1xuICAgICAgICAgIGFjdHVhbEtleXMucHVzaChrZXkpO1xuICAgICAgICAgIGV4cGVjdGVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQXZvaWQgY2lyY3VsYXIgcmVmZXJlbmNlcyFcbiAgLy8gUmVjb3JkIG1hcCBmcm9tIG9iamVjdHMgdG8gZGVwdGggaW4gdGhlIGhpZXJhcmNoeVxuXG5cbiAgaWYgKHJlZmVyZW5jZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZmVyZW5jZXMgPSB7XG4gICAgICBhY3R1YWw6IG5ldyBNYXAoKSxcbiAgICAgIGV4cGVjdGVkOiBuZXcgTWFwKCksXG4gICAgICBkZXB0aDogMFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gc2VlIGlmIHdlJ3ZlIGFscmVhZHkgcmVjb3JkZWQgdGhlc2Ugb2JqZWN0cy5cbiAgICAvLyBpZiBzbywgbWFrZSBzdXJlIHRoZXkgcmVmZXIgdG8gc2FtZSBkZXB0aCBpbiBvYmplY3QgaGllcmFyY2h5XG4gICAgY29uc3QgbWVtb2l6ZWRBY3R1YWwgPSByZWZlcmVuY2VzLmFjdHVhbC5nZXQoYWN0dWFsKTtcblxuICAgIGlmIChtZW1vaXplZEFjdHVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtZW1vaXplZEV4cGVjdGVkID0gcmVmZXJlbmNlcy5leHBlY3RlZC5nZXQoZXhwZWN0ZWQpO1xuXG4gICAgICBpZiAobWVtb2l6ZWRFeHBlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBtZW1vaXplZEFjdHVhbCA9PT0gbWVtb2l6ZWRFeHBlY3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWZlcmVuY2VzLmRlcHRoKys7XG4gIH0gLy8gc3RvcmUgdGhlIG9iamVjdCAtPiBkZXB0aCBtYXBwaW5nXG5cblxuICByZWZlcmVuY2VzLmFjdHVhbC5zZXQoYWN0dWFsLCByZWZlcmVuY2VzLmRlcHRoKTtcbiAgcmVmZXJlbmNlcy5leHBlY3RlZC5zZXQoZXhwZWN0ZWQsIHJlZmVyZW5jZXMuZGVwdGgpOyAvLyBXaGVuIGNvbXBhcmluZyBNYXBzL1NldHMsIGNvbXBhcmUgZWxlbWVudHMgYmVmb3JlIGN1c3RvbSBwcm9wZXJ0aWVzXG5cbiAgbGV0IHJlc3VsdCA9IHRydWU7XG5cbiAgaWYgKGNvbXBhcmlzb24gPT09IENPTVBBUkVfVFlQRS5TZXQpIHtcbiAgICByZXN1bHQgPSBjb21wYXJlU2V0cyhhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3RuZXNzLCByZWZlcmVuY2VzKTtcbiAgfSBlbHNlIGlmIChjb21wYXJpc29uID09PSBDT01QQVJFX1RZUEUuTWFwKSB7XG4gICAgcmVzdWx0ID0gY29tcGFyZU1hcHMoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcyk7XG4gIH1cblxuICBpZiAocmVzdWx0KSB7XG4gICAgLy8gTm93IGxvb3Agb3ZlciBrZXlzIGFuZCBjb21wYXJlIHRoZW0gdG8gZWFjaCBvdGhlciFcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBhY3R1YWxLZXlzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgc3RyaWN0bmVzcywgcmVmZXJlbmNlcykpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB3aXBlIHRoZSBvYmplY3QgdG8gZGVwdGggbWFwcGluZyBmb3IgdGhlc2Ugb2JqZWN0cyBub3dcblxuXG4gIHJlZmVyZW5jZXMuYWN0dWFsLmRlbGV0ZShhY3R1YWwpO1xuICByZWZlcmVuY2VzLmV4cGVjdGVkLmRlbGV0ZShleHBlY3RlZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmFzc2VydCQxLmRlZXBTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuU3RyaWN0KSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBtZXNzYWdlLFxuICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgfSk7XG4gIH1cbn07XG5cbmFzc2VydCQxLm5vdERlZXBTdHJpY3RFcXVhbCA9IChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBTdHJpY3RFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0JDEuZGVlcEVxdWFsID0gKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpID0+IHtcbiAgaWYgKCFkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgU1RSSUNUTkVTUy5Mb29zZSkpIHtcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbCxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIG9wZXJhdG9yOiAnZGVlcEVxdWFsJ1xuICAgIH0pO1xuICB9XG59O1xuXG5hc3NlcnQkMS5ub3REZWVwRXF1YWwgPSAoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkgPT4ge1xuICBpZiAoZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIFNUUklDVE5FU1MuTG9vc2UpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBvcGVyYXRvcjogJ25vdERlZXBFcXVhbCdcbiAgICB9KTtcbiAgfVxufTtcblxuYXNzZXJ0JDEuZmFpbCA9IChtZXNzYWdlID0gJ0ZhaWxlZCcpID0+IHRocm93RXJyb3Ioe1xuICBtZXNzYWdlXG59KTtcblxuY29uc3QgTk9fRVhDRVBUSU9OID0ge307XG5cbmZ1bmN0aW9uIGV4ZWN1dGUoZm4pIHtcbiAgYXNzZXJ0QXJndW1lbnRUeXBlKGZuLCAnZm4nLCAnRnVuY3Rpb24nKTtcblxuICB0cnkge1xuICAgIGZuKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHJldHVybiBOT19FWENFUFRJT047XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UoZm4pIHtcbiAgcmV0dXJuIHV0aWwudHlwZXMuaXNQcm9taXNlKGZuKSB8fCBmbiAmJiB0eXBlb2YgZm4gPT09ICdvYmplY3QnICYmIHR5cGVvZiBmbi50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBleGVjdXRlUHJvbWlzZShmbikge1xuICBsZXQgcHJvbWlzZTtcbiAgY29uc3QgZm5UeXBlID0gdHlwZW9mIGZuO1xuXG4gIGlmIChmblR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9taXNlID0gZm4oKTtcblxuICAgIGlmICghaXNQcm9taXNlTGlrZShwcm9taXNlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5zdGFuY2VvZiBQcm9taXNlIHRvIGJlIHJldHVybmVkIGZyb20gdGhlIFwiZm5cIiBmdW5jdGlvbiBidXQgZ290ICR7dHlwZW9mIHByb21pc2V9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghaXNQcm9taXNlTGlrZShmbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZuXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uIG9yIFByb21pc2UuIFJlY2VpdmVkIHR5cGUgJHtmblR5cGV9YCk7XG4gICAgfVxuXG4gICAgcHJvbWlzZSA9IGZuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBwcm9taXNlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICByZXR1cm4gTk9fRVhDRVBUSU9OO1xufVxuXG5hc3NlcnQkMS50aHJvd3MgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pO1xuXG4gIGlmIChhY3R1YWwgPT09IE5PX0VYQ0VQVElPTikge1xuICAgIC8vIEZJWE1FOiBhcHBlbmQgbWVzc2FnZSBpZiBub3QgbnVsbFxuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsOiB1bmRlZmluZWQsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24uJyxcbiAgICAgIG9wZXJhdG9yOiAndGhyb3dzJ1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfSAvLyBUaGV5IGRpZG4ndCBzcGVjaWZ5IGhvdyB0byB2YWxpZGF0ZSwgc28ganVzdCByb2xsIHdpdGggaXRcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWNoZWNrRXJyb3IoYWN0dWFsLCBlcnJvciwgbWVzc2FnZSkpIHtcbiAgICB0aHJvdyBhY3R1YWw7IC8vIHRocm93IHRoZSBFcnJvciBpdCBkaWQgZ2VuZXJhdGVcbiAgfVxufTtcblxuYXNzZXJ0JDEucmVqZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChhc3luY0ZuLCBlcnJvciwgbWVzc2FnZSkge1xuICBjb25zdCBhY3R1YWwgPSBhd2FpdCBleGVjdXRlUHJvbWlzZShhc3luY0ZuKTtcblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICAvLyBGSVhNRTogYXBwZW5kIG1lc3NhZ2UgaWYgbm90IG51bGxcbiAgICB0aHJvd0Vycm9yKHtcbiAgICAgIGFjdHVhbDogdW5kZWZpbmVkLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgbWVzc2FnZTogJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uLicsXG4gICAgICBvcGVyYXRvcjogJ3JlamVjdHMnXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJvbGwgd2l0aCBpdFxuXG5cbiAgaWYgKCFlcnJvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghY2hlY2tFcnJvcihhY3R1YWwsIGVycm9yLCBtZXNzYWdlKSkge1xuICAgIHRocm93IGFjdHVhbDsgLy8gdGhyb3cgdGhlIEVycm9yIGl0IGRpZCBnZW5lcmF0ZVxuICB9XG59O1xuXG5hc3NlcnQkMS5kb2VzTm90VGhyb3cgPSAoZm4sIGVycm9yLCBtZXNzYWdlKSA9PiB7XG4gIGNvbnN0IGFjdHVhbCA9IGV4ZWN1dGUoZm4pOyAvLyBubyBFcnJvciwganVzdCByZXR1cm5cblxuICBpZiAoYWN0dWFsID09PSBOT19FWENFUFRJT04pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVGhleSBkaWRuJ3Qgc3BlY2lmeSBob3cgdG8gdmFsaWRhdGUsIHNvIGp1c3QgcmUtdGhyb3dcblxuXG4gIGlmICghZXJyb3IpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH0gLy8gSWYgZXJyb3IgbWF0Y2hlcyBleHBlY3RlZCwgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3JcblxuXG4gIGlmIChjaGVja0Vycm9yKGFjdHVhbCwgZXJyb3IpKSB7XG4gICAgdGhyb3dFcnJvcih7XG4gICAgICBhY3R1YWwsXG4gICAgICBleHBlY3RlZDogZXJyb3IsXG4gICAgICBvcGVyYXRvcjogJ2RvZXNOb3RUaHJvdycsXG4gICAgICBtZXNzYWdlOiBgR290IHVud2FudGVkIGV4Y2VwdGlvbiR7bWVzc2FnZSA/ICc6ICcgKyBtZXNzYWdlIDogJy4nfWBcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gZG9lc24ndCBtYXRjaCwgcmUtdGhyb3dcblxuXG4gIHRocm93IGFjdHVhbDtcbn07XG5cbmFzc2VydCQxLmRvZXNOb3RSZWplY3QgPSBhc3luYyBmdW5jdGlvbiAoZm4sIGVycm9yLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGFjdHVhbCA9IGF3YWl0IGV4ZWN1dGVQcm9taXNlKGZuKTsgLy8gbm8gRXJyb3IsIGp1c3QgcmV0dXJuXG5cbiAgaWYgKGFjdHVhbCA9PT0gTk9fRVhDRVBUSU9OKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXkgZGlkbid0IHNwZWNpZnkgaG93IHRvIHZhbGlkYXRlLCBzbyBqdXN0IHJlLXRocm93XG5cblxuICBpZiAoIWVycm9yKSB7XG4gICAgdGhyb3cgYWN0dWFsO1xuICB9IC8vIElmIGVycm9yIG1hdGNoZXMgZXhwZWN0ZWQsIHRocm93IGFuIEFzc2VydGlvbkVycm9yXG5cblxuICBpZiAoY2hlY2tFcnJvcihhY3R1YWwsIGVycm9yKSkge1xuICAgIHRocm93RXJyb3Ioe1xuICAgICAgYWN0dWFsLFxuICAgICAgZXhwZWN0ZWQ6IGVycm9yLFxuICAgICAgb3BlcmF0b3I6ICdkb2VzTm90VGhyb3cnLFxuICAgICAgbWVzc2FnZTogYEdvdCB1bndhbnRlZCBleGNlcHRpb24ke21lc3NhZ2UgPyAnOiAnICsgbWVzc2FnZSA6ICcuJ31gXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9IC8vIGRvZXNuJ3QgbWF0Y2gsIHJlLXRocm93XG5cblxuICB0aHJvdyBhY3R1YWw7XG59O1xuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBhY3R1YWwgdGhlIGFjdHVhbCBFcnJvciBnZW5lcmF0ZWQgYnkgdGhlIHdyYXBwZWQgZnVuY3Rpb24vYmxvY2tcbiAqIEBwYXJhbSB7b2JqZWN0fFJlZ0V4cHxGdW5jdGlvbnxFcnJvcnxDbGFzc30gZXhwZWN0ZWQgVGhlIHZhbHVlIHRvIHRlc3QgYWdhaW5zdCB0aGUgRXJyb3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWVzc2FnZV0gY3VzdG9tIG1lc3NhZ2UgdG8gYXBwZW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgRXJyb3IgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgdmFsdWUvb2JqZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBjaGVja0Vycm9yKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgLy8gV2hhdCB3ZSBkbyBoZXJlIGRlcGVuZHMgb24gd2hhdCBgZXhwZWN0ZWRgIGlzOlxuICAvLyBmdW5jdGlvbiAtIGNhbGwgaXQgdG8gdmFsaWRhdGVcbiAgLy8gb2JqZWN0IC0gdGVzdCBwcm9wZXJ0aWVzIGFnYWluc3QgYWN0dWFsXG4gIC8vIFJlZ2V4cCAtIHRlc3QgYWdhaW5zdCBhY3R1YWwudG9TdHJpbmcoKVxuICAvLyBFcnJvciB0eXBlIC0gY2hlY2sgdHlwZSBtYXRjaGVzXG4gIC8vIEVycm9yIGluc3RhbmNlIC0gY29tcGFyZSBwcm9wZXJ0aWVzXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHV0aWwudHlwZXMuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpOyAvLyBkb2VzIHRoZSBlcnJvciBtYXRjaCB0aGUgUmVnRXhwIGV4cHJlc3Npb24/IGlmIHNvLCBwYXNzXG4gICAgfSAvLyBUZXN0IHByb3BlcnRpZXMgKGBleHBlY3RlZGAgaXMgZWl0aGVyIGEgZ2VuZXJpYyBPYmplY3Qgb3IgYW4gRXJyb3IgaW5zdGFuY2UpXG5cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhleHBlY3RlZCk7IC8vIElmIHdlJ3JlIHRlc3RpbmcgYWdhaW5zdCBhbiBpbnN0YW5jZSBvZiBhbiBFcnJvciwgd2UgbmVlZCB0byBoYWNrIGluIG5hbWUvbWVzc2FnZSBwcm9wZXJ0aWVzLlxuXG4gICAgaWYgKGV4cGVjdGVkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGtleXMudW5zaGlmdCgnbmFtZScsICdtZXNzYWdlJyk7IC8vIHdlIHdhbnQgdG8gY29tcGFyZSBuYW1lIGFuZCBtZXNzYWdlLCBidXQgdGhleSdyZSBub3Qgc2V0IGFzIGVudW1lcmFibGUgb24gRXJyb3JcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhY3R1YWxba2V5XSwgZXhwZWN0ZWRba2V5XSwgU1RSSUNUTkVTUy5TdHJpY3QpKSB7XG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgIC8vIGdlbmVyYXRlIGEgbWVhbmluZ2Z1bCBtZXNzYWdlISBDaGVhdCBieSB0cmVhdGluZyBsaWtlIGVxdWFsaXR5IGNoZWNrIG9mIHZhbHVlc1xuICAgICAgICAgIC8vIHRoZW4gc3RlYWwgdGhlIG1lc3NhZ2UgaXQgZ2VuZXJhdGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93RXJyb3Ioe1xuICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFtrZXldLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRba2V5XSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6ICdkZWVwU3RyaWN0RXF1YWwnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvd0Vycm9yKHtcbiAgICAgICAgICBhY3R1YWwsXG4gICAgICAgICAgZXhwZWN0ZWQsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBvcGVyYXRvcjogJ3Rocm93cydcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTsgLy8gVGhleSBhbGwgbWF0Y2hlZCwgcGFzcyFcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBpZiBgZXhwZWN0ZWRgIGlzIGEgXCJ0eXBlXCIgYW5kIGFjdHVhbCBpcyBhbiBpbnN0YW5jZSBvZiB0aGF0IHR5cGUsIHRoZW4gcGFzc1xuICAgIGlmIChleHBlY3RlZC5wcm90b3R5cGUgIT0gbnVsbCAmJiBhY3R1YWwgaW5zdGFuY2VvZiBleHBlY3RlZCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsLGVxZXFlcVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJZiBgZXhwZWN0ZWRgIGlzIGEgc3ViY2xhc3Mgb2YgRXJyb3IgYnV0IGBhY3R1YWxgIHdhc24ndCBhbiBpbnN0YW5jZSBvZiBpdCAoYWJvdmUpLCBmYWlsXG5cblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbChFcnJvciwgZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBvaywgbGV0J3MgYXNzdW1lIHdoYXQncyBsZWZ0IGlzIHRoYXQgYGV4cGVjdGVkYCB3YXMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLFxuICAgIC8vIHNvIGNhbGwgaXQgd2l0aCBlbXB0eSBgdGhpc2AgYW5kIHNpbmdsZSBhcmd1bWVudCBvZiB0aGUgYWN0dWFsIGVycm9yIHdlIHJlY2VpdmVkXG5cblxuICAgIHJldHVybiBleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5hc3NlcnQkMS5pZkVycm9yID0gdmFsdWUgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRocm93RXJyb3Ioe1xuICAgIGFjdHVhbDogdmFsdWUsXG4gICAgZXhwZWN0ZWQ6IG51bGwsXG4gICAgbWVzc2FnZTogYGlmRXJyb3IgZ290IHVud2FudGVkIGV4Y2VwdGlvbjogJHt2YWx1ZX1gLFxuICAgIG9wZXJhdG9yOiAnaWZFcnJvcidcbiAgfSk7XG59OyAvLyBDcmVhdGUgXCJzdHJpY3RcIiBjb3B5IHdoaWNoIG92ZXJyaWRlcyBcImxvb3NlXCIgbWV0aG9kcyB0byBjYWxsIHN0cmljdCBlcXVpdmFsZW50c1xuXG5cbmFzc2VydCQxLnN0cmljdCA9ICh2YWx1ZSwgbWVzc2FnZSkgPT4gYXNzZXJ0JDEub2sodmFsdWUsIG1lc3NhZ2UpOyAvLyBcIkNvcHlcIiBtZXRob2RzIGZyb20gYXNzZXJ0IHRvIGFzc2VydC5zdHJpY3QhXG5cblxuT2JqZWN0LmFzc2lnbihhc3NlcnQkMS5zdHJpY3QsIGFzc2VydCQxKTsgLy8gT3ZlcnJpZGUgdGhlIFwibG9vc2VcIiBtZXRob2RzIHRvIHBvaW50IHRvIHRoZSBzdHJpY3Qgb25lc1xuXG5hc3NlcnQkMS5zdHJpY3QuZGVlcEVxdWFsID0gYXNzZXJ0JDEuZGVlcFN0cmljdEVxdWFsO1xuYXNzZXJ0JDEuc3RyaWN0Lm5vdERlZXBFcXVhbCA9IGFzc2VydCQxLm5vdERlZXBTdHJpY3RFcXVhbDtcbmFzc2VydCQxLnN0cmljdC5lcXVhbCA9IGFzc2VydCQxLnN0cmljdEVxdWFsO1xuYXNzZXJ0JDEuc3RyaWN0Lm5vdEVxdWFsID0gYXNzZXJ0JDEubm90U3RyaWN0RXF1YWw7IC8vIGhhbmcgc3RyaWN0IG9mZiBpdHNlbGZcblxuYXNzZXJ0JDEuc3RyaWN0LnN0cmljdCA9IGFzc2VydCQxLnN0cmljdDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gVGhlIGNoYXJhY3RlciBlbmNvZGluZyB0aGUgYFN0cmluZ0RlY29kZXJgIHdpbGwgdXNlLlxuICovXG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgVXRmOFN0cmluZ0RlY29kZXIoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2LWxlJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgVXRmMTZTdHJpbmdEZWNvZGVyKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLl9pbXBsID0gbmV3IEJhc2U2NFN0cmluZ0RlY29kZXIoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMuX2ltcGwgPSBuZXcgU3RyaW5nRGVjb2RlckltcGwodGhpcy5lbmNvZGluZyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGFueSByZW1haW5pbmcgaW5wdXQgc3RvcmVkIGluIHRoZSBpbnRlcm5hbCBidWZmZXIgYXMgYSBzdHJpbmcuXG4gKiBCeXRlcyByZXByZXNlbnRpbmcgaW5jb21wbGV0ZSBVVEYtOCBhbmQgVVRGLTE2IGNoYXJhY3RlcnMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHN1YnN0aXR1dGlvblxuICogY2hhcmFjdGVycyBhcHByb3ByaWF0ZSBmb3IgdGhlIGNoYXJhY3RlciBlbmNvZGluZy5cbiAqXG4gKiBJZiB0aGUgYnVmZmVyIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBvbmUgZmluYWwgY2FsbCB0byBzdHJpbmdEZWNvZGVyLndyaXRlKCkgaXMgcGVyZm9ybWVkIGJlZm9yZSByZXR1cm5pbmcgdGhlIHJlbWFpbmluZyBpbnB1dC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBbYnVmZmVyXSBjb250YWluaW5nIHRoZSBieXRlcyB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGJ1ZmZlcikge1xuICByZXR1cm4gdGhpcy5faW1wbC5lbmQoYnVmZmVyKTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBkZWNvZGVkIHN0cmluZywgZW5zdXJpbmcgdGhhdCBhbnkgaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVycyBhdCB0aGUgZW5kIG9mIHRoZSBCdWZmZXIsIG9yXG4gKiBUeXBlZEFycmF5LCBvciBEYXRhVmlldyBhcmUgb21pdHRlZCBmcm9tIHRoZSByZXR1cm5lZCBzdHJpbmcgYW5kIHN0b3JlZCBpbiBhbiBpbnRlcm5hbCBidWZmZXIgZm9yIHRoZVxuICogbmV4dCBjYWxsIHRvIHN0cmluZ0RlY29kZXIud3JpdGUoKSBvciBzdHJpbmdEZWNvZGVyLmVuZCgpLlxuICogQHBhcmFtIHtCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gYnVmZmVyIGNvbnRhaW5pbmcgdGhlIGJ5dGVzIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlKGJ1ZmZlcikge1xuICBpZiAodHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9IC8vIGVtcHR5IHN0cmluZyBmb3IgZW1wdHkgYnVmZmVyXG5cblxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9pbXBsLndyaXRlKGJ1ZmZlcik7XG59O1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzLiBXZSBvdmVycmlkZSBwYXJ0cyBvZiBpdCBmb3IgY2VydGFpbiBlbmNvZGluZ3MuIEZvciBhc2NpaS9oZXgvYmluYXJ5L2xhdGluMSB0aGUgaW1wbCBpcyBzdXBlci1lYXN5XG4gKi9cblxuXG5jbGFzcyBTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAxO1xuICB9IC8vIHRoZSBhY3R1YWwgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbiFcblxuXG4gIGVuZChidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGggIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLndyaXRlKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgd3JpdGUoYnVmZmVyKSB7XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpOyAvLyBzaW5nbGUgYnl0ZSBjaGFyYWN0ZXIgZW5jb2RpbmdzIGFyZSBhIGNpbmNoXG4gICAgfVxuXG4gICAgcmV0dXJuICcnOyAvLyBubyBidWZmZXIsIG9yIGVtcHR5XG4gIH1cblxufSAvLyBGb3IgbXVsdGktYnl0ZSBlbmNvZGluZ3MsIGxldCdzIGltcGxlbWVudCBzb21lIGJhc2UgbG9naWMuLi5cblxuXG5jbGFzcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCBleHRlbmRzIFN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcsIGJ5dGVzUGVyQ2hhcikge1xuICAgIHN1cGVyKGVuY29kaW5nKTtcbiAgICB0aGlzLmluY29tcGxldGUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXNQZXJDaGFyKTsgLy8gdGVtcG9yYXJ5IGluY29tcGxldGUgY2hhcmFjdGVyIGJ1ZmZlclxuICB9XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBJbmNvbXBsZXRlQ2hhck9iamVjdFxuICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGJ5dGVzTmVlZGVkIGJ5dGVzIG1pc3NpbmcgdG8gY29tcGxldGUgdGhlIGNoYXJhY3RlclxuICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGNoYXJMZW5ndGggYnl0ZXMgZXhwZWN0ZWQgdG8gY29tcGxldGUgdGhlIGNoYXJhY3RlclxuICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4IGxvY2F0aW9uIGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIGNoYXJhY3RlciBzdGFydHNcbiAgICovXG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgQnVmZmVyLCBzZWVzIGlmIHdlIGhhdmUgYW4gaW5jb21wbGV0ZSBcImNoYXJhY3RlclwiIGF0IHRoZSBlbmQgb2YgaXQuXG4gICAqIFJldHVybnMgaW5mbyBvbiB0aGF0OlxuICAgKiAtIGJ5dGVzTmVlZGVkOiAwLTMsIG51bWJlciBvZiBieXRlcyBzdGlsbCByZW1haW5pbmdcbiAgICogLSBjaGFyTGVuZ3RoOiBleHBlY3RlZCBudW1iZXIgb2YgYnl0ZXMgZm9yIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgKiAtIGluZGV4OiBpbmRleCBpbiB0aGUgYnVmZmVyIHdoZXJlIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBiZWdpbnNcbiAgICogQHBhcmFtIHtCdWZmZXJ9IF9idWZmZXIgQnVmZmVyIHdlIGFyZSBjaGVja2luZyB0byBzZWUgaWYgaXQgaGFzIGFuIGluY29tcGVsdGUgXCJjaGFyYWN0ZXJcIiBhdCB0aGUgZW5kXG4gICAqIEByZXR1cm5zIHtJbmNvbXBsZXRlQ2hhck9iamVjdH1cbiAgICovXG5cblxuICBfY2hlY2tJbmNvbXBsZXRlQnl0ZXMoX2J1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignc3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlIScpO1xuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUhJyk7XG4gIH1cblxuICBfaW5jb21wbGV0ZUJ1ZmZlckVtcHRpZWQoKSB7XG4gICAgLy8gdHlwaWNhbGx5IHdlIHJlc2V0IGJ5dGUgY291bnQgYmFjayB0byAwIGFuZCBjaGFyYWN0ZXIgbGVuZ3RoIHRvIDFcbiAgICB0aGlzLmJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMTtcbiAgfVxuXG4gIGVuZChidWZmZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gc3VwZXIuZW5kKGJ1ZmZlcik7XG5cbiAgICBpZiAodGhpcy5ieXRlQ291bnQgIT09IDApIHtcbiAgICAgIC8vIHdlIGhhdmUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJzIVxuICAgICAgcmVzdWx0ICs9IHRoaXMuX2luY29tcGxldGVFbmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpOyAvLyByZXNldCBvdXIgaW50ZXJuYWxzIHRvIFwid2lwZVwiIHRoZSBpbmNvbXBsZXRlIGJ1ZmZlclxuXG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgd3JpdGUoYnVmZmVyKSB7XG4gICAgLy8gZmlyc3QgbGV0J3Mgc2VlIGlmIHdlIGhhZCBzb21lIG11bHRpLWJ5dGUgY2hhcmFjdGVyIHdlIGRpZG4ndCBmaW5pc2guLi5cbiAgICBsZXQgY2hhciA9ICcnO1xuXG4gICAgaWYgKHRoaXMuYnl0ZUNvdW50ICE9PSAwKSB7XG4gICAgICAvLyB3ZSBzdGlsbCBuZWVkZWQgc29tZSBieXRlcyB0byBmaW5pc2ggdGhlIGNoYXJhY3RlclxuICAgICAgLy8gSG93IG1hbnkgYnl0ZXMgZG8gd2Ugc3RpbGwgbmVlZD8gY2hhckxlbmd0aCAtIGJ5dGVzIHdlIHJlY2VpdmVkXG4gICAgICBjb25zdCBsZWZ0ID0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5ieXRlQ291bnQ7IC8vIG5lZWQgNCwgaGF2ZSAxPyB0aGVuIHdlIGhhdmUgMyBcImxlZnRcIlxuXG4gICAgICBjb25zdCBieXRlc0NvcGllZCA9IE1hdGgubWluKGxlZnQsIGJ1ZmZlci5sZW5ndGgpOyAvLyBjb3B5IHVwIHRvIHRoYXQgbWFueSBieXRlc1xuICAgICAgLy8gY29weSBieXRlcyBmcm9tIGBidWZmZXJgIHRvIG91ciBpbmNvbXBsZXRlIGJ1ZmZlclxuXG4gICAgICBidWZmZXIuY29weSh0aGlzLmluY29tcGxldGUsIHRoaXMuYnl0ZUNvdW50LCAwLCBieXRlc0NvcGllZCk7XG4gICAgICB0aGlzLmJ5dGVDb3VudCArPSBieXRlc0NvcGllZDsgLy8gcmVjb3JkIGhvdyBtYW55IG1vcmUgYnl0ZXMgd2UgY29waWVkLi4uXG5cbiAgICAgIGlmIChieXRlc0NvcGllZCA8IGxlZnQpIHtcbiAgICAgICAgLy8gc3RpbGwgbmVlZCBtb3JlIGJ5dGVzIHRvIGNvbXBsZXRlIVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IC8vIHdlIHdlcmUgYWJsZSB0byBjb21wbGV0ZSwgeWF5IVxuICAgICAgLy8gZ3JhYiB0aGUgY2hhcmFjdGVyIHdlIGNvbXBsZXRlZFxuXG5cbiAgICAgIGNoYXIgPSB0aGlzLmluY29tcGxldGUuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsgLy8gcmVzZXQgb3VyIGNvdW50ZXJzXG5cbiAgICAgIHRoaXMuX2luY29tcGxldGVCdWZmZXJFbXB0aWVkKCk7IC8vIGRvIHdlIGhhdmUgYW55IGJ5dGVzIGxlZnQgaW4gdGhpcyBidWZmZXI/XG5cblxuICAgICAgaWYgKGJ5dGVzQ29waWVkID09PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjaGFyOyAvLyBpZiBub3QsIHJldHVybiB0aGUgY2hhcmFjdGVyIHdlIGZpbmlzaGVkIVxuICAgICAgfSAvLyB3ZSBzdGlsbCBoYXZlIG1vcmUgYnl0ZXMsIHNvIHNsaWNlIHRoZSBidWZmZXIgdXBcblxuXG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYnl0ZXNDb3BpZWQsIGJ1ZmZlci5sZW5ndGgpO1xuICAgIH0gLy8gY2hlY2sgdGhpcyBidWZmZXIgdG8gc2VlIGlmIGl0IGluZGljYXRlcyB3ZSBuZWVkIG1vcmUgYnl0ZXM/XG5cblxuICAgIGNvbnN0IGluY29tcGxldGVDaGFyRGF0YSA9IHRoaXMuX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcik7XG5cbiAgICBpZiAoaW5jb21wbGV0ZUNoYXJEYXRhLmJ5dGVzTmVlZGVkID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhciArIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTsgLy8gbm8gaW5jb21wbGV0ZSBieXRlcywgcmV0dXJuIGFueSBjaGFyYWN0ZXIgd2UgY29tcGxldGVkIHBsdXMgdGhlIGJ1ZmZlclxuICAgIH0gLy8gb2sgc28gdGhlIGJ1ZmZlciBob2xkcyBhbiBpbmNvbXBsZXRlIGNoYXJhY3RlciBhdCBpdCdzIGVuZFxuXG5cbiAgICB0aGlzLmNoYXJMZW5ndGggPSBpbmNvbXBsZXRlQ2hhckRhdGEuY2hhckxlbmd0aDsgLy8gcmVjb3JkIGhvdyBtYW55IGJ5dGVzIHdlIG5lZWQgZm9yIHRoZSAnY2hhcmFjdGVyJ1xuXG4gICAgY29uc3QgaW5jb21wbGV0ZUNoYXJJbmRleCA9IGluY29tcGxldGVDaGFyRGF0YS5pbmRleDsgLy8gdGhpcyBpcyB0aGUgaW5kZXggb2YgdGhlIG11bHRpYnl0ZSBjaGFyYWN0ZXIgdGhhdCBpcyBpbmNvbXBsZXRlXG4gICAgLy8gY29weSBmcm9tIGluZGV4IG9mIGluY29tcGxldGUgY2hhcmFjdGVyIHRvIGVuZCBvZiBidWZmZXJcblxuICAgIGNvbnN0IGJ5dGVzVG9Db3B5ID0gYnVmZmVyLmxlbmd0aCAtIGluY29tcGxldGVDaGFySW5kZXg7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5pbmNvbXBsZXRlLCAwLCBpbmNvbXBsZXRlQ2hhckluZGV4LCBidWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLmJ5dGVDb3VudCA9IGJ5dGVzVG9Db3B5OyAvLyByZWNvcmQgaG93IG1hbnkgYnl0ZXMgd2UgYWN0dWFsbHkgY29waWVkXG5cbiAgICBpZiAoYnl0ZXNUb0NvcHkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAvLyBidWZmZXIgaGFkIGJ5dGVzIGJlZm9yZSB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICAgIC8vIHNvIHNtdXNoIGFueSBjaGFyYWN0ZXIgd2UgbWF5IGhhdmUgY29tcGxldGVkIHdpdGggYW55IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gdGhlIGJ1ZmZlclxuICAgICAgcmV0dXJuIGNoYXIgKyBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgaW5jb21wbGV0ZUNoYXJJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXI7IC8vIGFueSBub3ctY29tcGxldGVkIGNoYXJhY3RlciB0aGF0IHdhcyBwcmV2aW91c2x5IGluY29tcGxldGUsIHBvc3NpYmx5IGVtcHR5XG4gIH1cblxufVxuXG5jbGFzcyBVdGY4U3RyaW5nRGVjb2RlciBleHRlbmRzIE11bHRpQnl0ZVN0cmluZ0RlY29kZXJJbXBsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3V0ZjgnLCA0KTtcbiAgfVxuXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoOyAvLyBGSVhNRTogSW4gTm9kZSwgdGhleSBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgZmlyc3QhXG4gICAgLy8gQW5kIHRoZXkgcmVseSBvbiBCdWZmZXIjdG9TdHJpbmcoKSB0byBoYW5kbGUgaW5qZWN0aW5nIHRoZSAnXFx1ZmZmZCcgY2hhcmFjdGVyIGZvciBidXN0ZWQgbXVsdGktYnl0ZSBzZXF1ZW5jZXMhXG4gICAgLy8gaU9TIGFwcGFyZW50bHkganVzdCByZXR1cm5zIHVuZGVmaW5lZCBpbiB0aGF0IHNwZWNpYWwgY2FzZSBhbmRcbiAgICAvLyBBbmRyb2lkIGRpZmZlcnMgaGVyZSBiZWNhdXNlIHdlIGRvbid0IHdvcmsgYmFja3dhcmRzIGZyb20gdGhlIGxhc3QgY2hhclxuICAgIC8vIENhbiB3ZSBjaGVhdCBoZXJlIGFuZC4uLlxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3N0cmluZ19kZWNvZGVyL2Jsb2IvbWFzdGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyNMMTczLUwxOThcbiAgICAvLyAtIGlmIHdlIHNlZSBhIG11bHRpLWJ5dGUgY2hhcmFjdGVyIHN0YXJ0LCB2YWxpZGF0ZSB0aGUgbmV4dCBjaGFyYWN0ZXJzIGFyZSBjb250aW51YXRpb24gY2hhcnNcbiAgICAvLyAtIGlmIHRoZXkncmUgbm90IHJlcGxhY2UgdGhlIHNlcXVlbmNlIHdpdGggJ1xcdWZmZmQnLCB0cmVhdCBsaWtlIHRoYXQgbXVsdGktYnl0ZSBjaGFyYWN0ZXIgd2FzIFwiY29tcGxldGVkXCJcbiAgICAvLyBOb3RlIHRoYXQgZXZlbiBpZiB3ZSBkbyBoYWNrIHRoaXMsIGlmIHRoZXJlJ3Mgc29tZSBpbnZhbGlkIG11bHRpLWJ5dGUgVVRGLTggaW4gdGhlIGJ1ZmZlciB0aGF0IGlzbid0IGF0IHRoZSBsYXN0IDMgYnl0ZXNcbiAgICAvLyB0aGVuIHdlJ3JlIGF0IHRoZSBtZXJjeSBvZiB0aGUgSlMgZW5naW5lL3BsYXRmb3JtIGNvZGUgZm9yIGhhbmRsaW5nIHRoYXRcbiAgICAvLyBIZXJlJ3Mgc29tZW9uZSdzIGhhY2sgdGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL29sZWdhbnphLzk5NzE1NVxuICAgIC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMywgY2hlY2sgM3JkIHRvIGxhc3QgYnl0ZVxuXG4gICAgaWYgKGxlbmd0aCA+PSAzKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDNdKTtcblxuICAgICAgaWYgKGNoYXJMZW5ndGggPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogMSxcbiAgICAgICAgICAvLyB3ZSBoYXZlIDMgbGFzdCBieXRlcywgbmVlZCA0dGhcbiAgICAgICAgICBpbmRleDogbGVuZ3RoIC0gMyxcbiAgICAgICAgICBjaGFyTGVuZ3RoOiA0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSAvLyBpZiBidWZmZXIubGVuZ3RoID49IDIsIGNoZWNrIDJuZCB0byBsYXN0IGJ5dGVcblxuXG4gICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICBsZXQgY2hhckxlbmd0aCA9IGNoZWNrQ2hhckxlbmd0aEZvclVURjgoYnVmZmVyW2xlbmd0aCAtIDJdKTtcblxuICAgICAgaWYgKGNoYXJMZW5ndGggPj0gMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiBjaGFyTGVuZ3RoIC0gMixcbiAgICAgICAgICAvLyB3ZSBoYXZlIDIgYnl0ZXMgb2Ygd2hhdGV2ZXIgd2UgbmVlZFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAyLFxuICAgICAgICAgIGNoYXJMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGlmIGJ1ZmZlci5sZW5ndGggPj0gMSwgY2hlY2sgbGFzdCBieXRlXG5cblxuICAgIGlmIChsZW5ndGggPj0gMSkge1xuICAgICAgbGV0IGNoYXJMZW5ndGggPSBjaGVja0NoYXJMZW5ndGhGb3JVVEY4KGJ1ZmZlcltsZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChjaGFyTGVuZ3RoID49IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieXRlc05lZWRlZDogY2hhckxlbmd0aCAtIDEsXG4gICAgICAgICAgLy8gd2UgaGF2ZSAxIGJ5dGUgb2Ygd2hhdGV2ZXIgd2UgbmVlZFxuICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuICAgICAgICAgIGNoYXJMZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IC8vIGJhc2UgY2FzZSwgbm8gYnl0ZXMgbmVlZGVkIC0gZW5kcyBvbiBjb21wbGV0ZSBjaGFyYWN0ZXJcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJ5dGVzTmVlZGVkOiAwLFxuICAgICAgaW5kZXg6IGxlbmd0aCAtIDEsXG4gICAgICBjaGFyTGVuZ3RoOiAxXG4gICAgfTtcbiAgfVxuXG4gIF9pbmNvbXBsZXRlRW5kKCkge1xuICAgIHJldHVybiAnXFx1ZmZmZCc7IC8vIHdlIHJlcGxhY2UgdGhlIG1pc3NpbmcgY2hhcmFjdGVyIHdpdGggYSBzcGVjaWFsIHV0ZjggY2hhclxuICB9XG5cbn1cblxuY2xhc3MgVXRmMTZTdHJpbmdEZWNvZGVyIGV4dGVuZHMgTXVsdGlCeXRlU3RyaW5nRGVjb2RlckltcGwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigndXRmMTZsZScsIDQpO1xuICB9XG5cbiAgX2NoZWNrSW5jb21wbGV0ZUJ5dGVzKGJ1ZmZlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgY29uc3QgbW9kdWxvID0gbGVuZ3RoICUgMjsgLy8gb2ssIHdlIGhhdmUgYSBtdWx0aXBsZSBvZiAyIGJ5dGVzXG5cbiAgICBpZiAobW9kdWxvID09PSAwKSB7XG4gICAgICAvLyBpcyB0aGUgbGFzdCBieXRlIGEgbGVhZGluZy9oaWdoIHN1cnJvZ2F0ZT9cbiAgICAgIGNvbnN0IGJ5dGUgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoYnl0ZSA+PSAweEQ4ICYmIGJ5dGUgPD0gMHhEQikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJ5dGVzTmVlZGVkOiAyLFxuICAgICAgICAgIGNoYXJMZW5ndGg6IDQsXG4gICAgICAgICAgaW5kZXg6IGxlbmd0aCAtIDJcbiAgICAgICAgfTtcbiAgICAgIH0gLy8gd2UncmUgZ29vZCwgbm90IGEgc3Vycm9nYXRlLCBzbyB3ZSBoYXZlIG91ciBuZWVkZWQgMiBieXRlc1xuXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzTmVlZGVkOiAwLFxuICAgICAgICBjaGFyTGVuZ3RoOiAyXG4gICAgICB9O1xuICAgIH0gLy8gb2sgd2UgaGF2ZSAxIGJ5dGUgbGVmdCBvdmVyLCBhc3N1bWUgd2UgbmVlZCAyIHRvIGZvcm0gdGhlIGNoYXJhY3RlclxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNOZWVkZWQ6IDEsXG4gICAgICBpbmRleDogbGVuZ3RoIC0gMSxcbiAgICAgIGNoYXJMZW5ndGg6IDJcbiAgICB9O1xuICB9XG5cbiAgX2luY29tcGxldGVFbmQoKSB7XG4gICAgLy8gSnVzdCB3cml0ZSBvdXQgdGhlIGxhc3QgTiBieXRlcywgaG9wZWZ1bGx5IHRoZSBlbmdpbmUgY2FuIGhhbmRsZSBpdCBmb3IgdXM/XG4gICAgcmV0dXJuIHRoaXMuaW5jb21wbGV0ZS50b1N0cmluZygndXRmMTZsZScsIDAsIHRoaXMuYnl0ZUNvdW50KTtcbiAgfVxuXG59XG5cbmNsYXNzIEJhc2U2NFN0cmluZ0RlY29kZXIgZXh0ZW5kcyBNdWx0aUJ5dGVTdHJpbmdEZWNvZGVySW1wbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdiYXNlNjQnLCAzKTtcbiAgICB0aGlzLmNoYXJMZW5ndGggPSAzOyAvLyBhbHdheXMgMyFcbiAgfVxuXG4gIF9jaGVja0luY29tcGxldGVCeXRlcyhidWZmZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IG1vZHVsbyA9IGxlbmd0aCAlIDM7IC8vIGJhc2U2NCBuZWVkcyAzIGJ5dGVzIGFsd2F5cywgc28gaWYgd2UgaGF2ZSB0aGF0IG1hbnkgKG9yIGEgbXVsdGlwbGUpLCB3ZSBoYXZlIGEgY29tcGxldGUgYnVmZmVyXG5cbiAgICBpZiAobW9kdWxvID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBieXRlc05lZWRlZDogMCxcbiAgICAgICAgY2hhckxlbmd0aDogM1xuICAgICAgfTtcbiAgICB9IC8vIG9rIHdlIGhhdmUgMSBvciAyIGJ5dGVzIGxlZnQgb3ZlclxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYnl0ZXNOZWVkZWQ6IDMgLSBtb2R1bG8sXG4gICAgICAvLyBhbHdheXMgbmVlZCAzLCBzbyBpZiB3ZSBoYXZlIDEgbGVmdCBvdmVyIC0+IG5lZWQgMlxuICAgICAgaW5kZXg6IGxlbmd0aCAtIG1vZHVsbyxcbiAgICAgIGNoYXJMZW5ndGg6IDMgLy8gYWx3YXlzIG5lZWQgM1xuXG4gICAgfTtcbiAgfVxuXG4gIF9pbmNvbXBsZXRlQnVmZmVyRW1wdGllZCgpIHtcbiAgICB0aGlzLmJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5jaGFyTGVuZ3RoID0gMzsgLy8gYWx3YXlzIDMhXG4gIH1cblxuICBfaW5jb21wbGV0ZUVuZCgpIHtcbiAgICAvLyBKdXN0IHdyaXRlIG91dCB0aGUgbGFzdCBOIGJ5dGVzLCBpdCBzaG91bGQgaW5zZXJ0IHRoZSAnPScgcGxhY2Vob2xkZXJzXG4gICAgLy8gaXQncyBub3QgcmVhbGx5ICdtaXNzaW5nJy8naW5jb21wbGV0ZScsIGp1c3QgbmVlZHMgcGxhY2Vob2xkZXIgaW5zZXJ0aW9uXG4gICAgcmV0dXJuIHRoaXMuaW5jb21wbGV0ZS50b1N0cmluZygnYmFzZTY0JywgMCwgdGhpcy5ieXRlQ291bnQpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gY2hlY2tDaGFyTGVuZ3RoRm9yVVRGOChieXRlKSB7XG4gIC8vIDExMTEwWFhYID0+IDExMTAgPT4gMHgxRVxuICBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSB7XG4gICAgcmV0dXJuIDQ7XG4gIH0gLy8gMTExMFhYWFggPT4gMTExMCA9PiAweDFFXG5cblxuICBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSB7XG4gICAgcmV0dXJuIDM7XG4gIH0gLy8gMTEwWFhYWFggPT4gMTEwID0+IDB4MDZcblxuXG4gIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHtcbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIHJldHVybiAxO1xufVxuXG52YXIgU3RyaW5nRGVjb2RlciQxID0ge1xuICBTdHJpbmdEZWNvZGVyXG59O1xuXG5jb25zdCBwcmludGVkV2FybmluZ3MgPSB7fTtcblxuZnVuY3Rpb24gb25lVGltZVdhcm5pbmcoa2V5LCBtc2cpIHtcbiAgaWYgKCFwcmludGVkV2FybmluZ3Nba2V5XSkge1xuICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIHByaW50ZWRXYXJuaW5nc1trZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBQcmludHMgYSBvbmUtdGltZSB3YXJuaW5nIG1lc3NhZ2UgdGhhdCB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZ2l2ZW4gQVBJIGFuZCBwZXJmb3JtcyBhbiBlZmZlY3RpdmUgbm8tb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gbm8tb3AgZnVuY3Rpb25cbiAqL1xuXG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgZnFuID0gYCR7bW9kdWxlTmFtZX0uJHtuYW1lfWA7XG4gICAgb25lVGltZVdhcm5pbmcoZnFuLCBgXCIke2Zxbn1cIiBpcyBub3Qgc3VwcG9ydGVkIHlldCBvbiBUaXRhbml1bSBhbmQgdXNlcyBhIG5vLW9wIGZhbGxiYWNrLmApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH07XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIG5hbWUgb2YgdGhlIG1vZHVsZS9vYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLnByb3BlcnR5IHdlIGRvbid0IHN1cHBvcnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrIHdlIGNhbGwgaW4gYSBxdWljayBzZXRUaW1lb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBhc3luY1Vuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spOyAvLyBlbmZvcmNlIHdlIGhhdmUgYSB2YWxpZCBjYWxsYmFja1xuXG4gIHVuc3VwcG9ydGVkTm9vcChtb2R1bGVOYW1lLCBuYW1lKSgpO1xuICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbn0gLy8gVXNlZCB0byBjaG9vc2UgdGhlIGJ1ZmZlci9jaHVuayBzaXplIHdoZW4gcHVtcGluZyBieXRlcyBkdXJpbmcgY29waWVzXG5cblxuY29uc3QgQ09QWV9GSUxFX0NIVU5LX1NJWkUgPSA4MDkyOyAvLyB3aGF0IHNob3VsZCB3ZSB1c2UgaGVyZT9cbi8vIEtlZXAgdHJhY2sgb2YgaW50ZWdlciAtPiBGaWxlU3RyZWFtIG1hcHBpbmdzXG5cbmNvbnN0IGZpbGVEZXNjcmlwdG9ycyA9IG5ldyBNYXAoKTtcbmxldCBmaWxlRGVzY3JpcHRvckNvdW50ID0gNDsgLy8gZ2xvYmFsIGNvdW50ZXIgdXNlZCB0byByZXBvcnQgZmlsZSBkZXNjcmlwdG9yIGludGVnZXJzXG4vLyBNYXAgZmlsZSBzeXN0ZW0gYWNjZXNzIGZsYWdzIHRvIFRpLkZpbGVzeXN0ZW0uTU9ERV8qIGNvbnN0YW50c1xuXG5jb25zdCBGTEFHU19UT19USV9NT0RFID0gbmV3IE1hcCgpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2EnLCBUaS5GaWxlc3lzdGVtLk1PREVfQVBQRU5EKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdheCcsIFRpLkZpbGVzeXN0ZW0uTU9ERV9BUFBFTkQpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ2ErJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXgrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnYXMrJywgVGkuRmlsZXN5c3RlbS5NT0RFX0FQUEVORCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgncicsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdyKycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9SRUFEKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCdycysnLCBUaS5GaWxlc3lzdGVtLk1PREVfUkVBRCk7XG5GTEFHU19UT19USV9NT0RFLnNldCgndycsIFRpLkZpbGVzeXN0ZW0uTU9ERV9XUklURSk7XG5GTEFHU19UT19USV9NT0RFLnNldCgnd3gnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuRkxBR1NfVE9fVElfTU9ERS5zZXQoJ3crJywgVGkuRmlsZXN5c3RlbS5NT0RFX1dSSVRFKTtcbkZMQUdTX1RPX1RJX01PREUuc2V0KCd3eCsnLCBUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpOyAvLyBDb21tb24gZXJyb3JzXG5cbmNvbnN0IHBlcm1pc3Npb25EZW5pZWQgPSAoc3lzY2FsbCwgcGF0aCkgPT4gbWFrZUVycm9yKCdFQUNDRVMnLCAncGVybWlzc2lvbiBkZW5pZWQnLCAtMTMsIHN5c2NhbGwsIHBhdGgpO1xuXG5jb25zdCBub1N1Y2hGaWxlID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PRU5UJywgJ25vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknLCAtMiwgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IGZpbGVBbHJlYWR5RXhpc3RzID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRUVYSVNUJywgJ2ZpbGUgYWxyZWFkeSBleGlzdHMnLCAtMTcsIHN5c2NhbGwsIHBhdGgpO1xuXG5jb25zdCBub3RBRGlyZWN0b3J5ID0gKHN5c2NhbGwsIHBhdGgpID0+IG1ha2VFcnJvcignRU5PVERJUicsICdub3QgYSBkaXJlY3RvcnknLCAtMjAsIHN5c2NhbGwsIHBhdGgpO1xuXG5jb25zdCBkaXJlY3RvcnlOb3RFbXB0eSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VOT1RFTVBUWScsICdkaXJlY3Rvcnkgbm90IGVtcHR5JywgLTY2LCBzeXNjYWxsLCBwYXRoKTtcblxuY29uc3QgaWxsZWdhbE9wZXJhdGlvbk9uQURpcmVjdG9yeSA9IChzeXNjYWxsLCBwYXRoKSA9PiBtYWtlRXJyb3IoJ0VJU0RJUicsICdpbGxlZ2FsIG9wZXJhdGlvbiBvbiBhIGRpcmVjdG9yeScsIC0yMSwgc3lzY2FsbCwgcGF0aCk7XG5cbmNvbnN0IGZzID0ge1xuICBjb25zdGFudHM6IHtcbiAgICBPX1JET05MWTogMCxcbiAgICBPX1dST05MWTogMSxcbiAgICBPX1JEV1I6IDIsXG4gICAgU19JRk1UOiA2MTQ0MCxcbiAgICBTX0lGUkVHOiAzMjc2OCxcbiAgICBTX0lGRElSOiAxNjM4NCxcbiAgICBTX0lGQ0hSOiA4MTkyLFxuICAgIFNfSUZCTEs6IDI0NTc2LFxuICAgIFNfSUZJRk86IDQwOTYsXG4gICAgU19JRkxOSzogNDA5NjAsXG4gICAgU19JRlNPQ0s6IDQ5MTUyLFxuICAgIE9fQ1JFQVQ6IDUxMixcbiAgICBPX0VYQ0w6IDIwNDgsXG4gICAgT19OT0NUVFk6IDEzMTA3MixcbiAgICBPX1RSVU5DOiAxMDI0LFxuICAgIE9fQVBQRU5EOiA4LFxuICAgIE9fRElSRUNUT1JZOiAxMDQ4NTc2LFxuICAgIE9fTk9GT0xMT1c6IDI1NixcbiAgICBPX1NZTkM6IDEyOCxcbiAgICBPX0RTWU5DOiA0MTk0MzA0LFxuICAgIE9fU1lNTElOSzogMjA5NzE1MixcbiAgICBPX05PTkJMT0NLOiA0LFxuICAgIFNfSVJXWFU6IDQ0OCxcbiAgICBTX0lSVVNSOiAyNTYsXG4gICAgU19JV1VTUjogMTI4LFxuICAgIFNfSVhVU1I6IDY0LFxuICAgIFNfSVJXWEc6IDU2LFxuICAgIFNfSVJHUlA6IDMyLFxuICAgIFNfSVdHUlA6IDE2LFxuICAgIFNfSVhHUlA6IDgsXG4gICAgU19JUldYTzogNyxcbiAgICBTX0lST1RIOiA0LFxuICAgIFNfSVdPVEg6IDIsXG4gICAgU19JWE9USDogMSxcbiAgICBGX09LOiAwLFxuICAgIFJfT0s6IDQsXG4gICAgV19PSzogMixcbiAgICBYX09LOiAxLFxuICAgIFVWX0ZTX0NPUFlGSUxFX0VYQ0w6IDEsXG4gICAgQ09QWUZJTEVfRVhDTDogMVxuICB9XG59O1xuXG5jbGFzcyBTdGF0cyB7XG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICB0aGlzLl9maWxlID0gbnVsbDtcbiAgICB0aGlzLmRldiA9IDA7XG4gICAgdGhpcy5pbm8gPSAwO1xuICAgIHRoaXMubW9kZSA9IDA7XG4gICAgdGhpcy5ubGluayA9IDA7XG4gICAgdGhpcy51aWQgPSAwO1xuICAgIHRoaXMuZ2lkID0gMDtcbiAgICB0aGlzLnJkZXYgPSAwO1xuICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgdGhpcy5ibGtzaXplID0gNDA5NjsgLy8gRklYTUU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMTUzMTEvd2hhdC1pcy10aGUtYmxvY2stc2l6ZS1vZi10aGUtaXBob25lLWZpbGVzeXN0ZW1cblxuICAgIHRoaXMuYmxvY2tzID0gMDtcbiAgICB0aGlzLmF0aW1lTXMgPSB0aGlzLm10aW1lTXMgPSB0aGlzLmN0aW1lTXMgPSB0aGlzLmJpcnRodGltZU1zID0gMDtcbiAgICB0aGlzLmF0aW1lID0gdGhpcy5tdGltZSA9IHRoaXMuY3RpbWUgPSB0aGlzLmJpcnRodGltZSA9IG5ldyBEYXRlKDApO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRoaXMuX2ZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTsgLy8gVE9ETzogdXNlIGxhenkgZ2V0dGVycyBoZXJlP1xuXG4gICAgICB0aGlzLmN0aW1lID0gdGhpcy5iaXJ0aHRpbWUgPSB0aGlzLl9maWxlLmNyZWF0ZWRBdCgpO1xuICAgICAgdGhpcy5hdGltZSA9IHRoaXMubXRpbWUgPSB0aGlzLl9maWxlLm1vZGlmaWVkQXQoKTtcbiAgICAgIHRoaXMuYXRpbWVNcyA9IHRoaXMuYXRpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5iaXJ0aHRpbWVNcyA9IHRoaXMuYmlydGh0aW1lLmdldFRpbWUoKTtcbiAgICAgIHRoaXMuY3RpbWVNcyA9IHRoaXMuY3RpbWUuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5tdGltZU1zID0gdGhpcy5tdGltZS5nZXRUaW1lKCk7XG4gICAgICB0aGlzLnNpemUgPSB0aGlzLl9maWxlLnNpemU7XG4gICAgICB0aGlzLmJsb2NrcyA9IE1hdGguY2VpbCh0aGlzLnNpemUgLyB0aGlzLmJsa3NpemUpOyAvLyBUT0RPOiBDYW4gd2UgZmFrZSBvdXQgdGhlIG1vZGUgYmFzZWQgb24gdGhlIHJlYWRvbmx5L3dyaXRhYmxlL2V4ZWN1dGFibGUgcHJvcGVydGllcz9cbiAgICB9XG4gIH1cblxuICBpc0ZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGUuaXNGaWxlKCk7XG4gIH1cblxuICBpc0RpcmVjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5pc0RpcmVjdG9yeSgpO1xuICB9XG5cbiAgaXNCbG9ja0RldmljZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpc1N5bWJvbGljTGluaygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZS5zeW1ib2xpY0xpbms7XG4gIH1cblxuICBpc0ZJRk8oKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXNTb2NrZXQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn1cblxuZnMuU3RhdHMgPSBTdGF0cztcblxuY2xhc3MgUmVhZFN0cmVhbSB7fVxuXG5mcy5SZWFkU3RyZWFtID0gUmVhZFN0cmVhbTtcblxuY2xhc3MgV3JpdGVTdHJlYW0ge31cblxuZnMuV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbTtcbi8qKlxuICogQGNhbGxiYWNrIHN0YXRzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtmcy5TdGF0c30gc3RhdHMgLSBmaWxlIHN0YXRzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx8QnVmZmVyfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbW9kZT1mcy5jb25zdGFudHMuRl9PS10gYWNjZXNzaWJpbGl0eSBtb2RlL2NoZWNrXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cbmZzLmFjY2VzcyA9IGZ1bmN0aW9uIChwYXRoLCBtb2RlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG1vZGU7XG4gICAgbW9kZSA9IGZzLmNvbnN0YW50cy5GX09LO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLmFjY2Vzc1N5bmMocGF0aCwgbW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx8QnVmZmVyfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbW9kZT1mcy5jb25zdGFudHMuRl9PS10gYWNjZXNzaWJpbGl0eSBtb2RlL2NoZWNrXG4gKi9cblxuXG5mcy5hY2Nlc3NTeW5jID0gZnVuY3Rpb24gKHBhdGgsIG1vZGUgPSBmcy5jb25zdGFudHMuRl9PSykge1xuICAvLyBGX09LIGlzIGp1c3Qgd2hldGhlciBmaWxlIGV4aXN0cyBvciBub3QsIG5vIHBlcm1pc3Npb25zIGNoZWNrXG4gIC8vIFJfT0sgaXMgcmVhZCBjaGVja1xuICAvLyBXX09LIGlzIHdyaXRlIGNoZWNrXG4gIC8vIFhfT0sgaXMgZXhlY3V0ZSBjaGVjayAoYWN0cyBsaWtlIEZfT0sgb24gV2luZG93cylcbiAgY29uc3QgZmlsZUhhbmRsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICghZmlsZUhhbmRsZS5leGlzdHMoKSkge1xuICAgIHRocm93IG5vU3VjaEZpbGUoJ2FjY2VzcycsIHBhdGgpO1xuICB9IC8vIFRPRE86IFdlIGhhdmUgbm8gbWVhbnMgb2YgdGVzdGluZyBpZiBhIGZpbGUgaXMgcmVhZGFibGUuIEl0J3MgYXNzdW1lZCBhbGwgZmlsZXMgdGhhdCBleGlzdCB1bmRlciB0aGUgYXBwIGFyZT9cblxuXG4gIGlmIChtb2RlICYgZnMuY29uc3RhbnRzLldfT0sgJiYgIWZpbGVIYW5kbGUud3JpdGFibGUpIHtcbiAgICB0aHJvdyBwZXJtaXNzaW9uRGVuaWVkKCdhY2Nlc3MnLCBwYXRoKTtcbiAgfVxuXG4gIGlmIChtb2RlICYgZnMuY29uc3RhbnRzLlhfT0sgJiYgIWZpbGVIYW5kbGUuZXhlY3V0YWJsZSAmJiBmaWxlSGFuZGxlLmlzRmlsZSgpKSB7XG4gICAgdGhyb3cgcGVybWlzc2lvbkRlbmllZCgnYWNjZXNzJywgcGF0aCk7XG4gIH1cbn07XG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGFwcGVuZCBkYXRhIHRvIGEgZmlsZSwgY3JlYXRpbmcgdGhlIGZpbGUgaWYgaXQgZG9lcyBub3QgeWV0IGV4aXN0LiBkYXRhIGNhbiBiZSBhIHN0cmluZyBvciBhIEJ1ZmZlci5cbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8RmlsZVN0cmVhbX0gZmlsZSBmaWxlcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGEgZGF0YSB0byBhcHBlbmQgdG8gZmlsZVxuICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdG8gdXNlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG82NjZdIG1vZGUgdG8gY3JlYXRlIGZpbGUsIGlmIG5vdCBjcmVhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZz0nYSddIGZpbGUgc3lzdGVtIGZsYWdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgYmFjayB3aXRoIGVycm9yIGlmIGZhaWxlZFxuICovXG5cblxuZnMuYXBwZW5kRmlsZSA9IChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICdhJ1xuICB9KTtcbiAgZnMud3JpdGVGaWxlKGZpbGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgYXBwZW5kIGRhdGEgdG8gYSBmaWxlLCBjcmVhdGluZyB0aGUgZmlsZSBpZiBpdCBkb2VzIG5vdCB5ZXQgZXhpc3QuIGRhdGEgY2FuIGJlIGEgc3RyaW5nIG9yIGEgQnVmZmVyLlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxGaWxlU3RyZWFtfSBmaWxlIGZpbGVwYXRoIHRvIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YSBkYXRhIHRvIGFwcGVuZCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubW9kZT0wbzY2Nl0gbW9kZSB0byBjcmVhdGUgZmlsZSwgaWYgbm90IGNyZWF0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdhJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICovXG5cblxuZnMuYXBwZW5kRmlsZVN5bmMgPSAoZmlsZSwgZGF0YSwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4JyxcbiAgICBtb2RlOiAwbzY2NixcbiAgICBmbGFnOiAnYSdcbiAgfSk7XG4gIGZzLndyaXRlRmlsZVN5bmMoZmlsZSwgZGF0YSwgb3B0aW9ucyk7IC8vIFRPRE86IFVzZSBUaS5GaWxlc3lzdGVtLkZpbGUuYXBwZW5kKCkgaW5zdGVhZD9cbn07XG5cbmZzLmNobW9kID0gKHBhdGgsIG1vZGUsIGNhbGxiYWNrKSA9PiBhc3luY1Vuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2htb2QnLCBjYWxsYmFjayk7XG5cbmZzLmNobW9kU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnY2htb2RTeW5jJyk7XG5cbmZzLmNob3duID0gKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2Nob3duJywgY2FsbGJhY2spO1xuXG5mcy5jaG93blN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2Nob3duU3luYycpO1xuLyoqXG4gKiBDYWxsYmFjayBmb3IgZnVuY3Rpb25zIHRoYXQgY2FuIG9ubHkgdGhyb3cgZXJyb3JzXG4gKlxuICogQGNhbGxiYWNrIGVycm9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IFtlcnJdIC0gRXJyb3IgdGhyb3duXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbmZzLmNsb3NlID0gKGZkLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjaygpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKi9cblxuXG5mcy5jbG9zZVN5bmMgPSBmZCA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJlYW0uY2xvc2UoKTtcbn07IC8vIFJhdGhlciB0aGFuIHVzZSBhIGhhY2sgdG8gd3JhcCBzeW5jIHZlcnNpb24gaW4gc2V0VGltZW91dCwgdXNlIGFjdHVhbCBhc3luYyBBUElzIVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHNyYyBzb3VyY2UgZmlsZW5hbWUgdG8gY29weVxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gZGVzdCBkZXN0aW5hdGlvbiBmaWxlbmFtZSBvZiB0aGUgY29weSBvcGVyYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZmxhZ3M9MF0gbW9kaWZpZXJzIGZvciBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBjYWxsZWQgYXQgZW5kIG9mIG9wZXJhdGlvblxuICovXG5cblxuZnMuY29weUZpbGUgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgZmxhZ3MgPSAwO1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTsgLy8gRklYTUU6IEkgZG9uJ3Qga25vdyB3aHksIGJ1dCBjaGFuZ2luZyB0aGlzIHRvIHVzZSBUaS5GaWxlc3lzdGVtLm9wZW5TdHJlYW0obW9kZSwgcGF0aCkgZmFpbHMgKGF0IGxlYXN0IG9uIGlPUylcblxuICBjb25zdCBzcmNGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKHNyYyk7XG4gIGNvbnN0IHNyY1N0cmVhbSA9IHNyY0ZpbGUub3BlbihUaS5GaWxlc3lzdGVtLk1PREVfUkVBRCk7XG4gIGNvbnN0IGRlc3RGaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKGRlc3QpO1xuICBjb25zdCBkZXN0U3RyZWFtID0gZGVzdEZpbGUub3BlbihUaS5GaWxlc3lzdGVtLk1PREVfV1JJVEUpO1xuICBwaXBlKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gc3JjIHNvdXJjZSBmaWxlbmFtZSB0byBjb3B5XG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBkZXN0IGRlc3RpbmF0aW9uIGZpbGVuYW1lIG9mIHRoZSBjb3B5IG9wZXJhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IFtmbGFncz0wXSBtb2RpZmllcnMgZm9yIGNvcHkgb3BlcmF0aW9uXG4gKi9cblxuXG5mcy5jb3B5RmlsZVN5bmMgPSBmdW5jdGlvbiAoc3JjLCBkZXN0LCBmbGFncyA9IDApIHtcbiAgY29uc3Qgc3JjRmlsZSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShzcmMpO1xuXG4gIGlmIChmbGFncyA9PT0gZnMuY29uc3RhbnRzLkNPUFlGSUxFX0VYQ0wgJiYgZnMuZXhpc3RzU3luYyhkZXN0KSkge1xuICAgIHRocm93IGZpbGVBbHJlYWR5RXhpc3RzKCdjb3B5RmlsZScsIGRlc3QpO1xuICB9XG5cbiAgaWYgKCFzcmNGaWxlLmNvcHkoZGVzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBjb3B5ICR7c3JjfSB0byAke2Rlc3R9YCk7IC8vIEZJWE1FOiBXaGF0IGVycm9yIHNob3VsZCB3ZSBnaXZlP1xuICB9XG59OyAvLyBUT0RPOiBmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG4vLyAvKipcbi8vICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCBsaWtlXG4vLyAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zLCBpZiBhIHN0cmluZywgaXQncyB0aGUgZW5jb2Rpbmdcbi8vICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFncz0nciddIFNlZSBzdXBwb3J0IG9mIGZpbGUgc3lzdGVtIGZsYWdzLlxuLy8gICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPW51bGxdIGVuY29kaW5nXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmZkPW51bGxdIGZpbGUgZGVzY3JpcHRvciwgaWYgc3BlY2lmaWVkLCBgcGF0aGAgaXMgaWdub3JlZFxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tb2RlPTBvNjY2XSBwZXJtaXNzaW9ucyB0byBzZXQgaWYgZmlsZSBpcyBjcmVhdGVkXG4vLyAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmF1dG9DbG9zZT10cnVlXSBpZiBmYWxzZSwgZmlsZSBkZXNjcmlwdG9yIHdpbGwgbm90IGJlIGNsb3NlZDsgaWYgdHJ1ZSBldmVuIG9uIGVycm9yIGl0IHdpbGwgYmUgY2xvc2VkXG4vLyAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLnN0YXJ0XSBzdGFydCBpbmRleCBvZiByYW5nZSBvZiBieXRlcyB0byByZWFkIGZyb20gZmlsZVxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5lbmQ9SW5maW5pdHldIGVuZCBpbmRleCBvZiByYW5nZSBvZiBieXRlcyB0byByZWFkIGZyb20gZmlsZVxuLy8gICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5oaWdoV2F0ZXJNYXJrPTY0ICogMTAyNF1cbi8vICAqIEByZXR1cm5zIHtmcy5SZWFkU3RyZWFtfVxuLy8gICovXG4vLyBmcy5jcmVhdGVSZWFkU3RyZWFtID0gKHBhdGgsIG9wdGlvbnMpID0+IHtcbi8vIFx0b3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgeyBmbGFnczogJ3InLCBlbmNvZGluZzogbnVsbCwgZmQ6IG51bGwsIG1vZGU6IDBvNjY2LCBhdXRvQ2xvc2U6IHRydWUsIGVuZDogSW5maW5pdHksIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNCB9KTtcbi8vIFx0Ly8gRklYTUU6IElmIG9wdGlvbnMuZmQsIHVzZSB0aGF0IGluIHBsYWNlIG9mIHBhdGghXG4vLyBcdGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuLy8gfTtcbi8vIFRPRE86IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgsIG9wdGlvbnMpXG5cbi8qKlxuICogQGNhbGxiYWNrIGV4aXN0c0NhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4aXN0cyAtIHdoZXRoZXIgcGF0aCBleGlzdHNcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHBhdGggdG8gY2hlY2tcbiAqIEBwYXJhbSB7ZXhpc3RzQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5cbmZzLmV4aXN0cyA9IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYWxsYmFjayhmcy5leGlzdHNTeW5jKHBhdGgpKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBwYXRoIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBhIGZpbGUgb3IgZGlyZWN0b3J5IGV4aXN0cyBhdCB0aGF0IHBhdGhcbiAqL1xuXG5cbmZzLmV4aXN0c1N5bmMgPSBmdW5jdGlvbiAocGF0aCkge1xuICB0cnkge1xuICAgIGZzLmFjY2Vzc1N5bmMocGF0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZzLmZjaG1vZCA9IChmZCwgbW9kZSwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2htb2QnLCBjYWxsYmFjayk7XG5cbmZzLmZjaG1vZFN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG1vZFN5bmMnKTtcblxuZnMuZmNob3duID0gKGZkLCB1aWQsIGdpZCwgY2FsbGJhY2spID0+IGFzeW5jVW5zdXBwb3J0ZWROb29wKCdmcycsICdmY2hvd24nLCBjYWxsYmFjayk7XG5cbmZzLmZjaG93blN5bmMgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZjaG93blN5bmMnKTtcblxuZnMuZmRhdGFzeW5jID0gKGZkLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ2ZkYXRhc3luYycsIGNhbGxiYWNrKTtcblxuZnMuZmRhdGFzeW5jU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAnZmRhdGFzeW5jU3luYycpO1xuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBhc3luYyBjYWxsYmFjayBmdW5jdGlvblxuICovXG5cbmZzLmZzdGF0ID0gKGZkLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgbGV0IHN0YXRzO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXRzID0gZnMuZnN0YXRTeW5jKGZkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjYWxsYmFjayhlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBzdGF0cyk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbX29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW19vcHRpb25zLmJpZ2ludF0gd2hldGhlciBzdGF0IHZhbHVlcyBzaG91bGQgYmUgYmlnaW50XG4gKiBAcmV0dXJucyB7ZnMuU3RhdHN9IHN0YXRzIGZvciBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG5cbmZzLmZzdGF0U3luYyA9IChmZCwgX29wdGlvbnMpID0+IHtcbiAgY29uc3QgcGF0aCA9IHBhdGhGb3JGaWxlRGVzY3JpcHRvcihmZCk7XG4gIHJldHVybiBmcy5zdGF0U3luYyhwYXRoKTtcbn07IC8vIFRPRE86IEFkZCB2ZXJzaW9ucyBvZiB0aGVzZSBBUElzOlxuLy8gZnMuZnN5bmMoZmQsIGNhbGxiYWNrKVxuLy8gZnMuZnN5bmNTeW5jKGZkKVxuLy8gZnMuZnRydW5jYXRlKGZkWywgbGVuXSwgY2FsbGJhY2spXG4vLyBmcy5mdHJ1bmNhdGVTeW5jKGZkWywgbGVuXSlcbi8vIGZzLmZ1dGltZXMoZmQsIGF0aW1lLCBtdGltZSwgY2FsbGJhY2spXG4vLyBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuLy8gZnMubGNobW9kKHBhdGgsIG1vZGUsIGNhbGxiYWNrKVxuLy8gZnMubGNobW9kU3luYyhwYXRoLCBtb2RlKVxuLy8gZnMubGNob3duKHBhdGgsIHVpZCwgZ2lkLCBjYWxsYmFjaylcbi8vIGZzLmxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4vLyBmcy5saW5rKGV4aXN0aW5nUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spXG4vLyBmcy5saW5rU3luYyhleGlzdGluZ1BhdGgsIG5ld1BhdGgpXG4vLyBGSVhNRTogSWYgc3ltYm9saWMgbGluayB3ZSBuZWVkIHRvIGZvbGxvdyBsaW5rIHRvIHRhcmdldCB0byBnZXQgc3RhdHMhIE91ciBBUEkgZG9lc24ndCBzdXBwb3J0IHRoYXQhXG5cblxuZnMubHN0YXQgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IGZzLnN0YXQocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spO1xuXG5mcy5sc3RhdFN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4gZnMuc3RhdFN5bmMocGF0aCwgb3B0aW9ucyk7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZT1mYWxzZV0gcmVjdXJzaXZsZXkgY3JlYXRlIGRpcnM/XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG83NzddIHBlcm1pc3Npb25zXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5ta2RpciA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiAwbzc3N1xuICAgIH07XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMubWtkaXJTeW5jKHBhdGgsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlY3Vyc2l2ZT1mYWxzZV0gcmVjdXJzaXZsZXkgY3JlYXRlIGRpcnM/XG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLm1vZGU9MG83NzddIHBlcm1pc3Npb25zXG4gKi9cblxuXG5mcy5ta2RpclN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgIHJlY3Vyc2l2ZTogZmFsc2UsXG4gICAgICBtb2RlOiBvcHRpb25zXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICByZWN1cnNpdmU6IGZhbHNlLFxuICAgICAgbW9kZTogMG83NzdcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghdGlGaWxlLmNyZWF0ZURpcmVjdG9yeShvcHRpb25zLnJlY3Vyc2l2ZSkgJiYgIW9wdGlvbnMucmVjdXJzaXZlKSB7XG4gICAgaWYgKHRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgLy8gYWxyZWFkeSBleGlzdGVkIVxuICAgICAgdGhyb3cgZmlsZUFscmVhZHlFeGlzdHMoJ21rZGlyJywgcGF0aCk7XG4gICAgfSAvLyBXZSBmYWlsZWQsIHByb2JhYmx5IGJlY2F1c2Ugd2UgZGlkbid0IGFzayBmb3IgcmVjdXJzaXZlIGFuZCBwYXJlbnQgZG9lc24ndCBleGlzdCwgc28gcmVwcm9kdWNlIG5vZGUncyBlcnJvclxuXG5cbiAgICB0aHJvdyBub1N1Y2hGaWxlKCdta2RpcicsIHBhdGgpO1xuICB9XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgdGVtcERpckNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXIgLSBnZW5lcmF0ZWQgZm9sZGVyIG5hbWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggZGlyZWN0b3J5IG5hbWUgcHJlZml4XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gcHJlZml4IGVuY29kaW5nXG4gKiBAcGFyYW0ge3RlbXBEaXJDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLm1rZHRlbXAgPSAocHJlZml4LCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBhc3NlcnRBcmd1bWVudFR5cGUocHJlZml4LCAncHJlZml4JywgJ3N0cmluZycpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGYtOCdcbiAgfSk7IC8vIHRyeSB0byBiZSBhbGwgYXN5bmNcblxuICBjb25zdCB0cnlNa2R0ZW1wID0gKCkgPT4ge1xuICAgIGNvbnN0IGdlbmVyYXRlZCA9IHJhbmRvbUNoYXJhY3RlcnMoNiwgb3B0aW9ucy5lbmNvZGluZyk7IC8vIGdlbmVyYXRlIHNpeCByYW5kb20gY2hhcmFjdGVyc1xuXG4gICAgY29uc3QgcGF0aCA9IGAke3ByZWZpeH0ke2dlbmVyYXRlZH1gO1xuICAgIGZzLm1rZGlyKHBhdGgsIDBvNzAwLCBlcnIgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdFRVhJU1QnKSB7XG4gICAgICAgICAgLy8gcmV0cnkhXG4gICAgICAgICAgc2V0VGltZW91dCh0cnlNa2R0ZW1wLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gYnViYmxlIHVwIGVycm9yXG5cblxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHN1Y2NlZWRlZCEgSHVycmF5IVxuXG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIHBhdGgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHNldFRpbWVvdXQodHJ5TWtkdGVtcCwgMSk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgdW5pcXVlIHRlbXBvcmFyeSBkaXJlY3RvcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IGRpcmVjdG9yeSBuYW1lIHByZWZpeFxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGYtOCddIHByZWZpeCBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ30gcGF0aCB0byBjcmVhdGVkIGRpcmVjdG9yeVxuICovXG5cblxuZnMubWtkdGVtcFN5bmMgPSAocHJlZml4LCBvcHRpb25zKSA9PiB7XG4gIGFzc2VydEFyZ3VtZW50VHlwZShwcmVmaXgsICdwcmVmaXgnLCAnc3RyaW5nJyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0Zi04J1xuICB9KTtcbiAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICBjb25zdCBNQVhfUkVUUklFUyA9IDEwMDtcblxuICB3aGlsZSAocmV0cnlDb3VudCA8IE1BWF9SRVRSSUVTKSB7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gcmFuZG9tQ2hhcmFjdGVycyg2LCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZ2VuZXJhdGUgc2l4IHJhbmRvbSBjaGFyYWN0ZXJzXG5cbiAgICBjb25zdCBwYXRoID0gYCR7cHJlZml4fSR7Z2VuZXJhdGVkfWA7XG5cbiAgICB0cnkge1xuICAgICAgZnMubWtkaXJTeW5jKHBhdGgsIDBvNzAwKTsgLy8gZG9uJ3QgdHJ5IHJlY3Vyc2l2ZVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlICE9PSAnRUVYSVNUJykge1xuICAgICAgICB0aHJvdyBlOyAvLyBidWJibGUgdXAgZXJyb3JcbiAgICAgIH0gLy8gbmFtZSB3YXMgbm90IHVuaXF1ZSwgc28gcmV0cnlcblxuXG4gICAgICByZXRyeUNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGEgdW5pcXVlIGRpcmVjdG9yeSBuYW1lIHdpdGggcHJlZml4ICR7cHJlZml4fWApO1xufTtcbi8qKlxuICogQGNhbGxiYWNrIGZpbGVEZXNjcmlwdG9yQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaWxlRGVzY3JpcHRvciAtIGdlbmVyYXRlZCBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzPSdyJ10gZmlsZSBzeXN0ZW0gYWNjZXNzIGZsYWdzXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFttb2RlPTBvNjY2XSBmaWxlIG1vZGUgdG8gdXNlIHdoZW4gY3JlYXRpbmcgZmlsZVxuICogQHBhcmFtIHtmaWxlRGVzY3JpcHRvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMub3BlbiA9IChwYXRoLCBmbGFncywgbW9kZSwgY2FsbGJhY2spID0+IHtcbiAgLy8gZmxhZ3MgYW5kIG1vZGUgYXJlIG9wdGlvbmFsLCB3ZSBuZWVkIHRvIGhhbmRsZSBpZiBub3Qgc3VwcGxpZWQhXG4gIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGZsYWdzO1xuICAgIGZsYWdzID0gJ3InO1xuICAgIG1vZGUgPSAwbzY2NjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gbW9kZTtcbiAgICBtb2RlID0gMG82NjY7XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgZmlsZURlc2NyaXB0b3I7XG5cbiAgICB0cnkge1xuICAgICAgZmlsZURlc2NyaXB0b3IgPSBmcy5vcGVuU3luYyhwYXRoLCBmbGFncywgbW9kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgZmlsZURlc2NyaXB0b3IpO1xuICB9LCAxKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzPSdyJ10gZmlsZSBzeXN0ZW0gYWNjZXNzIGZsYWdzXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtfbW9kZT0wbzY2Nl0gZmlsZSBtb2RlIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGZpbGVcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5cblxuZnMub3BlblN5bmMgPSAocGF0aCwgZmxhZ3MgPSAncicsIF9tb2RlID0gMG82NjYpID0+IHtcbiAgY29uc3QgdGlGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUocGF0aCk7XG5cbiAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAvLyBUT0RPOiBTdXBwb3J0IGNyZWF0aW5nIGZpbGUgd2l0aCBzcGVjaWZpYyBtb2RlXG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLm9wZW5TeW5jLm1vZGUnLCAnZnMub3BlblN5bmNcXCdzIG1vZGUgcGFyYW1ldGVyIGlzIHVuc3VwcG9ydGVkIGluIFRpdGFuaXVtIGFuZCB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIGlmICghdGlGaWxlLmNyZWF0ZUZpbGUoKSkge1xuICAgICAgLy8gT2ggY3JhcCwgd2UgZmFpbGVkIHRvIGNyZWF0ZSB0aGUgZmlsZS4gd2h5P1xuICAgICAgaWYgKCF0aUZpbGUucGFyZW50LmV4aXN0cygpKSB7XG4gICAgICAgIC8vIHBhcmVudCBkb2VzIG5vdCBleGlzdCFcbiAgICAgICAgdGhyb3cgbm9TdWNoRmlsZSgnb3BlbicsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBjcmVhdGUgZmlsZSBhdCBwYXRoICR7cGF0aH1gKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmxhZ3MpIHtcbiAgICAvLyBmaWxlL2RpciBleGlzdHMuLi5cbiAgICBpZiAoKGZsYWdzLmNoYXJBdCgwKSA9PT0gJ3cnIHx8IGZsYWdzLmNoYXJBdCgwKSA9PT0gJ2EnKSAmJiB0aUZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgLy8gSWYgdXNlciBpcyB0cnlpbmcgdG8gd3JpdGUgb3IgYXBwZW5kIGFuZCBpdCdzIGEgZGlyZWN0b3J5LCBmYWlsXG4gICAgICB0aHJvdyBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCdvcGVuJywgcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzLmxlbmd0aCA+IDEgJiYgZmxhZ3MuY2hhckF0KDEpID09PSAneCcpIHtcbiAgICAgIC8vIElmIHVzZXIgaGFzIFwiZXhjbHVzaXZlXCIgZmxhZyBvbiwgZmFpbCBpZiBmaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICB0aHJvdyBmaWxlQWxyZWFkeUV4aXN0cygnb3BlbicsIHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRpTW9kZSA9IEZMQUdTX1RPX1RJX01PREUuZ2V0KGZsYWdzKTtcblxuICBpZiAodGlNb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUT0RPOiBNYWtlIHVzZSBvZiBjb21tb24gZXJyb3IgdHlwZS9jb2RlIGZvciB0aGlzIG9uY2Ugd2UgaGF2ZSBpbnRlcm5hbC9lcnJvcnMuanNcbiAgICBjb25zdCBlcnIgPSBuZXcgVHlwZUVycm9yKGBUaGUgdmFsdWUgXCIke1N0cmluZyhmbGFncyl9XCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwiZmxhZ3NcImApO1xuICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX09QVF9WQUxVRSc7XG4gICAgdGhyb3cgZXJyO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpbGVEZXNjcmlwdG9yKHBhdGgsIHRpRmlsZS5vcGVuKHRpTW9kZSkpO1xufTtcbi8qKlxuICogQGNhbGxiYWNrIHJlYWRDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGJ5dGVzUmVhZCAtIG51bWJlciBvZiBieXRlcyByZWFkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGJ1ZmZlclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfFRpLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGF0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gcG9zaXRpb24gd2hlcmUgdG8gYmVnaW4gcmVhZGluZyBmcm9tIGluIHRoZSBmaWxlXG4gKiBAcGFyYW0ge3JlYWRDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnJlYWQgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgfSAvLyBGSVhNRTogQWxsb3cgdXNpbmcgcG9zaXRpb24gYXJndW1lbnQhXG5cblxuICBpZiAocG9zaXRpb24gIT09IG51bGwpIHtcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZFN5bmMucG9zaXRpb24nLCAnZnMucmVhZFN5bmNcXCdzIHBvc2l0aW9uIGFyZ3VtZW50IGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXMgbnVsbCcpO1xuICB9XG5cbiAgdGlGaWxlU3RyZWFtLnJlYWQoYnVmZmVyLnRvVGlCdWZmZXIoKSwgb2Zmc2V0LCBsZW5ndGgsIHJlYWRPYmogPT4ge1xuICAgIGlmICghcmVhZE9iai5zdWNjZXNzKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZE9iai5lcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlYWRPYmouYnl0ZXNQcm9jZXNzZWQsIGJ1ZmZlcik7XG4gIH0pO1xufTtcbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfFRpLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB0byByZWFkIGludG9cbiAqIEBwYXJhbSB7aW50ZWdlcn0gb2Zmc2V0IHRoZSBvZmZzZXQgaW4gdGhlIGJ1ZmZlciB0byBzdGFydCB3cml0aW5nIGF0LlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggaW50ZWdlciBzcGVjaWZ5aW5nIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gX3Bvc2l0aW9uIHdoZXJlIHRvIGJlZ2luIHJlYWRpbmcgZnJvbSBpbiB0aGUgZmlsZVxuICogQHJldHVybnMge2ludGVnZXJ9IGJ5dGVzIHJlYWRcbiAqL1xuXG5cbmZzLnJlYWRTeW5jID0gKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBfcG9zaXRpb24pID0+IHtcbiAgY29uc3QgZmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIpO1xuICB9IC8vIEZJWE1FOiBBbGxvdyB1c2luZyBwb3NpdGlvbiBhcmd1bWVudCFcblxuXG4gIGlmIChfcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICBvbmVUaW1lV2FybmluZygnZnMucmVhZFN5bmMucG9zaXRpb24nLCAnZnMucmVhZFN5bmNcXCdzIHBvc2l0aW9uIGFyZ3VtZW50IGlzIHVuc3VwcG9ydGVkIGJ5IFRpdGFuaXVtIGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXMgbnVsbCcpO1xuICB9XG5cbiAgcmV0dXJuIGZpbGVTdHJlYW0ucmVhZChidWZmZXIudG9UaUJ1ZmZlcigpLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuLyoqXG4gKiBAY2FsbGJhY2sgZmlsZXNDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ1tdfEJ1ZmZlcltdfGZzLkRpcmVudFtdfSBmaWxlcyAtIGZpbGUgbGlzdGluZ1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZGlyZWN0b3J5IHRvIGxpc3RcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gW29wdGlvbnNdIG9wdGlvbmFsIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIHRvIHVzZSBmb3IgZmlsZW5hbWVzLCBpZiBgJ2J1ZmZlcidgLCByZXR1cm5zIGBCdWZmZXJgIG9iamVjdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMud2l0aEZpbGVUeXBlcz1mYWxzZV0gaWYgdHJ1ZSwgcmV0dXJucyBgZnMuRGlyZW50YCBvYmplY3RzXG4gKiBAcGFyYW0ge2ZpbGVzQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBsZXQgcmVzdWx0O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZzLnJlYWRkaXJTeW5jKHBhdGgsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoIGRpcmVjdG9yeSB0byBsaXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IFtvcHRpb25zXSBvcHRpb25hbCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB0byB1c2UgZm9yIGZpbGVuYW1lcywgaWYgYCdidWZmZXInYCwgcmV0dXJucyBgQnVmZmVyYCBvYmplY3RzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndpdGhGaWxlVHlwZXM9ZmFsc2VdIGlmIHRydWUsIHJldHVybnMgYGZzLkRpcmVudGAgb2JqZWN0c1xuICogQHJldHVybnMge3N0cmluZ1tdfEJ1ZmZlcltdfGZzLkRpcmVudFtdfVxuICovXG5cblxuZnMucmVhZGRpclN5bmMgPSAoZmlsZXBhdGgsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgZmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKGZpbGVwYXRoKTtcblxuICBpZiAoIWZpbGUuZXhpc3RzKCkpIHtcbiAgICB0aHJvdyBub1N1Y2hGaWxlKCdzY2FuZGlyJywgZmlsZXBhdGgpO1xuICB9XG5cbiAgaWYgKCFmaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICB0aHJvdyBub3RBRGlyZWN0b3J5KCdzY2FuZGlyJywgZmlsZXBhdGgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBsaXN0aW5nID0gZmlsZS5nZXREaXJlY3RvcnlMaXN0aW5nKCk7XG5cbiAgaWYgKG9wdGlvbnMud2l0aEZpbGVUeXBlcyA9PT0gdHJ1ZSkge1xuICAgIC8vIFRPRE86IGlmIG9wdGlvbnMud2l0aEZpbGVUeXBlcyA9PT0gdHJ1ZSwgcmV0dXJuIGZzLkRpcmVudCBvYmplY3RzXG4gICAgb25lVGltZVdhcm5pbmcoJ2ZzLnJlYWRkaXJcXCdzIG9wdGlvbnMud2l0aEZpbGVUeXBlcyBpcyB1bnN1cHBvcnRlZCBieSBUaXRhbml1bSBhbmQgc3RyaW5ncyB3aWxsIGJlIHJldHVybmVkJyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5lbmNvZGluZyA9PT0gJ2J1ZmZlcicpIHtcbiAgICByZXR1cm4gbGlzdGluZy5tYXAobmFtZSA9PiBCdWZmZXIuZnJvbShuYW1lKSk7XG4gIH1cblxuICByZXR1cm4gbGlzdGluZztcbn07XG4vKipcbiAqIEBjYWxsYmFjayByZWFkRmlsZVBvc3RPcGVuQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtUaS5CdWZmZXJ9IGJ1ZmZlclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmaWxlRGVzY3JpcHRvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7cmVhZEZpbGVQb3N0T3BlbkNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnVuY3Rpb24gcmVhZEZpbGVQb3N0T3BlbihmaWxlRGVzY3JpcHRvciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgZnMuZnN0YXQoZmlsZURlc2NyaXB0b3IsIChlcnIsIHN0YXRzKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlU2l6ZSA9IHN0YXRzLnNpemU7IC8vIENyZWF0ZSBhIFRpLkJ1ZmZlciB0byByZWFkIGludG9cblxuICAgIGNvbnN0IGJ1ZmZlciA9IFRpLmNyZWF0ZUJ1ZmZlcih7XG4gICAgICBsZW5ndGg6IGZpbGVTaXplXG4gICAgfSk7IC8vIFVzZSBUaS5TdHJlYW0ucmVhZEFsbChzb3VyY2VTdHJlYW0sIGJ1ZmZlciwgY2FsbGJhY2spIHdoaWNoIHNwaW5zIG9mZiBhIHNlcGFyYXRlIHRocmVhZCB0byByZWFkIGluIHdoaWxlIGxvb3AhXG5cbiAgICBjb25zdCBzb3VyY2VTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTtcbiAgICBUaS5TdHJlYW0ucmVhZEFsbChzb3VyY2VTdHJlYW0sIGJ1ZmZlciwgcmVhZEFsbE9iaiA9PiB7XG4gICAgICBpZiAoIXJlYWRBbGxPYmouc3VjY2Vzcykge1xuICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IocmVhZEFsbE9iai5lcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGJ1ZmZlcik7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXG4gKiBAY2FsbGJhY2sgcmVhZEZpbGVDYWxsYmFja1xuICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgaWYgb25lIG9jY3VycmVkXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlYWQgZW50aXJlIGNvbnRlbnRzIG9mIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx8aW50ZWdlcn0gcGF0aCBmaWxlbmFtZSBvciBmaWxlIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz1udWxsXSBlbmNvZGluZyB0byB1c2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mbGFnPSdyJ10gZmlsZSBzeXN0ZW0gZmxhZ1xuICogQHBhcmFtIHtyZWFkRmlsZUNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cblxuZnMucmVhZEZpbGUgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBlbmNvZGluZzogbnVsbCxcbiAgICAgIGZsYWc6ICdyJ1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBmbGFnOiAncidcbiAgICB9KTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIHBhdGggPT09ICdudW1iZXInO1xuICBsZXQgZmlsZURlc2NyaXB0b3IgPSBwYXRoOyAvLyBtYXkgYmUgb3ZlcnJpZGVuIGxhdGVyXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyciBwb3NzaWJsZSBFcnJvclxuICAgKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gYnVmZmVyIFRpLkJ1ZmZlciBpbnN0YW5jZVxuICAgKi9cblxuICBjb25zdCBoYW5kbGVCdWZmZXIgPSAoZXJyLCBidWZmZXIpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZnMuY2xvc2VTeW5jIGlmIGl0IHdhcyBub3Qgb3JpZ2luYWxseSBhIGZpbGUgZGVzY3JpcHRvclxuXG5cbiAgICBpZiAoIXdhc0ZpbGVEZXNjcmlwdG9yKSB7XG4gICAgICBmcy5jbG9zZVN5bmMoZmlsZURlc2NyaXB0b3IpO1xuICAgIH0gLy8gVE9ETzogdHJpbSBidWZmZXIgaWYgd2UgZGlkbid0IHJlYWQgZnVsbCBzaXplP1xuXG5cbiAgICBjYWxsYmFjayhudWxsLCBlbmNvZGVCdWZmZXIob3B0aW9ucy5lbmNvZGluZywgYnVmZmVyKSk7XG4gIH07XG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLm9wZW4ocGF0aCwgb3B0aW9ucy5mbGFnLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZpbGVEZXNjcmlwdG9yID0gZmQ7XG4gICAgICByZWFkRmlsZVBvc3RPcGVuKGZkLCBoYW5kbGVCdWZmZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJlYWRGaWxlUG9zdE9wZW4ocGF0aCwgaGFuZGxlQnVmZmVyKTtcbiAgfVxufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY29udGVudHMgb2YgdGhlIHBhdGguXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IHBhdGggcGF0aCB0byBmaWxlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gZW5jb2RpbmcgdG8gdXNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZmxhZz0nciddIGZpbGUgc3lzdGVtIGZsYWdcbiAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfSBzdHJpbmcgaWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkLCBvdGhlcndpc2UgQnVmZmVyXG4gKi9cblxuXG5mcy5yZWFkRmlsZVN5bmMgPSAocGF0aCwgb3B0aW9ucykgPT4ge1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgZmxhZzogJ3InXG4gIH0pO1xuICBjb25zdCB3YXNGaWxlRGVzY3JpcHRvciA9IHR5cGVvZiBwYXRoID09PSAnbnVtYmVyJztcbiAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSB3YXNGaWxlRGVzY3JpcHRvciA/IHBhdGggOiBmcy5vcGVuU3luYyhwYXRoLCBvcHRpb25zLmZsYWcpOyAvLyB1c2UgZGVmYXVsdCBtb2RlXG5cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvcik7IC8vIEp1c3QgdXNlIG91ciBvd24gQVBJIHRoYXQgcmVhZHMgZnVsbCBzdHJlYW0gaW5cblxuICBjb25zdCBidWZmZXIgPSBUaS5TdHJlYW0ucmVhZEFsbCh0aUZpbGVTdHJlYW0pOyAvLyBmcy5jbG9zZVN5bmMgaWYgaXQgd2FzIG5vdCBvcmlnaW5hbGx5IGEgZmlsZSBkZXNjcmlwdG9yXG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gIH0gLy8gVE9ETzogdHJpbSBidWZmZXIgaWYgd2UgZGlkbid0IHJlYWQgZnVsbCBzaXplP1xuXG5cbiAgcmV0dXJuIGVuY29kZUJ1ZmZlcihvcHRpb25zLmVuY29kaW5nLCBidWZmZXIpO1xufTsgLy8gVE9ETzogZnMucmVhZGxpbmsocGF0aFssIG9wdGlvbnNdLCBjYWxsYmFjaylcbi8vIFRPRE86IGZzLnJlYWRsaW5rU3luYyhwYXRoWywgb3B0aW9uc10pXG5cbi8qKlxuICogQGNhbGxiYWNrIHJlYWxwYXRoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSByZXNvbHZlZFBhdGggdGhlIHJlc29sdmVkIHBhdGhcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IGZpbGVwYXRoIG9yaWdpbmFsIGZpbGVwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvc24gb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9J3V0ZjgnXSBlbmNvZGluZyB1c2VkIGZvciByZXR1cm5lZCBvYmplY3QuIElmICdidWZmZXJcIiwgd2UnbGwgcmV0dXJuIGEgQnVmZmVyIGluIHBhbGNlIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge3JlYWxwYXRoQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZWFscGF0aCA9IChmaWxlcGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IG9wdGlvbnMpO1xuICBvcHRpb25zID0gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCB7XG4gICAgZW5jb2Rpbmc6ICd1dGY4J1xuICB9KTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gRklYTUU6IFRoaXMgYXNzdW1lcyBubyBzeW1saW5rcywgd2hpY2ggd2UgcmVhbGx5IGRvbid0IGhhdmUgZnVsbCBzdXBwb3J0IGZvciBpbiBvdXIgU0RLIGFueXdheXMuXG4gICAgY29uc3QgcmVzdWx0ID0gcGF0aC5ub3JtYWxpemUoZmlsZXBhdGgpO1xuICAgIGZzLmV4aXN0cyhyZXN1bHQsIHJlc3VsdEV4aXN0cyA9PiB7XG4gICAgICBpZiAocmVzdWx0RXhpc3RzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVuY29kaW5nID09PSAnYnVmZmVyJykge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBCdWZmZXIuZnJvbShyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgfSAvLyB0aGlzIHBhdGggZG9lc24ndCBleGlzdCwgdHJ5IGVhY2ggc2VnbWVudCB1bnRpbCB3ZSBmaW5kIGZpcnN0IHRoYXQgZG9lc24ndFxuXG5cbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gcmVzdWx0LnNwbGl0KHBhdGguc2VwKTsgLy8gRklYTUU6IERyb3AgbGFzdCBzZWdtZW50IGFzIHdlIGFscmVhZHkga25vdyB0aGUgZnVsbCBwYXRoIGRvZXNuJ3QgZXhpc3Q/XG5cbiAgICAgIGxldCBwYXJ0aWFsRmlsZVBhdGggPSAnJztcbiAgICAgIGxldCBpbmRleCA9IDA7IC8vIGhhbmRsZSB0eXBpY2FsIGNhc2Ugb2YgZW1wdHkgZmlyc3Qgc2VnbWVudCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFuIGFzeW5jIHNldFRpbWVvdXQgdG8gZ2V0IHRvIGZpcnN0IHJlYWwgY2FzZVxuXG4gICAgICBpZiAoc2VnbWVudHNbaW5kZXhdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KHRyeVBhdGgsIDEpO1xuXG4gICAgICBmdW5jdGlvbiB0cnlQYXRoKCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgcnVuIHBhc3QgZW5kIG9mIHNlZ21lbnRzLCB0aHJvdyBlcnJvciBmb3IgcmVzb2x2ZWQgcGF0aFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhub1N1Y2hGaWxlKHJlc3VsdCkpO1xuICAgICAgICB9IC8vIGdyYWIgbmV4dCBzZWdtZW50XG5cblxuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXgrK107XG5cbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gaWYgaXQncyBhbiBlbXB0eSBzZWdtZW50Li4uXG4gICAgICAgICAgLy8gdHJ5IGFnYWluIGF0IG5leHQgaW5kZXhcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCh0cnlQYXRoLCAxKTtcbiAgICAgICAgfSAvLyBub3JtYWwgY2FzZVxuXG5cbiAgICAgICAgcGFydGlhbEZpbGVQYXRoICs9IHBhdGguc2VwICsgc2VnbWVudDsgLy8gY2hlY2sgaWYgcGF0aCB1cCB0byB0aGlzIHBvaW50IGV4aXN0cy4uLlxuXG4gICAgICAgIGZzLmV4aXN0cyhwYXJ0aWFsRmlsZVBhdGgsIHBhcnRpYWxFeGlzdHMgPT4ge1xuICAgICAgICAgIGlmICghcGFydGlhbEV4aXN0cykge1xuICAgICAgICAgICAgLy8gbm9wZSwgdGhyb3cgdGhlIEVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobm9TdWNoRmlsZSgnbHN0YXQnLCBwYXJ0aWFsRmlsZVBhdGgpKTtcbiAgICAgICAgICB9IC8vIHRyeSBhZ2FpbiBhdCBuZXh0IGRlcHRoIG9mIGRpciB0cmVlXG5cblxuICAgICAgICAgIHNldFRpbWVvdXQodHJ5UGF0aCwgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCAxKTtcbn07XG5cbmZzLnJlYWxwYXRoLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBmcy5yZWFscGF0aChwYXRoLCBvcHRpb25zLCBjYWxsYmFjayk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBmaWxlcGF0aCBvcmlnaW5hbCBmaWxlcGF0aFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPSd1dGY4J10gZW5jb2RpbmcgdXNlZCBmb3IgcmV0dXJuZWQgb2JqZWN0LiBJZiAnYnVmZmVyXCIsIHdlJ2xsIHJldHVybiBhIEJ1ZmZlciBpbiBwYWxjZSBvZiBhIHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ3xCdWZmZXJ9XG4gKi9cblxuXG5mcy5yZWFscGF0aFN5bmMgPSAoZmlsZXBhdGgsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCdcbiAgfSk7IC8vIEZJWE1FOiBUaGlzIGFzc3VtZXMgbm8gc3ltbGlua3MsIHdoaWNoIHdlIHJlYWxseSBkb24ndCBoYXZlIGZ1bGwgc3VwcG9ydCBmb3IgaW4gb3VyIFNESyBhbnl3YXlzLlxuXG4gIGNvbnN0IHJlc3VsdCA9IHBhdGgubm9ybWFsaXplKGZpbGVwYXRoKTtcblxuICBpZiAoIWZzLmV4aXN0c1N5bmMocmVzdWx0KSkge1xuICAgIC8vIHRoaXMgcGF0aCBkb2Vzbid0IGV4aXN0LCB0cnkgZWFjaCBzZWdtZW50IHVudGlsIHdlIGZpbmQgZmlyc3QgdGhhdCBkb2Vzbid0XG4gICAgY29uc3Qgc2VnbWVudHMgPSByZXN1bHQuc3BsaXQocGF0aC5zZXApO1xuICAgIGxldCBwYXJ0aWFsRmlsZVBhdGggPSAnJztcblxuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwYXJ0aWFsRmlsZVBhdGggKz0gcGF0aC5zZXAgKyBzZWdtZW50O1xuXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGFydGlhbEZpbGVQYXRoKSkge1xuICAgICAgICB0aHJvdyBub1N1Y2hGaWxlKCdsc3RhdCcsIHBhcnRpYWxGaWxlUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcgPT09ICdidWZmZXInKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnMucmVhbHBhdGhTeW5jLm5hdGl2ZSA9IChwYXRoLCBvcHRpb25zKSA9PiB7XG4gIGZzLnJlYWxwYXRoU3luYyhwYXRoLCBvcHRpb25zKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IG9sZFBhdGggc291cmNlIGZpbGVwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBuZXdQYXRoIGRlc3RpbmF0aW9uIGZpbGVwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5yZW5hbWUgPSAob2xkUGF0aCwgbmV3UGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnJlbmFtZVN5bmMob2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgfSwgMSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBvbGRQYXRoIHNvdXJjZSBmaWxlcGF0aFxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gbmV3UGF0aCBkZXN0aW5hdGlvbiBmaWxlcGF0aFxuICovXG5cblxuZnMucmVuYW1lU3luYyA9IChvbGRQYXRoLCBuZXdQYXRoKSA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKG9sZFBhdGgpOyAvLyBzcmMgZG9lc24ndCBhY3R1YWxseSBleGlzdD9cblxuICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgIGNvbnN0IGVyciA9IG5vU3VjaEZpbGUoJ3JlbmFtZScsIG9sZFBhdGgpO1xuICAgIGVyci5tZXNzYWdlID0gYCR7ZXJyLm1lc3NhZ2V9IC0+ICcke25ld1BhdGh9J2A7XG4gICAgZXJyLmRlc3QgPSBuZXdQYXRoO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIGNvbnN0IGRlc3RGaWxlID0gZ2V0VGlGaWxlRnJvbVBhdGhMaWtlVmFsdWUobmV3UGF0aCk7XG5cbiAgaWYgKGRlc3RGaWxlLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAvLyBkZXN0IGlzIGEgZGlyZWN0b3J5IHRoYXQgYWxyZWFkeSBleGlzdHNcbiAgICBjb25zdCBlcnIgPSBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCdyZW5hbWUnLCBvbGRQYXRoKTtcbiAgICBlcnIubWVzc2FnZSA9IGAke2Vyci5tZXNzYWdlfSAtPiAnJHtuZXdQYXRofSdgO1xuICAgIGVyci5kZXN0ID0gbmV3UGF0aDtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICBsZXQgdGVtcFBhdGg7XG5cbiAgaWYgKGRlc3RGaWxlLmlzRmlsZSgpKSB7XG4gICAgLy8gZGVzdGluYXRpb24gZmlsZSBleGlzdHMsIHdlIHNob3VsZCBvdmVyd3JpdGVcbiAgICAvLyBPdXIgQVBJcyB3aWxsIGZhaWwgaWYgd2UgdHJ5LCBzbyBmaXJzdCBsZXQncyBtYWtlIGEgYmFja3VwIGNvcHkgYW5kIGRlbGV0ZSB0aGUgdGhlIG9yaWdpbmFsXG4gICAgdGVtcFBhdGggPSBwYXRoLmpvaW4oZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKFRpLkZpbGVzeXN0ZW0udGVtcERpcmVjdG9yeSwgJ3JlbmFtZS0nKSksIHBhdGguYmFzZW5hbWUobmV3UGF0aCkpO1xuICAgIGRlc3RGaWxlLm1vdmUodGVtcFBhdGgpO1xuICB9XG5cbiAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHN1Y2Nlc3MgPSB0aUZpbGUubW92ZShuZXdQYXRoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAodGVtcFBhdGgpIHtcbiAgICAgIC8vIHdlIHRlbXBvcmFyaWx5IGNvcGllZCB0aGUgZXhpc3RpbmcgZGVzdGluYXRpb24gdG8gYmFjayBpdCB1cC4uLlxuICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgLy8gbW92ZSB3b3JrZWQsIHNvIHdlIGNhbiB3aXBlIGl0IGF3YXkgd2hlbmV2ZXIuLi5cbiAgICAgICAgZnMudW5saW5rKHRlbXBQYXRoLCBfZXJyID0+IHt9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgaXQgYmFjaywgYmVjYXVzZSB3ZSBmYWlsZWQhXG4gICAgICAgIGNvbnN0IHRtcEZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZSh0ZW1wUGF0aCk7XG4gICAgICAgIHRtcEZpbGUubW92ZShuZXdQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy5ybWRpciA9IChwYXRoLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgZnMucm1kaXJTeW5jKHBhdGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNhbGxiYWNrKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqL1xuXG5cbmZzLnJtZGlyU3luYyA9IHBhdGggPT4ge1xuICBjb25zdCB0aUZpbGUgPSBnZXRUaUZpbGVGcm9tUGF0aExpa2VWYWx1ZShwYXRoKTtcblxuICBpZiAoIXRpRmlsZS5kZWxldGVEaXJlY3RvcnkoZmFsc2UpKSB7XG4gICAgLy8gZG8gbm90IGRlbGV0ZSBjb250ZW50cyFcbiAgICAvLyB3ZSBmYWlsZWQgdG8gZGVsZXRlLCBidXQgd2h5P1xuICAgIC8vIGRvZXMgaXQgZXhpc3Q/XG4gICAgaWYgKCF0aUZpbGUuZXhpc3RzKCkpIHtcbiAgICAgIHRocm93IG5vU3VjaEZpbGUoJ3JtZGlyJywgcGF0aCk7XG4gICAgfSAvLyBpcyBpdCBhIGZpbGU/XG5cblxuICAgIGlmICh0aUZpbGUuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5vdEFEaXJlY3RvcnkoJ3JtZGlyJywgcGF0aCk7XG4gICAgfSAvLyBpcyBpdCBub3QgZW1wdHk/XG5cblxuICAgIGNvbnN0IHN1YkZpbGVzID0gdGlGaWxlLmdldERpcmVjdG9yeUxpc3RpbmcoKTtcblxuICAgIGlmIChzdWJGaWxlcyAmJiBzdWJGaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBkaXJlY3RvcnlOb3RFbXB0eSgncm1kaXInLCBwYXRoKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEBwYXJhbSB7c3RhdHNDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZzLnN0YXQgPSAocGF0aCwgb3B0aW9ucywgY2FsbGJhY2spID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNhbGxiYWNrID0gbWF5YmVDYWxsYmFjayhjYWxsYmFjayk7XG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGNhbGxiYWNrKG51bGwsIG5ldyBmcy5TdGF0cyhwYXRoKSk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBwYXRoIGZpbGVwYXRoIG9yIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtvYmplY3R9IFtfb3B0aW9uc10gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbX29wdGlvbnMuYmlnaW50XSB3aGV0aGVyIHN0YXQgdmFsdWVzIHNob3VsZCBiZSBiaWdpbnRcbiAqIEByZXR1cm5zIHtmcy5TdGF0c31cbiAqL1xuXG5cbmZzLnN0YXRTeW5jID0gKHBhdGgsIF9vcHRpb25zKSA9PiBuZXcgZnMuU3RhdHMocGF0aCk7XG5cbmZzLnN5bWxpbmsgPSAodGFyZ2V0LCBwYXRoLCB0eXBlLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3N5bWxpbmsnLCBjYWxsYmFjayk7XG5cbmZzLnN5bWxpbmtTeW5jID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICdzeW1saW5rU3luYycpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSBieXRlcyB0byB0cmltIHRvXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuZnMudHJ1bmNhdGUgPSAocGF0aCwgbGVuLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgbGVuKTtcblxuICBpZiAodHlwZW9mIGxlbiAhPT0gJ251bWJlcicpIHtcbiAgICBsZW4gPSAwO1xuICB9XG5cbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgZnMud3JpdGVGaWxlKHBhdGgsICcnLCBjYWxsYmFjayk7IC8vIGVtcHR5IHRoZSBmaWxlXG5cbiAgICByZXR1cm47XG4gIH0gLy8gd2UgaGF2ZSB0byByZXRhaW4gc29tZSBvZiB0aGUgZmlsZSFcbiAgLy8geXVjaywgc28gbGV0J3MgcmVhZCB3aGF0IHdlIG5lZWQgdG8gcmV0YWluLCB0aGVuIG92ZXJ3cml0ZSBmaWxlIHdpdGggaXRcblxuXG4gIGZzLm9wZW4ocGF0aCwgKGVyciwgZmQpID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MobGVuKTtcbiAgICBmcy5yZWFkKGZkLCBidWZmZXIsIDAsIGxlbiwgbnVsbCwgKGVyciwgYnl0ZXNSZWFkLCBidWZmZXIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIGZzLmNsb3NlKGZkLCBlcnIgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBmcy53cml0ZUZpbGUocGF0aCwgYnVmZmVyLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBmaWxlIHBhdGhcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW2xlbj0wXSBieXRlcyB0byB0cmltIHRvXG4gKi9cblxuXG5mcy50cnVuY2F0ZVN5bmMgPSAocGF0aCwgbGVuID0gMCkgPT4ge1xuICBpZiAobGVuIDw9IDApIHtcbiAgICAvLyBlbXB0eSB0aGUgZmlsZVxuICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgJycpO1xuICAgIHJldHVybjtcbiAgfSAvLyB3ZSBoYXZlIHRvIHJldGFpbiBzb21lIG9mIHRoZSBmaWxlIVxuICAvLyB5dWNrLCBzbyBsZXQncyByZWFkIHdoYXQgd2UgbmVlZCB0byByZXRhaW4sIHRoZW4gb3ZlcndyaXRlIGZpbGUgd2l0aCBpdFxuXG5cbiAgY29uc3QgZmQgPSBmcy5vcGVuU3luYyhwYXRoKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbik7XG4gIGZzLnJlYWRTeW5jKGZkLCBidWZmZXIsIDAsIGxlbiwgbnVsbCk7XG4gIGZzLmNsb3NlU3luYyhmZCk7XG4gIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgYnVmZmVyKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxVUkx9IHBhdGggZmlsZSBwYXRoXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mcy51bmxpbmsgPSAocGF0aCwgY2FsbGJhY2spID0+IHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGZzLnVubGlua1N5bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0sIDEpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuXG5mcy51bmxpbmtTeW5jID0gcGF0aCA9PiB7XG4gIGNvbnN0IHRpRmlsZSA9IGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpO1xuXG4gIGlmICghdGlGaWxlLmRlbGV0ZUZpbGUoKSkge1xuICAgIC8vIHdlIGZhaWxlZCwgYnV0IHdoeT9cbiAgICBpZiAoIXRpRmlsZS5leGlzdHMoKSkge1xuICAgICAgdGhyb3cgbm9TdWNoRmlsZSgndW5saW5rJywgcGF0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRpRmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBpbGxlZ2FsT3BlcmF0aW9uT25BRGlyZWN0b3J5KCd1bmxpbmsnLCBwYXRoKTtcbiAgICB9XG4gIH1cbn07XG5cbmZzLnVud2F0Y2hGaWxlID0gdW5zdXBwb3J0ZWROb29wKCdmcycsICd1bndhdGNoRmlsZScpO1xuXG5mcy51dGltZXMgPSAocGF0aCwgYXRpbWUsIG10aW1lLCBjYWxsYmFjaykgPT4gYXN5bmNVbnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3V0aW1lcycsIGNhbGxiYWNrKTtcblxuZnMudXRpbWVzU3luYyA9IHVuc3VwcG9ydGVkTm9vcCgnZnMnLCAndXRpbWVzU3luYycpO1xuZnMud2F0Y2ggPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoJyk7XG5mcy53YXRjaEZpbGUgPSB1bnN1cHBvcnRlZE5vb3AoJ2ZzJywgJ3dhdGNoRmlsZScpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfGludGVnZXJ9IGZpbGUgZmlsZSBwYXRoIG9yIGRlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcnxUeXBlZEFycmF5fERhdGFWaWV3fSBkYXRhIGRhdGEgdG8gd3JpdGVcbiAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gW29wdGlvbnNdIG9wdGlvbnMsIGVuY29kaW5nIGlmIHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gW29wdGlvbnMuZW5jb2Rpbmc9J3V0Zi04J10gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLm1vZGU9MG82NjZdIG9wdGlvbnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5mbGFnPSd3J10gb3B0aW9uc1xuICogQHBhcmFtIHtlcnJvckNhbGxiYWNrfSBjYWxsYmFjayBhc3luYyBjYWxsYmFja1xuICovXG5cbmZzLndyaXRlRmlsZSA9IChmaWxlLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2sgfHwgb3B0aW9ucyk7XG4gIG9wdGlvbnMgPSBtZXJnZURlZmF1bHRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIG1vZGU6IDBvNjY2LFxuICAgIGZsYWc6ICd3J1xuICB9KTsgLy8gVHVybiBpbnRvIGZpbGUgZGVzY3JpcHRvclxuXG4gIGNvbnN0IHdhc0ZpbGVEZXNjcmlwdG9yID0gdHlwZW9mIGZpbGUgPT09ICdudW1iZXInO1xuICBsZXQgZmlsZURlc2NyaXB0b3IgPSBmaWxlOyAvLyBtYXkgYmUgb3ZlcnJpZGVuIGxhdGVyXG5cbiAgY29uc3QgZmluaXNoID0gZXJyID0+IHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGZzLmNsb3NlIGlmIGl0IHdhcyBub3Qgb3JpZ2luYWxseSBhIGZpbGUgZGVzY3JpcHRvclxuXG5cbiAgICBmcy5jbG9zZShmaWxlRGVzY3JpcHRvciwgY2FsbGJhY2spO1xuICB9O1xuXG4gIGlmICghd2FzRmlsZURlc2NyaXB0b3IpIHtcbiAgICBmcy5vcGVuKGZpbGUsIG9wdGlvbnMuZmxhZywgb3B0aW9ucy5tb2RlLCAoZXJyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZpbGVEZXNjcmlwdG9yID0gZmQ7XG4gICAgICBmcy53cml0ZShmaWxlRGVzY3JpcHRvciwgZGF0YSwgZmluaXNoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmcy53cml0ZShmaWxlRGVzY3JpcHRvciwgZGF0YSwgZmluaXNoKTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTHxpbnRlZ2VyfSBmaWxlIGZpbGUgcGF0aCBvciBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VHlwZWRBcnJheXxEYXRhVmlld30gZGF0YSBkYXRhIHRvIHdyaXRlXG4gKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXSBvcHRpb25zLCBlbmNvZGluZyBpZiBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5lbmNvZGluZz0ndXRmLTgnXSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnMubW9kZT0wbzY2Nl0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLmZsYWc9J3cnXSBvcHRpb25zXG4gKi9cblxuXG5mcy53cml0ZUZpbGVTeW5jID0gKGZpbGUsIGRhdGEsIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywge1xuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbW9kZTogMG82NjYsXG4gICAgZmxhZzogJ3cnXG4gIH0pOyAvLyBUdXJuIGludG8gZmlsZSBkZXNjcmlwdG9yXG5cbiAgY29uc3Qgd2FzRmlsZURlc2NyaXB0b3IgPSB0eXBlb2YgZmlsZSA9PT0gJ251bWJlcic7XG4gIGNvbnN0IGZpbGVEZXNjcmlwdG9yID0gd2FzRmlsZURlc2NyaXB0b3IgPyBmaWxlIDogZnMub3BlblN5bmMoZmlsZSwgb3B0aW9ucy5mbGFnLCBvcHRpb25zLm1vZGUpOyAvLyBpZiBkYXRhIGlzIGEgc3RyaW5nLCBtYWtlIGl0IGEgYnVmZmVyIGZpcnN0XG5cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oJycgKyBkYXRhLCBvcHRpb25zLmVuY29kaW5nKTsgLy8gZm9yY2UgZGF0YSB0byBiZSBhIHN0cmluZywgaGFuZGxlcyBjYXNlIHdoZXJlIGl0J3MgdW5kZWZpbmVkIGFuZCB3cml0ZXMgJ3VuZGVmaW5lZCcgdG8gZmlsZSFcbiAgfVxuXG4gIGZzLndyaXRlU3luYyhmaWxlRGVzY3JpcHRvciwgZGF0YSk7IC8vIGNsb3NlIGlmIHVzZXIgZGlkbid0IGdpdmUgdXMgZmlsZSBkZXNjcmlwdG9yXG5cbiAgaWYgKCF3YXNGaWxlRGVzY3JpcHRvcikge1xuICAgIGZzLmNsb3NlU3luYyhmaWxlRGVzY3JpcHRvcik7XG4gIH1cbn07XG4vKipcbiAqIEBjYWxsYmFjayB3cml0ZVRpRmlsZVN0cmVhbUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciBpZiBvbmUgb2NjdXJyZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd3JpdHRlbiAtIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VGkuRmlsZXN5c3RlbS5GaWxlU3RyZWFtfSB0aUZpbGVTdHJlYW0gZmlsZSBzdHJlYW1cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgYnVmZmVyIHdlJ3JlIHdyaXRpbmdcbiAqIEBwYXJhbSB7d3JpdGVUaUZpbGVTdHJlYW1DYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG1heWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICBUaS5TdHJlYW0ud3JpdGUodGlGaWxlU3RyZWFtLCBidWZmZXIudG9UaUJ1ZmZlcigpLCB3cml0ZU9iaiA9PiB7XG4gICAgaWYgKCF3cml0ZU9iai5zdWNjZXNzKSB7XG4gICAgICBjYWxsYmFjayhuZXcgRXJyb3Iod3JpdGVPYmouZXJyb3IpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB3cml0ZU9iai5ieXRlc1Byb2Nlc3NlZCk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBidWZmZXIgY29udGVudHMgdG8gd3JpdGU6IEJ1ZmZlciBvciBzdHJpbmdcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29mZnNldF0gb2Zmc2V0IHdpdGhpbiBCdWZmZXIgdG8gd3JpdGU7IE9SIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuIChpZiBzdHJpbmcpXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyOyBPUiBleHBlY3RlZCBzdHJpbmcgZW5jb2RpbmdcbiAqIEBwYXJhbSB7d3JpdGVDYWxsYmFja3xpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuIChpZiBCdWZmZXIpOyBPUiBhc3luYyBjYWxsYmFjayBpZiBzdHJpbmdcbiAqIEBwYXJhbSB7d3JpdGVDYWxsYmFja30gW2NhbGxiYWNrXSBhc3luYyBjYWxsYmFjayAoaWYgQnVmZmVyKVxuICovXG5cblxuZnMud3JpdGUgPSAoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYWxsYmFjaykgPT4ge1xuICBjb25zdCBpc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpO1xuXG4gIGlmIChpc0J1ZmZlcikge1xuICAgIHdyaXRlQnVmZmVyKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlU3RyaW5nKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbik7XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlblxuICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW2xlbmd0aF0gIGV4cGVjdGVkIHN0cmluZyBlbmNvZGluZ1xuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG5cbmZzLndyaXRlU3luYyA9IChmZCwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pID0+IHtcbiAgY29uc3QgaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKTtcblxuICBpZiAoaXNCdWZmZXIpIHtcbiAgICByZXR1cm4gd3JpdGVCdWZmZXJTeW5jKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB3cml0ZVN0cmluZ1N5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgpO1xufTsgLy8gVE9ETzogQWRkIEZpbGVIYW5kbGUgY2xhc3MgdG8gbWF0Y2ggTm9kZSdzIHdyYXBwZXIgZm9yIGZpbGUgZGVzY3JpcHRvcnMuIFJlLXB1cnBvc2Ugb3VyIG93biB3cmFwcGVyP1xuLy8gVE9ETzogQWRkIHRoZSBmcy5wcm9taXNlcyBBUEkhXG4vLyBUT0RPOiBEZWZpbmUgZnMuRGlyZW50IGNsYXNzLCB3aGljaCBjYW4gc2ltcGx5IHdyYXAgYSBUaS5GaWxlc3lzdGVtLkZpbGUgKGFuZCBpcyB2ZXJ5IHNpbWlsYXIgdG8gZnMuU3RhdHMhKVxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUcmFja3MgdGhlIHBhaXJpbmcgb2YgdGhlIG51bWJlciB3ZSB1c2UgdG8gcmVwcmVzZW50IHRoZSBmaWxlIGV4dGVybmFsbHksIHRoZSBmaWxlcGF0aCBpdCdzIHBvaW50aW5nIGF0LCBhbmQgdGhlIHN0cmVhbSBwb2ludGluZyBhdCBpdC5cbiAqL1xuXG5cbmNsYXNzIEZpbGVEZXNjcmlwdG9yIHtcbiAgY29uc3RydWN0b3IobnVtYmVyLCBwYXRoLCBzdHJlYW0pIHtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICB9XG5cbn1cbi8qKlxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gc3JjU3RyZWFtIGlucHV0IHN0cmVhbSB3ZSdyZSByZWFkaW5nIGZyb21cbiAqIEBwYXJhbSB7VGkuSU9TdHJlYW19IGRlc3RTdHJlYW0gb3V0cHV0IHN0cmVhbSB3ZSdyZSB3cml0aW5nIHRvXG4gKiBAcGFyYW0ge2Vycm9yQ2FsbGJhY2t9IGNhbGxiYWNrIGFzeW5jIGNhbGxiYWNrXG4gKi9cblxuXG5mdW5jdGlvbiBwaXBlKHNyY1N0cmVhbSwgZGVzdFN0cmVhbSwgY2FsbGJhY2spIHtcbiAge1xuICAgIC8vIEFuZHJvaWQgaXMgcHJvYmFibHkgYmV0dGVyIG9mZiB3aXRoIFRpLlN0cmVhbS53cml0ZVN0cmVhbSwgbGVzcyBvdmVyaGVhZCBiYWNrIGFuZCBmb3J0aCB0aGUgYnJpZGdlXG4gICAgLy8gVGhvdWdoIEFuZHJvaWQgZG9lcyBzdXBwb3J0IHRoZSBUaS5TdHJlYW0ucHVtcC9UaS5TdHJlYW0ud3JpdGUgcGF0dGVybiB1c2luZyBib3RoIEFQSXMgYXN5bmNcbiAgICBwaXBlVmlhV3JpdGVTdHJlYW0oc3JjU3RyZWFtLCBkZXN0U3RyZWFtLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuO1xuICB9IC8vIGlPUyBoYXMgc29tZS4uLiBpc3N1ZXMgd2l0aCB3cml0ZVN0cmVhbSBjYWxsaW5nIHRoZSBjYWxsYmFjayBldmVyeSBpdGVyYXRpb24gb2YgdGhlIGxvb3AgKmFuZCogYXQgdGhlIGVuZFxufVxuLyoqXG4gKiBAcGFyYW0ge1RpLklPU3RyZWFtfSBzcmNTdHJlYW0gaW5wdXQgc3RyZWFtIHdlJ3JlIHJlYWRpbmcgZnJvbVxuICogQHBhcmFtIHtUaS5JT1N0cmVhbX0gZGVzdFN0cmVhbSBvdXRwdXQgc3RyZWFtIHdlJ3JlIHdyaXRpbmcgdG9cbiAqIEBwYXJhbSB7ZXJyb3JDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHBpcGVWaWFXcml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIGNhbGxiYWNrKSB7XG4gIFRpLlN0cmVhbS53cml0ZVN0cmVhbShzcmNTdHJlYW0sIGRlc3RTdHJlYW0sIENPUFlfRklMRV9DSFVOS19TSVpFLCByZXN1bHQgPT4ge1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IocmVzdWx0LmVycm9yKSk7XG4gICAgfSAvLyBBbmRyb2lkIHdpbGwgb25seSBjYWxsIHRoaXMgYXQgdGhlIGVuZCBvciBlcnJvciwgc28gd2UgY2FuIHNhZmVseSBhc3N1bWUgd2UncmUgZG9uZSBoZXJlLlxuICAgIC8vIGlPUyB3aWxsIGNhbGwgcGVyIGxvb3AgaXRlcmF0aW9uLCBzZWUgaHR0cHM6Ly9qaXJhLmFwcGNlbGVyYXRvci5vcmcvYnJvd3NlL1RJTU9CLTI3MzIwXG5cblxuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xCdWZmZXJ8VVJMfSBwYXRoIGZpbGUgcGF0aFxuICogQHBhcmFtIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IGZpbGVTdHJlYW0gZmlsZSBzdHJlYW1cbiAqIEByZXR1cm5zIHtpbnRlZ2VyfSBmaWxlIGRlc2NyaXB0b3JcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbGVEZXNjcmlwdG9yKHBhdGgsIGZpbGVTdHJlYW0pIHtcbiAgY29uc3QgcG9pbnRlciA9IGZpbGVEZXNjcmlwdG9yQ291bnQrKzsgLy8gaW5jcmVtZW50IGdsb2JhbCBjb3VudGVyXG5cbiAgY29uc3QgZmQgPSBuZXcgRmlsZURlc2NyaXB0b3IocG9pbnRlciwgcGF0aCwgZmlsZVN0cmVhbSk7XG4gIGZpbGVEZXNjcmlwdG9ycy5zZXQocG9pbnRlciwgZmQpOyAvLyB1c2UgaXQgdG8gcmVmZXIgdG8gdGhpcyBmaWxlIHN0cmVhbSBhcyB0aGUgXCJkZXNjcmlwdG9yXCJcblxuICByZXR1cm4gcG9pbnRlcjtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtUaS5GaWxlc3lzdGVtLkZpbGVTdHJlYW19IG1hdGNoaW5nIHN0cmVhbVxuICovXG5cblxuZnVuY3Rpb24gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCkge1xuICBjb25zdCB3cmFwcGVyID0gZmlsZURlc2NyaXB0b3JzLmdldChmZCk7XG4gIHJldHVybiB3cmFwcGVyLnN0cmVhbTtcbn1cbi8qKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBmZCBmaWxlIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9IG1hdGNoaW5nIHN0cmVhbVxuICovXG5cblxuZnVuY3Rpb24gcGF0aEZvckZpbGVEZXNjcmlwdG9yKGZkKSB7XG4gIGNvbnN0IHdyYXBwZXIgPSBmaWxlRGVzY3JpcHRvcnMuZ2V0KGZkKTtcbiAgcmV0dXJuIHdyYXBwZXIucGF0aDtcbn1cbi8qKlxuICogVXNlZCB0byBtZXJnZSB0aGUgdXNlci1zdXBwbGllZCBvcHRpb25zIHdpdGggdGhlIGRlZmF1bHRzIGZvciBhIGZ1bmN0aW9uLiBTcGVjaWFsIGNhc2VzIGEgc3RyaW5nIHRvIGJlIGVuY29kaW5nLlxuICogQHBhcmFtIHsqfSBvcHRpb25zIHVzZXItc3VwcGxpZWQgb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRzIGRlZmF1bHRzIHRvIHVzZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0T3B0aW9ucyhvcHRpb25zLCBkZWZhdWx0cykge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnNUeXBlID0gdHlwZW9mIG9wdGlvbnM7XG5cbiAgc3dpdGNoIChvcHRpb25zVHlwZSkge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFVzZSBjb3B5IG9mIGRlZmF1bHRzIGJ1dCB3aXRoIGVuY29kaW5nIHNldCB0byB0aGUgJ29wdGlvbnMnIHZhbHVlIVxuICAgICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMpO1xuICAgICAgbWVyZ2VkLmVuY29kaW5nID0gb3B0aW9ucztcbiAgICAgIHJldHVybiBtZXJnZWQ7XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYXNzZXJ0QXJndW1lbnRUeXBlKG9wdGlvbnMsICdvcHRpb25zJywgJ29iamVjdCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgLy8gc2hvdWxkIG5ldmVyIGdldCByZWFjaGVkXG4gIH1cbn1cbi8qKlxuICogRW5mb3JjZXMgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgY2FsbGJhY2sgZnVuY3Rpb24uIFRocm93cyBUeXBlRXJyb3IgaWYgbm90LlxuICogQHBhcmFtIHsqfSBjYiBwb3NzaWJsZSBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICovXG5cblxuZnVuY3Rpb24gbWF5YmVDYWxsYmFjayhjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNiO1xuICB9XG5cbiAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcihgQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLiBSZWNlaXZlZCAke2NifWApO1xuICBlcnIuY29kZSA9ICdFUlJfSU5WQUxJRF9DQUxMQkFDSyc7XG4gIHRocm93IGVycjtcbn1cbi8qKlxuICogcmV0dXJucyByYW5kb21seSBnZW5lcmF0ZWQgY2hhcmFjdGVycyBvZiBnaXZlbiBsZW5ndGggMS0xNlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZW5ndGggMSAtIDE2XG4gKiBAcGFyYW0ge3N0cmluZ30gW19lbmNvZGluZz0ndXRmOCddIGVuY29kaW5nIG9mIHRoZSBzdHJpbmcgZ2VuZXJhdGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gcmFuZG9tQ2hhcmFjdGVycyhsZW5ndGgsIF9lbmNvZGluZyA9ICd1dGY4Jykge1xuICAvLyBGSVhNRTogdXNlIHRoZSBlbmNvZGluZyBzcGVjaWZpZWQhXG4gIHJldHVybiAoTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikgKyAnMDAwMDAwMDAwMDAwMDAwMDAnKS5zbGljZSgyLCBsZW5ndGggKyAyKTtcbn1cblxuZnVuY3Rpb24gbWFrZUVycm9yKGNvZGUsIG1lc3NhZ2UsIGVycm5vLCBzeXNjYWxsLCBwYXRoKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGAke2NvZGV9OiAke21lc3NhZ2V9LCAke3N5c2NhbGx9ICcke3BhdGh9J2ApO1xuICBlcnJvci5lcnJubyA9IGVycm5vO1xuICBlcnJvci5zeXNjYWxsID0gc3lzY2FsbDtcbiAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIGVycm9yLnBhdGggPSBwYXRoO1xuICByZXR1cm4gZXJyb3I7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyB3aGF0IHdlJ3JlIGVuY29kaW5nIHRvXG4gKiBAcGFyYW0ge1RpLkJ1ZmZlcn0gdGlCdWZmZXIgVGkuQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBub2RlLWNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlXG4gKi9cblxuXG5mdW5jdGlvbiBlbmNvZGVCdWZmZXIoZW5jb2RpbmcsIHRpQnVmZmVyKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdidWZmZXInOlxuICAgIGNhc2UgbnVsbDpcbiAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSdyZSBhbHdheXMgcmVhZGluZyBhIGZpbGUgaW50byBhIFRpLkJ1ZmZlclxuICAgICAgLy8gV3JhcHBpbmcgVGkuQnVmZmVyIGlzIHN1cGVyLXNsb3cgYW5kIHNob3VsZCByZWFsbHkgb25seSBiZSBpZiB3ZSdyZSBnb2luZyB0byB3cml0ZSB0byBpdFxuICAgICAgLy8gR28gdGhlIGZhc3RlciBwYXRoIGJ5IGNvbnZlcnRpbmcgdG8gQXJyYXlCdWZmZXIgYW5kIHdyYXBwaW5nIHRoYXRcbiAgICAgIC8vIFRPRE86IEV4cGxpY2l0bHkgcmVsZWFzZSB0aGUgYmxvYiBhZnRlciBjb252ZXJzaW9uP1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRpQnVmZmVyLnRvQmxvYigpLnRvQXJyYXlCdWZmZXIoKSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gaGVyZScgd2VyZSBjb252ZXJ0aW5nIHRvIGEgc3RyaW5nIGJhc2VkIG9uIGVuY29kaW5nLiBJbnRlcm5hbGx5IG91ciBmYXN0ZXIgQnVmZmVyIGltcGwgc3RpbGwgZGVsZWdhdGVzIHRvIFRpLkJ1ZmZlciBpbiBtb3N0IGNhc2VzXG4gICAgICAvLyBzbyBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgbXVjaCBiZW5lZml0IGZyb20gY29udmVydGluZyB0byBBcnJheUJ1ZmZlciBmaXJzdFxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRpQnVmZmVyKS50b1N0cmluZyhlbmNvZGluZyk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfFVSTH0gcGF0aCBmaWxlIHBhdGhcbiAqIEByZXR1cm4ge1RpLkZpbGVzeXN0ZW0uRmlsZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRpRmlsZUZyb21QYXRoTGlrZVZhbHVlKHBhdGgpIHtcbiAgLy8gVGhpcyBpcyBhIGhhY2sgdGhhdCBpcyBsaWtlbHkgdG8gd29yayBpbiBtb3N0IGNhc2VzP1xuICAvLyBCYXNpY2FsbHkgYXNzdW1lcyBCdWZmZXIgaXMgaG9sZGluZyBhIHV0Zi04IHN0cmluZyBmaWxlbmFtZS9wYXRoXG4gIC8vIE5vZGUganVzdCBjb3BpZXMgdGhlIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlciBhcy1pcyBvbiB0aGUgbmF0aXZlIHNpZGUgYW5kIGFkZHMgYSBudWxsIHRlcm1pbmF0b3JcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihwYXRoKSkge1xuICAgIHBhdGggPSBwYXRoLnRvU3RyaW5nKCk7IC8vIGFzc3VtZXMgdXRmLTggc3RyaW5nXG4gIH0gLy8gRklYTUU6IEhhbmRsZSBVUkxzISBXZSBkb24ndCBoYXZlIGFuIFVSTCBzaGltIHlldCwgc28gbm8gd2F5IHRvIGhhbmRsZSB0aG9zZSB5ZXRcblxuXG4gIGFzc2VydEFyZ3VtZW50VHlwZShwYXRoLCAncGF0aCcsICdzdHJpbmcnKTtcbiAgcmV0dXJuIFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShwYXRoKTtcbn1cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlQnVmZmVyQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciAtIG9yaWdpbmFsIEJ1ZmZlciBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb2Zmc2V0XSBvZmZzZXQgd2l0aGluIEJ1ZmZlciB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbbGVuZ3RoXSBsZW5ndGggb2YgYnl0ZXMgdG8gd3JpdGUgaWYgQnVmZmVyXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtwb3NpdGlvbl0gb2Zmc2V0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgZmlsZSB3aGVyZSB0aGlzIGRhdGEgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqIEBwYXJhbSB7d3JpdGVCdWZmZXJDYWxsYmFja30gY2FsbGJhY2sgYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyKGZkLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IHBvc2l0aW9uIHx8IGxlbmd0aCB8fCBvZmZzZXQpO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cblxuICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICBwb3NpdGlvbiA9IG51bGw7XG4gIH0gLy8gb2sgbm93IHdoYXQ/XG5cblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTsgLy8gTWFrZSB1c2Ugb2YgdGhlIGJ1ZmZlciBzbGljZSB0aGF0J3Mgc3BlY2lmaWVkIGJ5IG9mZnNldC9sZW5ndGhcblxuICBpZiAob2Zmc2V0ICE9PSAwIHx8IGxlbmd0aCAhPT0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGxlbmd0aCk7XG4gIH0gLy8gVE9ETzogU3VwcG9ydCB1c2Ugb2YgcG9zaXRpb24gYXJndW1lbnQuIEkgYXNzdW1lIHdlJ2QgbmVlZCBhIHdheSB0byBhZGQgYSBtZXRob2QgdG8gbW92ZSB0byBzdHJlYW0gcG9zaXRpb24gc29tZWhvd1xuXG5cbiAgd3JpdGVUaUZpbGVTdHJlYW0odGlGaWxlU3RyZWFtLCBidWZmZXIsIChlcnIsIGJ5dGVzUHJvY2Vzc2VkKSA9PiB7XG4gICAgaWYgKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCBieXRlc1Byb2Nlc3NlZCwgYnVmZmVyKTtcbiAgfSk7XG59XG4vKipcbiAqIEBwYXJhbSB7aW50ZWdlcn0gZmQgZmlsZSBkZXNjcmlwdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIGNvbnRlbnRzIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvZmZzZXRdIG9mZnNldCB3aXRoaW4gQnVmZmVyIHRvIHdyaXRlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtsZW5ndGhdIGxlbmd0aCBvZiBieXRlcyB0byB3cml0ZSBpZiBCdWZmZXJcbiAqIEBwYXJhbSB7aW50ZWdlcn0gW3Bvc2l0aW9uXSBvZmZzZXQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBmaWxlIHdoZXJlIHRoaXMgZGF0YSBzaG91bGQgYmUgd3JpdHRlblxuICogQHJldHVybnMge2ludGVnZXJ9IG51bWJlciBvZiBieXRlcyB3cml0dGVuXG4gKi9cblxuXG5mdW5jdGlvbiB3cml0ZUJ1ZmZlclN5bmMoZmQsIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7XG4gIGlmICh0eXBlb2Ygb2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgIG9mZnNldCA9IDA7XG4gIH1cblxuICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC0gb2Zmc2V0O1xuICB9XG5cblxuICBjb25zdCB0aUZpbGVTdHJlYW0gPSBzdHJlYW1Gb3JEZXNjcmlwdG9yKGZkKTsgLy8gTWFrZSB1c2Ugb2YgdGhlIGJ1ZmZlciBzbGljZSB0aGF0J3Mgc3BlY2lmaWVkIGJ5IG9mZnNldC9sZW5ndGhcblxuICBpZiAob2Zmc2V0ICE9PSAwIHx8IGxlbmd0aCAhPT0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGxlbmd0aCk7XG4gIH0gLy8gVE9ETzogU3VwcG9ydCB1c2Ugb2YgcG9zaXRpb24gYXJndW1lbnQuIEkgYXNzdW1lIHdlJ2QgbmVlZCBhIHdheSB0byBhZGQgYSBtZXRob2QgdG8gbW92ZSB0byBzdHJlYW0gcG9zaXRpb24gc29tZWhvd1xuXG5cbiAgcmV0dXJuIHRpRmlsZVN0cmVhbS53cml0ZShidWZmZXIudG9UaUJ1ZmZlcigpKTtcbn1cbi8qKlxuICogQGNhbGxiYWNrIHdyaXRlU3RyaW5nQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciAtIEVycm9yIGlmIG9uZSBvY2N1cnJlZFxuICogQHBhcmFtIHtpbnRlZ2VyfSB3cml0dGVuIC0gYnl0ZXMgd3JpdHRlblxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIG9yaWdpbmFsIHN0cmluZyBiZWluZyB3cml0dGVuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcGFyYW0ge3dyaXRlU3RyaW5nQ2FsbGJhY2t9IFtjYWxsYmFja10gYXN5bmMgY2FsbGJhY2tcbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nKGZkLCBzdHJpbmcsIHBvc2l0aW9uLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sgPSBtYXliZUNhbGxiYWNrKGNhbGxiYWNrIHx8IGVuY29kaW5nIHx8IHBvc2l0aW9uKTsgLy8gcG9zaXRpb24gY291bGQgYmU6IG51bWJlciwgZnVuY3Rpb24gKGNhbGxiYWNrKVxuXG4gIGlmICh0eXBlb2YgcG9zaXRpb24gIT09ICdudW1iZXInKSB7XG4gICAgcG9zaXRpb24gPSBudWxsO1xuICB9IC8vIGVuY29kaW5nIGNvdWxkIGJlOiBmdW5jdGlvbiAoY2FsbGJhY2spIG9yIHN0cmluZ1xuXG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGNvbnN0IHRpRmlsZVN0cmVhbSA9IHN0cmVhbUZvckRlc2NyaXB0b3IoZmQpO1xuICBzdHJpbmcgKz0gJyc7IC8vIGNvZXJjZSB0byBzdHJpbmdcblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShzdHJpbmcsIGVuY29kaW5nKTsgLy8gVE9ETzogU3VwcG9ydCB1c2Ugb2YgcG9zaXRpb24gYXJndW1lbnQuIEkgYXNzdW1lIHdlJ2QgbmVlZCBhIHdheSB0byBhZGQgYSBtZXRob2QgdG8gbW92ZSB0byBzdHJlYW0gcG9zaXRpb24gc29tZWhvd1xuXG4gIHdyaXRlVGlGaWxlU3RyZWFtKHRpRmlsZVN0cmVhbSwgYnVmZmVyLCAoZXJyLCBieXRlc1Byb2Nlc3NlZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgYnl0ZXNQcm9jZXNzZWQsIHN0cmluZyk7XG4gIH0pO1xufVxuLyoqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGZkIGZpbGUgZGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBjb250ZW50cyB0byB3cml0ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbcG9zaXRpb25dIG9mZnNldCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpbGUgd2hlcmUgdGhpcyBkYXRhIHNob3VsZCBiZSB3cml0dGVuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kaW5nPSd1dGY4J10gZXhwZWN0ZWQgc3RyaW5nIGVuY29kaW5nXG4gKiBAcmV0dXJucyB7aW50ZWdlcn0gbnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nU3luYyhmZCwgc3RyaW5nLCBwb3NpdGlvbiwgZW5jb2RpbmcpIHtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICB9XG5cbiAgY29uc3QgdGlGaWxlU3RyZWFtID0gc3RyZWFtRm9yRGVzY3JpcHRvcihmZCk7XG4gIHN0cmluZyArPSAnJzsgLy8gY29lcmNlIHRvIHN0cmluZ1xuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZywgZW5jb2RpbmcpOyAvLyBUT0RPOiBTdXBwb3J0IHVzZSBvZiBwb3NpdGlvbiBhcmd1bWVudC4gSSBhc3N1bWUgd2UnZCBuZWVkIGEgd2F5IHRvIGFkZCBhIG1ldGhvZCB0byBtb3ZlIHRvIHN0cmVhbSBwb3NpdGlvbiBzb21laG93XG5cbiAgcmV0dXJuIHRpRmlsZVN0cmVhbS53cml0ZShidWZmZXIudG9UaUJ1ZmZlcigpKTtcbn1cblxuZnVuY3Rpb24gU3RyZWFtKG9wdHMpIHtcbiAgLy8gRklYTUU6IENhbid0IGNhbGwgRXZlbnRFbWl0dGVyIGFzIGEgZnVuY3Rpb24hXG4gIHRoaXMuX2V2ZW50c1RvTGlzdGVuZXJzID0ge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDsgLy8gRXZlbnRFbWl0dGVyLmNhbGwodGhpcywgb3B0cyk7XG4gIC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzP1xufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU3RyZWFtLCBFdmVudEVtaXR0ZXIpOyAvLyBVc2UgdXRpbC5pbmhlcml0cz9cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcbiAgfSAvLyBUT0RPOiByZWFkYWJsZVN0YXRlP1xuXG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRocm93IG5ldyBFcnJvcignbWV0aG9kIG5vdCBpbXBsZW1lbnRlZDogX3JlYWQoKScpO1xufTtcblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBjb25zdCBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgaWYgKCFpc0R1cGxleCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgICB9XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgfVxuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7IC8vIFRPRE86IFByb3ZpZGUgbW9yZSB0aGFuIGFuIGVtcHR5IGNsYXNzIVxuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7IC8vIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpOyAvLyBDb3B5IFdyaXRhYmxlIG1ldGhvZHMgdG8gRHVwbGV4IChiYXNpY2FsbHkgdGhlIG9kZCBkb3VibGUtaW5oZXJpdGFuY2UpXG5cbmNvbnN0IHdyaXRhYmxlTWV0aG9kcyA9IE9iamVjdC5rZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbmZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGFibGVNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHdyaXRhYmxlTWV0aG9kcztcblxuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkge1xuICAgIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSB7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIH1cblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTsgLy8gVE9ETzogUHJvdmlkZSBtb3JlIHRoYW4gYW4gZW1wdHkgY2xhc3MhXG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgICB9XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICAvLyB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xuXG59XG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTsgLy8gbGVnYWN5IGNvbXBhdFxuXG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7IC8vIFN0cmVhbS5QYXNzVGhyb3VnaCA9IFBhc3NUaHJvdWdoO1xuXG4vLyBMb2FkIGFsbCB0aGUgbm9kZSBjb21wYXRpYmxlIGNvcmUgbW9kdWxlc1xucmVnaXN0ZXIoJ3BhdGgnLCBwYXRoKTtcbnJlZ2lzdGVyKCdvcycsIE9TKTtcbnJlZ2lzdGVyKCd0dHknLCB0dHkpO1xucmVnaXN0ZXIoJ3V0aWwnLCB1dGlsKTtcbnJlZ2lzdGVyKCdhc3NlcnQnLCBhc3NlcnQkMSk7XG5yZWdpc3RlcignZXZlbnRzJywgRXZlbnRFbWl0dGVyKTtcbnJlZ2lzdGVyKCdidWZmZXInLCBCdWZmZXJNb2R1bGUpO1xucmVnaXN0ZXIoJ3N0cmluZ19kZWNvZGVyJywgU3RyaW5nRGVjb2RlciQxKTtcbnJlZ2lzdGVyKCdmcycsIGZzKTtcbnJlZ2lzdGVyKCdzdHJlYW0nLCBTdHJlYW0pOyAvLyBSZWdpc3RlciByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIgYXMgZ2xvYmFsXG5cbmdsb2JhbC5CdWZmZXIgPSBCdWZmZXJNb2R1bGUuQnVmZmVyO1xuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqXG4gKiBEZXNjcmlwdGlvbjpcbiAqIFRoaXMgc2NyaXB0IGxvYWRzIGFsbCBKYXZhU2NyaXB0IGZpbGVzIGVuZGluZyB3aXRoIHRoZSBuYW1lIFwiKi5ib290c3RyYXAuanNcIiBhbmQgdGhlbiBleGVjdXRlcyB0aGVtLlxuICogVGhlIG1haW4gaW50ZW50aW9uIG9mIHRoaXMgZmVhdHVyZSBpcyB0byBhbGxvdyBKYXZhU2NyaXB0IGZpbGVzIHRvIGtpY2stb2ZmIGZ1bmN0aW9uYWxpdHkgb3JcbiAqIGRpc3BsYXkgVUkgdG8gdGhlIGVuZC11c2VyIGJlZm9yZSB0aGUgXCJhcHAuanNcIiBnZXRzIGxvYWRlZC4gVGhpcyBmZWF0dXJlIGlzIHRoZSBDb21tb25KU1xuICogZXF1aXZhbGVudCB0byBUaXRhbml1bSdzIEFuZHJvaWQgbW9kdWxlIG9uQXBwQ3JlYXRlKCkgb3IgaU9TIG1vZHVsZSBsb2FkKCkgZmVhdHVyZXMuXG4gKlxuICogVXNlLUNhc2VzOlxuICogLSBBdXRvbWF0aWNhbGx5IGtpY2stb2ZmIGFuYWx5dGljcyBmdW5jdGlvbmFsaXR5IG9uIGFwcCBzdGFydHVwLlxuICogLSBFbnN1cmUgXCJHb29nbGUgUGxheSBTZXJ2aWNlc1wiIGlzIGluc3RhbGxlZC91cGRhdGVkIG9uIGFwcCBzdGFydHVwIG9uIEFuZHJvaWQuXG4gKi9cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBsb2FkIGFsbCBib290c3RyYXBzIGZyb20gYSBcImJvb3RzdHJhcC5qc29uXCIgZmlsZSBjcmVhdGVkIGJ5IHRoZSBhcHAgYnVpbGQgc3lzdGVtLlxuICogVGhpcyBpcyBhbiBvcHRpb25hbCBmZWF0dXJlIGFuZCBpcyB0aGUgZmFzdGVzdCBtZXRob2Qgb2YgYWNxdWlyaW5nIGJvb3N0cmFwcyBjb25maWd1cmVkIGZvciB0aGUgYXBwLlxuICogVGhpcyBKU09OIGZpbGUsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyB0aGlzIHNjcmlwdC5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBpZiBib290c3RyYXBzIHdlcmUgc3VjY2Vzc2Z1bGx5IGxvYWRlZCBmcm9tIEpTT04uXG4gKiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIEpTT04gZmlsZSB3YXMgZm91bmQsIGJ1dCBubyBib290c3RyYXBzIHdlcmUgY29uZmlndXJlZCBmb3IgdGhlIGFwcC5cbiAqIFJldHVybnMgbnVsbCBpZiBKU09OIGZpbGUgd2FzIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKSB7XG4gIGNvbnN0IEpTT05fRklMRV9OQU1FID0gJ2Jvb3RzdHJhcC5qc29uJztcblxuICB0cnkge1xuICAgIGNvbnN0IGpzb25GaWxlID0gVGkuRmlsZXN5c3RlbS5nZXRGaWxlKFRpLkZpbGVzeXN0ZW0ucmVzb3VyY2VzRGlyZWN0b3J5LCBgdGkuaW50ZXJuYWwvJHtKU09OX0ZJTEVfTkFNRX1gKTtcblxuICAgIGlmIChqc29uRmlsZS5leGlzdHMoKSkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBKU09OLnBhcnNlKGpzb25GaWxlLnJlYWQoKS50ZXh0KTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3Muc2NyaXB0cykpIHtcbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLnNjcmlwdHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgVGkuQVBJLmVycm9yKGBGYWlsZWQgdG8gcmVhZCBcIiR7SlNPTl9GSUxFX05BTUV9XCIuIFJlYXNvbjogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHNlYXJjaGVzIHRoZSBcIlJlc291cmNlc1wiIGRpcmVjdG9yeSBmb3IgYWxsIFwiKi5ib290c3RyYXAuanNcIiBmaWxlcy5cbiAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgcmVxdWlyZSgpIGNvbXBhdGlibGUgc3RyaW5ncyBmb3IgZWFjaCBib290c3RyYXAgZm91bmQgaW4gdGhlIHNlYXJjaC5cbiAqIFJldHVybnMgYW4gZW1wdHkgYXJyYXkgaWYgbm8gYm9vdHN0cmFwIGZpbGVzIHdlcmUgZm91bmQuXG4gKi9cblxuXG5mdW5jdGlvbiBmZXRjaFNjcmlwdHNGcm9tUmVzb3VyY2VzRGlyZWN0b3J5KCkge1xuICBjb25zdCByZXNvdXJjZURpcmVjdG9yeSA9IFRpLkZpbGVzeXN0ZW0uZ2V0RmlsZShUaS5GaWxlc3lzdGVtLnJlc291cmNlc0RpcmVjdG9yeSk7XG4gIGNvbnN0IHJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCA9IHJlc291cmNlRGlyZWN0b3J5Lm5hdGl2ZVBhdGgubGVuZ3RoO1xuICBjb25zdCBib290c3RyYXBTY3JpcHRzID0gW107XG5cbiAgZnVuY3Rpb24gbG9hZEZyb20oZmlsZSkge1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3RvcnkuIFJlY3Vyc2l2ZWx5IGxvb2sgZm9yIGJvb3RzdHJhcCBmaWxlcyB1bmRlciBpdC5cbiAgICAgICAgY29uc3QgZmlsZU5hbWVBcnJheSA9IGZpbGUuZ2V0RGlyZWN0b3J5TGlzdGluZygpO1xuXG4gICAgICAgIGlmIChmaWxlTmFtZUFycmF5KSB7XG4gICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGZpbGVOYW1lQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBsb2FkRnJvbShUaS5GaWxlc3lzdGVtLmdldEZpbGUoZmlsZS5uYXRpdmVQYXRoLCBmaWxlTmFtZUFycmF5W2luZGV4XSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWxlLm5hbWUuc2VhcmNoKC8uYm9vdHN0cmFwLmpzJC8pID49IDApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJvb3RzdHJhcCBmaWxlLlxuICAgICAgICAvLyBDb252ZXJ0IGl0cyBwYXRoIHRvIHNvbWV0aGluZyBsb2FkYWJsZSB2aWEgcmVxdWlyZSgpIGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5LlxuICAgICAgICBsZXQgYm9vdHN0cmFwUGF0aCA9IGZpbGUubmF0aXZlUGF0aDtcbiAgICAgICAgYm9vdHN0cmFwUGF0aCA9IGJvb3RzdHJhcFBhdGguc3Vic3RyKHJlc291cmNlRGlyZWN0b3J5UGF0aExlbmd0aCwgYm9vdHN0cmFwUGF0aC5sZW5ndGggLSByZXNvdXJjZURpcmVjdG9yeVBhdGhMZW5ndGggLSAnLmpzJy5sZW5ndGgpO1xuICAgICAgICBib290c3RyYXBTY3JpcHRzLnB1c2goYm9vdHN0cmFwUGF0aCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbG9hZEZyb20ocmVzb3VyY2VEaXJlY3RvcnkpO1xuICByZXR1cm4gYm9vdHN0cmFwU2NyaXB0cztcbn1cbi8qKlxuICogTm9uLWJsb2NraW5nIGZ1bmN0aW9uIHdoaWNoIGxvYWRzIGFuZCBleGVjdXRlcyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgY29uZmlndXJlZCBmb3IgdGhlIGFwcC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZpbmlzaGVkIENhbGxiYWNrIHRvIGJlIGludm9rZWQgb25jZSBhbGwgYm9vdHN0cmFwcyBoYXZlIGZpbmlzaGVkIGV4ZWN1dGluZy4gQ2Fubm90IGJlIG51bGwuXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkQXN5bmMoZmluaXNoZWQpIHtcbiAgLy8gQWNxdWlyZSBhbiBhcnJheSBvZiBhbGwgYm9vdHN0cmFwIHNjcmlwdHMgaW5jbHVkZWQgd2l0aCB0aGUgYXBwLlxuICAvLyAtIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBhdHRlbXB0IHRvIGZldGNoIHNjcmlwdHMgdmlhIGFuIG9wdGlvbmFsIEpTT04gZmlsZSBjcmVhdGVkIGJ5IHRoZSBidWlsZCBzeXN0ZW0uXG4gIC8vIC0gSWYgSlNPTiBmaWxlIG5vdCBmb3VuZCAod2lsbCByZXR1cm4gbnVsbCksIHRoZW4gc2VhcmNoIFwiUmVzb3VyY2VzXCIgZGlyZWN0b3J5IGZvciBib290c3RyYXAgZmlsZXMuXG4gIGxldCBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbUpzb24oKTtcblxuICBpZiAoIWJvb3RzdHJhcFNjcmlwdHMpIHtcbiAgICBib290c3RyYXBTY3JpcHRzID0gZmV0Y2hTY3JpcHRzRnJvbVJlc291cmNlc0RpcmVjdG9yeSgpO1xuICB9IC8vIERvIG5vdCBjb250aW51ZSBpZiBubyBib290c3RyYXBzIHdlcmUgZm91bmQuXG5cblxuICBpZiAoIWJvb3RzdHJhcFNjcmlwdHMgfHwgYm9vdHN0cmFwU2NyaXB0cy5sZW5ndGggPD0gMCkge1xuICAgIGZpbmlzaGVkKCk7XG4gICAgcmV0dXJuO1xuICB9IC8vIFNvcnQgdGhlIGJvb3RzdHJhcHMgc28gdGhhdCB0aGV5J2xsIGJlIGxvYWRlZCBpbiBhIGNvbnNpc3RlbnQgb3JkZXIgYmV0d2VlbiBwbGF0Zm9ybXMuXG5cblxuICBib290c3RyYXBTY3JpcHRzLnNvcnQoKTsgLy8gTG9hZHMgYWxsIGJvb3RzdHJhcCBzY3JpcHRzIGZvdW5kLlxuXG4gIGZ1bmN0aW9uIGxvYWRCb290c3RyYXBTY3JpcHRzKGZpbmlzaGVkKSB7XG4gICAgbGV0IGJvb3RzdHJhcEluZGV4ID0gMDtcblxuICAgIGZ1bmN0aW9uIGRvTG9hZCgpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gbG9hZCBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gICAgICB3aGlsZSAoYm9vdHN0cmFwSW5kZXggPCBib290c3RyYXBTY3JpcHRzLmxlbmd0aCkge1xuICAgICAgICAvLyBMb2FkIHRoZSBuZXh0IGJvb3RzdHJhcC5cbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBib290c3RyYXBTY3JpcHRzW2Jvb3RzdHJhcEluZGV4XTtcblxuICAgICAgICBjb25zdCBib290c3RyYXAgPSByZXF1aXJlKGZpbGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBzZWN1cml0eS9kZXRlY3Qtbm9uLWxpdGVyYWwtcmVxdWlyZVxuICAgICAgICAvLyBJbnZva2UgdGhlIGJvb3RzdHJhcCdzIGV4ZWN1dGUoKSBtZXRob2QgaWYgaXQgaGFzIG9uZS4gKFRoaXMgaXMgb3B0aW9uYWwuKVxuICAgICAgICAvLyBXZSBtdXN0IHdhaXQgZm9yIHRoZSBnaXZlbiBjYWxsYmFjayB0byBiZSBpbnZva2VkIGJlZm9yZSBsb2FkaW5nIHRoZSBuZXh0IHNjcmlwdC5cbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBleHBlY3RlZCB0byBiZSB1c2VkIHRvIGRpc3BsYXkgVUkgdG8gdGhlIGVuZC11c2VyLlxuXG5cbiAgICAgICAgaWYgKGJvb3RzdHJhcC5leGVjdXRlKSB7XG4gICAgICAgICAgYm9vdHN0cmFwLmV4ZWN1dGUob25Cb290c3RyYXBFeGVjdXRpb25GaW5pc2hlZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGUgY3VycmVudCBib290c3RyYXAuIFRpbWUgdG8gbG9hZCB0aGUgbmV4dCBvbmUuXG5cblxuICAgICAgICBib290c3RyYXBJbmRleCsrO1xuICAgICAgfSAvLyBJbnZva2UgZ2l2ZW4gY2FsbGJhY2sgdG8gaW5mb3JtIGNhbGxlciB0aGF0IGFsbCBsb2FkaW5nIGlzIGRvbmUuXG5cblxuICAgICAgZmluaXNoZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkJvb3RzdHJhcEV4ZWN1dGlvbkZpbmlzaGVkKCkge1xuICAgICAgLy8gTGFzdCBib290c3RyYXAgaGFzIGZpbmlzaGVkIGV4ZWN1dGlvbi4gVGltZSB0byBsb2FkIHRoZSBuZXh0IG9uZS5cbiAgICAgIC8vIE5vdGU6IEFkZCBhIHRpbnkgZGVsYXkgc28gd2hhdGV2ZXIgVUkgdGhlIGxhc3QgYm9vdHN0cmFwIGxvYWRlZCBoYXMgdGltZSB0byBjbG9zZS5cbiAgICAgIGJvb3RzdHJhcEluZGV4Kys7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGRvTG9hZCgpLCAxKTtcbiAgICB9XG5cbiAgICBkb0xvYWQoKTtcbiAgfSAvLyBXZSd2ZSBmaW5pc2hlZCBsb2FkaW5nL2V4ZWN1dGluZyBhbGwgYm9vdHN0cmFwIHNjcmlwdHMuXG4gIC8vIEluZm9ybSBjYWxsZXIgYnkgaW52b2tpbmcgdGhlIGNhbGxiYWNrIGdpdmVuIHRvIGxvYWRBc3luYygpLlxuXG5cbiAgbG9hZEJvb3RzdHJhcFNjcmlwdHMoZmluaXNoZWQpO1xufVxuXG4vKipcbiAqIEFwcGNlbGVyYXRvciBUaXRhbml1bSBNb2JpbGVcbiAqIENvcHlyaWdodCAoYykgMjAxOCBieSBBeHdheSwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgUHVibGljIExpY2Vuc2VcbiAqIFBsZWFzZSBzZWUgdGhlIExJQ0VOU0UgaW5jbHVkZWQgd2l0aCB0aGlzIGRpc3RyaWJ1dGlvbiBmb3IgZGV0YWlscy5cbiAqXG4gKiBUaGlzIHNjcmlwdCBpcyBsb2FkZWQgb24gYXBwIHN0YXJ0dXAgb24gYWxsIHBsYXRmb3Jtcy4gSXQgaXMgdXNlZCB0byBkbyB0aGUgZm9sbG93aW5nOlxuICogLSBQcm92aWRlIGNvbnNpc3RlbnQgc3RhcnR1cCBiZWhhdmlvciBiZXR3ZWVuIHBsYXRmb3Jtcywgc3VjaCBhcyBsb2dnaW5nIFRpdGFuaXVtIHZlcnNpb24uXG4gKiAtIExvYWQgVGl0YW5pdW0ncyBjb3JlIEphdmFTY3JpcHQgZXh0ZW5zaW9ucyBzaGFyZWQgYnkgYWxsIHBsYXRmb3Jtcy5cbiAqIC0gUHJvdmlkZSBcIiouYm9vdHN0cmFwLmpzXCIgc2NyaXB0IHN1cHBvcnQuIChTaW1pbGFyIHRvIG5hdGl2ZSBtb2R1bGUgb25BcHBDcmVhdGUoKS9sb2FkKCkgc3VwcG9ydC4pXG4gKiAtIExvYWQgdGhlIGFwcCBkZXZlbG9wZXIncyBtYWluIFwiYXBwLmpzXCIgc2NyaXB0IGFmdGVyIGRvaW5nIGFsbCBvZiB0aGUgYWJvdmUuXG4gKi9cbi8vIExvZyB0aGUgYXBwIG5hbWUsIGFwcCB2ZXJzaW9uLCBhbmQgVGl0YW5pdW0gdmVyc2lvbiBvbiBzdGFydHVwLlxuVGkuQVBJLmluZm8oYCR7VGkuQXBwLm5hbWV9ICR7VGkuQXBwLnZlcnNpb259IChQb3dlcmVkIGJ5IFRpdGFuaXVtICR7XCI5LjIuMVwifS4ke1wiMTkxMjI5NjFlM1wifSlgKTsgLy8gQXR0ZW1wdCB0byBsb2FkIGNyYXNoIGFuYWx5dGljcyBtb2R1bGUuXG4vLyBOT1RFOiBUaGlzIHNob3VsZCBiZSB0aGUgZmlyc3QgbW9kdWxlIHRoYXQgbG9hZHMgb24gc3RhcnR1cC5cblxudHJ5IHtcbiAgcmVxdWlyZSgnY29tLmFwcGNlbGVyYXRvci5hY2EnKTtcbn0gY2F0Y2ggKGUpIHt9IC8vIENvdWxkIG5vdCBsb2FkIG1vZHVsZSwgc2lsZW50bHkgaWdub3JlIGV4Y2VwdGlvbi5cbmxvYWRBc3luYyhmdW5jdGlvbiAoKSB7XG4gIC8vIFdlJ3ZlIGZpbmlzaGVkIGxvYWRpbmcvZXhlY3V0aW5nIGFsbCBib290c3RyYXAgc2NyaXB0cy5cbiAgLy8gV2UgY2FuIG5vdyBwcm9jZWVkIHRvIHJ1biB0aGUgbWFpbiBcImFwcC5qc1wiIHNjcmlwdC5cbiAgcmVxdWlyZSgnLi9hcHAnKTsgLy8gVGhpcyBldmVudCBpcyB0byBiZSBmaXJlZCBhZnRlciBcImFwcC5qc1wiIGV4ZWN1dGlvbi4gUmVhc29uczpcbiAgLy8gLSBBbGxvdyBzeXN0ZW0gdG8gcXVldWUgc3RhcnR1cCByZWxhdGVkIGV2ZW50cyB1bnRpbCBcImFwcC5qc1wiIGhhcyBoYWQgYSBjaGFuY2UgdG8gYWRkIGxpc3RlbmVycy5cbiAgLy8gLSBGb3IgQWxsb3kgYXBwcywgd2Ugbm93IGtub3cgdGhhdCBBbGxveSBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaXRzIGdsb2JhbHMgd2VyZSBhZGRlZC5cblxuXG4gIFRpLkFwcC5maXJlRXZlbnQoJ3N0YXJ0ZWQnKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIvVXNlcnMvbHVpZ2l2aXRlbGxpL0xpYnJhcnkvQXBwbGljYXRpb24gU3VwcG9ydC9UaXRhbml1bS9tb2JpbGVzZGsvb3N4LzkuMi4xLkdBL2NvbW1vbi9SZXNvdXJjZXMvYW5kcm9pZCJ9
